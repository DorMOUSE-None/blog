<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/xx4WXnl7odya2QE7dUtyW/pages/post.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/xx4WXnl7odya2QE7dUtyW/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.966200943f7869d2249d.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.2d2aeb3a0a1eb931bc6e.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.a70990b9.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.196d8b6b.chunk.css"/></head><body><div id="__next"><header><h1 class="title">ffutop</h1><div><a href="/blog/blog/">博客</a><a href="/blog/archives/">归档</a><a href="/blog/tags/">标签</a><a href="/blog/about/">关于</a></div></header><div><main class="main"><div><p>前些天看了关于在密码学应用中使用<code>java.lang.String</code>与<code>byte[]</code>的相关讨论，不推荐使用<code>java.lang.String</code>的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。</p>
<h2>/proc/${pid}/maps</h2>
<p>首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从<code>/proc</code>虚拟文件系统中，提供了进程虚拟地址映射。</p>
<pre><code>address                   perm offset   dev   inode                      pathname
556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run
556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run
556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run
55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]
7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so
7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so
7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so
7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so
7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0
7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so
7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0
7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so
7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so
7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0
7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]
7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]
7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
</code></pre>
<p>&lt;!-- more --&gt;</p>
<p><code>/proc/${pid}/maps</code> 记录了当前进程虚拟内存区域的分配以及其访问控制。</p>
<ul>
<li>前三行表述的是当前进程ELF文件在虚拟内存中的地址（这里使用的ELF文件名为 <code>run</code> ）
<ul>
<li>第一行 <code>r-xp</code> 表示其将配合<code>Code Segment Register (CS)</code> 作为CPU执行指令的直接依据。</li>
<li>第二三行分别用作可读、可写数据区，将配合 <code>Data Segment Register (DS), ES, FS, GS</code> 等使用</li>
</ul>
</li>
<li>第四行直截了当，就是分配给堆的地址空间。当然，如果不够，可以不断地向上扩张。</li>
<li><code>xxx.so</code> 文件描述的是C共享库在虚拟内存中的地址。</li>
<li>最后才是栈内存，将以倒序的方式下内存低地址扩张。</li>
<li>至于之后的内容，不了解，不表。</li>
</ul>
<h2>ptrace</h2>
<p>拿到了进程虚拟内存分布，又如何获取其中的内容。<code>ptrace</code> 总算是派上用场了。之前在阅读内核源码的时候，任务数据结构 <code>struct task</code> 专门为此预留了一些字段来加以描述，但始终找不到其用途。现在总算对其有了初步的了解。</p>
<p>一般来说，进程彼此之间应该相互独立，虽然运行在同一台机器上，但应该是相互间不知道其他进程的存在。那又如何能够通过一个进程的代码来获取另一个进程的堆栈数据呢？<code>ptrace</code> 提供的就是这么一种可能性。通过 <code>PTRACE_ATTACH</code> 和 <code>PTRACE_DETACH</code>，A进程会使得目标进程B陷入Sleeping状态，而等待A继续通过其他命令来获取其数据。至于为什么会是陷入Sleeping呢？一旦B进程的在运行，数据等随时可能改变，显然不适合读取数据啊。</p>
<p>如何读取？<code>PTRACE_PEEKTEXT</code> 就是这样一个实现进程间交互的好工具。</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">if</span> (ptrace(PTRACE_ATTACH, options.pid, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>)
    {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"ptract attach failed. %s(errno: %d)\n"</span>, strerror(errno), errno);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"attach to %d success!\n"</span>, options.pid);
    wait(<span class="hljs-literal">NULL</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">char</span> maps[<span class="hljs-number">17</span>];
    <span class="hljs-built_in">sprintf</span>(maps, <span class="hljs-string">"/proc/%d/maps"</span>, options.pid);
    FILE *fd = fopen(maps, <span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">if</span> (fd == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"open /proc/%d/maps failed. %s(errno: %d)\n"</span>, strerror(errno), errno);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }

    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">map</span> *<span class="hljs-title">map</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">map</span> *) <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">map</span> *));</span>

    <span class="hljs-keyword">long</span> word;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(fd, <span class="hljs-string">"%llx-%llx %s %lx %*s %*s%*[^\n]"</span>, &amp;<span class="hljs-built_in">map</span>-&gt;start_addr, &amp;<span class="hljs-built_in">map</span>-&gt;end_addr, <span class="hljs-built_in">map</span>-&gt;op_flag, &amp;<span class="hljs-built_in">map</span>-&gt;offset) != EOF)
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;op_flag[<span class="hljs-number">0</span>] == <span class="hljs-string">'-'</span>)
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"peek from [%llx-%llx]\n"</span>, <span class="hljs-built_in">map</span>-&gt;start_addr, <span class="hljs-built_in">map</span>-&gt;end_addr);
        <span class="hljs-keyword">long</span> mem_len = <span class="hljs-built_in">map</span>-&gt;end_addr - <span class="hljs-built_in">map</span>-&gt;start_addr;
        <span class="hljs-keyword">char</span> *data = <span class="hljs-built_in">malloc</span>(mem_len + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> cursor = <span class="hljs-built_in">map</span>-&gt;start_addr;cursor &lt; <span class="hljs-built_in">map</span>-&gt;end_addr;cursor += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>))
        {
            <span class="hljs-keyword">if</span> ((word = ptrace(PTRACE_PEEKTEXT, options.pid, cursor, <span class="hljs-literal">NULL</span>)) == <span class="hljs-number">-1</span> &amp;&amp; errno)
            {
                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"peek failed. %s(errno: %d)\n"</span>, strerror(errno), errno);
                <span class="hljs-built_in">free</span>(data);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
            }
            <span class="hljs-built_in">memcpy</span>(data+cursor-<span class="hljs-built_in">map</span>-&gt;start_addr, &amp;word, <span class="hljs-keyword">sizeof</span>(word));
        }
        dump(data, mem_len);

        <span class="hljs-built_in">free</span>(data);
    }

    <span class="hljs-built_in">free</span>(<span class="hljs-built_in">map</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">if</span> (ptrace(PTRACE_DETACH, options.pid, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>)
    {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-string">"ptract detach failed. %s(errno: %d)\n"</span>, strerror(errno), errno);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"detach from %d success!"</span>, options.pid);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span>
</span>{
    <span class="hljs-comment">// ...</span>

    attach();
    peek();
    detach();
}</code></pre><p>此处的代码片段就能完成dump堆栈的工作了（当然，由于没有对其它内容进行处理，同时会dump下ELF数据等）。<a href="https://github.com/DorMOUSE-None/ffDump">完整代码</a></p>
<h2>小结</h2>
<p>当然，之后才发现 GDB 的实现借用的也正是这样一套机制。同时也意味着上面这段代码的实现在 GDB 中有现成的工具了:&lt;</p>
<pre><code class="hljs">__                    __                  
 / _| __ _ _ __   __ _ / _| ___ _ __   __ _ 
| |_ / _` | '_ \ / _` | |_ / _ \ '_ \ / _` |
|  _| (_| | | | | (_| |  _|  __/ | | | (_| |
|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |
                 |___/                |___/</code></pre></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/post","query":{"fullUrl":"/2019-03-25-mem-dump"},"buildId":"xx4WXnl7odya2QE7dUtyW","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/post" src="https://www.ffutop.com/blog/_next/static/xx4WXnl7odya2QE7dUtyW/pages/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/xx4WXnl7odya2QE7dUtyW/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.966200943f7869d2249d.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.2d2aeb3a0a1eb931bc6e.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>