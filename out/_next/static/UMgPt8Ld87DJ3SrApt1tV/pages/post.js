(window.webpackJsonp=window.webpackJsonp||[]).push([["98d3"],{"2LNF":function(n){n.exports={fileMap:{"content/2018-03-01-区块链简单介绍.json":{title:"区块链技术概述",layout:"post",author:"fangfeng",date:"2018-03-01T00:00:00.000Z",tags:["BlockChain","Smart Contract"],preview:"",dir:"content",base:"2018-03-01-区块链简单介绍.json",ext:".json",sourceBase:"2018-03-01-区块链简单介绍.md",sourceExt:".md"},"content/2018-06-21-java-memory-model.json":{title:"java-memory-model",date:"2018-06-21T00:00:00.000Z",author:"fangfeng",tags:["Java","JVM","Memory Model"],preview:"",dir:"content",base:"2018-06-21-java-memory-model.json",ext:".json",sourceBase:"2018-06-21-java-memory-model.md",sourceExt:".md"},"content/2018-06-28-ASM-VerifyError.json":{title:"ASM-VerifyError错误信息解决",author:"fangfeng",date:"2018-06-28T00:00:00.000Z",tag:["ASM","Java","CGlib"],preview:"",dir:"content",base:"2018-06-28-ASM-VerifyError.json",ext:".json",sourceBase:"2018-06-28-ASM-VerifyError.md",sourceExt:".md"},"content/2018-07-13-How-to-easily-get-CGlib-generated-code.json":{title:"如何方便地获取 CGlib 生成类",author:"fangfeng",date:"2018-07-13T00:00:00.000Z",tags:["CGlib","tools"],preview:"",dir:"content",base:"2018-07-13-How-to-easily-get-CGlib-generated-code.json",ext:".json",sourceBase:"2018-07-13-How-to-easily-get-CGlib-generated-code.md",sourceExt:".md"},"content/2018-08-19-understand-Kernel-1.json":{title:"理解 Linux Kernel (1) - BIOS",author:"fangfeng",date:"2018-08-19T00:00:00.000Z",tags:["Linux","Kernel","BIOS"],preview:"",dir:"content",base:"2018-08-19-understand-Kernel-1.json",ext:".json",sourceBase:"2018-08-19-understand-Kernel-1.md",sourceExt:".md"},"content/2018-09-08-preprocessor-output.json":{title:"Preprocessor Output",author:"fangfeng",date:"2018-09-08T00:00:00.000Z",tags:["C","CPP","GCC"],preview:"",dir:"content",base:"2018-09-08-preprocessor-output.json",ext:".json",sourceBase:"2018-09-08-preprocessor-output.md",sourceExt:".md"},"content/2018-09-27-mail.json":{title:"Understand MAIL",author:"fangfeng",date:"2018-09-27T00:00:00.000Z",tags:["mail","SMTP","TCP"],preview:"",dir:"content",base:"2018-09-27-mail.json",ext:".json",sourceBase:"2018-09-27-mail.md",sourceExt:".md"},"content/2018-11-16-regex-exponential-explosion.json":{title:"正则表达式指数爆炸",author:"fangfeng",date:"2018-11-16T00:00:00.000Z",tags:["regular expression","指数爆炸"],mathjax:!0,preview:"",dir:"content",base:"2018-11-16-regex-exponential-explosion.json",ext:".json",sourceBase:"2018-11-16-regex-exponential-explosion.md",sourceExt:".md"},"content/2019-01-15-understand-Kernel-8.json":{preview:"",title:"Linux",dir:"content",base:"2019-01-15-understand-Kernel-8.json",ext:".json",sourceBase:"2019-01-15-understand-Kernel-8.md",sourceExt:".md"},"content/2019-02-27-Java-Fatal-API.json":{title:"【Java】API 参数误定义的后果",author:"fangfeng",date:"2019-02-27T00:00:00.000Z",tags:["Java","API"],preview:"",dir:"content",base:"2019-02-27-Java-Fatal-API.json",ext:".json",sourceBase:"2019-02-27-Java-Fatal-API.md",sourceExt:".md"},"content/2019-02-02-unicode.json":{preview:"",title:"Unicode",dir:"content",base:"2019-02-02-unicode.json",ext:".json",sourceBase:"2019-02-02-unicode.md",sourceExt:".md"},"content/2019-03-25-mem-dump.json":{title:"如何获取运行时进程堆栈",author:"fangfeng",date:"2019-03-25T00:00:00.000Z",tags:["Kernel","Linux","dump"],preview:"",dir:"content",base:"2019-03-25-mem-dump.json",ext:".json",sourceBase:"2019-03-25-mem-dump.md",sourceExt:".md"},"content/2019-03-19-JANUS.json":{title:"认证与授权·简述",author:"fangfeng",date:"2019-03-19T00:00:00.000Z",tags:["Authenticate","Authorize"],preview:"",dir:"content",base:"2019-03-19-JANUS.json",ext:".json",sourceBase:"2019-03-19-JANUS.md",sourceExt:".md"},"content/2018-07-04-JDK-Permission.json":{title:"Java 安全访问与权限控制",author:"fangfeng",date:"2018-07-04T00:00:00.000Z",tags:["Java","Security","Permission"],preview:"",dir:"content",base:"2018-07-04-JDK-Permission.json",ext:".json",sourceBase:"2018-07-04-JDK-Permission.md",sourceExt:".md"},"content/2018-07-24-JVM-Instruction.json":{title:"JVM 指令简析",author:"fangfeng",date:"2018-07-24T00:00:00.000Z",tags:["JVM","Instruction"],preview:"",dir:"content",base:"2018-07-24-JVM-Instruction.json",ext:".json",sourceBase:"2018-07-24-JVM-Instruction.md",sourceExt:".md"},"content/2018-08-15-Java-Instrumentation.json":{title:"Java Instrumentation",author:"fangfeng",date:"2018-08-15T00:00:00.000Z",tags:["Java","ASM","BTrace"],preview:"",dir:"content",base:"2018-08-15-Java-Instrumentation.json",ext:".json",sourceBase:"2018-08-15-Java-Instrumentation.md",sourceExt:".md"},"content/2018-08-26-understand-Kernel-2.json":{title:"理解 Linux Kernel (2) - 多任务切换",author:"fangfeng",date:"2018-08-26T00:00:00.000Z",tags:["Linux","Kernel","Multi-Task"],preview:"",dir:"content",base:"2018-08-26-understand-Kernel-2.json",ext:".json",sourceBase:"2018-08-26-understand-Kernel-2.md",sourceExt:".md"},"content/2018-08-19-understand-Kernel-0.json":{title:"理解 Linux Kernel (0) - 概述",author:"fangfeng",date:"2018-08-19T00:00:00.000Z",tags:["Linux","Kernel"],preview:"",dir:"content",base:"2018-08-19-understand-Kernel-0.json",ext:".json",sourceBase:"2018-08-19-understand-Kernel-0.md",sourceExt:".md"},"content/2018-09-18-TCP-SYN.json":{title:"TCP SYN 包模拟",author:"fangfeng",date:"2018-09-18T00:00:00.000Z",tags:["TCP"],preview:"",dir:"content",base:"2018-09-18-TCP-SYN.json",ext:".json",sourceBase:"2018-09-18-TCP-SYN.md",sourceExt:".md"},"content/2018-12-15-sql-injection.json":{title:"SQL 注入",author:"fangfeng",date:"2018-12-15T00:00:00.000Z",tags:["Security","SQL"],preview:"",dir:"content",base:"2018-12-15-sql-injection.json",ext:".json",sourceBase:"2018-12-15-sql-injection.md",sourceExt:".md"},"content/2018-12-28-understand-Kernel-7.json":{title:"理解 Linux Kernel (7) - 字符设备",author:"fangfeng",date:"2018-12-28T00:00:00.000Z",tags:["Linux","Kernel","Char Dev"],preview:"",dir:"content",base:"2018-12-28-understand-Kernel-7.json",ext:".json",sourceBase:"2018-12-28-understand-Kernel-7.md",sourceExt:".md"},"content/2018-07-20-Java-Proxy.json":{title:"Java Proxy 源码解析",author:"fangfeng",date:"2018-07-20T00:00:00.000Z",tag:["Java","Proxy"],preview:"",dir:"content",base:"2018-07-20-Java-Proxy.json",ext:".json",sourceBase:"2018-07-20-Java-Proxy.md",sourceExt:".md"},"content/2018-10-12-understand-Kernel-4.json":{title:"理解 Linux Kernel (4) - 任务调度",author:"fangfeng",tags:["Kernel","Linux","time interrupt"],preview:"",dir:"content",base:"2018-10-12-understand-Kernel-4.json",ext:".json",sourceBase:"2018-10-12-understand-Kernel-4.md",sourceExt:".md"},"content/2018-10-06-understand-Kernel-3.json":{title:"理解 Linux Kernel (3) - 操作系统启动",author:"fangfeng",date:"2018-10-06T00:00:00.000Z",tags:["Kernel","Linux","OS"],preview:"",dir:"content",base:"2018-10-06-understand-Kernel-3.json",ext:".json",sourceBase:"2018-10-06-understand-Kernel-3.md",sourceExt:".md"},"content/2018-10-14-understand-Kernel-5.json":{title:"理解 Linux Kernel (5) - 文件系统(宏观描述)",author:"fangfeng",date:"2018-10-14T00:00:00.000Z",tags:["Kernel","Linux","File System"],preview:"",dir:"content",base:"2018-10-14-understand-Kernel-5.json",ext:".json",sourceBase:"2018-10-14-understand-Kernel-5.md",sourceExt:".md"},"content/2019-03-05-understand-Kernel-9.json":{title:"理解 Linux Kernel (9) - IO Multiplexing",author:"fangfeng",date:"2019-03-05T00:00:00.000Z",tags:["Linux","Kernel","IO Model"],preview:"",dir:"content",base:"2019-03-05-understand-Kernel-9.json",ext:".json",sourceBase:"2019-03-05-understand-Kernel-9.md",sourceExt:".md"},"content/2018-06-11-ASM-ClassReader.json":{title:"ASM - ClassReader 与 Java ClassFile 文件格式",author:"fangfeng",date:"2018-06-11T00:00:00.000Z",preview:"",dir:"content",base:"2018-06-11-ASM-ClassReader.json",ext:".json",sourceBase:"2018-06-11-ASM-ClassReader.md",sourceExt:".md"},"content/2018-06-25-ASM-Core.json":{title:"ASM 核心包基本内容漫谈",author:"fangfeng",date:"2018-06-25T00:00:00.000Z",tags:["Java","ASM","Visitor Pattern"],preview:"",dir:"content",base:"2018-06-25-ASM-Core.json",ext:".json",sourceBase:"2018-06-25-ASM-Core.md",sourceExt:".md"},"content/2019-04-10-understand-Kernel-10.json":{title:"理解 Linux Kernel(10) - Context of Execution",author:"fangfeng",date:"2019-04-10T00:00:00.000Z",tags:["Linux","Kernel","COE"],preview:"",dir:"content",base:"2019-04-10-understand-Kernel-10.json",ext:".json",sourceBase:"2019-04-10-understand-Kernel-10.md",sourceExt:".md"},"content/2018-07-10-CGlib-Enhancer.json":{title:"CGlib Enhancer 主流程源码解析",author:"fangfeng",date:"2018-07-10T00:00:00.000Z",tags:["CGlib","ASM"],preview:"",dir:"content",base:"2018-07-10-CGlib-Enhancer.json",ext:".json",sourceBase:"2018-07-10-CGlib-Enhancer.md",sourceExt:".md"},"content/2018-11-11-understand-Kernel-6.json":{title:"理解 Linux Kernel (6) - read & write",author:"fangfeng",date:"2018-11-11T00:00:00.000Z",tags:["Linux","Kernel","File System","read & write"],preview:"",dir:"content",base:"2018-11-11-understand-Kernel-6.json",ext:".json",sourceBase:"2018-11-11-understand-Kernel-6.md",sourceExt:".md"},"content/2018-01-15-Spring-JDBC-Code-Reading.json":{title:"Spring JDBC 源码学习",layout:"post",author:"fangfeng",date:"2018-01-15T00:00:00.000Z",tags:["Spring","JDBC"],"typora-copy-images-to":"ipic",preview:"",dir:"content",base:"2018-01-15-Spring-JDBC-Code-Reading.json",ext:".json",sourceBase:"2018-01-15-Spring-JDBC-Code-Reading.md",sourceExt:".md"}},sourceFileArray:["content/2018-01-15-Spring-JDBC-Code-Reading.md","content/2018-03-01-区块链简单介绍.md","content/2018-06-11-ASM-ClassReader.md","content/2018-06-21-java-memory-model.md","content/2018-06-25-ASM-Core.md","content/2018-06-28-ASM-VerifyError.md","content/2018-07-04-JDK-Permission.md","content/2018-07-10-CGlib-Enhancer.md","content/2018-07-13-How-to-easily-get-CGlib-generated-code.md","content/2018-07-20-Java-Proxy.md","content/2018-07-24-JVM-Instruction.md","content/2018-08-15-Java-Instrumentation.md","content/2018-08-19-understand-Kernel-0.md","content/2018-08-19-understand-Kernel-1.md","content/2018-08-26-understand-Kernel-2.md","content/2018-09-08-preprocessor-output.md","content/2018-09-18-TCP-SYN.md","content/2018-09-27-mail.md","content/2018-10-06-understand-Kernel-3.md","content/2018-10-12-understand-Kernel-4.md","content/2018-10-14-understand-Kernel-5.md","content/2018-11-11-understand-Kernel-6.md","content/2018-11-16-regex-exponential-explosion.md","content/2018-12-15-sql-injection.md","content/2018-12-28-understand-Kernel-7.md","content/2019-01-15-understand-Kernel-8.md","content/2019-02-02-unicode.md","content/2019-02-27-Java-Fatal-API.md","content/2019-03-05-understand-Kernel-9.md","content/2019-03-19-JANUS.md","content/2019-03-25-mem-dump.md","content/2019-04-10-understand-Kernel-10.md"]}},"5DNh":function(n){n.exports={title:"理解 Linux Kernel (6) - read & write",author:"fangfeng",date:"2018-11-11T00:00:00.000Z",tags:["Linux","Kernel","File System","read & write"],bodyContent:'[前一篇](https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/)已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。\n\n首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\nint panic()\n{\n    fprintf(stderr, "%s (errno=%d)\\n", strerror(errno), errno);\n    return -1;\n}\n\nint main(int argc, char *argv[])\n{\n    /* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */\n    int fd = open("/root/frw.txt", O_RDWR | O_CREAT);\n    if (fd == -1)\n        return panic();\n\n    /* 向文件写入 Hello World! 共计 12 个字符 */\n    ssize_t wsize = write(fd, "Hello World!", 12);\n    if (wsize == -1)\n        return panic();\n\n    /* 重定位文件读写指针 */\n    off_t off = lseek(fd, 0, SEEK_SET);\n    if (off == -1)\n        return panic();\n\n    char* buf = (char *) malloc(wsize);\n    /* 读取文件内容 */\n    ssize_t rsize = read(fd, buf, wsize);\n    if (rsize == -1)\n        return panic();\n\n    printf("%s\\n", buf);\n    free(buf);\n    /* 关闭文件 */\n    int stat = close(fd);\n    if (stat == -1)\n        return panic();\n\n    return 0;\n}\n```\n\n\x3c!-- more --\x3e\n\n## 高速缓冲区初始化\n\n上一篇已经描述过了，文件系统的结构、包括数据，都是持久化地存储在存储设备中的。\n\n但是，我们应该也隐约的了解另一个事实，文件读写操作并不会直接操作存储设备上的数据，而是先经过一个称之为高速缓冲的内存区域。\n\n那么，高速缓冲是什么? 究竟承担什么工作? 先来看看它的初始化流程吧。\n\n首先回到 `main.c` (内核代码的主函数)\n\n```c\nvoid main(void)\t\n{\n \tROOT_DEV = ORIG_ROOT_DEV;\n \tdrive_info = DRIVE_INFO;\n\tmemory_end = (1<<20) + (EXT_MEM_K<<10);\n\tmemory_end &= 0xfffff000;\n\tif (memory_end > 16*1024*1024)\n\t\tmemory_end = 16*1024*1024;\n\tif (memory_end > 12*1024*1024)\n\t\tbuffer_memory_end = 4*1024*1024;\n\telse if (memory_end > 6*1024*1024)\n\t\tbuffer_memory_end = 2*1024*1024;\n\telse\n\t\tbuffer_memory_end = 1*1024*1024;\n\tmain_memory_start = buffer_memory_end;\n#ifdef RAMDISK\n\tmain_memory_start += rd_init(main_memory_start, RAMDISK*1024);\n#endif\n\tmem_init(main_memory_start,memory_end);\n\ttrap_init();\n\tblk_dev_init();\n\tchr_dev_init();\n\ttty_init();\n\ttime_init();\n\tsched_init();                       // 第四篇已经讲过，负责任务调度模块的初始化\n\tbuffer_init(buffer_memory_end);     // 本篇的起始，负责缓冲区的初始化\n\thd_init();\n\tfloppy_init();\n\tsti();\n\tmove_to_user_mode();\n\tif (!fork()) {\t\t/* we count on this going ok */\n\t\tinit();\n\t}\n\tfor(;;) pause();\n}\n```\n\n`buffer_init(buffer_memory_end);` 用来初始化缓冲区。此处有几个原因:\n\n1. CPU 读写操作如果直接操作外存，速度上是一个极大的考验。毕竟内存已经较之 CPU 速度慢，外存的读写速度就更慢了。\n\n2. 解耦，其实读写操作并不仅仅发生在外存(块存储设备)，同样的，字符设备等等也都会需要读写操作，增加中间层可以封装变化。\n\n3. 更多，个人了解有限...\n\n```c\nstruct buffer_head {\n char * b_data;\n unsigned long b_blocknr;\n unsigned short b_dev;\n unsigned char b_uptodate;\n unsigned char b_dirt;\n unsigned char b_count;\n unsigned char b_lock;\n struct task_struct * b_wait;\n struct buffer_head * b_prev;\n struct buffer_head * b_next;\n struct buffer_head * b_prev_free;\n struct buffer_head * b_next_free;\n};\n\n/* from fs/buffer.c */\nvoid buffer_init(long buffer_end)\n{\n\tstruct buffer_head * h = start_buffer;\n\tvoid * b;\n\tint i;\n\n\tif (buffer_end == 1<<20)\n\t\tb = (void *) (640*1024);\n\telse\n\t\tb = (void *) buffer_end;\n\twhile ( (b -= BLOCK_SIZE) >= ((void *) (h+1)) ) {\n\t\th->b_dev = 0;\n\t\th->b_dirt = 0;\n\t\th->b_count = 0;\n\t\th->b_lock = 0;\n\t\th->b_uptodate = 0;\n\t\th->b_wait = NULL;\n\t\th->b_next = NULL;\n\t\th->b_prev = NULL;\n\t\th->b_data = (char *) b;\n\t\th->b_prev_free = h-1;\n\t\th->b_next_free = h+1;\n\t\th++;\n\t\tNR_BUFFERS++;\n        /* 跳过 640K ~ 1M 的显存和 BIOS RAM 部分 */\n\t\tif (b == (void *) 0x100000)\n\t\t\tb = (void *) 0xA0000;\n\t}\n\th--;\n\tfree_list = start_buffer;\n\tfree_list->b_prev_free = h;\n\th->b_next_free = free_list;\n\tfor (i=0;i<NR_HASH;i++)\n\t\thash_table[i]=NULL;\n}\n```\n\n缓冲块的所有关键信息都由 `buffer_head` 数据结构进行记录, 至于有多少个 `buffer_head`? 只能说能划分多少就划分多少。\n\n比较直观的结构信息如下\n\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fwy2iag1exj31kw0k1dgb.jpg)\n\n在 `main.c` 中已经提前确认了内核程序占用内存的大小，缓冲区大小以及主内存大小。\n\n在高速缓冲区的开始位置，都用来存储 `buffer_head` 的信息，与每个缓冲块(从缓冲区结束位置开始分配)一一对应，直到中间某个位置不足以分配缓冲块为止。\n\n另外的信息，就是可以看到一个 `hash_table` 数据结构了。\n\n应该都能够想象，每个缓存块与外存中的数据块相对应，通过设备号 + 数据块号进行唯一定位。但是，如何快速查找需要操作的数据块是否已经存在与高速缓存中了呢? 显然直接遍历查找是不太可靠的办法。采用开放地址法的哈希表能够协助快速定位缓冲块。\n\n## 挂载文件系统\n\n既然高速缓冲区都准备就绪了，那么文件系统是否已经挂载了呢? 很遗憾，知道 `main()` 调用 `init()` 函数之前，文件系统依然没有挂载，也就是说，CPU 仍然只能通过基本输入输出对存储设备进行相当初级的 IO 操作。\n\n那么，什么时候才能去挂载根目录呢?\n\n```c\n/* from init/main.c */\n/* 由 main() 触发 */\nvoid init(void)\n{\n\tint pid,i;\n    /* 这是比较重要的一环了，开始挂载的起始动作 */\n\tsetup((void *) &drive_info);\n    ...\n}\n```\n\n`setup` 函数做了什么呢？这是一个内嵌汇编，主要做的就是触发系统调用 `int 0x80`\n```asm\n__inline__ int setup(void * BIOS) { \n    long __res; \n    __asm__ volatile (\n            "int $0x80" \n            : "=a" (__res) \n            : "0" (0),"b" ((long)(BIOS))\n    ); \n    if (__res >= 0) \n        return (int) __res; \n    errno = -__res; \n    return -1; \n}\n```\n\n其中看到给出的 `EAX = 0`, 查表(表在 `include/linux/sys.h` 里) 可以知道触发的是 `sys_setup` 函数(函数位于 `kernel/blk_drv/hd.c`)\n\n```c\n/* This may be used only once, enforced by \'static int callable\' */\nint sys_setup(void * BIOS)\n{\n\tstatic int callable = 1;\n\tint i,drive;\n\tunsigned char cmos_disks;\n\tstruct partition *p;\n\tstruct buffer_head * bh;\n\n    /* setup 只允许被调用一次 */\n\tif (!callable)\n\t\treturn -1;\n\tcallable = 0;\n    /* 可以强制在源码中指定硬盘参数, 所以加了宏定义作判断*/\n#ifndef HD_TYPE\n\tfor (drive=0 ; drive<2 ; drive++) {\n\t\thd_info[drive].cyl = *(unsigned short *) BIOS;\n\t\thd_info[drive].head = *(unsigned char *) (2+BIOS);\n\t\thd_info[drive].wpcom = *(unsigned short *) (5+BIOS);\n\t\thd_info[drive].ctl = *(unsigned char *) (8+BIOS);\n\t\thd_info[drive].lzone = *(unsigned short *) (12+BIOS);\n\t\thd_info[drive].sect = *(unsigned char *) (14+BIOS);\n\t\tBIOS += 16;\n\t}\n\tif (hd_info[1].cyl)\n\t\tNR_HD=2;\n\telse\n\t\tNR_HD=1;\n#endif\n\tfor (i=0 ; i<NR_HD ; i++) {\n\t\thd[i*5].start_sect = 0;\n\t\thd[i*5].nr_sects = hd_info[i].head*\n\t\t\t\thd_info[i].sect*hd_info[i].cyl;\n\t}\n\n\t/*\n\t\tWe querry CMOS about hard disks : it could be that\n\t\twe have a SCSI/ESDI/etc controller that is BIOS\n\t\tcompatable with ST-506, and thus showing up in our\n\t\tBIOS table, but not register compatable, and therefore\n\t\tnot present in CMOS.\n\n\t\tFurthurmore, we will assume that our ST-506 drives\n\t\t<if any> are the primary drives in the system, and\n\t\tthe ones reflected as drive 1 or 2.\n\n\t\tThe first drive is stored in the high nibble of CMOS\n\t\tbyte 0x12, the second in the low nibble.  This will be\n\t\teither a 4 bit drive type or 0xf indicating use byte 0x19\n\t\tfor an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.\n\n\t\tNeedless to say, a non-zero value means we have\n\t\tan AT controller hard disk for that drive.\n\n\n\t*/\n\n\tif ((cmos_disks = CMOS_READ(0x12)) & 0xf0)\n\t\tif (cmos_disks & 0x0f)\n\t\t\tNR_HD = 2;\n\t\telse\n\t\t\tNR_HD = 1;\n\telse\n\t\tNR_HD = 0;\n\tfor (i = NR_HD ; i < 2 ; i++) {\n\t\thd[i*5].start_sect = 0;\n\t\thd[i*5].nr_sects = 0;\n\t}\n    /* 更进一步设置每个盘的参数 */\n\tfor (drive=0 ; drive<NR_HD ; drive++) {\n        /* 0x300 和 0x305 分别代表两个硬盘 */\n        /* 读取每个硬盘的第一块数据 (1024B) */\n\t\tif (!(bh = bread(0x300 + drive*5,0))) {\n\t\t\tprintk("Unable to read partition table of drive %d\\n\\r",\n\t\t\t\tdrive);\n\t\t\tpanic("");\n\t\t}\n        /* 判断硬盘有效性 */\n\t\tif (bh->b_data[510] != 0x55 || (unsigned char)\n\t\t    bh->b_data[511] != 0xAA) {\n\t\t\tprintk("Bad partition table on drive %d\\n\\r",drive);\n\t\t\tpanic("");\n\t\t}\n        /* 读取分区表 (位于 引导扇区第 446 字节开始处 */\n\t\tp = 0x1BE + (void *)bh->b_data;\n\t\tfor (i=1;i<5;i++,p++) {\n\t\t\thd[i+5*drive].start_sect = p->start_sect;\n\t\t\thd[i+5*drive].nr_sects = p->nr_sects;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\tif (NR_HD)\n\t\tprintk("Partition table%s ok.\\n\\r",(NR_HD>1)?"s":"");\n\trd_load();              /* 尝试创建并加载虚拟盘 */\n\tmount_root();           /* mount 根文件系统 */\n\treturn (0);\n}\n```\n\n终于到了挂载文件系统的时候了\n\n`mount_root` 用来做初级的初始化工作。同时，上一节已经描述过了，存储设备的超级块是用了记录整个文件系统最重要的结构。\n\n那么通过将超级块的信息读取到内存，也就可以将内存与外存的文件系统相互联系起来了。\n\n下面这段代码最重要的内容就是 `read_super()` 函数了 .\n\n```c\nvoid mount_root(void)\n{\n\tint i,free;\n\tstruct super_block * p;\n\tstruct m_inode * mi;\n\n\tif (32 != sizeof (struct d_inode))\n\t\tpanic("bad i-node size");\n    /* 先初始化文件表，该版本操作系统限制最大同时打开 NR_FILE(64个) 文件 */\n\tfor(i=0;i<NR_FILE;i++)\n        /* f_count = 0 表明没有被引用 */\n\t\tfile_table[i].f_count=0;\n    /* 如果引导盘是软盘的话，提示插入根文件系统盘 */\n\tif (MAJOR(ROOT_DEV) == 2) {\n\t\tprintk("Insert root floppy and press ENTER");\n\t\twait_for_keypress();\n\t}\n    /* 初始化内存超级块数据结构 (总共 8 个) */\n\tfor(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {\n\t\tp->s_dev = 0;\n\t\tp->s_lock = 0;\n\t\tp->s_wait = NULL;\n\t}\n    /* Hint: 读取超级块的信息，挂载根文件系统重要的部分(代码请往下翻) */\n\tif (!(p=read_super(ROOT_DEV)))\n\t\tpanic("Unable to mount root");\n    /* 读取文件系统的 1 号i节点 (即该设备上文件系统的根节点) */\n\tif (!(mi=iget(ROOT_DEV,ROOT_INO)))\n\t\tpanic("Unable to read root i-node");\n\tmi->i_count += 3 ;\t/* NOTE! it is logically used 4 times, not 1 */\n\tp->s_isup = p->s_imount = mi;\n    /* 应该还记得吧，current 指的是当前的任务(任务1)，以后所有的任务都会由任务1或任务1的子任务进行派生，也就意味着 current->root 会一直复制过去\n     * 到这里为止，应该认为根文件系统以及被挂载了。是不是跟被耍了一样?\n     */\n\tcurrent->pwd = mi;\n\tcurrent->root = mi;\n\tfree=0;\n\ti=p->s_nzones;\n    /* 统计还有多少空闲数据块以及多少可用i节点 (附上一张启动过程中打印的信息) */\n\twhile (-- i >= 0)\n\t\tif (!set_bit(i&8191,p->s_zmap[i>>13]->b_data))\n\t\t\tfree++;\n\tprintk("%d/%d free blocks\\n\\r",free,p->s_nzones);\n\tfree=0;\n\ti=p->s_ninodes+1;\n\twhile (-- i >= 0)\n\t\tif (!set_bit(i&8191,p->s_imap[i>>13]->b_data))\n\t\t\tfree++;\n\tprintk("%d/%d free inodes\\n\\r",free,p->s_ninodes);\n}\n```\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fwz8kvvgbpj30l006i3yb.jpg)\n\n重要要的部分，`read_super(int dev)`，用于读取超级块的数据\n\n```c\nstatic struct super_block * read_super(int dev)\n{\n\tstruct super_block * s;\n\tstruct buffer_head * bh;\n\tint i,block;\n\n\tif (!dev)\n\t\treturn NULL;\n\tcheck_disk_change(dev);\n    /* 如果该超级块已经在内存中了，那么就直接使用 (和这里挂载根文件系统的流程无关) */\n\tif (s = get_super(dev))\n\t\treturn s;\n    /* 设备超级块不在内存中，就先找一个空闲的内存超级块 (总共维护 8 个超级块数据结构) */\n\tfor (s = 0+super_block ;; s++) {\n\t\tif (s >= NR_SUPER+super_block)\n\t\t\treturn NULL;\n\t\tif (!s->s_dev)\n\t\t\tbreak;\n\t}\n\ts->s_dev = dev;\n\ts->s_isup = NULL;\n\ts->s_imount = NULL;\n\ts->s_time = 0;\n\ts->s_rd_only = 0;\n\ts->s_dirt = 0;\n\tlock_super(s);\n    /* 通过 block read 读取设备第一个物理块 (每个物理块 1024 B) */\n\tif (!(bh = bread(dev,1))) {\n\t\ts->s_dev=0;\n\t\tfree_super(s);\n\t\treturn NULL;\n\t}\n    /* 复制一份超级块的数据 */\n\t*((struct d_super_block *) s) =\n\t\t*((struct d_super_block *) bh->b_data);\n    /* 释放缓冲区的数据 */\n\tbrelse(bh);\n    /* 验证魔数, 该版本操作系统只支持 1.0 版 Minix 文件系统，魔数 0x137F */\n\tif (s->s_magic != SUPER_MAGIC) {\n\t\ts->s_dev = 0;\n\t\tfree_super(s);\n\t\treturn NULL;\n\t}\n    /* 先清空内存中的数据 */\n\tfor (i=0;i<I_MAP_SLOTS;i++)\n\t\ts->s_imap[i] = NULL;\n\tfor (i=0;i<Z_MAP_SLOTS;i++)\n\t\ts->s_zmap[i] = NULL;\n\tblock=2;\n    /* 读取 i 节点位图块 */\n\tfor (i=0 ; i < s->s_imap_blocks ; i++)\n\t\tif (s->s_imap[i]=bread(dev,block))\n\t\t\tblock++;\n\t\telse\n\t\t\tbreak;\n    /* 读取数据块位图 */\n\tfor (i=0 ; i < s->s_zmap_blocks ; i++)\n\t\tif (s->s_zmap[i]=bread(dev,block))\n\t\t\tblock++;\n\t\telse\n\t\t\tbreak;\n\tif (block != 2+s->s_imap_blocks+s->s_zmap_blocks) {\n\t\tfor(i=0;i<I_MAP_SLOTS;i++)\n\t\t\tbrelse(s->s_imap[i]);\n\t\tfor(i=0;i<Z_MAP_SLOTS;i++)\n\t\t\tbrelse(s->s_zmap[i]);\n\t\ts->s_dev=0;\n\t\tfree_super(s);\n\t\treturn NULL;\n\t}\n\ts->s_imap[0]->b_data[0] |= 1;\n\ts->s_zmap[0]->b_data[0] |= 1;\n    /* 与前面的 wait_on_super() 对应(解开lock标志) */\n\tfree_super(s);\n\treturn s;\n}\n```\n\n是不是觉得也没什么，就这样根文件系统已经挂载了? 毫无实感是吧。\n\n## Extra: 普通挂载\n\n既然讲过了根文件系统的挂载。那就顺带着讲讲普通文件系统的挂载吧。\n\n相信从命令上来讲应该比较简单也比较熟悉吧。`mount disk.img /mnt` 也算是挂载到 /mnt 下了\n\n但是，究竟是怎么实现的呢?\n\n```c\nint sys_mount(char * dev_name, char * dir_name, int rw_flag)\n{\n\tstruct m_inode * dev_i, * dir_i;\n\tstruct super_block * sb;\n\tint dev;\n\n    /** \n     * 省略大部分判断逻辑, 主要就是:\n     * 1. 判断 dev_name 所属的设备号，读取该设备上的超级块\n     * 2. 读取 dir_name (需要挂载到的位置)，判定是否允许被挂载(比如根节点不允许挂其它设备)\n     */\n    ...\n\n    /* 设置超级块的 mount 标志 */\n\tsb->s_imount=dir_i;\n    /* 设置该 i 节点的 mount 标志 */\n\tdir_i->i_mount=1;\n\tdir_i->i_dirt=1;\t\t/* NOTE! we don\'t iput(dir_i) */\n\treturn 0;\t\t\t/* we do that in umount */\n}\n```\n\n## 文件读写\n\n前面讲了这么多，终于到了最关心的部分了。当然，也并不是说前面的内容不重要，事实上，相当重要，只是都隐藏在了内核引导的过程中，且调用频度低，才导致了没有存在感。但是这恰恰才是支持文件读写的基石。\n\n不多说废话，下面就要开始文件读写的内容。\n\n### 打开文件\n\n打开文件的函数原型是 `int open(const char * filename, int flag, ...);`\n\n当然，此类系统调用最终的实现都是 `int 0x80` , 明确一个调用号，然后就陷入内核态了。\n\n内核态下调用的函数是: `int sys_open(const char * filename,int flag,int mode)` \n\n来看看细节:\n\n```c\nint sys_open(const char * filename,int flag,int mode)\n{\n\tstruct m_inode * inode;\n\tstruct file * f;\n\tint i,fd;\n\n    /*\n     * current 是由内核数据段维护的当前任务的指针\n     * umask 是指当前任务在新建文件时的默认掩码\n     *   例如 Linux 默认是 022, 即新建文件被禁止了组用户与其它用户的写权限\n     * 这里是先确定新建文件的权限\n     */\n\tmode &= 0777 & ~current->umask;\n    /*\n     * 文件描述符，每个文件单独维护一套，以数字标记\n     * 找一个空闲的文件描述符项\n     */\n\tfor(fd=0 ; fd<NR_OPEN ; fd++)\n\t\tif (!current->filp[fd])\n\t\t\tbreak;\n\tif (fd>=NR_OPEN)\n\t\treturn -EINVAL;\n    /*\n     * 顾名思义，设置在调用 exec() 函数时主动关闭的文件\n     * exec() 通常与 fork() 联用，fork() 负责复制一个任务，而 exec 负责替换新任务的代码和数据段(从而产生一个新的任务)\n     * 这里的声明即是复位 fd 位置的标志，允许子任务也持有相同的文件描述符项\n     */\n\tcurrent->close_on_exec &= ~(1<<fd);\n\tf=0+file_table;\n    /* 在文件表中找一项空闲的 */\n\tfor (i=0 ; i<NR_FILE ; i++,f++)\n\t\tif (!f->f_count) break;\n\tif (i>=NR_FILE)\n\t\treturn -EINVAL;\n    /* 当前任务的文件描述符项指向文件表项, 同时文件表项的引用计数+1*/\n\t(current->filp[fd]=f)->f_count++;\n    /* 调用 open_namei 打开文件，如果失败则释放刚才占用的文件结构，并返回错误码 */\n\tif ((i=open_namei(filename,flag,mode,&inode))<0) {\n\t\tcurrent->filp[fd]=NULL;\n\t\tf->f_count=0;\n\t\treturn i;\n\t}\n    /* \n     * 对不同的文件进行不同的特殊处理, 毕竟有 "一切皆文件" 的口号嘛\n     * 诸如字符设备等也都是文件\n     */\n/* ttys are somewhat special (ttyxx major==4, tty major==5) */\n\tif (S_ISCHR(inode->i_mode))\n\t\tif (MAJOR(inode->i_zone[0])==4) {\n\t\t\tif (current->leader && current->tty<0) {\n\t\t\t\tcurrent->tty = MINOR(inode->i_zone[0]);\n\t\t\t\ttty_table[current->tty].pgrp = current->pgrp;\n\t\t\t}\n\t\t} else if (MAJOR(inode->i_zone[0])==5)\n\t\t\tif (current->tty<0) {\n\t\t\t\tiput(inode);\n\t\t\t\tcurrent->filp[fd]=NULL;\n\t\t\t\tf->f_count=0;\n\t\t\t\treturn -EPERM;\n\t\t\t}\n/* Likewise with block-devices: check for floppy_change */\n\tif (S_ISBLK(inode->i_mode))\n\t\tcheck_disk_change(inode->i_zone[0]);\n    /* 初始化内存文件结构的各个参数 */\n\tf->f_mode = inode->i_mode;\n\tf->f_flags = flag;\n\tf->f_count = 1;\n\tf->f_inode = inode;\n\tf->f_pos = 0;\n\treturn (fd);\n}\n```\n\n在整个打开文件的过程中，除了真正去文件系统查找文件的时候用到了文件名，其它时候，都将是以文件描述符进行交互的。\n\n再看看更细节的方面，毕竟就目前来说，我们跳过了最重要的一环 `open_namei` ，从而看似整个流程都简单了很多很多。\n\n通常我们在编码过程中都是通过绝对地址/相对地址来唯一定位一个文件。因此，就必然存在逐级寻找文件的过程\n\n```c\n\nstatic struct m_inode * get_dir(const char * pathname)\n{\n\tchar c;\n\tconst char * thisname;\n\tstruct m_inode * inode;\n\tstruct buffer_head * bh;\n\tint namelen,inr,idev;\n\tstruct dir_entry * de;\n\n    /* 判定当前任务设定的根节点是否有效 */\n\tif (!current->root || !current->root->i_count)\n\t\tpanic("No root inode");\n    /* 判定当前路径i节点是否有效 */\n\tif (!current->pwd || !current->pwd->i_count)\n\t\tpanic("No cwd inode");\n    /* \n     * 这里的 get_fs_byte(..) 是宏定义，fs 指的是 FS 段寄存器\n     * Linux 内核将 DS, ES 用于内核数据段, 用 FS 指向局部描述符表的当前任务数据段\n     * 这里可以简单理解成取字符数组的第一个字节\n     */\n\tif ((c=get_fs_byte(pathname))==\'/\') {\n\t\tinode = current->root;\n\t\tpathname++;\n\t} else if (c)\n\t\tinode = current->pwd;\n\telse\n\t\treturn NULL;\t/* empty name is bad */\n\tinode->i_count++;\n\twhile (1) {\n\t\tthisname = pathname;\n\t\tif (!S_ISDIR(inode->i_mode) || !permission(inode,MAY_EXEC)) {\n\t\t\tiput(inode);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor(namelen=0;(c=get_fs_byte(pathname++))&&(c!=\'/\');namelen++)\n\t\t\t/* nothing */ ;\n\t\tif (!c)\n\t\t\treturn inode;\n\t\tif (!(bh = find_entry(&inode,thisname,namelen,&de))) {\n\t\t\tiput(inode);\n\t\t\treturn NULL;\n\t\t}\n\t\tinr = de->inode;\n\t\tidev = inode->i_dev;\n\t\tbrelse(bh);\n\t\tiput(inode);\n\t\tif (!(inode = iget(idev,inr)))\n\t\t\treturn NULL;\n\t}\n}\n\n/*\n *\tdir_namei()\n *\n * 处理路径 pathname, 处理成i节点表示的最终一级目录+目录下文件名(也可能pathname表示的就是目录)\n */\nstatic struct m_inode * dir_namei(const char * pathname, int * namelen, const char ** name)\n{\n\tchar c;\n\tconst char * basename;\n\tstruct m_inode * dir;\n\n\tif (!(dir = get_dir(pathname)))\n\t\treturn NULL;\n\tbasename = pathname;\n\twhile (c=get_fs_byte(pathname++))\n\t\tif (c==\'/\')\n\t\t\tbasename=pathname;\n\t*namelen = pathname-basename-1;\n\t*name = basename;\n\treturn dir;\n}\n\n/*\n *\topen_namei()\n *\n * namei for open - this is in fact almost the whole open-routine.\n */\nint open_namei(const char * pathname, int flag, int mode,\n\tstruct m_inode ** res_inode)\n{\n\tconst char * basename;\n\tint inr,dev,namelen;\n\tstruct m_inode * dir, *inode;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tif ((flag & O_TRUNC) && !(flag & O_ACCMODE))\n\t\tflag |= O_WRONLY;\n\tmode &= 0777 & ~current->umask;\n\tmode |= I_REGULAR;\n\tif (!(dir = dir_namei(pathname,&namelen,&basename)))\n\t\treturn -ENOENT;\n    /* 如果给的 pathname 是一个目录 */\n\tif (!namelen) {\t\t\t/* special case: \'/usr/\' etc */\n\t\tif (!(flag & (O_ACCMODE|O_CREAT|O_TRUNC))) {\n\t\t\t*res_inode=dir;\n\t\t\treturn 0;\n\t\t}\n\t\tiput(dir);\n\t\treturn -EISDIR;\n\t}\n    /* 找到目录对应的i节点的数据块 */\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tif (!(flag & O_CREAT)) {\n\t\t\tiput(dir);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (!permission(dir,MAY_WRITE)) {\n\t\t\tiput(dir);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tinode = new_inode(dir->i_dev);\n\t\tif (!inode) {\n\t\t\tiput(dir);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tinode->i_uid = current->euid;\n\t\tinode->i_mode = mode;\n\t\tinode->i_dirt = 1;\n\t\tbh = add_entry(dir,basename,namelen,&de);\n\t\tif (!bh) {\n\t\t\tinode->i_nlinks--;\n\t\t\tiput(inode);\n\t\t\tiput(dir);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tde->inode = inode->i_num;\n\t\tbh->b_dirt = 1;\n\t\tbrelse(bh);\n\t\tiput(dir);\n\t\t*res_inode = inode;\n\t\treturn 0;\n\t}\n\tinr = de->inode;\n\tdev = dir->i_dev;\n\tbrelse(bh);\n\tiput(dir);\n\tif (flag & O_EXCL)\n\t\treturn -EEXIST;\n\tif (!(inode=iget(dev,inr)))\n\t\treturn -EACCES;\n\tif ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||\n\t    !permission(inode,ACC_MODE(flag))) {\n\t\tiput(inode);\n\t\treturn -EPERM;\n\t}\n\tinode->i_atime = CURRENT_TIME;\n\tif (flag & O_TRUNC)\n\t\ttruncate(inode);\n\t*res_inode = inode;\n\treturn 0;\n}\n```\n\n### 文件写入\n\n接下来就要进行文件写入的流程了\n\n如何陷入内核态函数就不再细说了，相信看过这么多系统调用之后，也能知道基本上系统调用在内核态对应的函数都是以 sys\\_<method> 形式出现的\n\n```c\nint sys_write(unsigned int fd,char * buf,int count)\n{\n\tstruct file * file;\n\tstruct m_inode * inode;\n\n    /* 非法 fd , 抛异常 */\n\tif (fd>=NR_OPEN || count <0 || !(file=current->filp[fd]))\n\t\treturn -EINVAL;\n    /* count = 0，无需写入数据 */\n\tif (!count)\n\t\treturn 0;\n\tinode=file->f_inode;\n    /* 针对不同的i节点类型，有不同的写入函数 */\n\tif (inode->i_pipe)\n\t\treturn (file->f_mode&2)?write_pipe(inode,buf,count):-EIO;\n\tif (S_ISCHR(inode->i_mode))\n\t\treturn rw_char(WRITE,inode->i_zone[0],buf,count,&file->f_pos);\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn block_write(inode->i_zone[0],&file->f_pos,buf,count);\n\tif (S_ISREG(inode->i_mode))\n\t\treturn file_write(inode,file,buf,count);\n\tprintk("(Write)inode->i_mode=%06o\\n\\r",inode->i_mode);\n\treturn -EINVAL;\n}\n```\n\n看看对于常规文件是怎么操作的吧。\n\n```c\nint file_write(struct m_inode * inode, struct file * filp, char * buf, int count)\n{\n\toff_t pos;      /* 偏移量 */\n\tint block,c;\n\tstruct buffer_head * bh;\n\tchar * p;\n\tint i=0;\n\n    /* 如果是 Append 模式，把偏移量重置到文件末尾 */\n\tif (filp->f_flags & O_APPEND) \n\t\tpos = inode->i_size;\n    /* 否则就使用当前文件数据结构持有的偏移量 */\n    /*\n        附上数据结构  file 的内容 \n        struct file {\n        \tunsigned short f_mode;\n        \tunsigned short f_flags;\n        \tunsigned short f_count;\n        \tstruct m_inode * f_inode;\n        \toff_t f_pos;    每个打开的文件都将持有当前的偏移值\n        };\n     */\n\telse\n\t\tpos = filp->f_pos;\n    /* 逐字符向缓冲区写入数据 */\n\twhile (i<count) {\n        /* 最开始当然是创建在磁盘上占用一个数据块了 (如果文件对应的块不存在的话) */\n\t\tif (!(block = create_block(inode,pos/BLOCK_SIZE)))\n\t\t\tbreak;\n        /* 根据数据块获得相应的缓冲块 */\n\t\tif (!(bh=bread(inode->i_dev,block)))\n\t\t\tbreak;\n        /* 在缓冲块中的偏移量 */\n\t\tc = pos % BLOCK_SIZE;\n        /* 定位到具体的缓冲区的内存地址 */\n\t\tp = c + bh->b_data;\n\t\tbh->b_dirt = 1;\n        /* 当前这个缓冲块还有多少字节可写 */\n\t\tc = BLOCK_SIZE-c;\n        /* 如果需要写入的数据量少于 c */\n\t\tif (c > count-i) c = count-i;\n        /* 添加偏移量计数, 更新数据结构中维护的值 */\n\t\tpos += c;\n\t\tif (pos > inode->i_size) {\n\t\t\tinode->i_size = pos;\n\t\t\tinode->i_dirt = 1;\n\t\t}\n\t\ti += c;\n        /* 向缓冲块逐字节写入数据 */\n\t\twhile (c--\x3e0)\n\t\t\t*(p++) = get_fs_byte(buf++);\n        /* 释放对缓冲块的占用，当然，在释放前会完成缓冲块<->外存数据块的同步 */\n\t\tbrelse(bh);\n\t}\n\tinode->i_mtime = CURRENT_TIME;\n\tif (!(filp->f_flags & O_APPEND)) {\n        /* 非 APPEND 模式，更新文件读写指针(偏移量); APPEND 模式是使用 inode->i_size ，所有就不需要在这里更新了 */\n\t\tfilp->f_pos = pos;\n\t\tinode->i_ctime = CURRENT_TIME;\n\t}\n\treturn (i?i:-1);\n}\n```\n\n是不是觉得也没有什么太高大上的操作。确实如此，更多关于缓存块与文件系统数据块的同步都已经被包装到 bread(), brelse() 中了。\n\n不过，暂时无需细究。总之到此为止，先要有一个基础的观念: 所有与外存储器(这里也包括控制台等)进行数据交互都必须经过缓冲区\n\n缓冲区封装了对外存储器的全部操作，而提供给 CPU 更高效的 I/O 操作，当然，也更为简单快捷\n\n\n### 文件读取\n\n至于文件读取，也基本类似了，所以也就不再深入描述。\n\n当然，要注意的就是，在本篇开始的部分提供的例程中，write & read 中插入了 `off_t off = lseek(fd, 0, SEEK_SET);`  这样的代码。\n\n原因应该也能够想到，学习 `sys_write(..)` 的时候我们已经看到，任务对同一个文件在内存中维护了一个文件读写偏移量。因此，要读取刚才写入的内容，就不得不先改动这个读写偏移量了\n\n```c\nint sys_read(unsigned int fd,char * buf,int count)\n{\n\tstruct file * file;\n\tstruct m_inode * inode;\n\n\tif (fd>=NR_OPEN || count<0 || !(file=current->filp[fd]))\n\t\treturn -EINVAL;\n\tif (!count)\n\t\treturn 0;\n\tverify_area(buf,count);\n\tinode = file->f_inode;\n\tif (inode->i_pipe)\n\t\treturn (file->f_mode&1)?read_pipe(inode,buf,count):-EIO;\n\tif (S_ISCHR(inode->i_mode))\n\t\treturn rw_char(READ,inode->i_zone[0],buf,count,&file->f_pos);\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn block_read(inode->i_zone[0],&file->f_pos,buf,count);\n\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode)) {\n\t\tif (count+file->f_pos > inode->i_size)\n\t\t\tcount = inode->i_size - file->f_pos;\n\t\tif (count<=0)\n\t\t\treturn 0;\n\t\treturn file_read(inode,file,buf,count);\n\t}\n\tprintk("(Read)inode->i_mode=%06o\\n\\r",inode->i_mode);\n\treturn -EINVAL;\n}\n```\n\n## 小结\n\n这篇对文件系统的代码层面的描述，仅仅只是捡了一个相当有限的片面 (常规文件读写)。从文件系统的挂载开始提供了一个读写的完整流程介绍(当然，很多细节是缺失的，不过不要着急)。\n\n虽然平常都能够了解到一个比较模糊的前提，文件读写需要利用缓冲区，但是究竟什么是缓存区，如何使用都不会有太多的概念。本篇最大的重点，就是首先请读者们建立起一个基础性的对缓冲区的了解。事实上，这个中介在 I/O 中扮演了相当重要的角色。而且内存也为其提供了相当大的一份空间，差不多有 1/4 了。\n\n跨了差不多半个多月来写，上下文的承接可能有些生硬了，甚至不一致了... 尴尬...\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<p><a href="https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/">前一篇</a>已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。</p>\n<p>首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式</p>\n<pre><code class="hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span>\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">panic</span><span class="hljs-params">()</span>\n</span>{\n    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s (errno=%d)\\n"</span>, strerror(errno), errno);\n    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;\n}\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span>\n</span>{\n    <span class="hljs-comment">/* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */</span>\n    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">"/root/frw.txt"</span>, O_RDWR | O_CREAT);\n    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)\n        <span class="hljs-keyword">return</span> panic();\n\n    <span class="hljs-comment">/* 向文件写入 Hello World! 共计 12 个字符 */</span>\n    <span class="hljs-keyword">ssize_t</span> wsize = write(fd, <span class="hljs-string">"Hello World!"</span>, <span class="hljs-number">12</span>);\n    <span class="hljs-keyword">if</span> (wsize == <span class="hljs-number">-1</span>)\n        <span class="hljs-keyword">return</span> panic();\n\n    <span class="hljs-comment">/* 重定位文件读写指针 */</span>\n    <span class="hljs-keyword">off_t</span> off = lseek(fd, <span class="hljs-number">0</span>, SEEK_SET);\n    <span class="hljs-keyword">if</span> (off == <span class="hljs-number">-1</span>)\n        <span class="hljs-keyword">return</span> panic();\n\n    <span class="hljs-keyword">char</span>* buf = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span>(wsize);\n    <span class="hljs-comment">/* 读取文件内容 */</span>\n    <span class="hljs-keyword">ssize_t</span> rsize = read(fd, buf, wsize);\n    <span class="hljs-keyword">if</span> (rsize == <span class="hljs-number">-1</span>)\n        <span class="hljs-keyword">return</span> panic();\n\n    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\\n"</span>, buf);\n    <span class="hljs-built_in">free</span>(buf);\n    <span class="hljs-comment">/* 关闭文件 */</span>\n    <span class="hljs-keyword">int</span> stat = close(fd);\n    <span class="hljs-keyword">if</span> (stat == <span class="hljs-number">-1</span>)\n        <span class="hljs-keyword">return</span> panic();\n\n    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n}</code></pre><p>&lt;!-- more --&gt;</p>\n<h2>高速缓冲区初始化</h2>\n<p>上一篇已经描述过了，文件系统的结构、包括数据，都是持久化地存储在存储设备中的。</p>\n<p>但是，我们应该也隐约的了解另一个事实，文件读写操作并不会直接操作存储设备上的数据，而是先经过一个称之为高速缓冲的内存区域。</p>\n<p>那么，高速缓冲是什么? 究竟承担什么工作? 先来看看它的初始化流程吧。</p>\n<p>首先回到 <code>main.c</code> (内核代码的主函数)</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\t\n</span>{\n \tROOT_DEV = ORIG_ROOT_DEV;\n \tdrive_info = DRIVE_INFO;\n\tmemory_end = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="hljs-number">10</span>);\n\tmemory_end &amp;= <span class="hljs-number">0xfffff000</span>;\n\t<span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">16</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)\n\t\tmemory_end = <span class="hljs-number">16</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;\n\t<span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">12</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)\n\t\tbuffer_memory_end = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;\n\t<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">6</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)\n\t\tbuffer_memory_end = <span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;\n\t<span class="hljs-keyword">else</span>\n\t\tbuffer_memory_end = <span class="hljs-number">1</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;\n\tmain_memory_start = buffer_memory_end;\n<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> RAMDISK</span>\n\tmain_memory_start += rd_init(main_memory_start, RAMDISK*<span class="hljs-number">1024</span>);\n<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>\n\tmem_init(main_memory_start,memory_end);\n\ttrap_init();\n\tblk_dev_init();\n\tchr_dev_init();\n\ttty_init();\n\ttime_init();\n\tsched_init();                       <span class="hljs-comment">// 第四篇已经讲过，负责任务调度模块的初始化</span>\n\tbuffer_init(buffer_memory_end);     <span class="hljs-comment">// 本篇的起始，负责缓冲区的初始化</span>\n\thd_init();\n\tfloppy_init();\n\tsti();\n\tmove_to_user_mode();\n\t<span class="hljs-keyword">if</span> (!fork()) {\t\t<span class="hljs-comment">/* we count on this going ok */</span>\n\t\tinit();\n\t}\n\t<span class="hljs-keyword">for</span>(;;) pause();\n}</code></pre><p><code>buffer_init(buffer_memory_end);</code> 用来初始化缓冲区。此处有几个原因:</p>\n<ol>\n<li>\n<p>CPU 读写操作如果直接操作外存，速度上是一个极大的考验。毕竟内存已经较之 CPU 速度慢，外存的读写速度就更慢了。</p>\n</li>\n<li>\n<p>解耦，其实读写操作并不仅仅发生在外存(块存储设备)，同样的，字符设备等等也都会需要读写操作，增加中间层可以封装变化。</p>\n</li>\n<li>\n<p>更多，个人了解有限...</p>\n</li>\n</ol>\n<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> {</span>\n <span class="hljs-keyword">char</span> * b_data;\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> b_blocknr;\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> b_dev;\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> b_uptodate;\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> b_dirt;\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> b_count;\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> b_lock;\n <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> * <span class="hljs-title">b_wait</span>;</span>\n <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">b_prev</span>;</span>\n <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">b_next</span>;</span>\n <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">b_prev_free</span>;</span>\n <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">b_next_free</span>;</span>\n};\n\n<span class="hljs-comment">/* from fs/buffer.c */</span>\n<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buffer_init</span><span class="hljs-params">(<span class="hljs-keyword">long</span> buffer_end)</span>\n</span>{\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">h</span> = <span class="hljs-title">start_buffer</span>;</span>\n\t<span class="hljs-keyword">void</span> * b;\n\t<span class="hljs-keyword">int</span> i;\n\n\t<span class="hljs-keyword">if</span> (buffer_end == <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)\n\t\tb = (<span class="hljs-keyword">void</span> *) (<span class="hljs-number">640</span>*<span class="hljs-number">1024</span>);\n\t<span class="hljs-keyword">else</span>\n\t\tb = (<span class="hljs-keyword">void</span> *) buffer_end;\n\t<span class="hljs-keyword">while</span> ( (b -= BLOCK_SIZE) &gt;= ((<span class="hljs-keyword">void</span> *) (h+<span class="hljs-number">1</span>)) ) {\n\t\th-&gt;b_dev = <span class="hljs-number">0</span>;\n\t\th-&gt;b_dirt = <span class="hljs-number">0</span>;\n\t\th-&gt;b_count = <span class="hljs-number">0</span>;\n\t\th-&gt;b_lock = <span class="hljs-number">0</span>;\n\t\th-&gt;b_uptodate = <span class="hljs-number">0</span>;\n\t\th-&gt;b_wait = <span class="hljs-literal">NULL</span>;\n\t\th-&gt;b_next = <span class="hljs-literal">NULL</span>;\n\t\th-&gt;b_prev = <span class="hljs-literal">NULL</span>;\n\t\th-&gt;b_data = (<span class="hljs-keyword">char</span> *) b;\n\t\th-&gt;b_prev_free = h<span class="hljs-number">-1</span>;\n\t\th-&gt;b_next_free = h+<span class="hljs-number">1</span>;\n\t\th++;\n\t\tNR_BUFFERS++;\n        <span class="hljs-comment">/* 跳过 640K ~ 1M 的显存和 BIOS RAM 部分 */</span>\n\t\t<span class="hljs-keyword">if</span> (b == (<span class="hljs-keyword">void</span> *) <span class="hljs-number">0x100000</span>)\n\t\t\tb = (<span class="hljs-keyword">void</span> *) <span class="hljs-number">0xA0000</span>;\n\t}\n\th--;\n\tfree_list = start_buffer;\n\tfree_list-&gt;b_prev_free = h;\n\th-&gt;b_next_free = free_list;\n\t<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;NR_HASH;i++)\n\t\thash_table[i]=<span class="hljs-literal">NULL</span>;\n}</code></pre><p>缓冲块的所有关键信息都由 <code>buffer_head</code> 数据结构进行记录, 至于有多少个 <code>buffer_head</code>? 只能说能划分多少就划分多少。</p>\n<p>比较直观的结构信息如下</p>\n<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwy2iag1exj31kw0k1dgb.jpg" alt=""></p>\n<p>在 <code>main.c</code> 中已经提前确认了内核程序占用内存的大小，缓冲区大小以及主内存大小。</p>\n<p>在高速缓冲区的开始位置，都用来存储 <code>buffer_head</code> 的信息，与每个缓冲块(从缓冲区结束位置开始分配)一一对应，直到中间某个位置不足以分配缓冲块为止。</p>\n<p>另外的信息，就是可以看到一个 <code>hash_table</code> 数据结构了。</p>\n<p>应该都能够想象，每个缓存块与外存中的数据块相对应，通过设备号 + 数据块号进行唯一定位。但是，如何快速查找需要操作的数据块是否已经存在与高速缓存中了呢? 显然直接遍历查找是不太可靠的办法。采用开放地址法的哈希表能够协助快速定位缓冲块。</p>\n<h2>挂载文件系统</h2>\n<p>既然高速缓冲区都准备就绪了，那么文件系统是否已经挂载了呢? 很遗憾，知道 <code>main()</code> 调用 <code>init()</code> 函数之前，文件系统依然没有挂载，也就是说，CPU 仍然只能通过基本输入输出对存储设备进行相当初级的 IO 操作。</p>\n<p>那么，什么时候才能去挂载根目录呢?</p>\n<pre><code class="hljs"><span class="hljs-comment">/* from init/main.c */</span>\n<span class="hljs-comment">/* 由 main() 触发 */</span>\n<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n\t<span class="hljs-keyword">int</span> pid,i;\n    <span class="hljs-comment">/* 这是比较重要的一环了，开始挂载的起始动作 */</span>\n\tsetup((<span class="hljs-keyword">void</span> *) &amp;drive_info);\n    ...\n}</code></pre><p><code>setup</code> 函数做了什么呢？这是一个内嵌汇编，主要做的就是触发系统调用 <code>int 0x80</code></p>\n<pre><code class="hljs">__inline__ int setup(void * BIOS) { \n    long __res; \n    __asm__ volatile (\n            "int $0x80" \n            : "=a" (__res) \n            : "0" (0),"b" ((long)(BIOS))\n    ); \n    if (__res &gt;= 0) \n        return (int) __res; \n    errno = -__res; \n    return -1; \n}</code></pre><p>其中看到给出的 <code>EAX = 0</code>, 查表(表在 <code>include/linux/sys.h</code> 里) 可以知道触发的是 <code>sys_setup</code> 函数(函数位于 <code>kernel/blk_drv/hd.c</code>)</p>\n<pre><code class="hljs"><span class="hljs-comment">/* This may be used only once, enforced by \'static int callable\' */</span>\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sys_setup</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * BIOS)</span>\n</span>{\n\t<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> callable = <span class="hljs-number">1</span>;\n\t<span class="hljs-keyword">int</span> i,drive;\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> cmos_disks;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition</span> *<span class="hljs-title">p</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">bh</span>;</span>\n\n    <span class="hljs-comment">/* setup 只允许被调用一次 */</span>\n\t<span class="hljs-keyword">if</span> (!callable)\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;\n\tcallable = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">/* 可以强制在源码中指定硬盘参数, 所以加了宏定义作判断*/</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> HD_TYPE</span>\n\t<span class="hljs-keyword">for</span> (drive=<span class="hljs-number">0</span> ; drive&lt;<span class="hljs-number">2</span> ; drive++) {\n\t\thd_info[drive].cyl = *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *) BIOS;\n\t\thd_info[drive].head = *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *) (<span class="hljs-number">2</span>+BIOS);\n\t\thd_info[drive].wpcom = *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *) (<span class="hljs-number">5</span>+BIOS);\n\t\thd_info[drive].ctl = *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *) (<span class="hljs-number">8</span>+BIOS);\n\t\thd_info[drive].lzone = *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *) (<span class="hljs-number">12</span>+BIOS);\n\t\thd_info[drive].sect = *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *) (<span class="hljs-number">14</span>+BIOS);\n\t\tBIOS += <span class="hljs-number">16</span>;\n\t}\n\t<span class="hljs-keyword">if</span> (hd_info[<span class="hljs-number">1</span>].cyl)\n\t\tNR_HD=<span class="hljs-number">2</span>;\n\t<span class="hljs-keyword">else</span>\n\t\tNR_HD=<span class="hljs-number">1</span>;\n<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>\n\t<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;NR_HD ; i++) {\n\t\thd[i*<span class="hljs-number">5</span>].start_sect = <span class="hljs-number">0</span>;\n\t\thd[i*<span class="hljs-number">5</span>].nr_sects = hd_info[i].head*\n\t\t\t\thd_info[i].sect*hd_info[i].cyl;\n\t}\n\n\t<span class="hljs-comment">/*\n\t\tWe querry CMOS about hard disks : it could be that\n\t\twe have a SCSI/ESDI/etc controller that is BIOS\n\t\tcompatable with ST-506, and thus showing up in our\n\t\tBIOS table, but not register compatable, and therefore\n\t\tnot present in CMOS.\n\n\t\tFurthurmore, we will assume that our ST-506 drives\n\t\t&lt;if any&gt; are the primary drives in the system, and\n\t\tthe ones reflected as drive 1 or 2.\n\n\t\tThe first drive is stored in the high nibble of CMOS\n\t\tbyte 0x12, the second in the low nibble.  This will be\n\t\teither a 4 bit drive type or 0xf indicating use byte 0x19\n\t\tfor an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.\n\n\t\tNeedless to say, a non-zero value means we have\n\t\tan AT controller hard disk for that drive.\n\n\n\t*/</span>\n\n\t<span class="hljs-keyword">if</span> ((cmos_disks = CMOS_READ(<span class="hljs-number">0x12</span>)) &amp; <span class="hljs-number">0xf0</span>)\n\t\t<span class="hljs-keyword">if</span> (cmos_disks &amp; <span class="hljs-number">0x0f</span>)\n\t\t\tNR_HD = <span class="hljs-number">2</span>;\n\t\t<span class="hljs-keyword">else</span>\n\t\t\tNR_HD = <span class="hljs-number">1</span>;\n\t<span class="hljs-keyword">else</span>\n\t\tNR_HD = <span class="hljs-number">0</span>;\n\t<span class="hljs-keyword">for</span> (i = NR_HD ; i &lt; <span class="hljs-number">2</span> ; i++) {\n\t\thd[i*<span class="hljs-number">5</span>].start_sect = <span class="hljs-number">0</span>;\n\t\thd[i*<span class="hljs-number">5</span>].nr_sects = <span class="hljs-number">0</span>;\n\t}\n    <span class="hljs-comment">/* 更进一步设置每个盘的参数 */</span>\n\t<span class="hljs-keyword">for</span> (drive=<span class="hljs-number">0</span> ; drive&lt;NR_HD ; drive++) {\n        <span class="hljs-comment">/* 0x300 和 0x305 分别代表两个硬盘 */</span>\n        <span class="hljs-comment">/* 读取每个硬盘的第一块数据 (1024B) */</span>\n\t\t<span class="hljs-keyword">if</span> (!(bh = bread(<span class="hljs-number">0x300</span> + drive*<span class="hljs-number">5</span>,<span class="hljs-number">0</span>))) {\n\t\t\tprintk(<span class="hljs-string">"Unable to read partition table of drive %d\\n\\r"</span>,\n\t\t\t\tdrive);\n\t\t\tpanic(<span class="hljs-string">""</span>);\n\t\t}\n        <span class="hljs-comment">/* 判断硬盘有效性 */</span>\n\t\t<span class="hljs-keyword">if</span> (bh-&gt;b_data[<span class="hljs-number">510</span>] != <span class="hljs-number">0x55</span> || (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)\n\t\t    bh-&gt;b_data[<span class="hljs-number">511</span>] != <span class="hljs-number">0xAA</span>) {\n\t\t\tprintk(<span class="hljs-string">"Bad partition table on drive %d\\n\\r"</span>,drive);\n\t\t\tpanic(<span class="hljs-string">""</span>);\n\t\t}\n        <span class="hljs-comment">/* 读取分区表 (位于 引导扇区第 446 字节开始处 */</span>\n\t\tp = <span class="hljs-number">0x1BE</span> + (<span class="hljs-keyword">void</span> *)bh-&gt;b_data;\n\t\t<span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">5</span>;i++,p++) {\n\t\t\thd[i+<span class="hljs-number">5</span>*drive].start_sect = p-&gt;start_sect;\n\t\t\thd[i+<span class="hljs-number">5</span>*drive].nr_sects = p-&gt;nr_sects;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\t<span class="hljs-keyword">if</span> (NR_HD)\n\t\tprintk(<span class="hljs-string">"Partition table%s ok.\\n\\r"</span>,(NR_HD&gt;<span class="hljs-number">1</span>)?<span class="hljs-string">"s"</span>:<span class="hljs-string">""</span>);\n\trd_load();              <span class="hljs-comment">/* 尝试创建并加载虚拟盘 */</span>\n\tmount_root();           <span class="hljs-comment">/* mount 根文件系统 */</span>\n\t<span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);\n}</code></pre><p>终于到了挂载文件系统的时候了</p>\n<p><code>mount_root</code> 用来做初级的初始化工作。同时，上一节已经描述过了，存储设备的超级块是用了记录整个文件系统最重要的结构。</p>\n<p>那么通过将超级块的信息读取到内存，也就可以将内存与外存的文件系统相互联系起来了。</p>\n<p>下面这段代码最重要的内容就是 <code>read_super()</code> 函数了 .</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mount_root</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n\t<span class="hljs-keyword">int</span> i,<span class="hljs-built_in">free</span>;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> * <span class="hljs-title">p</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">mi</span>;</span>\n\n\t<span class="hljs-keyword">if</span> (<span class="hljs-number">32</span> != <span class="hljs-keyword">sizeof</span> (struct d_inode))\n\t\tpanic(<span class="hljs-string">"bad i-node size"</span>);\n    <span class="hljs-comment">/* 先初始化文件表，该版本操作系统限制最大同时打开 NR_FILE(64个) 文件 */</span>\n\t<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;NR_FILE;i++)\n        <span class="hljs-comment">/* f_count = 0 表明没有被引用 */</span>\n\t\tfile_table[i].f_count=<span class="hljs-number">0</span>;\n    <span class="hljs-comment">/* 如果引导盘是软盘的话，提示插入根文件系统盘 */</span>\n\t<span class="hljs-keyword">if</span> (MAJOR(ROOT_DEV) == <span class="hljs-number">2</span>) {\n\t\tprintk(<span class="hljs-string">"Insert root floppy and press ENTER"</span>);\n\t\twait_for_keypress();\n\t}\n    <span class="hljs-comment">/* 初始化内存超级块数据结构 (总共 8 个) */</span>\n\t<span class="hljs-keyword">for</span>(p = &amp;super_block[<span class="hljs-number">0</span>] ; p &lt; &amp;super_block[NR_SUPER] ; p++) {\n\t\tp-&gt;s_dev = <span class="hljs-number">0</span>;\n\t\tp-&gt;s_lock = <span class="hljs-number">0</span>;\n\t\tp-&gt;s_wait = <span class="hljs-literal">NULL</span>;\n\t}\n    <span class="hljs-comment">/* Hint: 读取超级块的信息，挂载根文件系统重要的部分(代码请往下翻) */</span>\n\t<span class="hljs-keyword">if</span> (!(p=read_super(ROOT_DEV)))\n\t\tpanic(<span class="hljs-string">"Unable to mount root"</span>);\n    <span class="hljs-comment">/* 读取文件系统的 1 号i节点 (即该设备上文件系统的根节点) */</span>\n\t<span class="hljs-keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO)))\n\t\tpanic(<span class="hljs-string">"Unable to read root i-node"</span>);\n\tmi-&gt;i_count += <span class="hljs-number">3</span> ;\t<span class="hljs-comment">/* NOTE! it is logically used 4 times, not 1 */</span>\n\tp-&gt;s_isup = p-&gt;s_imount = mi;\n    <span class="hljs-comment">/* 应该还记得吧，current 指的是当前的任务(任务1)，以后所有的任务都会由任务1或任务1的子任务进行派生，也就意味着 current-&gt;root 会一直复制过去\n     * 到这里为止，应该认为根文件系统以及被挂载了。是不是跟被耍了一样?\n     */</span>\n\tcurrent-&gt;pwd = mi;\n\tcurrent-&gt;root = mi;\n\t<span class="hljs-built_in">free</span>=<span class="hljs-number">0</span>;\n\ti=p-&gt;s_nzones;\n    <span class="hljs-comment">/* 统计还有多少空闲数据块以及多少可用i节点 (附上一张启动过程中打印的信息) */</span>\n\t<span class="hljs-keyword">while</span> (-- i &gt;= <span class="hljs-number">0</span>)\n\t\t<span class="hljs-keyword">if</span> (!set_bit(i&amp;<span class="hljs-number">8191</span>,p-&gt;s_zmap[i&gt;&gt;<span class="hljs-number">13</span>]-&gt;b_data))\n\t\t\t<span class="hljs-built_in">free</span>++;\n\tprintk(<span class="hljs-string">"%d/%d free blocks\\n\\r"</span>,<span class="hljs-built_in">free</span>,p-&gt;s_nzones);\n\t<span class="hljs-built_in">free</span>=<span class="hljs-number">0</span>;\n\ti=p-&gt;s_ninodes+<span class="hljs-number">1</span>;\n\t<span class="hljs-keyword">while</span> (-- i &gt;= <span class="hljs-number">0</span>)\n\t\t<span class="hljs-keyword">if</span> (!set_bit(i&amp;<span class="hljs-number">8191</span>,p-&gt;s_imap[i&gt;&gt;<span class="hljs-number">13</span>]-&gt;b_data))\n\t\t\t<span class="hljs-built_in">free</span>++;\n\tprintk(<span class="hljs-string">"%d/%d free inodes\\n\\r"</span>,<span class="hljs-built_in">free</span>,p-&gt;s_ninodes);\n}</code></pre><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwz8kvvgbpj30l006i3yb.jpg" alt=""></p>\n<p>重要要的部分，<code>read_super(int dev)</code>，用于读取超级块的数据</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> struct super_block * <span class="hljs-title">read_super</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dev)</span>\n</span>{\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> * <span class="hljs-title">s</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">bh</span>;</span>\n\t<span class="hljs-keyword">int</span> i,block;\n\n\t<span class="hljs-keyword">if</span> (!dev)\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;\n\tcheck_disk_change(dev);\n    <span class="hljs-comment">/* 如果该超级块已经在内存中了，那么就直接使用 (和这里挂载根文件系统的流程无关) */</span>\n\t<span class="hljs-keyword">if</span> (s = get_super(dev))\n\t\t<span class="hljs-keyword">return</span> s;\n    <span class="hljs-comment">/* 设备超级块不在内存中，就先找一个空闲的内存超级块 (总共维护 8 个超级块数据结构) */</span>\n\t<span class="hljs-keyword">for</span> (s = <span class="hljs-number">0</span>+super_block ;; s++) {\n\t\t<span class="hljs-keyword">if</span> (s &gt;= NR_SUPER+super_block)\n\t\t\t<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;\n\t\t<span class="hljs-keyword">if</span> (!s-&gt;s_dev)\n\t\t\t<span class="hljs-keyword">break</span>;\n\t}\n\ts-&gt;s_dev = dev;\n\ts-&gt;s_isup = <span class="hljs-literal">NULL</span>;\n\ts-&gt;s_imount = <span class="hljs-literal">NULL</span>;\n\ts-&gt;s_time = <span class="hljs-number">0</span>;\n\ts-&gt;s_rd_only = <span class="hljs-number">0</span>;\n\ts-&gt;s_dirt = <span class="hljs-number">0</span>;\n\tlock_super(s);\n    <span class="hljs-comment">/* 通过 block read 读取设备第一个物理块 (每个物理块 1024 B) */</span>\n\t<span class="hljs-keyword">if</span> (!(bh = bread(dev,<span class="hljs-number">1</span>))) {\n\t\ts-&gt;s_dev=<span class="hljs-number">0</span>;\n\t\tfree_super(s);\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;\n\t}\n    <span class="hljs-comment">/* 复制一份超级块的数据 */</span>\n\t*((struct d_super_block *) s) =\n\t\t*((struct d_super_block *) bh-&gt;b_data);\n    <span class="hljs-comment">/* 释放缓冲区的数据 */</span>\n\tbrelse(bh);\n    <span class="hljs-comment">/* 验证魔数, 该版本操作系统只支持 1.0 版 Minix 文件系统，魔数 0x137F */</span>\n\t<span class="hljs-keyword">if</span> (s-&gt;s_magic != SUPER_MAGIC) {\n\t\ts-&gt;s_dev = <span class="hljs-number">0</span>;\n\t\tfree_super(s);\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;\n\t}\n    <span class="hljs-comment">/* 先清空内存中的数据 */</span>\n\t<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;I_MAP_SLOTS;i++)\n\t\ts-&gt;s_imap[i] = <span class="hljs-literal">NULL</span>;\n\t<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;Z_MAP_SLOTS;i++)\n\t\ts-&gt;s_zmap[i] = <span class="hljs-literal">NULL</span>;\n\tblock=<span class="hljs-number">2</span>;\n    <span class="hljs-comment">/* 读取 i 节点位图块 */</span>\n\t<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i &lt; s-&gt;s_imap_blocks ; i++)\n\t\t<span class="hljs-keyword">if</span> (s-&gt;s_imap[i]=bread(dev,block))\n\t\t\tblock++;\n\t\t<span class="hljs-keyword">else</span>\n\t\t\t<span class="hljs-keyword">break</span>;\n    <span class="hljs-comment">/* 读取数据块位图 */</span>\n\t<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i &lt; s-&gt;s_zmap_blocks ; i++)\n\t\t<span class="hljs-keyword">if</span> (s-&gt;s_zmap[i]=bread(dev,block))\n\t\t\tblock++;\n\t\t<span class="hljs-keyword">else</span>\n\t\t\t<span class="hljs-keyword">break</span>;\n\t<span class="hljs-keyword">if</span> (block != <span class="hljs-number">2</span>+s-&gt;s_imap_blocks+s-&gt;s_zmap_blocks) {\n\t\t<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;I_MAP_SLOTS;i++)\n\t\t\tbrelse(s-&gt;s_imap[i]);\n\t\t<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;Z_MAP_SLOTS;i++)\n\t\t\tbrelse(s-&gt;s_zmap[i]);\n\t\ts-&gt;s_dev=<span class="hljs-number">0</span>;\n\t\tfree_super(s);\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;\n\t}\n\ts-&gt;s_imap[<span class="hljs-number">0</span>]-&gt;b_data[<span class="hljs-number">0</span>] |= <span class="hljs-number">1</span>;\n\ts-&gt;s_zmap[<span class="hljs-number">0</span>]-&gt;b_data[<span class="hljs-number">0</span>] |= <span class="hljs-number">1</span>;\n    <span class="hljs-comment">/* 与前面的 wait_on_super() 对应(解开lock标志) */</span>\n\tfree_super(s);\n\t<span class="hljs-keyword">return</span> s;\n}</code></pre><p>是不是觉得也没什么，就这样根文件系统已经挂载了? 毫无实感是吧。</p>\n<h2>Extra: 普通挂载</h2>\n<p>既然讲过了根文件系统的挂载。那就顺带着讲讲普通文件系统的挂载吧。</p>\n<p>相信从命令上来讲应该比较简单也比较熟悉吧。<code>mount disk.img /mnt</code> 也算是挂载到 /mnt 下了</p>\n<p>但是，究竟是怎么实现的呢?</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sys_mount</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * dev_name, <span class="hljs-keyword">char</span> * dir_name, <span class="hljs-keyword">int</span> rw_flag)</span>\n</span>{\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">dev_i</span>, * <span class="hljs-title">dir_i</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> * <span class="hljs-title">sb</span>;</span>\n\t<span class="hljs-keyword">int</span> dev;\n\n    <span class="hljs-comment">/** \n     * 省略大部分判断逻辑, 主要就是:\n     * 1. 判断 dev_name 所属的设备号，读取该设备上的超级块\n     * 2. 读取 dir_name (需要挂载到的位置)，判定是否允许被挂载(比如根节点不允许挂其它设备)\n     */</span>\n    ...\n\n    <span class="hljs-comment">/* 设置超级块的 mount 标志 */</span>\n\tsb-&gt;s_imount=dir_i;\n    <span class="hljs-comment">/* 设置该 i 节点的 mount 标志 */</span>\n\tdir_i-&gt;i_mount=<span class="hljs-number">1</span>;\n\tdir_i-&gt;i_dirt=<span class="hljs-number">1</span>;\t\t<span class="hljs-comment">/* NOTE! we don\'t iput(dir_i) */</span>\n\t<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\t\t\t<span class="hljs-comment">/* we do that in umount */</span>\n}</code></pre><h2>文件读写</h2>\n<p>前面讲了这么多，终于到了最关心的部分了。当然，也并不是说前面的内容不重要，事实上，相当重要，只是都隐藏在了内核引导的过程中，且调用频度低，才导致了没有存在感。但是这恰恰才是支持文件读写的基石。</p>\n<p>不多说废话，下面就要开始文件读写的内容。</p>\n<h3>打开文件</h3>\n<p>打开文件的函数原型是 <code>int open(const char * filename, int flag, ...);</code></p>\n<p>当然，此类系统调用最终的实现都是 <code>int 0x80</code> , 明确一个调用号，然后就陷入内核态了。</p>\n<p>内核态下调用的函数是: <code>int sys_open(const char * filename,int flag,int mode)</code></p>\n<p>来看看细节:</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sys_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename,<span class="hljs-keyword">int</span> flag,<span class="hljs-keyword">int</span> mode)</span>\n</span>{\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">inode</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">f</span>;</span>\n\t<span class="hljs-keyword">int</span> i,fd;\n\n    <span class="hljs-comment">/*\n     * current 是由内核数据段维护的当前任务的指针\n     * umask 是指当前任务在新建文件时的默认掩码\n     *   例如 Linux 默认是 022, 即新建文件被禁止了组用户与其它用户的写权限\n     * 这里是先确定新建文件的权限\n     */</span>\n\tmode &amp;= <span class="hljs-number">0777</span> &amp; ~current-&gt;umask;\n    <span class="hljs-comment">/*\n     * 文件描述符，每个文件单独维护一套，以数字标记\n     * 找一个空闲的文件描述符项\n     */</span>\n\t<span class="hljs-keyword">for</span>(fd=<span class="hljs-number">0</span> ; fd&lt;NR_OPEN ; fd++)\n\t\t<span class="hljs-keyword">if</span> (!current-&gt;filp[fd])\n\t\t\t<span class="hljs-keyword">break</span>;\n\t<span class="hljs-keyword">if</span> (fd&gt;=NR_OPEN)\n\t\t<span class="hljs-keyword">return</span> -EINVAL;\n    <span class="hljs-comment">/*\n     * 顾名思义，设置在调用 exec() 函数时主动关闭的文件\n     * exec() 通常与 fork() 联用，fork() 负责复制一个任务，而 exec 负责替换新任务的代码和数据段(从而产生一个新的任务)\n     * 这里的声明即是复位 fd 位置的标志，允许子任务也持有相同的文件描述符项\n     */</span>\n\tcurrent-&gt;close_on_exec &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;fd);\n\tf=<span class="hljs-number">0</span>+file_table;\n    <span class="hljs-comment">/* 在文件表中找一项空闲的 */</span>\n\t<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;NR_FILE ; i++,f++)\n\t\t<span class="hljs-keyword">if</span> (!f-&gt;f_count) <span class="hljs-keyword">break</span>;\n\t<span class="hljs-keyword">if</span> (i&gt;=NR_FILE)\n\t\t<span class="hljs-keyword">return</span> -EINVAL;\n    <span class="hljs-comment">/* 当前任务的文件描述符项指向文件表项, 同时文件表项的引用计数+1*/</span>\n\t(current-&gt;filp[fd]=f)-&gt;f_count++;\n    <span class="hljs-comment">/* 调用 open_namei 打开文件，如果失败则释放刚才占用的文件结构，并返回错误码 */</span>\n\t<span class="hljs-keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="hljs-number">0</span>) {\n\t\tcurrent-&gt;filp[fd]=<span class="hljs-literal">NULL</span>;\n\t\tf-&gt;f_count=<span class="hljs-number">0</span>;\n\t\t<span class="hljs-keyword">return</span> i;\n\t}\n    <span class="hljs-comment">/* \n     * 对不同的文件进行不同的特殊处理, 毕竟有 "一切皆文件" 的口号嘛\n     * 诸如字符设备等也都是文件\n     */</span>\n<span class="hljs-comment">/* ttys are somewhat special (ttyxx major==4, tty major==5) */</span>\n\t<span class="hljs-keyword">if</span> (S_ISCHR(inode-&gt;i_mode))\n\t\t<span class="hljs-keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="hljs-number">0</span>])==<span class="hljs-number">4</span>) {\n\t\t\t<span class="hljs-keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty&lt;<span class="hljs-number">0</span>) {\n\t\t\t\tcurrent-&gt;tty = MINOR(inode-&gt;i_zone[<span class="hljs-number">0</span>]);\n\t\t\t\ttty_table[current-&gt;tty].pgrp = current-&gt;pgrp;\n\t\t\t}\n\t\t} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="hljs-number">0</span>])==<span class="hljs-number">5</span>)\n\t\t\t<span class="hljs-keyword">if</span> (current-&gt;tty&lt;<span class="hljs-number">0</span>) {\n\t\t\t\tiput(inode);\n\t\t\t\tcurrent-&gt;filp[fd]=<span class="hljs-literal">NULL</span>;\n\t\t\t\tf-&gt;f_count=<span class="hljs-number">0</span>;\n\t\t\t\t<span class="hljs-keyword">return</span> -EPERM;\n\t\t\t}\n<span class="hljs-comment">/* Likewise with block-devices: check for floppy_change */</span>\n\t<span class="hljs-keyword">if</span> (S_ISBLK(inode-&gt;i_mode))\n\t\tcheck_disk_change(inode-&gt;i_zone[<span class="hljs-number">0</span>]);\n    <span class="hljs-comment">/* 初始化内存文件结构的各个参数 */</span>\n\tf-&gt;f_mode = inode-&gt;i_mode;\n\tf-&gt;f_flags = flag;\n\tf-&gt;f_count = <span class="hljs-number">1</span>;\n\tf-&gt;f_inode = inode;\n\tf-&gt;f_pos = <span class="hljs-number">0</span>;\n\t<span class="hljs-keyword">return</span> (fd);\n}</code></pre><p>在整个打开文件的过程中，除了真正去文件系统查找文件的时候用到了文件名，其它时候，都将是以文件描述符进行交互的。</p>\n<p>再看看更细节的方面，毕竟就目前来说，我们跳过了最重要的一环 <code>open_namei</code> ，从而看似整个流程都简单了很多很多。</p>\n<p>通常我们在编码过程中都是通过绝对地址/相对地址来唯一定位一个文件。因此，就必然存在逐级寻找文件的过程</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> struct m_inode * <span class="hljs-title">get_dir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * pathname)</span>\n</span>{\n\t<span class="hljs-keyword">char</span> c;\n\t<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * thisname;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">inode</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">bh</span>;</span>\n\t<span class="hljs-keyword">int</span> namelen,inr,idev;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dir_entry</span> * <span class="hljs-title">de</span>;</span>\n\n    <span class="hljs-comment">/* 判定当前任务设定的根节点是否有效 */</span>\n\t<span class="hljs-keyword">if</span> (!current-&gt;root || !current-&gt;root-&gt;i_count)\n\t\tpanic(<span class="hljs-string">"No root inode"</span>);\n    <span class="hljs-comment">/* 判定当前路径i节点是否有效 */</span>\n\t<span class="hljs-keyword">if</span> (!current-&gt;pwd || !current-&gt;pwd-&gt;i_count)\n\t\tpanic(<span class="hljs-string">"No cwd inode"</span>);\n    <span class="hljs-comment">/* \n     * 这里的 get_fs_byte(..) 是宏定义，fs 指的是 FS 段寄存器\n     * Linux 内核将 DS, ES 用于内核数据段, 用 FS 指向局部描述符表的当前任务数据段\n     * 这里可以简单理解成取字符数组的第一个字节\n     */</span>\n\t<span class="hljs-keyword">if</span> ((c=get_fs_byte(pathname))==<span class="hljs-string">\'/\'</span>) {\n\t\tinode = current-&gt;root;\n\t\tpathname++;\n\t} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c)\n\t\tinode = current-&gt;pwd;\n\t<span class="hljs-keyword">else</span>\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;\t<span class="hljs-comment">/* empty name is bad */</span>\n\tinode-&gt;i_count++;\n\t<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {\n\t\tthisname = pathname;\n\t\t<span class="hljs-keyword">if</span> (!S_ISDIR(inode-&gt;i_mode) || !permission(inode,MAY_EXEC)) {\n\t\t\tiput(inode);\n\t\t\t<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;\n\t\t}\n\t\t<span class="hljs-keyword">for</span>(namelen=<span class="hljs-number">0</span>;(c=get_fs_byte(pathname++))&amp;&amp;(c!=<span class="hljs-string">\'/\'</span>);namelen++)\n\t\t\t<span class="hljs-comment">/* nothing */</span> ;\n\t\t<span class="hljs-keyword">if</span> (!c)\n\t\t\t<span class="hljs-keyword">return</span> inode;\n\t\t<span class="hljs-keyword">if</span> (!(bh = find_entry(&amp;inode,thisname,namelen,&amp;de))) {\n\t\t\tiput(inode);\n\t\t\t<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;\n\t\t}\n\t\tinr = de-&gt;inode;\n\t\tidev = inode-&gt;i_dev;\n\t\tbrelse(bh);\n\t\tiput(inode);\n\t\t<span class="hljs-keyword">if</span> (!(inode = iget(idev,inr)))\n\t\t\t<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;\n\t}\n}\n\n<span class="hljs-comment">/*\n *\tdir_namei()\n *\n * 处理路径 pathname, 处理成i节点表示的最终一级目录+目录下文件名(也可能pathname表示的就是目录)\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">static</span> struct m_inode * <span class="hljs-title">dir_namei</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * pathname, <span class="hljs-keyword">int</span> * namelen, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> ** name)</span>\n</span>{\n\t<span class="hljs-keyword">char</span> c;\n\t<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * basename;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">dir</span>;</span>\n\n\t<span class="hljs-keyword">if</span> (!(dir = get_dir(pathname)))\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;\n\tbasename = pathname;\n\t<span class="hljs-keyword">while</span> (c=get_fs_byte(pathname++))\n\t\t<span class="hljs-keyword">if</span> (c==<span class="hljs-string">\'/\'</span>)\n\t\t\tbasename=pathname;\n\t*namelen = pathname-basename<span class="hljs-number">-1</span>;\n\t*name = basename;\n\t<span class="hljs-keyword">return</span> dir;\n}\n\n<span class="hljs-comment">/*\n *\topen_namei()\n *\n * namei for open - this is in fact almost the whole open-routine.\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open_namei</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * pathname, <span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> mode,\n\tstruct m_inode ** res_inode)</span>\n</span>{\n\t<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * basename;\n\t<span class="hljs-keyword">int</span> inr,dev,namelen;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">dir</span>, *<span class="hljs-title">inode</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">bh</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dir_entry</span> * <span class="hljs-title">de</span>;</span>\n\n\t<span class="hljs-keyword">if</span> ((flag &amp; O_TRUNC) &amp;&amp; !(flag &amp; O_ACCMODE))\n\t\tflag |= O_WRONLY;\n\tmode &amp;= <span class="hljs-number">0777</span> &amp; ~current-&gt;umask;\n\tmode |= I_REGULAR;\n\t<span class="hljs-keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))\n\t\t<span class="hljs-keyword">return</span> -ENOENT;\n    <span class="hljs-comment">/* 如果给的 pathname 是一个目录 */</span>\n\t<span class="hljs-keyword">if</span> (!namelen) {\t\t\t<span class="hljs-comment">/* special case: \'/usr/\' etc */</span>\n\t\t<span class="hljs-keyword">if</span> (!(flag &amp; (O_ACCMODE|O_CREAT|O_TRUNC))) {\n\t\t\t*res_inode=dir;\n\t\t\t<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n\t\t}\n\t\tiput(dir);\n\t\t<span class="hljs-keyword">return</span> -EISDIR;\n\t}\n    <span class="hljs-comment">/* 找到目录对应的i节点的数据块 */</span>\n\tbh = find_entry(&amp;dir,basename,namelen,&amp;de);\n\t<span class="hljs-keyword">if</span> (!bh) {\n\t\t<span class="hljs-keyword">if</span> (!(flag &amp; O_CREAT)) {\n\t\t\tiput(dir);\n\t\t\t<span class="hljs-keyword">return</span> -ENOENT;\n\t\t}\n\t\t<span class="hljs-keyword">if</span> (!permission(dir,MAY_WRITE)) {\n\t\t\tiput(dir);\n\t\t\t<span class="hljs-keyword">return</span> -EACCES;\n\t\t}\n\t\tinode = new_inode(dir-&gt;i_dev);\n\t\t<span class="hljs-keyword">if</span> (!inode) {\n\t\t\tiput(dir);\n\t\t\t<span class="hljs-keyword">return</span> -ENOSPC;\n\t\t}\n\t\tinode-&gt;i_uid = current-&gt;euid;\n\t\tinode-&gt;i_mode = mode;\n\t\tinode-&gt;i_dirt = <span class="hljs-number">1</span>;\n\t\tbh = add_entry(dir,basename,namelen,&amp;de);\n\t\t<span class="hljs-keyword">if</span> (!bh) {\n\t\t\tinode-&gt;i_nlinks--;\n\t\t\tiput(inode);\n\t\t\tiput(dir);\n\t\t\t<span class="hljs-keyword">return</span> -ENOSPC;\n\t\t}\n\t\tde-&gt;inode = inode-&gt;i_num;\n\t\tbh-&gt;b_dirt = <span class="hljs-number">1</span>;\n\t\tbrelse(bh);\n\t\tiput(dir);\n\t\t*res_inode = inode;\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n\t}\n\tinr = de-&gt;inode;\n\tdev = dir-&gt;i_dev;\n\tbrelse(bh);\n\tiput(dir);\n\t<span class="hljs-keyword">if</span> (flag &amp; O_EXCL)\n\t\t<span class="hljs-keyword">return</span> -EEXIST;\n\t<span class="hljs-keyword">if</span> (!(inode=iget(dev,inr)))\n\t\t<span class="hljs-keyword">return</span> -EACCES;\n\t<span class="hljs-keyword">if</span> ((S_ISDIR(inode-&gt;i_mode) &amp;&amp; (flag &amp; O_ACCMODE)) ||\n\t    !permission(inode,ACC_MODE(flag))) {\n\t\tiput(inode);\n\t\t<span class="hljs-keyword">return</span> -EPERM;\n\t}\n\tinode-&gt;i_atime = CURRENT_TIME;\n\t<span class="hljs-keyword">if</span> (flag &amp; O_TRUNC)\n\t\ttruncate(inode);\n\t*res_inode = inode;\n\t<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n}</code></pre><h3>文件写入</h3>\n<p>接下来就要进行文件写入的流程了</p>\n<p>如何陷入内核态函数就不再细说了，相信看过这么多系统调用之后，也能知道基本上系统调用在内核态对应的函数都是以 sys_&lt;method&gt; 形式出现的</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sys_write</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">char</span> * buf,<span class="hljs-keyword">int</span> count)</span>\n</span>{\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">file</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">inode</span>;</span>\n\n    <span class="hljs-comment">/* 非法 fd , 抛异常 */</span>\n\t<span class="hljs-keyword">if</span> (fd&gt;=NR_OPEN || count &lt;<span class="hljs-number">0</span> || !(file=current-&gt;filp[fd]))\n\t\t<span class="hljs-keyword">return</span> -EINVAL;\n    <span class="hljs-comment">/* count = 0，无需写入数据 */</span>\n\t<span class="hljs-keyword">if</span> (!count)\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n\tinode=file-&gt;f_inode;\n    <span class="hljs-comment">/* 针对不同的i节点类型，有不同的写入函数 */</span>\n\t<span class="hljs-keyword">if</span> (inode-&gt;i_pipe)\n\t\t<span class="hljs-keyword">return</span> (file-&gt;f_mode&amp;<span class="hljs-number">2</span>)?write_pipe(inode,buf,count):-EIO;\n\t<span class="hljs-keyword">if</span> (S_ISCHR(inode-&gt;i_mode))\n\t\t<span class="hljs-keyword">return</span> rw_char(WRITE,inode-&gt;i_zone[<span class="hljs-number">0</span>],buf,count,&amp;file-&gt;f_pos);\n\t<span class="hljs-keyword">if</span> (S_ISBLK(inode-&gt;i_mode))\n\t\t<span class="hljs-keyword">return</span> block_write(inode-&gt;i_zone[<span class="hljs-number">0</span>],&amp;file-&gt;f_pos,buf,count);\n\t<span class="hljs-keyword">if</span> (S_ISREG(inode-&gt;i_mode))\n\t\t<span class="hljs-keyword">return</span> file_write(inode,file,buf,count);\n\tprintk(<span class="hljs-string">"(Write)inode-&gt;i_mode=%06o\\n\\r"</span>,inode-&gt;i_mode);\n\t<span class="hljs-keyword">return</span> -EINVAL;\n}</code></pre><p>看看对于常规文件是怎么操作的吧。</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">file_write</span><span class="hljs-params">(struct m_inode * inode, struct file * filp, <span class="hljs-keyword">char</span> * buf, <span class="hljs-keyword">int</span> count)</span>\n</span>{\n\t<span class="hljs-keyword">off_t</span> pos;      <span class="hljs-comment">/* 偏移量 */</span>\n\t<span class="hljs-keyword">int</span> block,c;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">bh</span>;</span>\n\t<span class="hljs-keyword">char</span> * p;\n\t<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;\n\n    <span class="hljs-comment">/* 如果是 Append 模式，把偏移量重置到文件末尾 */</span>\n\t<span class="hljs-keyword">if</span> (filp-&gt;f_flags &amp; O_APPEND) \n\t\tpos = inode-&gt;i_size;\n    <span class="hljs-comment">/* 否则就使用当前文件数据结构持有的偏移量 */</span>\n    <span class="hljs-comment">/*\n        附上数据结构  file 的内容 \n        struct file {\n        \tunsigned short f_mode;\n        \tunsigned short f_flags;\n        \tunsigned short f_count;\n        \tstruct m_inode * f_inode;\n        \toff_t f_pos;    每个打开的文件都将持有当前的偏移值\n        };\n     */</span>\n\t<span class="hljs-keyword">else</span>\n\t\tpos = filp-&gt;f_pos;\n    <span class="hljs-comment">/* 逐字符向缓冲区写入数据 */</span>\n\t<span class="hljs-keyword">while</span> (i&lt;count) {\n        <span class="hljs-comment">/* 最开始当然是创建在磁盘上占用一个数据块了 (如果文件对应的块不存在的话) */</span>\n\t\t<span class="hljs-keyword">if</span> (!(block = create_block(inode,pos/BLOCK_SIZE)))\n\t\t\t<span class="hljs-keyword">break</span>;\n        <span class="hljs-comment">/* 根据数据块获得相应的缓冲块 */</span>\n\t\t<span class="hljs-keyword">if</span> (!(bh=bread(inode-&gt;i_dev,block)))\n\t\t\t<span class="hljs-keyword">break</span>;\n        <span class="hljs-comment">/* 在缓冲块中的偏移量 */</span>\n\t\tc = pos % BLOCK_SIZE;\n        <span class="hljs-comment">/* 定位到具体的缓冲区的内存地址 */</span>\n\t\tp = c + bh-&gt;b_data;\n\t\tbh-&gt;b_dirt = <span class="hljs-number">1</span>;\n        <span class="hljs-comment">/* 当前这个缓冲块还有多少字节可写 */</span>\n\t\tc = BLOCK_SIZE-c;\n        <span class="hljs-comment">/* 如果需要写入的数据量少于 c */</span>\n\t\t<span class="hljs-keyword">if</span> (c &gt; count-i) c = count-i;\n        <span class="hljs-comment">/* 添加偏移量计数, 更新数据结构中维护的值 */</span>\n\t\tpos += c;\n\t\t<span class="hljs-keyword">if</span> (pos &gt; inode-&gt;i_size) {\n\t\t\tinode-&gt;i_size = pos;\n\t\t\tinode-&gt;i_dirt = <span class="hljs-number">1</span>;\n\t\t}\n\t\ti += c;\n        <span class="hljs-comment">/* 向缓冲块逐字节写入数据 */</span>\n\t\t<span class="hljs-keyword">while</span> (c--&gt;<span class="hljs-number">0</span>)\n\t\t\t*(p++) = get_fs_byte(buf++);\n        <span class="hljs-comment">/* 释放对缓冲块的占用，当然，在释放前会完成缓冲块&lt;-&gt;外存数据块的同步 */</span>\n\t\tbrelse(bh);\n\t}\n\tinode-&gt;i_mtime = CURRENT_TIME;\n\t<span class="hljs-keyword">if</span> (!(filp-&gt;f_flags &amp; O_APPEND)) {\n        <span class="hljs-comment">/* 非 APPEND 模式，更新文件读写指针(偏移量); APPEND 模式是使用 inode-&gt;i_size ，所有就不需要在这里更新了 */</span>\n\t\tfilp-&gt;f_pos = pos;\n\t\tinode-&gt;i_ctime = CURRENT_TIME;\n\t}\n\t<span class="hljs-keyword">return</span> (i?i:<span class="hljs-number">-1</span>);\n}</code></pre><p>是不是觉得也没有什么太高大上的操作。确实如此，更多关于缓存块与文件系统数据块的同步都已经被包装到 bread(), brelse() 中了。</p>\n<p>不过，暂时无需细究。总之到此为止，先要有一个基础的观念: 所有与外存储器(这里也包括控制台等)进行数据交互都必须经过缓冲区</p>\n<p>缓冲区封装了对外存储器的全部操作，而提供给 CPU 更高效的 I/O 操作，当然，也更为简单快捷</p>\n<h3>文件读取</h3>\n<p>至于文件读取，也基本类似了，所以也就不再深入描述。</p>\n<p>当然，要注意的就是，在本篇开始的部分提供的例程中，write &amp; read 中插入了 <code>off_t off = lseek(fd, 0, SEEK_SET);</code>  这样的代码。</p>\n<p>原因应该也能够想到，学习 <code>sys_write(..)</code> 的时候我们已经看到，任务对同一个文件在内存中维护了一个文件读写偏移量。因此，要读取刚才写入的内容，就不得不先改动这个读写偏移量了</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sys_read</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">char</span> * buf,<span class="hljs-keyword">int</span> count)</span>\n</span>{\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">file</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">inode</span>;</span>\n\n\t<span class="hljs-keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="hljs-number">0</span> || !(file=current-&gt;filp[fd]))\n\t\t<span class="hljs-keyword">return</span> -EINVAL;\n\t<span class="hljs-keyword">if</span> (!count)\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n\tverify_area(buf,count);\n\tinode = file-&gt;f_inode;\n\t<span class="hljs-keyword">if</span> (inode-&gt;i_pipe)\n\t\t<span class="hljs-keyword">return</span> (file-&gt;f_mode&amp;<span class="hljs-number">1</span>)?read_pipe(inode,buf,count):-EIO;\n\t<span class="hljs-keyword">if</span> (S_ISCHR(inode-&gt;i_mode))\n\t\t<span class="hljs-keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="hljs-number">0</span>],buf,count,&amp;file-&gt;f_pos);\n\t<span class="hljs-keyword">if</span> (S_ISBLK(inode-&gt;i_mode))\n\t\t<span class="hljs-keyword">return</span> block_read(inode-&gt;i_zone[<span class="hljs-number">0</span>],&amp;file-&gt;f_pos,buf,count);\n\t<span class="hljs-keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) {\n\t\t<span class="hljs-keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)\n\t\t\tcount = inode-&gt;i_size - file-&gt;f_pos;\n\t\t<span class="hljs-keyword">if</span> (count&lt;=<span class="hljs-number">0</span>)\n\t\t\t<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n\t\t<span class="hljs-keyword">return</span> file_read(inode,file,buf,count);\n\t}\n\tprintk(<span class="hljs-string">"(Read)inode-&gt;i_mode=%06o\\n\\r"</span>,inode-&gt;i_mode);\n\t<span class="hljs-keyword">return</span> -EINVAL;\n}</code></pre><h2>小结</h2>\n<p>这篇对文件系统的代码层面的描述，仅仅只是捡了一个相当有限的片面 (常规文件读写)。从文件系统的挂载开始提供了一个读写的完整流程介绍(当然，很多细节是缺失的，不过不要着急)。</p>\n<p>虽然平常都能够了解到一个比较模糊的前提，文件读写需要利用缓冲区，但是究竟什么是缓存区，如何使用都不会有太多的概念。本篇最大的重点，就是首先请读者们建立起一个基础性的对缓冲区的了解。事实上，这个中介在 I/O 中扮演了相当重要的角色。而且内存也为其提供了相当大的一份空间，差不多有 1/4 了。</p>\n<p>跨了差不多半个多月来写，上下文的承接可能有些生硬了，甚至不一致了... 尴尬...</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-11-11-understand-Kernel-6.json",ext:".json",sourceBase:"2018-11-11-understand-Kernel-6.md",sourceExt:".md"}},"6bZZ":function(n){n.exports={title:"Spring JDBC 源码学习",layout:"post",author:"fangfeng",date:"2018-01-15T00:00:00.000Z",tags:["Spring","JDBC"],"typora-copy-images-to":"ipic",bodyContent:'## 概览\n\n在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。\n\n\x3c!-- more --\x3e\n```java\n/**\n * copied from https://www.tutorialspoint.com/jdbc/jdbc-sample-code.htm\n * updated by DorMOUSENone\n */\n\n//STEP 1. 引入必须的包\nimport java.sql.*;\n\npublic class Example {\n\t// JDBC 驱动名 与 DB URL \n    static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";  \n    static final String DB_URL = "jdbc:mysql://<host>:<port>/<dbName>";\n\n  \t// 数据库登录验证 (用户名、密码等)\n    static final String USER = "username";\n    static final String PASS = "password";\n   \n\tpublic static void main(String[] args) {\n\t\tConnection conn = null;\n\t\tStatement stmt = null;\n\t\ttry{\n\t\t\t//STEP 2: 注册驱动(注册到驱动管理器 DriverManager 类中)\n\t\t\tClass.forName("com.mysql.jdbc.Driver");\n\n            //STEP 3: 创建一个连接\n          \tSystem.out.println("Connecting to database...");\n          \tconn = DriverManager.getConnection(DB_URL,USER,PASS);\n\n          \t//STEP 4: 执行一个查询\n          \tSystem.out.println("Creating statement...");\n          \tstmt = conn.createStatement();\n          \tString sql;\n          \tsql = "SELECT id, first, last, age FROM Employees";\n          \tResultSet rs = stmt.executeQuery(sql);\n\n          \t//STEP 5: 将结果从结果集(ResultSet)中取出\n          \twhile(rs.next()){\n             \t//根据列名逐一取出数据\n             \tint id  = rs.getInt("id");\n             \tint age = rs.getInt("age");\n             \tString first = rs.getString("first");\n             \tString last = rs.getString("last");\n\n             \t//展示结果\n             \tSystem.out.print("ID: " + id);\n             \tSystem.out.print(", Age: " + age);\n             \tSystem.out.print(", First: " + first);\n             \tSystem.out.println(", Last: " + last);\n          \t}\n          \t//STEP 6: 清理环境\n          \trs.close();\n          \tstmt.close();\n          \tconn.close();\n       \t}catch(SQLException se){\n          \t//处理 JDBC 错误\n          \tse.printStackTrace();\n       \t}catch(Exception e){\n          \t//处理 Class.forName() 引起的错误\n          \te.printStackTrace();\n       \t}finally{\n          \t// finally 代码库来关闭资源\n          \ttry{\n            \tif(stmt!=null)\n                \tstmt.close();\n          \t}catch(SQLException se2){\n          \t}// 不做任何处理\n          \ttry{\n           \t\tif(conn!=null)\n                \tconn.close();\n            }catch(SQLException se){\n               \tse.printStackTrace();\n            }\n       \t}\n       \tSystem.out.println("Goodbye!");\n\t}\n}\n```\n\n从上面的通用 JDBC 代码可以看到，利用 Java 原生提供的 java.sql.* 包可以完成注册驱动，创建连接，执行查询，处理结果等一系列一整套操作。\n\n而 Spring-JDBC 对于 Java 原生提供的 JDBC ，对一系列数据及操作进行了整合：\n\n1. 实现了 DataSource 接口，用于整合数据源配置，将各种零散的属性值（诸如 URL、用户名、 密码等）整合成完整的一个对象，便于重用；也实现了 getConnection(…) 接口，便于直接通过 DataSource 获取连接。\n2. 对执行查询的流程进行了封装。\n3. 对结果集的处理提供了多种接口，针对不同的应用场景可自由选择所必须的实现类。例如直接通过 JDBC 获得 Bean ，而无需如上例 39-42 行所示，逐一编码进行提取。\n\n本节提供对《Spring-JDBC 源码学习》完整学习过程的一个梳理：\n\n1. [JdbcTemplate](http://blog.csdn.net/dormousenone/article/details/79035440) 一节作为学习 Spring-jdbc 的切入点，是 org.springframework.jdbc.core 包中的核心类，是一个提供不同场景下数据库操作的模板类。主要描述其持有的属性 DataSource 等以及其实现的方法。\n2. [DataSource](http://blog.csdn.net/dormousenone/article/details/79037012) 一节承接 JdbcTemplate 一节，提供 Spring-jdbc 对数据源的一个包装与应用。同时描述其核心方法 getConnection(…) 的实现。\n3. [DriverManager](http://blog.csdn.net/dormousenone/article/details/79042212) 描述其对不同数据库供应商提供的驱动的管理与使用方法。同时简单描述通过具体驱动获得一个连接的实现。\n4. [PreparedStatement & CallableStatement](http://blog.csdn.net/dormousenone/article/details/79046865) 一节主要表述 Spring-jdbc 如何对执行查询的流程进行了封装。特别是对于 PreparedStatement 与 CallableStatement 这类预置可变 SQL 语句，在执行前必须对其中可变参数进行补全的 Statement 。\n5. [ResultSet](http://blog.csdn.net/dormousenone/article/details/79062275) 描述 Spring-jdbc 如何对结果集进行处理，提供了多种不同的接口实现不同的处理逻辑。这种封装后的操作可以极大地简化直接使用 Java 原生 JDBC 所必须的硬编码提取数据的问题。\n\n## JdbcTemplate\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fn90ghu9ufj30ki0jm75t.jpg)\n\nJdbcTemplate 类作为 org.springframework.core 包下的核心类，对 Java 实现的 JDBC 进行了一定程度的封装，可以简化 JDBC 的使用，同时避免许多常见的错误。由该类来执行 JDBC 工作流，应用程序只需要提供 SQL 语句就可以获得 DB 执行结果（😀，当然实际操作上没有描述的这么简单）。\n\n**使用 JdbcTemplate 类只需要实现两个回调接口 PreparedStatementCreator (创建一个 PreparedStatement，给定连接，提供 SQL 语句以及必要的参数), ResultSetExtractor (用于花式获取结果集)。当然，不实现上述两个接口也可以进行简单的数据库操作，比如只通过 JdbcTemplate 获取一个连接(Connection) 或者执行一个静态 SQL Update。**\n\n*看不懂无所谓，先继续向下看，会做更详细的讲解。*\n\n### JdbcAccessor\n\n首先了解 JdbcTemplate 的实现，JdbcTemplate 继承了 JdbcAccessor 抽象类，该抽象类有两个主要属性—— **DataSource dataSource** & **SQLExceptionTranslator exceptionTranslator** ，以及一个懒加载标识符 **lazyInit** 。\n\n其中，\n\n- DataSource 可以认为是一个存储有与数据库相关的属性实例，主要方法包括 `Connection getConnection()` & `Connection getConnection(String username, String password)` 。\n- SQLExceptionTranslator 利用策略模式将 Java 定义的 SQLException 转换成 Spring 声明的 DataAccessException。\n\nJdbcAccessor 实现的 InitializingBean 接口，InitializingBean 接口为 Bean 提供了一个初始化实例的方法 —— afterPropertiesSet() 方法，凡是继承该接口的类，一般都在类构造方法中执行该方法。同样的，声明初始化实例调用的方法还可采用 `<bean id="" class="" init-method="myInitMethod"/>` 在初始化 bean 时执行 myInitMethod() 方法。具体执行顺序为 ：\n\n1. bean 的属性注入\n2. 调用 afterPropertiesSet() 方法\n3. 执行 myInitMethod() 方法\n\n此处继承该接口是为了实现 DataSource 验证以及 SQLExceptionTranslator 的懒加载 OR NOT 的选择。\n\n```java\n@Override\npublic void afterPropertiesSet() {\n\tif (getDataSource() == null) {\t// 判断是否注入了 DataSource\n\t\tthrow new IllegalArgumentException("Property \'dataSource\' is required");\n\t}\n\tif (!isLazyInit()) {\t// 根据懒加载标识符选择执行与否\n\t\tgetExceptionTranslator();\t// 获取一个 SQLExceptionTranslator 实例\n\t}\n}\n```\n\n该方法在 BeanFactory 完成该 bean 的依赖注入后执行，将首先判断 DataSource 是否已经被注入，再根据懒加载标识符来决定是否实例化一个 SQLExceptionTranslator 。\n\n### JdbcOperations\n\n同时，JdbcTemplate 类实现了 JdbcOperations 接口，该接口定义了基本的 JDBC 操作。基本方法如下：\n\n1. `<T> T execute(ConnectionCallback<T> action);`\n2. `<T> T execute(StatementCallback<T> action);`\n3. `<T> T execute(PreparedStatementCreator psc, PreparedStatementCallback<T> action);`\n4. `<T> T execute(CallableStatementCreator csc, CallableStatementCallback<T> action);`\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fncp2ncqd6j31j00au0uv.jpg)\n\n其它的 execute(…) , query(…), update(…) 等最终都将调用上述 4 种方法其一来完成目的。\n\n详细观察上述方法的入参， ConnectionCallback, StatementCallback, PreparedStatementCallback 和 CallableStatementCallback 四个 Callback 接口，分别都是函数式接口，其中的唯一方法 doInXXX() 将在 execute() 中被调用，以此实现获得 ResultSet 并返回 Result 。execute 中调用 doInXXX() 的通用代码如下 （以 Statement 为例）：\n\n*对于不理解**回调**的同学，请自行了解概念*\n\n```java\npublic <T> T execute(StatementCallback<T> action) throws DataAccessException {\n\t// 通过工具类 DataSourceUtils 获取一个连接\n  \tConnection con = DataSourceUtils.getConnection(obtainDataSource());\n  \t// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似\n\tStatement stmt = null;\n\ttry {\n\t\tstmt = con.createStatement();\t// 通过连接(Connection)获取一个 Statement\n\t\tapplyStatementSettings(stmt);\t// 配置 Statement 参数\n      \t// 回调执行 doInXXX() 方法, 并获得 result\n\t\tT result = action.doInStatement(stmt);\t\n\t\thandleWarnings(stmt);\n\t\treturn result;\n\t}\n\tcatch (SQLException ex) {\n\t\t// Release Connection early, to avoid potential connection pool deadlock\n\t\t// in the case when the exception translator hasn\'t been initialized yet.\n\t\tString sql = getSql(action);\n\t\tJdbcUtils.closeStatement(stmt);\n\t\tstmt = null;\n\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\tcon = null;\n\t\tthrow translateException("StatementCallback", sql, ex);\n\t}\n\tfinally {\n\t\tJdbcUtils.closeStatement(stmt);\n\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t}\n}\n```\n\n对于 Statement, PreparedStatement, CallableStatement 的区别，首先下图表现了三个接口的继承关系。\n\n- Statement 可以支持静态 SQL 语句\n- PreparedStatement 支持可变参数的 SQL 语句\n- CallableStatement 支持可变参数的 SQL 语句，并且支持定制 DB 的输出结果\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fncpaec17yj30ew0hcdh7.jpg)\n\n## DataSource\n\n上一节在粗略地了解了 JdbcTemplate 提供的方法之后，下面先来对 DataSource 做一点了解。\n\n### Java 提供的 DataSource 定义\n\nDataSource 是 Java 核心库提供的接口。位于 javax.sql package 下。\n\nDataSource 接口可以被视作是一个提供物理 DB 实例连接(Connection) 的工厂，通过 DataSource 持有的各种属性（包括 DB Url, Username, Password 等）来获取一个连接(Connection) 。DataSource 接口有三种不同的实现方案：\n\n1. 最基本的实现——生产一个标准连接(Connection) 对象\n2. 连接池方案——生产会被自动添加到连接池的对象\n3. 分布式事物实现——生产一个可以支持分布式事物，并默认被添加到连接池的连接对象\n\n包括两个对外提供连接(Connection) 对象的方法，\n\n```java\nConnection getConnection() throws SQLException;\nConnection getConnection(String username, String password) throws SQLException;\n```\n\n其父接口 CommonDataSource 提供设置/获取 LogWriter，登录 DB 超时时间和获取父 Logger 的方法。\n\n### Spring-JDBC 扩展的 DataSource 定义\n\n在 Spring-jdbc 下，DataSources 最顶级的类是 AbstractDataSource ，对 DataSource 的所有父接口方法做了实现。但保留 getConnection() 方法由子类实现。\n\n在 AbstractDriverBasedDataSource 中，定义了大量的参数，诸如 url, username 等，这些都被用来定位并定义与数据库实例的连接。\n\n```java\npublic abstract class AbstractDriverBasedDataSource extends AbstractDataSource {\n\n   @Nullable\n   private String url;\n\n   @Nullable\n   private String username;\n\n   @Nullable\n   private String password;\n\n   @Nullable\n   private String catalog;\n\n   @Nullable\n   private String schema;\n\n   @Nullable\n   // 可以看到此处有一个 Properties 类\n   private Properties connectionProperties;\n   \n   // 省略若干方法\n  \n\n\t@Override\n\tpublic Connection getConnection() throws SQLException {\n      \t// 调用内部方法 getConnectionFromDriver()\n\t\treturn getConnectionFromDriver(getUsername(), getPassword());\n\t}\n\n\t@Override\n\tpublic Connection getConnection(String username, String password) throws SQLException {\n      \t// 调用内部方法 getConnectionFromDriver()\n\t\treturn getConnectionFromDriver(username, password);\n\t}\n  \n   // 定义了一个获取 Connection 的方法，由 getConnection() 方法调用，\n   // 此方法主要是将属性做了一个整合\n   // 具体获取 Connection 的逻辑仍然下放到子类实现 见 40 行\n   protected Connection getConnectionFromDriver(@Nullable String username, @Nullable String password) throws SQLException {\n\t\tProperties mergedProps = new Properties();\n\t\tProperties connProps = getConnectionProperties();\n\t\tif (connProps != null) {\n\t\t\tmergedProps.putAll(connProps);\n\t\t}\n\t\tif (username != null) {\n\t\t\tmergedProps.setProperty("user", username);\n\t\t}\n\t\tif (password != null) {\n\t\t\tmergedProps.setProperty("password", password);\n\t\t}\n\t\t\n     \t// 获取 Connection 逻辑下放\n\t\tConnection con = getConnectionFromDriver(mergedProps);\n\t\tif (this.catalog != null) {\n\t\t\tcon.setCatalog(this.catalog);\n\t\t}\n\t\tif (this.schema != null) {\n\t\t\tcon.setSchema(this.schema);\n\t\t}\n\t\treturn con;\n\t}\n  \n  \t// 该类中获取 Connection 的方法是抽象方法\n    protected abstract Connection getConnectionFromDriver(Properties props) throws SQLException;\n\n}\n```\n\n整合方案为将除 url 外的所有参数整合在同一个 Properties 对象中 (其中，Properties 可以被认为是一个线程安全的 Hash Map) 。最终调用 `Connection getConnectionFromDriver(Properties props)` 获取连接。\n\nAbstractDriverBasedDataSource 抽象类的两个子类 DriverManagerDataSource 和 SimpleDriverDataSource 都以不同方式获得了连接(Connection)，但总结而言，获取连接(Connection) 的任务被委托给了 Driver 来实现（其中，Driver 有 Java 定义接口，并由各数据库提供商提供，例如 MySQL 提供了 mysql-connector-java-XXX.jar 来完成针对相应数据库的具体实现）。\n\n```java\n// ----------------------------\n// SimpleDriverDataSource 的实现\n// ----------------------------\n@Override\nprotected Connection getConnectionFromDriver(Properties props) throws SQLException {\n\tDriver driver = getDriver();\n\tString url = getUrl();\n\tAssert.notNull(driver, "Driver must not be null");\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug("Creating new JDBC Driver Connection to [" + url + "]");\n\t}\n  \t// 哈哈，重点在这... driver 在该类中被预先注入\n\treturn driver.connect(url, props);\n}\n\n// -----------------------------\n// DriverManagerDataSource 的实现\n// -----------------------------\n@Override\nprotected Connection getConnectionFromDriver(Properties props) throws SQLException {\n\tString url = getUrl();\n\tAssert.state(url != null, "\'url\' not set");\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug("Creating new JDBC DriverManager Connection to [" + url + "]");\n\t}\n  \t// 调了个内部函数\n\treturn getConnectionFromDriverManager(url, props);\n}\n\nprotected Connection getConnectionFromDriverManager(String url, Properties props) throws SQLException {\n    // 委托给 DriverManager 类来获取连接\n    // DriverManager 的主要操作是遍历在该管理类中注册的 Driver\n    // 每个 Driver 实例都去尝试一下，能不能获得一个连接\n    // 第一次在某个 Driver 中拿到一个连接即返回连接 (Connection)\n\treturn DriverManager.getConnection(url, props);\n}\n```\n\n简要的类图如下：\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fncrgqcjqoj31es15ajxj.jpg)\n\n## DriverManager\n\n上面提到 DataSource 获取连接(Connection) 的操作实质上将委托具体的 Driver 来提供 Connection 。有两种不同的方式，包括经由 DriverManager 遍历所有处于管理下的 Driver 尝试获取连接，或者在 DataSource 实例中直接声明一个特定的 Driver 来获取连接。\n\n对于获取连接的具体操作，挖坑-待填。只描述简单的数据库供应商提供的 Driver 如何与 java 相联系。\n\n###在 DriverManager 中注册 Driver 实例\n\n通常在与数据库交互逻辑的 Java 代码中，都会有 `Class.forName("com.mysql.jdbc.Driver")` (此处以 MySQL 提供的 mysql-connector-java-XXX.jar 为例，下同）的代码块，加载指定的 com.mysql.jdbc.Driver 为 java.lang.Class 类。\n\n*当然，在 JDBC 4.0 标准下，可以不必再显示声明 `Class.forName("")` 语句，Driver 也同样会在 DriverManager 初始化时自动注册。*\n\n```java\n// Class 类中对于 forName(String className) 的方法\n// 作用为返回一个 java.lang.Class 实例。\npublic static Class<?> forName(String className) throws ClassNotFoundException {...}\n```\n\n同时， JVM 在加载类的过程中会执行类中的 static 代码块。下述 row 10 ~ 16 的代码片段将被执行。唯一的逻辑就是 new 一个 com.mysql.jdbc.Driver 实例，并将实例注册(registerDriver) 到 **java.sql.DriverManager** 中。 \n\n```java\npackage com.mysql.jdbc;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n\t// ~ Static fields/initializers\n\t// ---------------------------------------------\n\n\t//\n\t// Register ourselves with the DriverManager\n\t//\n\tstatic {\n\t\ttry {\n\t\t\tjava.sql.DriverManager.registerDriver(new Driver());\n\t\t} catch (SQLException E) {\n\t\t\tthrow new RuntimeException("Can\'t register driver!");\n\t\t}\n\t}\n\n\t// ~ Constructors\n\t// -----------------------------------------------------------\n\n\t/**\n\t * Construct a new driver and register it with DriverManager\n\t * \n\t * @throws SQLException\n\t *             if a database error occurs.\n\t */\n\tpublic Driver() throws SQLException {\n\t\t// Required for Class.forName().newInstance()\n\t}\n}\n```\n\n下面再来看一下 DriverManager 中的 registerDriver() 方法。\n\n```java\npublic class DriverManager {\n\n  \t// DriverManager 维护一个线程安全的 Driver 列表\n  \t// 此处的 DriverInfo 里面即包装了 Driver \n    private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = \n      \tnew CopyOnWriteArrayList<>();\n\n  \t// 在 DriverManager 中注册 Driver\n\tpublic static synchronized void registerDriver(java.sql.Driver driver)\n        throws SQLException {\n        registerDriver(driver, null);\n    }\n  \n\tpublic static synchronized void registerDriver(java.sql.Driver driver,\n            DriverAction da)\n        throws SQLException {\n\n      \t/* 如果当前 Driver 不在列表中，即添加到列表。 */\n        if(driver != null) {\n            registeredDrivers.addIfAbsent(new DriverInfo(driver, da));\n        } else {\n            // This is for compatibility with the original DriverManager\n            throw new NullPointerException();\n        }\n\n        println("registerDriver: " + driver);\n\n    }\n}\n```\n\n### 通过 DriverManager 获取连接(Connection)\n\n上一节有提到过可以通过 DriverManager 来遍历获取连接，也可以直接声明具体 Driver 并获取连接。下面代码展示的是通过 DriverManager 获取连接的操作。 ~~哈哈哈，反正最后都是由具体驱动实现获取连接。~~\n\n```java\npublic class DriverManager {\n  \t// 获取连接的 public 接口 (1)\n\tpublic static Connection getConnection(String url,\n\t\tjava.util.Properties info) throws SQLException {\n\t\treturn (getConnection(url, info, Reflection.getCallerClass()));\n\t}\n\t// 获取连接的 public 接口 (2)\n    public static Connection getConnection(String url,\n        String user, String password) throws SQLException {\n        java.util.Properties info = new java.util.Properties();\n\n        if (user != null) {\n            info.put("user", user);\n        }\n        if (password != null) {\n            info.put("password", password);\n        }\n\n        return (getConnection(url, info, Reflection.getCallerClass()));\n    }\n\t// 获取连接的 public 接口 (3)\n    public static Connection getConnection(String url)\n        throws SQLException {\n        java.util.Properties info = new java.util.Properties();\n        return (getConnection(url, info, Reflection.getCallerClass()));\n    }\n \n  \t// 获取连接的内部逻辑实现\n    private static Connection getConnection(\n        String url, java.util.Properties info, Class<?> caller) \n      \tthrows SQLException {\n        /*\n         * When callerCl is null, we should check the application\'s\n         * (which is invoking this class indirectly)\n         * classloader, so that the JDBC driver class outside rt.jar\n         * can be loaded from here.\n         */\n        ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;\n        synchronized(DriverManager.class) {\n            // synchronize loading of the correct classloader.\n            if (callerCL == null) {\n                callerCL = Thread.currentThread().getContextClassLoader();\n            }\n        }\n\t\t// url 是定位 DBMS 最重要的参数，不能为空\n        if(url == null) {\n            throw new SQLException("The url cannot be null", "08001");\n        }\n\n        println("DriverManager.getConnection(\\"" + url + "\\")");\n\n      \t// 遍历所有注册的 Driver ，并都尝试获取连接(Connection)\n        SQLException reason = null;\n\n        for(DriverInfo aDriver : registeredDrivers) {\n          \t// 判断注册的 Driver 是否由 ClassLoader callerCL 加载，不是则跳过\n            if(isDriverAllowed(aDriver.driver, callerCL)) {\n                try {\n                    println("    trying " + aDriver.driver.getClass().getName());\n                    // 获取连接，:) 还是由 driver 实例自行提供\n                  \tConnection con = aDriver.driver.connect(url, info);\n                    if (con != null) {\n                        // Success!\n                        println("getConnection returning " + \n                                aDriver.driver.getClass().getName());\n                        return (con);\n                    }\n                } catch (SQLException ex) {\n                    if (reason == null) {\n                        reason = ex;\n                    }\n                }\n\n            } else {\n                println("    skipping: " + aDriver.getClass().getName());\n            }\n\n        }\n\n        // 如果运行到下列代码，则表明获取连接失败，抛出错误\n        if (reason != null)    {\n            println("getConnection failed: " + reason);\n            throw reason;\n        }\n\n        println("getConnection: no suitable driver found for "+ url);\n        throw new SQLException("No suitable driver found for "+ url, "08001");\n    }\n\n}\n```\n\n*简单的提一嘴，Connection 仍然只是一个针对 Java -> DB Server 的上层接口，如果想要更深层次地了解 Connection 与 DB Server 的交互，可以尝试去看一下 com.mysql.jdbc.MysqlIO 类，MySQL 实现的 JDBC4Connection 类也是在使用该类来实现对 DB Server 交互。（哈哈，只看过 MySQL 提供的 Driver 包）。*\n\n## PreparedStatement & CallableStatement\n\n在了解了 DataSource 获取连接(Connection) 的实质以及 JdbcTemplate 的通用接口之后，使用 Spring-jdbc 进行数据库相关的操作可以直截了当的利用如下代码进行实现（此处仅展示通过 Java 硬编码的形式进行实现，XML 配置方法类似）。\n\n```java\npublic static void main(String... args) {\n  \t// 定义数据源\n\tDriverManagerDataSource dataSource = new DriverManagerDataSource();\n  \t// 配置参数\n\tdataSource.setUrl("jdbc:mysql://<host>:<port>/<dbName>?<props>");\n   \tdataSource.setUsername("<username>");\n    dataSource.setPassword("<passwd>");\n  \t\n  \t// 实例化一个 JDBC 工具类\n  \tJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n  \t// 执行相关 CRUD 操作\t\n  \tjdbcTemplate.execute();\n}\n```\n\n回顾第一节所讲的 JdbcTemplate 的 4 个基础方法：\n\n1. `<T> T execute(ConnectionCallback<T> action);`\n2. `<T> T execute(StatementCallback<T> action);`\n3. `<T> T execute(PreparedStatementCreator psc, PreparedStatementCallback<T> action);`\n4. `<T> T execute(CallableStatementCreator csc, CallableStatementCallback<T> action);`\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1fndsm5tl7aj30zg0byq47.jpg)\n\n四个基础方法都有一个特定的回调函数将通过预配置的 DataSource 得到的 Connection 或 更进一步的 Statement or PreparedStatement or CallableStatement 作为入参来执行定义的唯一方法。\n\n以 `<T> T execute(StatementCallback<T> action);` 为例来了解一下方法的核心逻辑。\n\n```java\npublic <T> T execute(StatementCallback<T> action) throws DataAccessException {\n\t// 通过工具类 DataSourceUtils 获取一个连接\n  \tConnection con = DataSourceUtils.getConnection(obtainDataSource());\n  \t// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似\n\tStatement stmt = null;\n\ttry {\n\t\tstmt = con.createStatement();\t// 通过连接(Connection)获取一个 Statement\n\t\tapplyStatementSettings(stmt);\t// 配置 Statement 参数\n      \t// 回调执行 doInXXX() 方法, 并获得 result\n\t\tT result = action.doInStatement(stmt);\t\n\t\thandleWarnings(stmt);\n\t\treturn result;\n    } catch() {\n      \n    } finally {\n      \n    }\n}\n```\n\n但是，对于 PreparedStatement 和 CallableStatement 而言，获取一个 *XXX*Statement 的方式就有所不同了。\n\n```java\n// 获取 Statement 实例\nStatement stmt = con.createStatement();\n```\n\n```java\n// 获取 PreparedStatement 实例\n// psc 是一个 PreparedStatementCreator 接口实现的实例\nPreparedStatement ps = psc.createPreparedStatement(con);\n```\n\n```java\n// 获取 CallableStatement 实例\n// csc 是一个 CallableStatementCreator 接口实现的实例\nCallableStatement cs = csc.createCallableStatement(con);\n```\n\n可以看到 Statement 直接通过 Connection 获取实例，但是 PreparedStatement 和 CallableStatement 就有所不同，其区别就在于 PreparedStatement 和 CallableStatement 两个 Statement 都是可以定制入参的，更甚者， CallableStatement 可以定制 DB 执行结果的出参。当然，核心还是 `con.prepareStatement() OR con.prepareCall()` 方法，只不过是将获取 XXXStatement 的操作下放给 XXXStatementCreator 实例类实现，给予使用者重复的自主权，同时也是逻辑解耦的一种操作。\n\n例如：\n\nSimplePreparedStatementCreator 这个 PreparedStatementCreator 接口的实现类，只是简单的调用了 `con.prepareStatement(sql)` 方法。\n\n```java\nprivate static class SimplePreparedStatementCreator \n  \timplements PreparedStatementCreator, SqlProvider {\n\n\tprivate final String sql;\n\n\t@Override\n\tpublic PreparedStatement createPreparedStatement(Connection con) \n      \tthrows SQLException {\n\t\treturn con.prepareStatement(this.sql);\n\t}\n}\n```\n\n而对于 PreparedStatementCreatorImpl ，在 createPreparedStatement(Connection con) 的实现上，又添加了更多的操作。\n\n```java\nprivate class PreparedStatementCreatorImpl\n\t\timplements PreparedStatementCreator, PreparedStatementSetter, SqlProvider, ParameterDisposer {\n\n\tprivate final String actualSql;\n\n\tprivate final List<?> parameters;\n\n\t@Override\n\tpublic PreparedStatement createPreparedStatement(Connection con) throws SQLException {\n\t\tPreparedStatement ps;\n\t\tif (generatedKeysColumnNames != null || returnGeneratedKeys) {\n\t\t\tif (generatedKeysColumnNames != null) {\n              \t// 获取一个 PreparedStatement 实例，下同\n\t\t\t\tps = con.prepareStatement(this.actualSql, \n                                          generatedKeysColumnNames);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps = con.prepareStatement(this.actualSql, \n                                         PreparedStatement.RETURN_GENERATED_KEYS);\n\t\t\t}\n\t\t}\n\t\telse if (resultSetType == ResultSet.TYPE_FORWARD_ONLY \n                 && !updatableResults) {\n\t\t\tps = con.prepareStatement(this.actualSql);\n\t\t}\n\t\telse {\n\t\t\tps = con.prepareStatement(this.actualSql, resultSetType,\n\t\t\t\tupdatableResults ? ResultSet.CONCUR_UPDATABLE : \n                                      ResultSet.CONCUR_READ_ONLY);\n\t\t}\n      \t// 将可变 SQL (例如 SELECT * FROM msg WHERE id = ?) 的 ? 用实际参数替换\n\t\tsetValues(ps);\n\t\treturn ps;\n\t}\n}\n```\n\n从上述两种 PreparedStatementCreator 接口的不同实现，也可以从另一种角度理解到，函数式接口将获取目标出参的具体逻辑交给使用者定义，给予了使用者充分的自主权，同时也是一种业务逻辑的解耦。\n\n\n\n在上面代码 PreparedStatementCreatorImpl 类的实现中，我们看到第 32 行代码 `setValue(ps)` 。此处的方法是由接口 PreparedStatementSetter 定义的。主要目的是将可变 SQL 中的 ? 参数用实际参数进行一个替换。\n\n```java\n// 以 SQL (SELECT * FROM msg WHERE id = ? AND day = ?) 为例\n/** 纯 Java 核心库的实现 PreparedStatement 参数注入 */\nps.setInt(1, 1763);\nps.setString(2, "2018-01-01");\nps.executeQuery();\n\n/** 以 Spring-jdbc 实现 PreparedStatement 参数注入 */\n// setValues() 由接口 PreparedStatementSetter 定义，封装了注入参数的具体实现逻辑\n// 可以由使用者自行定义\nsetValues(ps);\t\nps.executeQuery();\n```\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1fndyybh4q1j31kw0u3afx.jpg)\n\n上面类图表示了 PreparedStatementSetter 及其实现类的相关依赖。\n\nSetter 的主要目标即为对 SQL 中的 ? 参数进行注入。\n\n~~个人精力有限，对Spring-jdbc在Statement上对参数注入的回调理解有限。~~\n\n## ResultSet\n\n在前几节已经提到讲了数据源、驱动管理器以及 Statement 之后，利用 JDBC 的最重要的目的就是对 DB 进行操作，并获得预期结果。对于查询语句而言，结果应该是若干记录行；就更新语句而言，结果可能是影响的行数。而 Spring-jdbc 对 ResultSet 额外进行的封装，即是将原本散乱的结果进行一个整合，例如整合成一个(一组)完整的 Bean 来进行展示。\n\n在 JdbcTemplate 中，四个基本方法入参都包括一个回调接口，而在执行回调获得 ResultSet 之后，方法并不是直接返回，而是进行了一定的操作。\n\n以一个 PreparedStatementCallback 的实例类为例，在 doInPreparedStatement() 方法中，获得了 ResultSet ，但是仍通过 rse.extractData(rs) 语句进行了处理后再返回结果\n\n```java\npublic T doInPreparedStatement(PreparedStatement ps) throws SQLException {\n  \t// 声明一个 ResultSet \n\tResultSet rs = null;\n\ttry {\n\t\tif (pss != null) {\t// setValues() 方法填充 PreparedStatement 中的可变参数 ? \n\t\t\tpss.setValues(ps);\n\t\t}\n\t\trs = ps.executeQuery();\t// 执行查询 sql ，获取结果\n\t\treturn rse.extractData(rs);\t// 重点... 该语句一定是对结果进行了一些操作.\n\t}\n\tfinally {\n\t\tJdbcUtils.closeResultSet(rs);\n\t\tif (pss instanceof ParameterDisposer) {\n\t\t\t((ParameterDisposer) pss).cleanupParameters();\n\t\t}\n\t}\n}\n```\n\n在来看一下究竟在返回结果前进行了什么操作。\n\n由于是一个回调接口的实现类，rse 应该在外部方法中。\n\n```java\npublic <T> T query(\n\t\tPreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, \n  \t\tfinal ResultSetExtractor<T> rse)\n\t\tthrows DataAccessException {\n\n\treturn execute(psc, new PreparedStatementCallback<T>() {\n\t\t@Override\n\t\tpublic T doInPreparedStatement(PreparedStatement ps) throws SQLException {\n\t\t\t...\t\n        }\n\t});\n}\n```\n\n可以看到 rse 是一个 ResultSetExtractor<T> 的实例。从名称上可以看出 Extractor 即为提取器，结果集提取器。\n\n```java\n/** 函数式接口，提供的唯一方法为 extractData(...) */\n@FunctionalInterface\npublic interface ResultSetExtractor<T> {\n\n\t@Nullable\n\tT extractData(ResultSet rs) throws SQLException, DataAccessException;\n\n}\n```\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fndzz0pqnrj31a60i676v.jpg)\n\nSpring-jdbc 中现有的实现有三个类，其中 RowCallbackHandlerResultSetExtractor 和 RowMapperResultSetExtractor 两个类从上面类图及命名即可看出，两个是作为一个适配器而存在的，将 extractData() 进行转换，分别由 RowCallbackHandler 和 RowMapper 实例进行具体操作。而 AbstractLobStreamingResultSetExtractor 类从名称上看，也是一个类似流操作的实现类(其中的 Lob 指的是 DB 中的 BLOB 与 CLOB 类型，在 Spring-jdbc 中也加入了额外的支持) 。\n\n### RowCallbackHandler\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fnh2uw3a0aj30h20jeta4.jpg)\n\n从名称上看，这是一个与 ResultSet 结果集行相关的回调接口。processRow(ResultSet rs) 方法将处理行相关的逻辑。\n\n从它的一个实现类 RowCountCallbackHandler 来说，其最主要的私有属性 rowCount 即是统计 ResultSet 的结果行数。下面是一个具体使用的该类的案例：\n\n```java\npublic static void main(String[] args) throws ClassNotFoundException {\n\n    DriverManagerDataSource dataSource = new DriverManagerDataSource();\n    dataSource.setUrl("jdbc:mysql://<host>:<port>/<dbName>");\n    dataSource.setUsername("<username>");\n    dataSource.setPassword("<password>");\n\n    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n    RowCountCallbackHandler rcch = new RowCountCallbackHandler();\n\n    jdbcTemplate.query("SELECT * FROM info WHERE id=\'2018\'", (RowCallbackHandler) rcch);\n\t\n  \tSystem.out.println(rcch.getRowCount());\t//获取结果集行数\n    System.out.println(rcch.getColumnCount());\t// 获取结果集列数\n    for (String arg : rcch.getColumnNames()) {\t// 打印结果集每一列名称\n        System.out.println("ColumnNames : " + arg);\n    }\n    for (int i : rcch.getColumnTypes()) {\t// 打印结果集每一列类型(Types 为枚举类)\n        System.out.println("ColumnTypes : " + i);\n    }\n}\n```\n\n具体查看 RowCountCallbackHandler 类的 processRow() 方法可以看到，其获取列相关信息都来自于 ResultSetMetaData 。而结果行数来源于 Iterator 迭代。\n\n```java\n@Override\npublic final void processRow(ResultSet rs) throws SQLException {\n\tif (this.rowCount == 0) {\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tthis.columnCount = rsmd.getColumnCount();\n\t\tthis.columnTypes = new int[this.columnCount];\n\t\tthis.columnNames = new String[this.columnCount];\n\t\tfor (int i = 0; i < this.columnCount; i++) {\n\t\t\tthis.columnTypes[i] = rsmd.getColumnType(i + 1);\n\t\t\tthis.columnNames[i] = JdbcUtils.lookupColumnName(rsmd, i + 1);\n\t\t}\n\t\t// could also get column names\n\t}\n\tprocessRow(rs, this.rowCount++);\n}\n```\n\n### RowMapper\n\n上面 RowCallbackHandler 接口从逻辑上划分是用于处理 ResultSet 元数据信息的。而 RowMapper 较上一个接口而言，有更高的实用性。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fnh3h739kaj30z60nago4.jpg)\n\n特别是其实现类 BeanPropertyRowMapper<T> 可以将散乱的 ResultSet 的结果数据整理成一个个 Object Bean 作为返回结果。而省去了对逐一读取 ResultSet 行记录并填充 Bean 属性的麻烦。\n\n```java\nJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n\nBeanPropertyRowMapper<Model> rowMapper = new BeanPropertyRowMapper<>(Model.class);\nList<Model> list = jdbcTemplate.query("SELECT * FROM info WHERE id = \'2018\'", rowMapper);\n/** 获得的 Model list 的对应属性将通过 Java 的反射机制进行填充\n *\tList<Model> list 即结果\n */\n```\n\n当然，要求是 Model 类中的属性与 DB table 中的列名保持一致（大小写无要求）。\n\n而其它两个类的实现也是基于反射机制，实现其相应的业务逻辑。\n\n```text\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<h2>概览</h2>\n<p>在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。</p>\n<p>&lt;!-- more --&gt;</p>\n<pre><code class="hljs"><span class="hljs-comment">/**\n * copied from https://www.tutorialspoint.com/jdbc/jdbc-sample-code.htm\n * updated by DorMOUSENone\n */</span>\n\n<span class="hljs-comment">//STEP 1. 引入必须的包</span>\n<span class="hljs-keyword">import</span> java.sql.*;\n\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>{\n\t<span class="hljs-comment">// JDBC 驱动名 与 DB URL </span>\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JDBC_DRIVER = <span class="hljs-string">"com.mysql.jdbc.Driver"</span>;  \n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DB_URL = <span class="hljs-string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>;\n\n  \t<span class="hljs-comment">// 数据库登录验证 (用户名、密码等)</span>\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String USER = <span class="hljs-string">"username"</span>;\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PASS = <span class="hljs-string">"password"</span>;\n   \n\t<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tConnection conn = <span class="hljs-keyword">null</span>;\n\t\tStatement stmt = <span class="hljs-keyword">null</span>;\n\t\t<span class="hljs-keyword">try</span>{\n\t\t\t<span class="hljs-comment">//STEP 2: 注册驱动(注册到驱动管理器 DriverManager 类中)</span>\n\t\t\tClass.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);\n\n            <span class="hljs-comment">//STEP 3: 创建一个连接</span>\n          \tSystem.out.println(<span class="hljs-string">"Connecting to database..."</span>);\n          \tconn = DriverManager.getConnection(DB_URL,USER,PASS);\n\n          \t<span class="hljs-comment">//STEP 4: 执行一个查询</span>\n          \tSystem.out.println(<span class="hljs-string">"Creating statement..."</span>);\n          \tstmt = conn.createStatement();\n          \tString sql;\n          \tsql = <span class="hljs-string">"SELECT id, first, last, age FROM Employees"</span>;\n          \tResultSet rs = stmt.executeQuery(sql);\n\n          \t<span class="hljs-comment">//STEP 5: 将结果从结果集(ResultSet)中取出</span>\n          \t<span class="hljs-keyword">while</span>(rs.next()){\n             \t<span class="hljs-comment">//根据列名逐一取出数据</span>\n             \t<span class="hljs-keyword">int</span> id  = rs.getInt(<span class="hljs-string">"id"</span>);\n             \t<span class="hljs-keyword">int</span> age = rs.getInt(<span class="hljs-string">"age"</span>);\n             \tString first = rs.getString(<span class="hljs-string">"first"</span>);\n             \tString last = rs.getString(<span class="hljs-string">"last"</span>);\n\n             \t<span class="hljs-comment">//展示结果</span>\n             \tSystem.out.print(<span class="hljs-string">"ID: "</span> + id);\n             \tSystem.out.print(<span class="hljs-string">", Age: "</span> + age);\n             \tSystem.out.print(<span class="hljs-string">", First: "</span> + first);\n             \tSystem.out.println(<span class="hljs-string">", Last: "</span> + last);\n          \t}\n          \t<span class="hljs-comment">//STEP 6: 清理环境</span>\n          \trs.close();\n          \tstmt.close();\n          \tconn.close();\n       \t}<span class="hljs-keyword">catch</span>(SQLException se){\n          \t<span class="hljs-comment">//处理 JDBC 错误</span>\n          \tse.printStackTrace();\n       \t}<span class="hljs-keyword">catch</span>(Exception e){\n          \t<span class="hljs-comment">//处理 Class.forName() 引起的错误</span>\n          \te.printStackTrace();\n       \t}<span class="hljs-keyword">finally</span>{\n          \t<span class="hljs-comment">// finally 代码库来关闭资源</span>\n          \t<span class="hljs-keyword">try</span>{\n            \t<span class="hljs-keyword">if</span>(stmt!=<span class="hljs-keyword">null</span>)\n                \tstmt.close();\n          \t}<span class="hljs-keyword">catch</span>(SQLException se2){\n          \t}<span class="hljs-comment">// 不做任何处理</span>\n          \t<span class="hljs-keyword">try</span>{\n           \t\t<span class="hljs-keyword">if</span>(conn!=<span class="hljs-keyword">null</span>)\n                \tconn.close();\n            }<span class="hljs-keyword">catch</span>(SQLException se){\n               \tse.printStackTrace();\n            }\n       \t}\n       \tSystem.out.println(<span class="hljs-string">"Goodbye!"</span>);\n\t}\n}</code></pre><p>从上面的通用 JDBC 代码可以看到，利用 Java 原生提供的 java.sql.* 包可以完成注册驱动，创建连接，执行查询，处理结果等一系列一整套操作。</p>\n<p>而 Spring-JDBC 对于 Java 原生提供的 JDBC ，对一系列数据及操作进行了整合：</p>\n<ol>\n<li>实现了 DataSource 接口，用于整合数据源配置，将各种零散的属性值（诸如 URL、用户名、 密码等）整合成完整的一个对象，便于重用；也实现了 getConnection(…) 接口，便于直接通过 DataSource 获取连接。</li>\n<li>对执行查询的流程进行了封装。</li>\n<li>对结果集的处理提供了多种接口，针对不同的应用场景可自由选择所必须的实现类。例如直接通过 JDBC 获得 Bean ，而无需如上例 39-42 行所示，逐一编码进行提取。</li>\n</ol>\n<p>本节提供对《Spring-JDBC 源码学习》完整学习过程的一个梳理：</p>\n<ol>\n<li><a href="http://blog.csdn.net/dormousenone/article/details/79035440">JdbcTemplate</a> 一节作为学习 Spring-jdbc 的切入点，是 org.springframework.jdbc.core 包中的核心类，是一个提供不同场景下数据库操作的模板类。主要描述其持有的属性 DataSource 等以及其实现的方法。</li>\n<li><a href="http://blog.csdn.net/dormousenone/article/details/79037012">DataSource</a> 一节承接 JdbcTemplate 一节，提供 Spring-jdbc 对数据源的一个包装与应用。同时描述其核心方法 getConnection(…) 的实现。</li>\n<li><a href="http://blog.csdn.net/dormousenone/article/details/79042212">DriverManager</a> 描述其对不同数据库供应商提供的驱动的管理与使用方法。同时简单描述通过具体驱动获得一个连接的实现。</li>\n<li><a href="http://blog.csdn.net/dormousenone/article/details/79046865">PreparedStatement &amp; CallableStatement</a> 一节主要表述 Spring-jdbc 如何对执行查询的流程进行了封装。特别是对于 PreparedStatement 与 CallableStatement 这类预置可变 SQL 语句，在执行前必须对其中可变参数进行补全的 Statement 。</li>\n<li><a href="http://blog.csdn.net/dormousenone/article/details/79062275">ResultSet</a> 描述 Spring-jdbc 如何对结果集进行处理，提供了多种不同的接口实现不同的处理逻辑。这种封装后的操作可以极大地简化直接使用 Java 原生 JDBC 所必须的硬编码提取数据的问题。</li>\n</ol>\n<h2>JdbcTemplate</h2>\n<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fn90ghu9ufj30ki0jm75t.jpg" alt=""></p>\n<p>JdbcTemplate 类作为 org.springframework.core 包下的核心类，对 Java 实现的 JDBC 进行了一定程度的封装，可以简化 JDBC 的使用，同时避免许多常见的错误。由该类来执行 JDBC 工作流，应用程序只需要提供 SQL 语句就可以获得 DB 执行结果（😀，当然实际操作上没有描述的这么简单）。</p>\n<p><strong>使用 JdbcTemplate 类只需要实现两个回调接口 PreparedStatementCreator (创建一个 PreparedStatement，给定连接，提供 SQL 语句以及必要的参数), ResultSetExtractor (用于花式获取结果集)。当然，不实现上述两个接口也可以进行简单的数据库操作，比如只通过 JdbcTemplate 获取一个连接(Connection) 或者执行一个静态 SQL Update。</strong></p>\n<p><em>看不懂无所谓，先继续向下看，会做更详细的讲解。</em></p>\n<h3>JdbcAccessor</h3>\n<p>首先了解 JdbcTemplate 的实现，JdbcTemplate 继承了 JdbcAccessor 抽象类，该抽象类有两个主要属性—— <strong>DataSource dataSource</strong> &amp; <strong>SQLExceptionTranslator exceptionTranslator</strong> ，以及一个懒加载标识符 <strong>lazyInit</strong> 。</p>\n<p>其中，</p>\n<ul>\n<li>DataSource 可以认为是一个存储有与数据库相关的属性实例，主要方法包括 <code>Connection getConnection()</code> &amp; <code>Connection getConnection(String username, String password)</code> 。</li>\n<li>SQLExceptionTranslator 利用策略模式将 Java 定义的 SQLException 转换成 Spring 声明的 DataAccessException。</li>\n</ul>\n<p>JdbcAccessor 实现的 InitializingBean 接口，InitializingBean 接口为 Bean 提供了一个初始化实例的方法 —— afterPropertiesSet() 方法，凡是继承该接口的类，一般都在类构造方法中执行该方法。同样的，声明初始化实例调用的方法还可采用 <code>&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;myInitMethod&quot;/&gt;</code> 在初始化 bean 时执行 myInitMethod() 方法。具体执行顺序为 ：</p>\n<ol>\n<li>bean 的属性注入</li>\n<li>调用 afterPropertiesSet() 方法</li>\n<li>执行 myInitMethod() 方法</li>\n</ol>\n<p>此处继承该接口是为了实现 DataSource 验证以及 SQLExceptionTranslator 的懒加载 OR NOT 的选择。</p>\n<pre><code class="hljs"><span class="hljs-meta">@Override</span>\n<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>{\n\t<span class="hljs-keyword">if</span> (getDataSource() == <span class="hljs-keyword">null</span>) {\t<span class="hljs-comment">// 判断是否注入了 DataSource</span>\n\t\t<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Property \'dataSource\' is required"</span>);\n\t}\n\t<span class="hljs-keyword">if</span> (!isLazyInit()) {\t<span class="hljs-comment">// 根据懒加载标识符选择执行与否</span>\n\t\tgetExceptionTranslator();\t<span class="hljs-comment">// 获取一个 SQLExceptionTranslator 实例</span>\n\t}\n}</code></pre><p>该方法在 BeanFactory 完成该 bean 的依赖注入后执行，将首先判断 DataSource 是否已经被注入，再根据懒加载标识符来决定是否实例化一个 SQLExceptionTranslator 。</p>\n<h3>JdbcOperations</h3>\n<p>同时，JdbcTemplate 类实现了 JdbcOperations 接口，该接口定义了基本的 JDBC 操作。基本方法如下：</p>\n<ol>\n<li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li>\n<li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li>\n<li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li>\n<li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li>\n</ol>\n<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncp2ncqd6j31j00au0uv.jpg" alt=""></p>\n<p>其它的 execute(…) , query(…), update(…) 等最终都将调用上述 4 种方法其一来完成目的。</p>\n<p>详细观察上述方法的入参， ConnectionCallback, StatementCallback, PreparedStatementCallback 和 CallableStatementCallback 四个 Callback 接口，分别都是函数式接口，其中的唯一方法 doInXXX() 将在 execute() 中被调用，以此实现获得 ResultSet 并返回 Result 。execute 中调用 doInXXX() 的通用代码如下 （以 Statement 为例）：</p>\n<p><em>对于不理解<strong>回调</strong>的同学，请自行了解概念</em></p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(StatementCallback&lt;T&gt; action)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>{\n\t<span class="hljs-comment">// 通过工具类 DataSourceUtils 获取一个连接</span>\n  \tConnection con = DataSourceUtils.getConnection(obtainDataSource());\n  \t<span class="hljs-comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span>\n\tStatement stmt = <span class="hljs-keyword">null</span>;\n\t<span class="hljs-keyword">try</span> {\n\t\tstmt = con.createStatement();\t<span class="hljs-comment">// 通过连接(Connection)获取一个 Statement</span>\n\t\tapplyStatementSettings(stmt);\t<span class="hljs-comment">// 配置 Statement 参数</span>\n      \t<span class="hljs-comment">// 回调执行 doInXXX() 方法, 并获得 result</span>\n\t\tT result = action.doInStatement(stmt);\t\n\t\thandleWarnings(stmt);\n\t\t<span class="hljs-keyword">return</span> result;\n\t}\n\t<span class="hljs-keyword">catch</span> (SQLException ex) {\n\t\t<span class="hljs-comment">// Release Connection early, to avoid potential connection pool deadlock</span>\n\t\t<span class="hljs-comment">// in the case when the exception translator hasn\'t been initialized yet.</span>\n\t\tString sql = getSql(action);\n\t\tJdbcUtils.closeStatement(stmt);\n\t\tstmt = <span class="hljs-keyword">null</span>;\n\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\tcon = <span class="hljs-keyword">null</span>;\n\t\t<span class="hljs-keyword">throw</span> translateException(<span class="hljs-string">"StatementCallback"</span>, sql, ex);\n\t}\n\t<span class="hljs-keyword">finally</span> {\n\t\tJdbcUtils.closeStatement(stmt);\n\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t}\n}</code></pre><p>对于 Statement, PreparedStatement, CallableStatement 的区别，首先下图表现了三个接口的继承关系。</p>\n<ul>\n<li>Statement 可以支持静态 SQL 语句</li>\n<li>PreparedStatement 支持可变参数的 SQL 语句</li>\n<li>CallableStatement 支持可变参数的 SQL 语句，并且支持定制 DB 的输出结果</li>\n</ul>\n<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncpaec17yj30ew0hcdh7.jpg" alt=""></p>\n<h2>DataSource</h2>\n<p>上一节在粗略地了解了 JdbcTemplate 提供的方法之后，下面先来对 DataSource 做一点了解。</p>\n<h3>Java 提供的 DataSource 定义</h3>\n<p>DataSource 是 Java 核心库提供的接口。位于 javax.sql package 下。</p>\n<p>DataSource 接口可以被视作是一个提供物理 DB 实例连接(Connection) 的工厂，通过 DataSource 持有的各种属性（包括 DB Url, Username, Password 等）来获取一个连接(Connection) 。DataSource 接口有三种不同的实现方案：</p>\n<ol>\n<li>最基本的实现——生产一个标准连接(Connection) 对象</li>\n<li>连接池方案——生产会被自动添加到连接池的对象</li>\n<li>分布式事物实现——生产一个可以支持分布式事物，并默认被添加到连接池的连接对象</li>\n</ol>\n<p>包括两个对外提供连接(Connection) 对象的方法，</p>\n<pre><code class="hljs"><span class="hljs-function">Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException</span>;\n<span class="hljs-function">Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</code></pre><p>其父接口 CommonDataSource 提供设置/获取 LogWriter，登录 DB 超时时间和获取父 Logger 的方法。</p>\n<h3>Spring-JDBC 扩展的 DataSource 定义</h3>\n<p>在 Spring-jdbc 下，DataSources 最顶级的类是 AbstractDataSource ，对 DataSource 的所有父接口方法做了实现。但保留 getConnection() 方法由子类实现。</p>\n<p>在 AbstractDriverBasedDataSource 中，定义了大量的参数，诸如 url, username 等，这些都被用来定位并定义与数据库实例的连接。</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractDriverBasedDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDataSource</span> </span>{\n\n   <span class="hljs-meta">@Nullable</span>\n   <span class="hljs-keyword">private</span> String url;\n\n   <span class="hljs-meta">@Nullable</span>\n   <span class="hljs-keyword">private</span> String username;\n\n   <span class="hljs-meta">@Nullable</span>\n   <span class="hljs-keyword">private</span> String password;\n\n   <span class="hljs-meta">@Nullable</span>\n   <span class="hljs-keyword">private</span> String catalog;\n\n   <span class="hljs-meta">@Nullable</span>\n   <span class="hljs-keyword">private</span> String schema;\n\n   <span class="hljs-meta">@Nullable</span>\n   <span class="hljs-comment">// 可以看到此处有一个 Properties 类</span>\n   <span class="hljs-keyword">private</span> Properties connectionProperties;\n   \n   <span class="hljs-comment">// 省略若干方法</span>\n  \n\n\t<span class="hljs-meta">@Override</span>\n\t<span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n      \t<span class="hljs-comment">// 调用内部方法 getConnectionFromDriver()</span>\n\t\t<span class="hljs-keyword">return</span> getConnectionFromDriver(getUsername(), getPassword());\n\t}\n\n\t<span class="hljs-meta">@Override</span>\n\t<span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n      \t<span class="hljs-comment">// 调用内部方法 getConnectionFromDriver()</span>\n\t\t<span class="hljs-keyword">return</span> getConnectionFromDriver(username, password);\n\t}\n  \n   <span class="hljs-comment">// 定义了一个获取 Connection 的方法，由 getConnection() 方法调用，</span>\n   <span class="hljs-comment">// 此方法主要是将属性做了一个整合</span>\n   <span class="hljs-comment">// 具体获取 Connection 的逻辑仍然下放到子类实现 见 40 行</span>\n   <span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">getConnectionFromDriver</span><span class="hljs-params">(@Nullable String username, @Nullable String password)</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n\t\tProperties mergedProps = <span class="hljs-keyword">new</span> Properties();\n\t\tProperties connProps = getConnectionProperties();\n\t\t<span class="hljs-keyword">if</span> (connProps != <span class="hljs-keyword">null</span>) {\n\t\t\tmergedProps.putAll(connProps);\n\t\t}\n\t\t<span class="hljs-keyword">if</span> (username != <span class="hljs-keyword">null</span>) {\n\t\t\tmergedProps.setProperty(<span class="hljs-string">"user"</span>, username);\n\t\t}\n\t\t<span class="hljs-keyword">if</span> (password != <span class="hljs-keyword">null</span>) {\n\t\t\tmergedProps.setProperty(<span class="hljs-string">"password"</span>, password);\n\t\t}\n\t\t\n     \t<span class="hljs-comment">// 获取 Connection 逻辑下放</span>\n\t\tConnection con = getConnectionFromDriver(mergedProps);\n\t\t<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.catalog != <span class="hljs-keyword">null</span>) {\n\t\t\tcon.setCatalog(<span class="hljs-keyword">this</span>.catalog);\n\t\t}\n\t\t<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.schema != <span class="hljs-keyword">null</span>) {\n\t\t\tcon.setSchema(<span class="hljs-keyword">this</span>.schema);\n\t\t}\n\t\t<span class="hljs-keyword">return</span> con;\n\t}\n  \n  \t<span class="hljs-comment">// 该类中获取 Connection 的方法是抽象方法</span>\n    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Connection <span class="hljs-title">getConnectionFromDriver</span><span class="hljs-params">(Properties props)</span> <span class="hljs-keyword">throws</span> SQLException</span>;\n\n}</code></pre><p>整合方案为将除 url 外的所有参数整合在同一个 Properties 对象中 (其中，Properties 可以被认为是一个线程安全的 Hash Map) 。最终调用 <code>Connection getConnectionFromDriver(Properties props)</code> 获取连接。</p>\n<p>AbstractDriverBasedDataSource 抽象类的两个子类 DriverManagerDataSource 和 SimpleDriverDataSource 都以不同方式获得了连接(Connection)，但总结而言，获取连接(Connection) 的任务被委托给了 Driver 来实现（其中，Driver 有 Java 定义接口，并由各数据库提供商提供，例如 MySQL 提供了 mysql-connector-java-XXX.jar 来完成针对相应数据库的具体实现）。</p>\n<pre><code class="hljs"><span class="hljs-comment">// ----------------------------</span>\n<span class="hljs-comment">// SimpleDriverDataSource 的实现</span>\n<span class="hljs-comment">// ----------------------------</span>\n<span class="hljs-meta">@Override</span>\n<span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">getConnectionFromDriver</span><span class="hljs-params">(Properties props)</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n\tDriver driver = getDriver();\n\tString url = getUrl();\n\tAssert.notNull(driver, <span class="hljs-string">"Driver must not be null"</span>);\n\t<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {\n\t\tlogger.debug(<span class="hljs-string">"Creating new JDBC Driver Connection to ["</span> + url + <span class="hljs-string">"]"</span>);\n\t}\n  \t<span class="hljs-comment">// 哈哈，重点在这... driver 在该类中被预先注入</span>\n\t<span class="hljs-keyword">return</span> driver.connect(url, props);\n}\n\n<span class="hljs-comment">// -----------------------------</span>\n<span class="hljs-comment">// DriverManagerDataSource 的实现</span>\n<span class="hljs-comment">// -----------------------------</span>\n<span class="hljs-meta">@Override</span>\n<span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">getConnectionFromDriver</span><span class="hljs-params">(Properties props)</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n\tString url = getUrl();\n\tAssert.state(url != <span class="hljs-keyword">null</span>, <span class="hljs-string">"\'url\' not set"</span>);\n\t<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {\n\t\tlogger.debug(<span class="hljs-string">"Creating new JDBC DriverManager Connection to ["</span> + url + <span class="hljs-string">"]"</span>);\n\t}\n  \t<span class="hljs-comment">// 调了个内部函数</span>\n\t<span class="hljs-keyword">return</span> getConnectionFromDriverManager(url, props);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">getConnectionFromDriverManager</span><span class="hljs-params">(String url, Properties props)</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n    <span class="hljs-comment">// 委托给 DriverManager 类来获取连接</span>\n    <span class="hljs-comment">// DriverManager 的主要操作是遍历在该管理类中注册的 Driver</span>\n    <span class="hljs-comment">// 每个 Driver 实例都去尝试一下，能不能获得一个连接</span>\n    <span class="hljs-comment">// 第一次在某个 Driver 中拿到一个连接即返回连接 (Connection)</span>\n\t<span class="hljs-keyword">return</span> DriverManager.getConnection(url, props);\n}</code></pre><p>简要的类图如下：</p>\n<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fncrgqcjqoj31es15ajxj.jpg" alt=""></p>\n<h2>DriverManager</h2>\n<p>上面提到 DataSource 获取连接(Connection) 的操作实质上将委托具体的 Driver 来提供 Connection 。有两种不同的方式，包括经由 DriverManager 遍历所有处于管理下的 Driver 尝试获取连接，或者在 DataSource 实例中直接声明一个特定的 Driver 来获取连接。</p>\n<p>对于获取连接的具体操作，挖坑-待填。只描述简单的数据库供应商提供的 Driver 如何与 java 相联系。</p>\n<p>###在 DriverManager 中注册 Driver 实例</p>\n<p>通常在与数据库交互逻辑的 Java 代码中，都会有 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> (此处以 MySQL 提供的 mysql-connector-java-XXX.jar 为例，下同）的代码块，加载指定的 com.mysql.jdbc.Driver 为 java.lang.Class 类。</p>\n<p><em>当然，在 JDBC 4.0 标准下，可以不必再显示声明 <code>Class.forName(&quot;&quot;)</code> 语句，Driver 也同样会在 DriverManager 初始化时自动注册。</em></p>\n<pre><code class="hljs"><span class="hljs-comment">// Class 类中对于 forName(String className) 的方法</span>\n<span class="hljs-comment">// 作用为返回一个 java.lang.Class 实例。</span>\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className) <span class="hljs-keyword">throws</span> ClassNotFoundException {...}</code></pre><p>同时， JVM 在加载类的过程中会执行类中的 static 代码块。下述 row 10 ~ 16 的代码片段将被执行。唯一的逻辑就是 new 一个 com.mysql.jdbc.Driver 实例，并将实例注册(registerDriver) 到 <strong>java.sql.DriverManager</strong> 中。</p>\n<pre><code class="hljs"><span class="hljs-keyword">package</span> com.mysql.jdbc;\n\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">sql</span>.<span class="hljs-title">Driver</span> </span>{\n\t<span class="hljs-comment">// ~ Static fields/initializers</span>\n\t<span class="hljs-comment">// ---------------------------------------------</span>\n\n\t<span class="hljs-comment">//</span>\n\t<span class="hljs-comment">// Register ourselves with the DriverManager</span>\n\t<span class="hljs-comment">//</span>\n\t<span class="hljs-keyword">static</span> {\n\t\t<span class="hljs-keyword">try</span> {\n\t\t\tjava.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());\n\t\t} <span class="hljs-keyword">catch</span> (SQLException E) {\n\t\t\t<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Can\'t register driver!"</span>);\n\t\t}\n\t}\n\n\t<span class="hljs-comment">// ~ Constructors</span>\n\t<span class="hljs-comment">// -----------------------------------------------------------</span>\n\n\t<span class="hljs-comment">/**\n\t * Construct a new driver and register it with DriverManager\n\t * \n\t * <span class="hljs-doctag">@throws</span> SQLException\n\t *             if a database error occurs.\n\t */</span>\n\t<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n\t\t<span class="hljs-comment">// Required for Class.forName().newInstance()</span>\n\t}\n}</code></pre><p>下面再来看一下 DriverManager 中的 registerDriver() 方法。</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DriverManager</span> </span>{\n\n  \t<span class="hljs-comment">// DriverManager 维护一个线程安全的 Driver 列表</span>\n  \t<span class="hljs-comment">// 此处的 DriverInfo 里面即包装了 Driver </span>\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = \n      \t<span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();\n\n  \t<span class="hljs-comment">// 在 DriverManager 中注册 Driver</span>\n\t<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDriver</span><span class="hljs-params">(java.sql.Driver driver)</span>\n        <span class="hljs-keyword">throws</span> SQLException </span>{\n        registerDriver(driver, <span class="hljs-keyword">null</span>);\n    }\n  \n\t<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDriver</span><span class="hljs-params">(java.sql.Driver driver,\n            DriverAction da)</span>\n        <span class="hljs-keyword">throws</span> SQLException </span>{\n\n      \t<span class="hljs-comment">/* 如果当前 Driver 不在列表中，即添加到列表。 */</span>\n        <span class="hljs-keyword">if</span>(driver != <span class="hljs-keyword">null</span>) {\n            registeredDrivers.addIfAbsent(<span class="hljs-keyword">new</span> DriverInfo(driver, da));\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-comment">// This is for compatibility with the original DriverManager</span>\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();\n        }\n\n        println(<span class="hljs-string">"registerDriver: "</span> + driver);\n\n    }\n}</code></pre><h3>通过 DriverManager 获取连接(Connection)</h3>\n<p>上一节有提到过可以通过 DriverManager 来遍历获取连接，也可以直接声明具体 Driver 并获取连接。下面代码展示的是通过 DriverManager 获取连接的操作。 <s>哈哈哈，反正最后都是由具体驱动实现获取连接。</s></p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DriverManager</span> </span>{\n  \t<span class="hljs-comment">// 获取连接的 public 接口 (1)</span>\n\t<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url,\n\t\tjava.util.Properties info)</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n\t\t<span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));\n\t}\n\t<span class="hljs-comment">// 获取连接的 public 接口 (2)</span>\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url,\n        String user, String password)</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n        java.util.Properties info = <span class="hljs-keyword">new</span> java.util.Properties();\n\n        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>) {\n            info.put(<span class="hljs-string">"user"</span>, user);\n        }\n        <span class="hljs-keyword">if</span> (password != <span class="hljs-keyword">null</span>) {\n            info.put(<span class="hljs-string">"password"</span>, password);\n        }\n\n        <span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));\n    }\n\t<span class="hljs-comment">// 获取连接的 public 接口 (3)</span>\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url)</span>\n        <span class="hljs-keyword">throws</span> SQLException </span>{\n        java.util.Properties info = <span class="hljs-keyword">new</span> java.util.Properties();\n        <span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));\n    }\n \n  \t<span class="hljs-comment">// 获取连接的内部逻辑实现</span>\n    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(\n        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> \n      \t<span class="hljs-keyword">throws</span> SQLException </span>{\n        <span class="hljs-comment">/*\n         * When callerCl is null, we should check the application\'s\n         * (which is invoking this class indirectly)\n         * classloader, so that the JDBC driver class outside rt.jar\n         * can be loaded from here.\n         */</span>\n        ClassLoader callerCL = caller != <span class="hljs-keyword">null</span> ? caller.getClassLoader() : <span class="hljs-keyword">null</span>;\n        <span class="hljs-keyword">synchronized</span>(DriverManager.class) {\n            <span class="hljs-comment">// synchronize loading of the correct classloader.</span>\n            <span class="hljs-keyword">if</span> (callerCL == <span class="hljs-keyword">null</span>) {\n                callerCL = Thread.currentThread().getContextClassLoader();\n            }\n        }\n\t\t<span class="hljs-comment">// url 是定位 DBMS 最重要的参数，不能为空</span>\n        <span class="hljs-keyword">if</span>(url == <span class="hljs-keyword">null</span>) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(<span class="hljs-string">"The url cannot be null"</span>, <span class="hljs-string">"08001"</span>);\n        }\n\n        println(<span class="hljs-string">"DriverManager.getConnection(\\""</span> + url + <span class="hljs-string">"\\")"</span>);\n\n      \t<span class="hljs-comment">// 遍历所有注册的 Driver ，并都尝试获取连接(Connection)</span>\n        SQLException reason = <span class="hljs-keyword">null</span>;\n\n        <span class="hljs-keyword">for</span>(DriverInfo aDriver : registeredDrivers) {\n          \t<span class="hljs-comment">// 判断注册的 Driver 是否由 ClassLoader callerCL 加载，不是则跳过</span>\n            <span class="hljs-keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) {\n                <span class="hljs-keyword">try</span> {\n                    println(<span class="hljs-string">"    trying "</span> + aDriver.driver.getClass().getName());\n                    <span class="hljs-comment">// 获取连接，:) 还是由 driver 实例自行提供</span>\n                  \tConnection con = aDriver.driver.connect(url, info);\n                    <span class="hljs-keyword">if</span> (con != <span class="hljs-keyword">null</span>) {\n                        <span class="hljs-comment">// Success!</span>\n                        println(<span class="hljs-string">"getConnection returning "</span> + \n                                aDriver.driver.getClass().getName());\n                        <span class="hljs-keyword">return</span> (con);\n                    }\n                } <span class="hljs-keyword">catch</span> (SQLException ex) {\n                    <span class="hljs-keyword">if</span> (reason == <span class="hljs-keyword">null</span>) {\n                        reason = ex;\n                    }\n                }\n\n            } <span class="hljs-keyword">else</span> {\n                println(<span class="hljs-string">"    skipping: "</span> + aDriver.getClass().getName());\n            }\n\n        }\n\n        <span class="hljs-comment">// 如果运行到下列代码，则表明获取连接失败，抛出错误</span>\n        <span class="hljs-keyword">if</span> (reason != <span class="hljs-keyword">null</span>)    {\n            println(<span class="hljs-string">"getConnection failed: "</span> + reason);\n            <span class="hljs-keyword">throw</span> reason;\n        }\n\n        println(<span class="hljs-string">"getConnection: no suitable driver found for "</span>+ url);\n        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(<span class="hljs-string">"No suitable driver found for "</span>+ url, <span class="hljs-string">"08001"</span>);\n    }\n\n}</code></pre><p><em>简单的提一嘴，Connection 仍然只是一个针对 Java -&gt; DB Server 的上层接口，如果想要更深层次地了解 Connection 与 DB Server 的交互，可以尝试去看一下 com.mysql.jdbc.MysqlIO 类，MySQL 实现的 JDBC4Connection 类也是在使用该类来实现对 DB Server 交互。（哈哈，只看过 MySQL 提供的 Driver 包）。</em></p>\n<h2>PreparedStatement &amp; CallableStatement</h2>\n<p>在了解了 DataSource 获取连接(Connection) 的实质以及 JdbcTemplate 的通用接口之后，使用 Spring-jdbc 进行数据库相关的操作可以直截了当的利用如下代码进行实现（此处仅展示通过 Java 硬编码的形式进行实现，XML 配置方法类似）。</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{\n  \t<span class="hljs-comment">// 定义数据源</span>\n\tDriverManagerDataSource dataSource = <span class="hljs-keyword">new</span> DriverManagerDataSource();\n  \t<span class="hljs-comment">// 配置参数</span>\n\tdataSource.setUrl(<span class="hljs-string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;?&lt;props&gt;"</span>);\n   \tdataSource.setUsername(<span class="hljs-string">"&lt;username&gt;"</span>);\n    dataSource.setPassword(<span class="hljs-string">"&lt;passwd&gt;"</span>);\n  \t\n  \t<span class="hljs-comment">// 实例化一个 JDBC 工具类</span>\n  \tJdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);\n  \t<span class="hljs-comment">// 执行相关 CRUD 操作\t</span>\n  \tjdbcTemplate.execute();\n}</code></pre><p>回顾第一节所讲的 JdbcTemplate 的 4 个基础方法：</p>\n<ol>\n<li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li>\n<li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li>\n<li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li>\n<li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li>\n</ol>\n<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndsm5tl7aj30zg0byq47.jpg" alt=""></p>\n<p>四个基础方法都有一个特定的回调函数将通过预配置的 DataSource 得到的 Connection 或 更进一步的 Statement or PreparedStatement or CallableStatement 作为入参来执行定义的唯一方法。</p>\n<p>以 <code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code> 为例来了解一下方法的核心逻辑。</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(StatementCallback&lt;T&gt; action)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>{\n\t<span class="hljs-comment">// 通过工具类 DataSourceUtils 获取一个连接</span>\n  \tConnection con = DataSourceUtils.getConnection(obtainDataSource());\n  \t<span class="hljs-comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span>\n\tStatement stmt = <span class="hljs-keyword">null</span>;\n\t<span class="hljs-keyword">try</span> {\n\t\tstmt = con.createStatement();\t<span class="hljs-comment">// 通过连接(Connection)获取一个 Statement</span>\n\t\tapplyStatementSettings(stmt);\t<span class="hljs-comment">// 配置 Statement 参数</span>\n      \t<span class="hljs-comment">// 回调执行 doInXXX() 方法, 并获得 result</span>\n\t\tT result = action.doInStatement(stmt);\t\n\t\thandleWarnings(stmt);\n\t\t<span class="hljs-keyword">return</span> result;\n    } <span class="hljs-keyword">catch</span>() {\n      \n    } <span class="hljs-keyword">finally</span> {\n      \n    }\n}</code></pre><p>但是，对于 PreparedStatement 和 CallableStatement 而言，获取一个 <em>XXX</em>Statement 的方式就有所不同了。</p>\n<pre><code class="hljs"><span class="hljs-comment">// 获取 Statement 实例</span>\nStatement stmt = con.createStatement();</code></pre><pre><code class="hljs"><span class="hljs-comment">// 获取 PreparedStatement 实例</span>\n<span class="hljs-comment">// psc 是一个 PreparedStatementCreator 接口实现的实例</span>\nPreparedStatement ps = psc.createPreparedStatement(con);</code></pre><pre><code class="hljs"><span class="hljs-comment">// 获取 CallableStatement 实例</span>\n<span class="hljs-comment">// csc 是一个 CallableStatementCreator 接口实现的实例</span>\nCallableStatement cs = csc.createCallableStatement(con);</code></pre><p>可以看到 Statement 直接通过 Connection 获取实例，但是 PreparedStatement 和 CallableStatement 就有所不同，其区别就在于 PreparedStatement 和 CallableStatement 两个 Statement 都是可以定制入参的，更甚者， CallableStatement 可以定制 DB 执行结果的出参。当然，核心还是 <code>con.prepareStatement() OR con.prepareCall()</code> 方法，只不过是将获取 XXXStatement 的操作下放给 XXXStatementCreator 实例类实现，给予使用者重复的自主权，同时也是逻辑解耦的一种操作。</p>\n<p>例如：</p>\n<p>SimplePreparedStatementCreator 这个 PreparedStatementCreator 接口的实现类，只是简单的调用了 <code>con.prepareStatement(sql)</code> 方法。</p>\n<pre><code class="hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimplePreparedStatementCreator</span> \n  \t<span class="hljs-keyword">implements</span> <span class="hljs-title">PreparedStatementCreator</span>, <span class="hljs-title">SqlProvider</span> </span>{\n\n\t<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String sql;\n\n\t<span class="hljs-meta">@Override</span>\n\t<span class="hljs-function"><span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title">createPreparedStatement</span><span class="hljs-params">(Connection con)</span> \n      \t<span class="hljs-keyword">throws</span> SQLException </span>{\n\t\t<span class="hljs-keyword">return</span> con.prepareStatement(<span class="hljs-keyword">this</span>.sql);\n\t}\n}</code></pre><p>而对于 PreparedStatementCreatorImpl ，在 createPreparedStatement(Connection con) 的实现上，又添加了更多的操作。</p>\n<pre><code class="hljs"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreparedStatementCreatorImpl</span>\n\t\t<span class="hljs-keyword">implements</span> <span class="hljs-title">PreparedStatementCreator</span>, <span class="hljs-title">PreparedStatementSetter</span>, <span class="hljs-title">SqlProvider</span>, <span class="hljs-title">ParameterDisposer</span> </span>{\n\n\t<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String actualSql;\n\n\t<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;?&gt; parameters;\n\n\t<span class="hljs-meta">@Override</span>\n\t<span class="hljs-function"><span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title">createPreparedStatement</span><span class="hljs-params">(Connection con)</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n\t\tPreparedStatement ps;\n\t\t<span class="hljs-keyword">if</span> (generatedKeysColumnNames != <span class="hljs-keyword">null</span> || returnGeneratedKeys) {\n\t\t\t<span class="hljs-keyword">if</span> (generatedKeysColumnNames != <span class="hljs-keyword">null</span>) {\n              \t<span class="hljs-comment">// 获取一个 PreparedStatement 实例，下同</span>\n\t\t\t\tps = con.prepareStatement(<span class="hljs-keyword">this</span>.actualSql, \n                                          generatedKeysColumnNames);\n\t\t\t}\n\t\t\t<span class="hljs-keyword">else</span> {\n\t\t\t\tps = con.prepareStatement(<span class="hljs-keyword">this</span>.actualSql, \n                                         PreparedStatement.RETURN_GENERATED_KEYS);\n\t\t\t}\n\t\t}\n\t\t<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (resultSetType == ResultSet.TYPE_FORWARD_ONLY \n                 &amp;&amp; !updatableResults) {\n\t\t\tps = con.prepareStatement(<span class="hljs-keyword">this</span>.actualSql);\n\t\t}\n\t\t<span class="hljs-keyword">else</span> {\n\t\t\tps = con.prepareStatement(<span class="hljs-keyword">this</span>.actualSql, resultSetType,\n\t\t\t\tupdatableResults ? ResultSet.CONCUR_UPDATABLE : \n                                      ResultSet.CONCUR_READ_ONLY);\n\t\t}\n      \t<span class="hljs-comment">// 将可变 SQL (例如 SELECT * FROM msg WHERE id = ?) 的 ? 用实际参数替换</span>\n\t\tsetValues(ps);\n\t\t<span class="hljs-keyword">return</span> ps;\n\t}\n}</code></pre><p>从上述两种 PreparedStatementCreator 接口的不同实现，也可以从另一种角度理解到，函数式接口将获取目标出参的具体逻辑交给使用者定义，给予了使用者充分的自主权，同时也是一种业务逻辑的解耦。</p>\n<p>在上面代码 PreparedStatementCreatorImpl 类的实现中，我们看到第 32 行代码 <code>setValue(ps)</code> 。此处的方法是由接口 PreparedStatementSetter 定义的。主要目的是将可变 SQL 中的 ? 参数用实际参数进行一个替换。</p>\n<pre><code class="hljs"><span class="hljs-comment">// 以 SQL (SELECT * FROM msg WHERE id = ? AND day = ?) 为例</span>\n<span class="hljs-comment">/** 纯 Java 核心库的实现 PreparedStatement 参数注入 */</span>\nps.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">1763</span>);\nps.setString(<span class="hljs-number">2</span>, <span class="hljs-string">"2018-01-01"</span>);\nps.executeQuery();\n\n<span class="hljs-comment">/** 以 Spring-jdbc 实现 PreparedStatement 参数注入 */</span>\n<span class="hljs-comment">// setValues() 由接口 PreparedStatementSetter 定义，封装了注入参数的具体实现逻辑</span>\n<span class="hljs-comment">// 可以由使用者自行定义</span>\nsetValues(ps);\t\nps.executeQuery();</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndyybh4q1j31kw0u3afx.jpg" alt=""></p>\n<p>上面类图表示了 PreparedStatementSetter 及其实现类的相关依赖。</p>\n<p>Setter 的主要目标即为对 SQL 中的 ? 参数进行注入。</p>\n<p><s>个人精力有限，对Spring-jdbc在Statement上对参数注入的回调理解有限。</s></p>\n<h2>ResultSet</h2>\n<p>在前几节已经提到讲了数据源、驱动管理器以及 Statement 之后，利用 JDBC 的最重要的目的就是对 DB 进行操作，并获得预期结果。对于查询语句而言，结果应该是若干记录行；就更新语句而言，结果可能是影响的行数。而 Spring-jdbc 对 ResultSet 额外进行的封装，即是将原本散乱的结果进行一个整合，例如整合成一个(一组)完整的 Bean 来进行展示。</p>\n<p>在 JdbcTemplate 中，四个基本方法入参都包括一个回调接口，而在执行回调获得 ResultSet 之后，方法并不是直接返回，而是进行了一定的操作。</p>\n<p>以一个 PreparedStatementCallback 的实例类为例，在 doInPreparedStatement() 方法中，获得了 ResultSet ，但是仍通过 rse.extractData(rs) 语句进行了处理后再返回结果</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">doInPreparedStatement</span><span class="hljs-params">(PreparedStatement ps)</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n  \t<span class="hljs-comment">// 声明一个 ResultSet </span>\n\tResultSet rs = <span class="hljs-keyword">null</span>;\n\t<span class="hljs-keyword">try</span> {\n\t\t<span class="hljs-keyword">if</span> (pss != <span class="hljs-keyword">null</span>) {\t<span class="hljs-comment">// setValues() 方法填充 PreparedStatement 中的可变参数 ? </span>\n\t\t\tpss.setValues(ps);\n\t\t}\n\t\trs = ps.executeQuery();\t<span class="hljs-comment">// 执行查询 sql ，获取结果</span>\n\t\t<span class="hljs-keyword">return</span> rse.extractData(rs);\t<span class="hljs-comment">// 重点... 该语句一定是对结果进行了一些操作.</span>\n\t}\n\t<span class="hljs-keyword">finally</span> {\n\t\tJdbcUtils.closeResultSet(rs);\n\t\t<span class="hljs-keyword">if</span> (pss <span class="hljs-keyword">instanceof</span> ParameterDisposer) {\n\t\t\t((ParameterDisposer) pss).cleanupParameters();\n\t\t}\n\t}\n}</code></pre><p>在来看一下究竟在返回结果前进行了什么操作。</p>\n<p>由于是一个回调接口的实现类，rse 应该在外部方法中。</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">query</span><span class="hljs-params">(\n\t\tPreparedStatementCreator psc, @Nullable <span class="hljs-keyword">final</span> PreparedStatementSetter pss, \n  \t\t<span class="hljs-keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span>\n\t\t<span class="hljs-keyword">throws</span> DataAccessException </span>{\n\n\t<span class="hljs-keyword">return</span> execute(psc, <span class="hljs-keyword">new</span> PreparedStatementCallback&lt;T&gt;() {\n\t\t<span class="hljs-meta">@Override</span>\n\t\t<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">doInPreparedStatement</span><span class="hljs-params">(PreparedStatement ps)</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n\t\t\t...\t\n        }\n\t});\n}</code></pre><p>可以看到 rse 是一个 ResultSetExtractor&lt;T&gt; 的实例。从名称上可以看出 Extractor 即为提取器，结果集提取器。</p>\n<pre><code class="hljs"><span class="hljs-comment">/** 函数式接口，提供的唯一方法为 extractData(...) */</span>\n<span class="hljs-meta">@FunctionalInterface</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResultSetExtractor</span>&lt;<span class="hljs-title">T</span>&gt; </span>{\n\n\t<span class="hljs-meta">@Nullable</span>\n\t<span class="hljs-function">T <span class="hljs-title">extractData</span><span class="hljs-params">(ResultSet rs)</span> <span class="hljs-keyword">throws</span> SQLException, DataAccessException</span>;\n\n}</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fndzz0pqnrj31a60i676v.jpg" alt=""></p>\n<p>Spring-jdbc 中现有的实现有三个类，其中 RowCallbackHandlerResultSetExtractor 和 RowMapperResultSetExtractor 两个类从上面类图及命名即可看出，两个是作为一个适配器而存在的，将 extractData() 进行转换，分别由 RowCallbackHandler 和 RowMapper 实例进行具体操作。而 AbstractLobStreamingResultSetExtractor 类从名称上看，也是一个类似流操作的实现类(其中的 Lob 指的是 DB 中的 BLOB 与 CLOB 类型，在 Spring-jdbc 中也加入了额外的支持) 。</p>\n<h3>RowCallbackHandler</h3>\n<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh2uw3a0aj30h20jeta4.jpg" alt=""></p>\n<p>从名称上看，这是一个与 ResultSet 结果集行相关的回调接口。processRow(ResultSet rs) 方法将处理行相关的逻辑。</p>\n<p>从它的一个实现类 RowCountCallbackHandler 来说，其最主要的私有属性 rowCount 即是统计 ResultSet 的结果行数。下面是一个具体使用的该类的案例：</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{\n\n    DriverManagerDataSource dataSource = <span class="hljs-keyword">new</span> DriverManagerDataSource();\n    dataSource.setUrl(<span class="hljs-string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>);\n    dataSource.setUsername(<span class="hljs-string">"&lt;username&gt;"</span>);\n    dataSource.setPassword(<span class="hljs-string">"&lt;password&gt;"</span>);\n\n    JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);\n    RowCountCallbackHandler rcch = <span class="hljs-keyword">new</span> RowCountCallbackHandler();\n\n    jdbcTemplate.query(<span class="hljs-string">"SELECT * FROM info WHERE id=\'2018\'"</span>, (RowCallbackHandler) rcch);\n\t\n  \tSystem.out.println(rcch.getRowCount());\t<span class="hljs-comment">//获取结果集行数</span>\n    System.out.println(rcch.getColumnCount());\t<span class="hljs-comment">// 获取结果集列数</span>\n    <span class="hljs-keyword">for</span> (String arg : rcch.getColumnNames()) {\t<span class="hljs-comment">// 打印结果集每一列名称</span>\n        System.out.println(<span class="hljs-string">"ColumnNames : "</span> + arg);\n    }\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : rcch.getColumnTypes()) {\t<span class="hljs-comment">// 打印结果集每一列类型(Types 为枚举类)</span>\n        System.out.println(<span class="hljs-string">"ColumnTypes : "</span> + i);\n    }\n}</code></pre><p>具体查看 RowCountCallbackHandler 类的 processRow() 方法可以看到，其获取列相关信息都来自于 ResultSetMetaData 。而结果行数来源于 Iterator 迭代。</p>\n<pre><code class="hljs"><span class="hljs-meta">@Override</span>\n<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRow</span><span class="hljs-params">(ResultSet rs)</span> <span class="hljs-keyword">throws</span> SQLException </span>{\n\t<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rowCount == <span class="hljs-number">0</span>) {\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\t<span class="hljs-keyword">this</span>.columnCount = rsmd.getColumnCount();\n\t\t<span class="hljs-keyword">this</span>.columnTypes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.columnCount];\n\t\t<span class="hljs-keyword">this</span>.columnNames = <span class="hljs-keyword">new</span> String[<span class="hljs-keyword">this</span>.columnCount];\n\t\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.columnCount; i++) {\n\t\t\t<span class="hljs-keyword">this</span>.columnTypes[i] = rsmd.getColumnType(i + <span class="hljs-number">1</span>);\n\t\t\t<span class="hljs-keyword">this</span>.columnNames[i] = JdbcUtils.lookupColumnName(rsmd, i + <span class="hljs-number">1</span>);\n\t\t}\n\t\t<span class="hljs-comment">// could also get column names</span>\n\t}\n\tprocessRow(rs, <span class="hljs-keyword">this</span>.rowCount++);\n}</code></pre><h3>RowMapper</h3>\n<p>上面 RowCallbackHandler 接口从逻辑上划分是用于处理 ResultSet 元数据信息的。而 RowMapper 较上一个接口而言，有更高的实用性。</p>\n<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh3h739kaj30z60nago4.jpg" alt=""></p>\n<p>特别是其实现类 BeanPropertyRowMapper&lt;T&gt; 可以将散乱的 ResultSet 的结果数据整理成一个个 Object Bean 作为返回结果。而省去了对逐一读取 ResultSet 行记录并填充 Bean 属性的麻烦。</p>\n<pre><code class="hljs">JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);\n\nBeanPropertyRowMapper&lt;Model&gt; rowMapper = <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Model.class);\nList&lt;Model&gt; list = jdbcTemplate.query(<span class="hljs-string">"SELECT * FROM info WHERE id = \'2018\'"</span>, rowMapper);\n<span class="hljs-comment">/** 获得的 Model list 的对应属性将通过 Java 的反射机制进行填充\n *\tList&lt;Model&gt; list 即结果\n */</span></code></pre><p>当然，要求是 Model 类中的属性与 DB table 中的列名保持一致（大小写无要求）。</p>\n<p>而其它两个类的实现也是基于反射机制，实现其相应的业务逻辑。</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-01-15-Spring-JDBC-Code-Reading.json",ext:".json",sourceBase:"2018-01-15-Spring-JDBC-Code-Reading.md",sourceExt:".md"}},"9vk+":function(n){n.exports={bodyContent:"title: 理解 Linux Kernel (8) - 网络\nauthor: fangfeng\ndate: 2019-01-15\ntags:\n  - Linux\n  - Kernel\n  - Network\n---\n\n{% pdf https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview %}",bodyHtml:"<p>title: 理解 Linux Kernel (8) - 网络\nauthor: fangfeng\ndate: 2019-01-15\ntags:</p>\n<ul>\n<li>Linux</li>\n<li>Kernel</li>\n<li>Network</li>\n</ul>\n<hr>\n<p>{% pdf https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview %}</p>\n",preview:"",title:"Linux",dir:"content",base:"2019-01-15-understand-Kernel-8.json",ext:".json",sourceBase:"2019-01-15-understand-Kernel-8.md",sourceExt:".md"}},"B/bq":function(n){n.exports={title:"理解 Linux Kernel (2) - 多任务切换",author:"fangfeng",date:"2018-08-26T00:00:00.000Z",tags:["Linux","Kernel","Multi-Task"],bodyContent:"## 概述\n\n《只是为了好玩》一书中，林纳斯描述过他最早的试验性程序就是让 CPU 执行两个不同的任务(一个不断输出A，另一个输出B)，同时不断地让 CPU 在两个任务间的切换。\n\n结合《Linux 内核完全注释》一书，得到了多任务切换的示例程序。\n\n本节所要描述的内容，正是结合一个框架式的汇编程序(多任务切换程序, 书中提供的内容比较老，无法适应目前的各种工具、环境)，在现有环境中加以处理并成功运行。\n\n关于运行环境的说明，欢迎参考 [理解 Linux Kernel (0)](https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/)\n\n\x3c!-- more --\x3e\n\n## 引导程序\n\n在 [理解 Linux Kernel (1)](https://dormouse-none.github.io/2018-08-19-understand-Kernel-1/) 已经描述过通过 BIOS 加载引导程序，并执行引导程序的全部流程。\n当然，也就仅仅到引导程序就结束了。诸如操作系统之类的内容根本就没有涉及。\n\n不过，无论是操作系统，还是用户程序，都是基于 CPU、内存等硬件而进一步抽象的上层概念。如果问没有操作系统而直接运行程序是否可行？毫无疑问，这绝对是没有问题的。\n\nCPU 只是忠实地执行寄存器定位到的机器指令，并加以执行。特别是，如果在 [理解 Linux Kernel (1)](https://dormouse-none.github.io/2018-08-19-understand-Kernel-1/) 提供的输出 \"System Loading...\" 的示例程序上继续加以改编，无论是算术运算、显示文本等等目的都是没有问题的。\n当然，限制也还是有的，512B 是引导程序的上限。\n\n在机器上电启动之后，存储在非易失性存储器 / 只读存储器上的 BIOS 程序将被加载到内存，并进行执行(至于细节，不甚了解，不表)\n之后，BIOS 将默认地将指定磁盘(软盘、硬盘等) 首个扇区 512 字节的内容(称为 boot 引导程序)加载到内存地址，并 JMP 到 CS:IP = 0x07c00:0x0000 的位置。从而触发引导程序。\n\n继而，如果在编写 boot 引导程序的时候，我们使其能够从外存加载额外的代码，并在引导程序结束位置将 CPU 的控制权交给这段额外加载的代码。显然，操作系统就是这样子被加载的。\n\n`BIOS -> boot 引导程序 -> 操作系统引导程序 -> 操作系统`\n这就构成了一个宏观的操作系统启动的一个流程。\n\nboot.s 引导程序 <small>主体代码来自《Linux 内核完全注释》，进行了一定量的改写</small>\n\n```\nBOOTSEG = 0x07c0\nSYSSEG = 0x0100\nSYSLEN = 17\n\nentry start\nstart:\n    jmpi    go,#BOOTSEG\ngo:\n    mov ax,cs\n    mov ds,ax\n    mov ss,ax\n    mov sp,#0x0400\n\nload_system:\n    xor dx,dx       ! 开始位置, 磁头:硬盘号\n    mov cx,#0x0002  ! 开始位置, 磁道:扇区\n    mov ax,#0x0100\n    mov es,ax       ! 载入到, ES 段\n    xor bx,bx       ! 载入到, 偏移量 \n    mov ax,#0x0211  ! AH: 读取扇区子功能, AL: 读取多少个扇区\n    int 0x13        ! BIOS 13 号中断\n    jnc continue_load   ! JUMP if CF = 0\ndie:\n    jmp die\n\ncontinue_load:\n    cli             ! 清除中断允许位标志\n    mov ax,#SYSSEG \n    mov ds,ax       ! 设置数据段寄存器位置 0x1000\n    xor ax,ax\n    mov es,ax       ! 设置扩展段寄存器 0x0000\n    mov cx,#0x1000  ! 计数器\n    sub si,si\n    sub di,di\n    rep \n    movsw\n\n    mov ax,#BOOTSEG\n    mov ds,ax       ! 重新设置数据段寄存器到当前数据段基地址\n    lidt idt_48     ! 设置中断描述符表寄存器\n    lgdt gdt_48     ! 设置全局描述符表寄存器\n\n    mov ax,#0x0001\n    lmsw ax         ! 设置 CR0, 进入保护模式\n    jmpi 0,8\n\ngdt:\n    .word   0,0,0,0\n    .word   0x07FF,0x0000,0x9A00,0x00C0\n    .word   0x07FF,0x0000,0x9200,0x00C0\n\nidt_48:\n    .word   0,0,0\ngdt_48:\n    .word   0x07FF,0x7C00+gdt,0\n\n.org 510\n    .word   0xAA55\n```\n\n这段汇编程序，通过 `load_system` 标识符标识的这段程序表明需要加载0号磁盘,0号磁头,0号磁道,从第2扇区开始,连续17个扇区的内容(这里将存储支持任务切换的程序)，加载到内存以 0x1000 开始的物理地址处。\n\n`continue_load` 标识将 0x1000 物理地址开始的 4096 字 (即 8192 字节) 的内容依次复制到以 0x0000 开始的物理地址处。\n\n其后，设置 IDT (中断描述符表)、IDTR(中断描述符表寄存器) 及 GDT(全局描述符表)、GDTR(全局描述符表寄存器)，将 CPU 运行模式改成 `保护模式` ，继而将控制权转交给这个被加载进来的程序。\n\n## 多任务程序\n\n<small>主体内容来自《Linux 内核完全注释》，经过一定量改变以适应当前运行环境</small>\n```\n# head.s\n.code32\nLATCH = 11930\nSCRN_SEL = 0x18\nTSS0_SEL = 0x20\nLDT0_SEL = 0x28\nTSS1_SEL = 0x30\nLDT1_SEL = 0x38\n\n.text\n.globl startup_32\nstartup_32:\n\n    movl $0x00000010,%eax       # 段选择符 2\n    mov %ax,%ds                \n    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP \n\n    call setup_idt              # 设置中断描述符表\n    call setup_gdt              # 设置全局描述符表\n    movl $0x00000010,%eax\n    mov %ax,%ds\n    mov %ax,%es\n    mov %ax,%fs\n    mov %ax,%gs\n    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP\n\n# 设置 8253 定时芯片 10s 一个中断\n    movb $0x36,%al  \n    movl $0x00000043,%edx\n    outb %al,%dx\n    movl $LATCH,%eax\n    movl $0x40,%edx\n    outb %al,%dx\n    movb %ah,%al\n    outb %al,%dx\n\n    movl $0x00080000,%eax       # 重新设置 int 0x08 时钟中断\n    movw $timer_interrupt,%ax\n    movw $0x8E00,%dx\n    movl $0x08,%ecx\n    lea idt(,%ecx,8),%esi\n    movl %eax,(%esi)\n    movl %edx,4(%esi)\n    movw $system_interrupt,%ax  # 重新设置 int 0x80 系统中断\n    movw $0xef00,%dx\n    movl $0x80,%ecx\n    lea idt(,%ecx,8),%esi\n    movl %eax,(%esi)\n    movl %edx,4(%esi)\n\n    pushfl                      # 重置 EFLAGS 嵌套任务标志位\n    andl $0xffffbfff,(%esp)\n    popfl\n    movl $TSS0_SEL,%eax\n    ltr %ax                     # Load Task Register\n    movl $LDT0_SEL,%eax\n    lldt %ax                    # Load Local Descriptor Register\n    movl $0,current\n    sti                         # set interrupt flag\n    pushl $0x17\n    pushl $init_stack\n    pushfl\n    pushl $0x0f\n    pushl $task0\n    iret\n\n\nsetup_gdt:\n    lgdt lgdt_opcode\n    ret\nsetup_idt:\n    lea ignore_int,%edx         # 预先把中断处理程序的偏移地址 ignore_int 存到 EDX\n    movl $0x00080000,%eax       # 预存 0x0008 - 段选择符\n    movw %dx,%ax                # 补上 0-15 位偏移地址\n    movw $0x8E00,%dx            # DX 补上标志位\n    lea idt,%edi\n    mov $256,%ecx\nrp_idt: movl %eax,(%edi)        # 循环 256 遍处理 IDT\n    movl %edx,4(%edi)\n    addl $8,%edi\n    dec %ecx\n    jne rp_idt\n    lidt lidt_opcode\n    ret\n\n\nwrite_char:\n    push %gs\n    pushl %ebx\n    mov $SCRN_SEL,%ebx\n    mov %bx,%gs\n    movl scr_loc,%ebx\n    shl $1,%ebx\n    movb %al,%gs:(%ebx)\n    shr $1,%ebx\n    incl %ebx\n    cmpl $2000,%ebx\n    jb 1f\n    movl $0,%ebx\n1:  movl %ebx,scr_loc\n    popl %ebx\n    pop %gs\n    ret\n\n\n\n.align 4\nignore_int:                 # 默认的中断处理程序\n    push %ds\n    pushl %eax\n    movl $0x10,%eax\n    mov %ax,%ds\n    movl $67,%eax\n    call write_char\n    popl %eax\n    pop %ds\n    iret\n\n\n.align 4\ntimer_interrupt:            # 定时中断处理程序\n    push %ds\n    pushl %eax\n    movl $0x10,%eax\n    mov %ax,%ds\n    movb $0x20,%al\n    outb %al,$0x20\n    movl $1,%eax\n    cmpl %eax,current\n    je 1f\n    movl %eax,current\n    jmp $TSS1_SEL, $0\n    jmp 2f\n1:  movl $0,current\n    jmp $TSS0_SEL, $0\n2:  popl %eax\n    pop %ds\n    iret\n\n\n.align 4\nsystem_interrupt:           # 系统调用中断处理程序\n    push %ds\n    pushl %edx\n    pushl %ecx\n    pushl %ebx\n    pushl %eax\n    movl $0x10,%edx\n    mov %dx,%ds\n    call write_char\n    popl %eax\n    popl %ebx\n    popl %ecx\n    popl %edx\n    pop %ds\n    iret\n\n\ncurrent:.long 0\nscr_loc:.long 0\n\n.align 4\nlidt_opcode:\n    .word 256*8-1\n    .long idt\nlgdt_opcode:\n    .word (end_gdt-gdt)-1\n    .long gdt\n\n.align 8\nidt:    .fill 256,8,0\n\ngdt:    .quad 0x0000000000000000\n        .quad 0x00c09a00000007ff\n        .quad 0x00c09200000007ff\n        .quad 0x00c0920b80000002\n        .word 0x68,tss0,0xe900,0x0\n        .word 0x40,ldt0,0xe200,0x0\n        .word 0x68,tss1,0xe900,0x0\n        .word 0x40,ldt1,0xe200,0x0\nend_gdt:\n        .fill 128,4,0\ninit_stack:\n    .long init_stack\n    .word 0x0010\n\n\n.align 8\nldt0:   .quad 0x0000000000000000\n        .quad 0x00c0fa00000003ff\n        .quad 0x00c0f200000003ff\n\ntss0:   .long 0\n        .long krn_stk0, 0x10\n        .long 0,0,0,0,0\n        .long 0,0,0,0,0\n        .long 0,0,0,0,0\n        .long 0,0,0,0,0,0\n        .long LDT0_SEL,0x8000000\n\n        .fill 128,4,0\nkrn_stk0:\n\n\n.align 8\nldt1:   .quad 0x0000000000000000\n        .quad 0x00c0fa00000003ff\n        .quad 0x00c0f200000003ff\n\ntss1:   .long 0\n        .long krn_stk1,0x10\n        .long 0,0,0,0,0\n        .long task1,0x200\n        .long 0,0,0,0\n        .long usr_stk1,0,0,0\n        .long 0x17,0x0f,0x17,0x17,0x17,0x17\n        .long LDT1_SEL,0x8000000\n\n        .fill 128,4,0\nkrn_stk1:\n\n\ntask0:\n    movl $0x17,%eax\n    movw %ax,%ds\n    mov $65,%al\n    int $0x80\n    movl $0xfff,%ecx\n1:  loop 1b\n    jmp task0\ntask1:\n    mov $66,%al\n    int $0x80\n    movl $0xfff,%ecx\n1:  loop 1b\n    jmp task1\n\n    .fill 128,4,0\nusr_stk1:\n```\n\n上面的这个程序内容不再详述，想了解细节请参考 《Linux 内核完全注释》\n\n下面提供编译 `boot.s` 以及 `head.s` 的可用 Makefile\n\n首先描述一下额外的工具版本\n\n- GNU as : GNU assembler version 2.26.1 \n- GNU ld : GNU ld 2.26.1\n其它内容详见 [理解 Linux Kernel (0)](https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/)\n\n```makefile\n# Makefile for the simple example kernel.\nAS86\t=as86 -0 -a\nLD86\t=ld86 -0\nAS\t=as\nASFLAGS =-32\nLD\t=ld\nLDFLAGS\t=-s -x -M -m elf_i386 -e startup_32 -Ttext 0x0\n\nall:\tImage\n\nImage: boot system\n\tdd bs=32 if=boot of=Image skip=1\n\tdd bs=512 if=system of=Image skip=8 seek=1\n\tsync\n\ndisk: Image\n\tdd bs=8192 if=Image of=/dev/fd0\n\tsync;sync;sync\n\nhead.o: \n\t$(AS) $(ASFLAGS) -o head.o head.s\n\nsystem:\thead.o \n\t$(LD) $(LDFLAGS) head.o  -o system > System.map\n\nboot:\tboot.s\n\t$(AS86) -o boot.o boot.s\n\t$(LD86) -s -o boot boot.o\n\nclean:\n\trm -f Image System.map core boot *.o system\n```\n\n## 运行结果\n\n想了解更多细节的请自行实操查看吧!\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fun1fvafhwg30k40d4x6p.gif)\n\n## 附件\n\n[程序源码](https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/understand-kernel-2.zip)\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```",bodyHtml:'<h2>概述</h2>\n<p>《只是为了好玩》一书中，林纳斯描述过他最早的试验性程序就是让 CPU 执行两个不同的任务(一个不断输出A，另一个输出B)，同时不断地让 CPU 在两个任务间的切换。</p>\n<p>结合《Linux 内核完全注释》一书，得到了多任务切换的示例程序。</p>\n<p>本节所要描述的内容，正是结合一个框架式的汇编程序(多任务切换程序, 书中提供的内容比较老，无法适应目前的各种工具、环境)，在现有环境中加以处理并成功运行。</p>\n<p>关于运行环境的说明，欢迎参考 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">理解 Linux Kernel (0)</a></p>\n<p>&lt;!-- more --&gt;</p>\n<h2>引导程序</h2>\n<p>在 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-1/">理解 Linux Kernel (1)</a> 已经描述过通过 BIOS 加载引导程序，并执行引导程序的全部流程。\n当然，也就仅仅到引导程序就结束了。诸如操作系统之类的内容根本就没有涉及。</p>\n<p>不过，无论是操作系统，还是用户程序，都是基于 CPU、内存等硬件而进一步抽象的上层概念。如果问没有操作系统而直接运行程序是否可行？毫无疑问，这绝对是没有问题的。</p>\n<p>CPU 只是忠实地执行寄存器定位到的机器指令，并加以执行。特别是，如果在 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-1/">理解 Linux Kernel (1)</a> 提供的输出 &quot;System Loading...&quot; 的示例程序上继续加以改编，无论是算术运算、显示文本等等目的都是没有问题的。\n当然，限制也还是有的，512B 是引导程序的上限。</p>\n<p>在机器上电启动之后，存储在非易失性存储器 / 只读存储器上的 BIOS 程序将被加载到内存，并进行执行(至于细节，不甚了解，不表)\n之后，BIOS 将默认地将指定磁盘(软盘、硬盘等) 首个扇区 512 字节的内容(称为 boot 引导程序)加载到内存地址，并 JMP 到 CS:IP = 0x07c00:0x0000 的位置。从而触发引导程序。</p>\n<p>继而，如果在编写 boot 引导程序的时候，我们使其能够从外存加载额外的代码，并在引导程序结束位置将 CPU 的控制权交给这段额外加载的代码。显然，操作系统就是这样子被加载的。</p>\n<p><code>BIOS -&gt; boot 引导程序 -&gt; 操作系统引导程序 -&gt; 操作系统</code>\n这就构成了一个宏观的操作系统启动的一个流程。</p>\n<p>boot.s 引导程序 &lt;small&gt;主体代码来自《Linux 内核完全注释》，进行了一定量的改写&lt;/small&gt;</p>\n<pre><code>BOOTSEG = 0x07c0\nSYSSEG = 0x0100\nSYSLEN = 17\n\nentry start\nstart:\n    jmpi    go,#BOOTSEG\ngo:\n    mov ax,cs\n    mov ds,ax\n    mov ss,ax\n    mov sp,#0x0400\n\nload_system:\n    xor dx,dx       ! 开始位置, 磁头:硬盘号\n    mov cx,#0x0002  ! 开始位置, 磁道:扇区\n    mov ax,#0x0100\n    mov es,ax       ! 载入到, ES 段\n    xor bx,bx       ! 载入到, 偏移量 \n    mov ax,#0x0211  ! AH: 读取扇区子功能, AL: 读取多少个扇区\n    int 0x13        ! BIOS 13 号中断\n    jnc continue_load   ! JUMP if CF = 0\ndie:\n    jmp die\n\ncontinue_load:\n    cli             ! 清除中断允许位标志\n    mov ax,#SYSSEG \n    mov ds,ax       ! 设置数据段寄存器位置 0x1000\n    xor ax,ax\n    mov es,ax       ! 设置扩展段寄存器 0x0000\n    mov cx,#0x1000  ! 计数器\n    sub si,si\n    sub di,di\n    rep \n    movsw\n\n    mov ax,#BOOTSEG\n    mov ds,ax       ! 重新设置数据段寄存器到当前数据段基地址\n    lidt idt_48     ! 设置中断描述符表寄存器\n    lgdt gdt_48     ! 设置全局描述符表寄存器\n\n    mov ax,#0x0001\n    lmsw ax         ! 设置 CR0, 进入保护模式\n    jmpi 0,8\n\ngdt:\n    .word   0,0,0,0\n    .word   0x07FF,0x0000,0x9A00,0x00C0\n    .word   0x07FF,0x0000,0x9200,0x00C0\n\nidt_48:\n    .word   0,0,0\ngdt_48:\n    .word   0x07FF,0x7C00+gdt,0\n\n.org 510\n    .word   0xAA55\n</code></pre>\n<p>这段汇编程序，通过 <code>load_system</code> 标识符标识的这段程序表明需要加载0号磁盘,0号磁头,0号磁道,从第2扇区开始,连续17个扇区的内容(这里将存储支持任务切换的程序)，加载到内存以 0x1000 开始的物理地址处。</p>\n<p><code>continue_load</code> 标识将 0x1000 物理地址开始的 4096 字 (即 8192 字节) 的内容依次复制到以 0x0000 开始的物理地址处。</p>\n<p>其后，设置 IDT (中断描述符表)、IDTR(中断描述符表寄存器) 及 GDT(全局描述符表)、GDTR(全局描述符表寄存器)，将 CPU 运行模式改成 <code>保护模式</code> ，继而将控制权转交给这个被加载进来的程序。</p>\n<h2>多任务程序</h2>\n<p>&lt;small&gt;主体内容来自《Linux 内核完全注释》，经过一定量改变以适应当前运行环境&lt;/small&gt;</p>\n<pre><code># head.s\n.code32\nLATCH = 11930\nSCRN_SEL = 0x18\nTSS0_SEL = 0x20\nLDT0_SEL = 0x28\nTSS1_SEL = 0x30\nLDT1_SEL = 0x38\n\n.text\n.globl startup_32\nstartup_32:\n\n    movl $0x00000010,%eax       # 段选择符 2\n    mov %ax,%ds                \n    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP \n\n    call setup_idt              # 设置中断描述符表\n    call setup_gdt              # 设置全局描述符表\n    movl $0x00000010,%eax\n    mov %ax,%ds\n    mov %ax,%es\n    mov %ax,%fs\n    mov %ax,%gs\n    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP\n\n# 设置 8253 定时芯片 10s 一个中断\n    movb $0x36,%al  \n    movl $0x00000043,%edx\n    outb %al,%dx\n    movl $LATCH,%eax\n    movl $0x40,%edx\n    outb %al,%dx\n    movb %ah,%al\n    outb %al,%dx\n\n    movl $0x00080000,%eax       # 重新设置 int 0x08 时钟中断\n    movw $timer_interrupt,%ax\n    movw $0x8E00,%dx\n    movl $0x08,%ecx\n    lea idt(,%ecx,8),%esi\n    movl %eax,(%esi)\n    movl %edx,4(%esi)\n    movw $system_interrupt,%ax  # 重新设置 int 0x80 系统中断\n    movw $0xef00,%dx\n    movl $0x80,%ecx\n    lea idt(,%ecx,8),%esi\n    movl %eax,(%esi)\n    movl %edx,4(%esi)\n\n    pushfl                      # 重置 EFLAGS 嵌套任务标志位\n    andl $0xffffbfff,(%esp)\n    popfl\n    movl $TSS0_SEL,%eax\n    ltr %ax                     # Load Task Register\n    movl $LDT0_SEL,%eax\n    lldt %ax                    # Load Local Descriptor Register\n    movl $0,current\n    sti                         # set interrupt flag\n    pushl $0x17\n    pushl $init_stack\n    pushfl\n    pushl $0x0f\n    pushl $task0\n    iret\n\n\nsetup_gdt:\n    lgdt lgdt_opcode\n    ret\nsetup_idt:\n    lea ignore_int,%edx         # 预先把中断处理程序的偏移地址 ignore_int 存到 EDX\n    movl $0x00080000,%eax       # 预存 0x0008 - 段选择符\n    movw %dx,%ax                # 补上 0-15 位偏移地址\n    movw $0x8E00,%dx            # DX 补上标志位\n    lea idt,%edi\n    mov $256,%ecx\nrp_idt: movl %eax,(%edi)        # 循环 256 遍处理 IDT\n    movl %edx,4(%edi)\n    addl $8,%edi\n    dec %ecx\n    jne rp_idt\n    lidt lidt_opcode\n    ret\n\n\nwrite_char:\n    push %gs\n    pushl %ebx\n    mov $SCRN_SEL,%ebx\n    mov %bx,%gs\n    movl scr_loc,%ebx\n    shl $1,%ebx\n    movb %al,%gs:(%ebx)\n    shr $1,%ebx\n    incl %ebx\n    cmpl $2000,%ebx\n    jb 1f\n    movl $0,%ebx\n1:  movl %ebx,scr_loc\n    popl %ebx\n    pop %gs\n    ret\n\n\n\n.align 4\nignore_int:                 # 默认的中断处理程序\n    push %ds\n    pushl %eax\n    movl $0x10,%eax\n    mov %ax,%ds\n    movl $67,%eax\n    call write_char\n    popl %eax\n    pop %ds\n    iret\n\n\n.align 4\ntimer_interrupt:            # 定时中断处理程序\n    push %ds\n    pushl %eax\n    movl $0x10,%eax\n    mov %ax,%ds\n    movb $0x20,%al\n    outb %al,$0x20\n    movl $1,%eax\n    cmpl %eax,current\n    je 1f\n    movl %eax,current\n    jmp $TSS1_SEL, $0\n    jmp 2f\n1:  movl $0,current\n    jmp $TSS0_SEL, $0\n2:  popl %eax\n    pop %ds\n    iret\n\n\n.align 4\nsystem_interrupt:           # 系统调用中断处理程序\n    push %ds\n    pushl %edx\n    pushl %ecx\n    pushl %ebx\n    pushl %eax\n    movl $0x10,%edx\n    mov %dx,%ds\n    call write_char\n    popl %eax\n    popl %ebx\n    popl %ecx\n    popl %edx\n    pop %ds\n    iret\n\n\ncurrent:.long 0\nscr_loc:.long 0\n\n.align 4\nlidt_opcode:\n    .word 256*8-1\n    .long idt\nlgdt_opcode:\n    .word (end_gdt-gdt)-1\n    .long gdt\n\n.align 8\nidt:    .fill 256,8,0\n\ngdt:    .quad 0x0000000000000000\n        .quad 0x00c09a00000007ff\n        .quad 0x00c09200000007ff\n        .quad 0x00c0920b80000002\n        .word 0x68,tss0,0xe900,0x0\n        .word 0x40,ldt0,0xe200,0x0\n        .word 0x68,tss1,0xe900,0x0\n        .word 0x40,ldt1,0xe200,0x0\nend_gdt:\n        .fill 128,4,0\ninit_stack:\n    .long init_stack\n    .word 0x0010\n\n\n.align 8\nldt0:   .quad 0x0000000000000000\n        .quad 0x00c0fa00000003ff\n        .quad 0x00c0f200000003ff\n\ntss0:   .long 0\n        .long krn_stk0, 0x10\n        .long 0,0,0,0,0\n        .long 0,0,0,0,0\n        .long 0,0,0,0,0\n        .long 0,0,0,0,0,0\n        .long LDT0_SEL,0x8000000\n\n        .fill 128,4,0\nkrn_stk0:\n\n\n.align 8\nldt1:   .quad 0x0000000000000000\n        .quad 0x00c0fa00000003ff\n        .quad 0x00c0f200000003ff\n\ntss1:   .long 0\n        .long krn_stk1,0x10\n        .long 0,0,0,0,0\n        .long task1,0x200\n        .long 0,0,0,0\n        .long usr_stk1,0,0,0\n        .long 0x17,0x0f,0x17,0x17,0x17,0x17\n        .long LDT1_SEL,0x8000000\n\n        .fill 128,4,0\nkrn_stk1:\n\n\ntask0:\n    movl $0x17,%eax\n    movw %ax,%ds\n    mov $65,%al\n    int $0x80\n    movl $0xfff,%ecx\n1:  loop 1b\n    jmp task0\ntask1:\n    mov $66,%al\n    int $0x80\n    movl $0xfff,%ecx\n1:  loop 1b\n    jmp task1\n\n    .fill 128,4,0\nusr_stk1:\n</code></pre>\n<p>上面的这个程序内容不再详述，想了解细节请参考 《Linux 内核完全注释》</p>\n<p>下面提供编译 <code>boot.s</code> 以及 <code>head.s</code> 的可用 Makefile</p>\n<p>首先描述一下额外的工具版本</p>\n<ul>\n<li>GNU as : GNU assembler version 2.26.1</li>\n<li>GNU ld : GNU ld 2.26.1\n其它内容详见 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">理解 Linux Kernel (0)</a></li>\n</ul>\n<pre><code class="hljs"><span class="hljs-comment"># Makefile for the simple example kernel.</span>\nAS86\t=as86 -0 -a\nLD86\t=ld86 -0\nAS\t=as\nASFLAGS =-32\nLD\t=ld\nLDFLAGS\t=-s -x -M -m elf_i386 -e startup_32 -Ttext 0x0\n\n<span class="hljs-section">all:\tImage</span>\n\n<span class="hljs-section">Image: boot system</span>\n\tdd bs=32 if=boot of=Image skip=1\n\tdd bs=512 if=system of=Image skip=8 seek=1\n\tsync\n\n<span class="hljs-section">disk: Image</span>\n\tdd bs=8192 if=Image of=/dev/fd0\n\tsync;sync;sync\n\n<span class="hljs-section">head.o: </span>\n\t<span class="hljs-variable">$(AS)</span> <span class="hljs-variable">$(ASFLAGS)</span> -o head.o head.s\n\n<span class="hljs-section">system:\thead.o </span>\n\t<span class="hljs-variable">$(LD)</span> <span class="hljs-variable">$(LDFLAGS)</span> head.o  -o system &gt; System.map\n\n<span class="hljs-section">boot:\tboot.s</span>\n\t<span class="hljs-variable">$(AS86)</span> -o boot.o boot.s\n\t<span class="hljs-variable">$(LD86)</span> -s -o boot boot.o\n\n<span class="hljs-section">clean:</span>\n\trm -f Image System.map core boot *.o system</code></pre><h2>运行结果</h2>\n<p>想了解更多细节的请自行实操查看吧!</p>\n<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fun1fvafhwg30k40d4x6p.gif" alt=""></p>\n<h2>附件</h2>\n<p><a href="https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/understand-kernel-2.zip">程序源码</a></p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-08-26-understand-Kernel-2.json",ext:".json",sourceBase:"2018-08-26-understand-Kernel-2.md",sourceExt:".md"}},BQvL:function(n){n.exports={title:"ASM-VerifyError错误信息解决",author:"fangfeng",date:"2018-06-28T00:00:00.000Z",tag:["ASM","Java","CGlib"],bodyContent:"## 报错信息\n\n```java\njava.lang.VerifyError: class net.sf.cglib.core.DebuggingClassWriter overrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V\n```\n\n\x3c!-- more --\x3e\n\n## 背景\n\n项目依赖的 \n - CGlib 版本是 2.2.2\n - ASM 版本是 3.3.1\n\n## 问题定位\n\n前两天刚粗略通读了 ASM ，结果就遇上这样一个问题。\n\n从 `net.sf.cglib.core.DebuggingClassWriter` 看，这是 CGlib 的一个实现类\n\n从描述 `overrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V` \n以及 DebuggingClassWriter 类的字节码反编译结果\n\n```java\npublic class DebuggingClassWriter extends ClassWriter {\n    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n        this.className = name.replace('/', '.');\n        this.superName = superName.replace('/', '.');\n        super.visit(version, access, name, signature, superName, interfaces);\n    }\n}\n```\n\n至少应该是 visit(...) 方法要重载的父类的被声明为 final 的 ClassWriter.visit(...) 才导致的问题。\n\n但是从 ASM 3.3.1 版本的 ClassWriter 类可以看到\n\n```java\n    public void visit(int var1, int var2, String var3, String var4, String var5, String[] var6) {\n        ...\n    }\n```\n\nvisit 方法并没有被声明为 final 。\n\n但是，结合一定的背景知识，ASM 项目在加入了 OW2 组织后的新版本(asm-3.3.1 是未加入 OW2 前的最后一个版本)， \nClassWriter 类的所有 visitXxx(...) 方法都被添加了 `final` 限制。\n\n因此，怀疑是项目实际依赖了高版本的 asm (asm 4.x 及以上)\n\n## 解决\n\n经过确认，由于整个项目依赖关系复杂，有其它项目引入了 asm-4.1.jar。\n而且由于使用 MAVEN 进行项目依赖管理，asm-4.1.jar 与依赖树根的深度更浅，\n因此，最终打包的 war 里面确实引入了 asm-4.1.jar 。导致了这个问题。\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```",bodyHtml:'<h2>报错信息</h2>\n<pre><code class="hljs">java.lang.VerifyError: <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">net</span>.<span class="hljs-title">sf</span>.<span class="hljs-title">cglib</span>.<span class="hljs-title">core</span>.<span class="hljs-title">DebuggingClassWriter</span> <span class="hljs-title">overrides</span> <span class="hljs-title">final</span> <span class="hljs-title">method</span> <span class="hljs-title">visit</span>.(<span class="hljs-title">IILjava</span>/<span class="hljs-title">lang</span>/<span class="hljs-title">String</span></span>;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V</code></pre><p>&lt;!-- more --&gt;</p>\n<h2>背景</h2>\n<p>项目依赖的</p>\n<ul>\n<li>CGlib 版本是 2.2.2</li>\n<li>ASM 版本是 3.3.1</li>\n</ul>\n<h2>问题定位</h2>\n<p>前两天刚粗略通读了 ASM ，结果就遇上这样一个问题。</p>\n<p>从 <code>net.sf.cglib.core.DebuggingClassWriter</code> 看，这是 CGlib 的一个实现类</p>\n<p>从描述 <code>overrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V</code>\n以及 DebuggingClassWriter 类的字节码反编译结果</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebuggingClassWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassWriter</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> version, <span class="hljs-keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>{\n        <span class="hljs-keyword">this</span>.className = name.replace(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'.\'</span>);\n        <span class="hljs-keyword">this</span>.superName = superName.replace(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'.\'</span>);\n        <span class="hljs-keyword">super</span>.visit(version, access, name, signature, superName, interfaces);\n    }\n}</code></pre><p>至少应该是 visit(...) 方法要重载的父类的被声明为 final 的 ClassWriter.visit(...) 才导致的问题。</p>\n<p>但是从 ASM 3.3.1 版本的 ClassWriter 类可以看到</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1, <span class="hljs-keyword">int</span> var2, String var3, String var4, String var5, String[] var6)</span> </span>{\n        ...\n    }</code></pre><p>visit 方法并没有被声明为 final 。</p>\n<p>但是，结合一定的背景知识，ASM 项目在加入了 OW2 组织后的新版本(asm-3.3.1 是未加入 OW2 前的最后一个版本)，\nClassWriter 类的所有 visitXxx(...) 方法都被添加了 <code>final</code> 限制。</p>\n<p>因此，怀疑是项目实际依赖了高版本的 asm (asm 4.x 及以上)</p>\n<h2>解决</h2>\n<p>经过确认，由于整个项目依赖关系复杂，有其它项目引入了 asm-4.1.jar。\n而且由于使用 MAVEN 进行项目依赖管理，asm-4.1.jar 与依赖树根的深度更浅，\n因此，最终打包的 war 里面确实引入了 asm-4.1.jar 。导致了这个问题。</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-06-28-ASM-VerifyError.json",ext:".json",sourceBase:"2018-06-28-ASM-VerifyError.md",sourceExt:".md"}},BX5X:function(n){n.exports={title:"理解 Linux Kernel (4) - 任务调度",author:"fangfeng",tags:["Kernel","Linux","time interrupt"],bodyContent:'前面几节已经描述过，对于单核 CPU 来说。CPU 就处于不断地执行指令的过程(或者通过 `hlt` 指令直接停止工作)。\n\n针对于每一个程序来说，这个程序执行流程是通过 CPU 中几组寄存器(通用寄存器、段寄存器、控制寄存器等) 和存储在内存中的代码和数据协作完成的。\n\n如果要达到单核多任务的目的，首先要做的就是完成对几组寄存器中当前值的保存(我称之为保存现场)。而对于内存来说，多个任务的代码、数据同时存在内存是完全合理且可行的。毕竟相较于有限的寄存器，内存实在是太大了(相对而言)。\n\n\x3c!-- more --\x3e\n\n## 任务调度的宏观描述\n\n从宏观上来说，操作系统维护了若干个任务(假设有 0, 1, 5, 6)。\n\n下面以一个假象的例子来对任务调度做一些形象的说明:\n\n1. 假设当前任务是任务 5 ，操作系统分配给它的 CPU 使用时间是 30ms。\n\n2. 每 10ms 计时器(Intel 8253, 可编程计数器/定时器) 向 CPU 发起一个时钟中断。\n\n3. CPU 开始处理时钟中断(此时是**内核态**)。当前任务剩余可用时间 -10ms。\n\n4. 检查当前任务的剩余时间片，有剩余 -> 步骤 5 ; 否则 -> 步骤 6 \n\n5. 直接退出对时钟中断的处理函数(回到 **用户态**), 重复步骤 1 \n\n6. 根据每个任务的优先级及其它一些因素确定把接下来的一段时间分配给哪个任务。(假设分配给任务 6 ，30ms 的 CPU 使用时间) -> 重复步骤 2 。\n\n当然，上面的描述中忽略了很多的因素。\n\n## 任务调度准备阶段\n\n这里都将以 Linux 0.11 版本代码作为实例。当然，其中一些代码为了适应现在的 GCC 做了一些修改，另外还可能直接摆出 GCC 编译后的汇编代码来解释说明。\n\n首先，内核代码在经过一系列的准备流程(包括设置一些寄存器以及在内存中暂存某些值，读取计算机的硬件配置等)。真正开始出现任务 0 始于下列这段代码:\n\n```c\n/* 来自 Linux0.11 init/main.c */\nvoid main(void)\t\n{\n    ...\n\n\tsched_init();       /* schedule, 顾名思义就是时间安排咯 */\n    \n    ...\n\tsti();\n\tmove_to_user_mode();\n\tif (!fork()) {\t\n\t\tinit();\n\t}\n\tfor(;;) pause();\n}\n```\n\n在操作系统的主函数中，开始对任务调度进行一定的准备工作。看看具体代码吧\n\n```c\n/* 这里给出的是 Linux0.11 kernel/sched.c 经过预编译的函数(里面有一些内联汇编) */\nvoid sched_init(void)\n{\n    int i;\n    struct desc_struct * p;    /* 声明一个描述符指针 */\n\n    if (sizeof(struct sigaction) != 16)\n        panic("Struct sigaction MUST be 16 bytes");\n    __asm__ (                           /* 这段是为了设置全局描述符表GDT的第4项，是一个 0 号任务(当前任务)的任务调用门*/\n            "movw $104,%1\\n\\t" \n            "movw %%ax,%2\\n\\t" \n            "rorl $16,%%eax\\n\\t" \n            "movb %%al,%3\\n\\t" \n            "movb $" "0x89" ",%4\\n\\t" \n            "movb $0x00,%5\\n\\t" \n            "movb %%ah,%6\\n\\t" \n            "rorl $16,%%eax" \n            ::"a" (&(init_task.task.tss)), "m" (*(((char *) (gdt+4)))), "m" (*(((char *) (gdt+4))+2)), "m" (*(((char *) (gdt+4))+4)), "m" (*(((char *) (gdt+4))+5)), "m" (*(((char *) (gdt+4))+6)), "m" (*(((char *) (gdt+4))+7)) \n            );\n    __asm__ (                           /* 这里设置全局描述符表的第5项，0号任务的局部描述符表基址选择符 */\n            "movw $104,%1\\n\\t" \n            "movw %%ax,%2\\n\\t" \n            "rorl $16,%%eax\\n\\t" \n            "movb %%al,%3\\n\\t" \n            "movb $" "0x82" ",%4\\n\\t" \n            "movb $0x00,%5\\n\\t" \n            "movb %%ah,%6\\n\\t" \n            "rorl $16,%%eax" \n            ::"a" (&(init_task.task.ldt)), "m" (*(((char *) (gdt+(4 +1))))), "m" (*(((char *) (gdt+(4 +1)))+2)), "m" (*(((char *) (gdt+(4 +1)))+4)), "m" (*(((char *) (gdt+(4 +1)))+5)), "m" (*(((char *) (gdt+(4 +1)))+6)), "m" (*(((char *) (gdt+(4 +1)))+7)) \n            );\n    p = gdt+2+4;        /* 描述符指针指向 GDT 第6项。因为前面已经占用了第4，5项。由内核占用了 0，1，2，3。*/\n    for(i=1;i<64;i++) {         /* 循环 63 次，这是 Linux0.11 最大支持 64 个任务同时存在。当前任务已经占了一个任务了*/\n        task[i] = ((void *) 0); /* 63个任务指针全部值为 NULL */\n        p->a=p->b=0;            /* GDT 累积 126 项(126 * 8 字节)全部置为 0 。每个任务占用 GDT 两项，一为任务门，一为局部描述符表选择符*/\n        p++;\n        p->a=p->b=0;\n        p++;\n    }\n\n    __asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl");\n    __asm__("ltr %%ax"::"a" (((((unsigned long) 0)<<4)+(4<<3))));           /* load Task Register TR 记录当前任务门为 gdt 第4项 */\n    __asm__("lldt %%ax"::"a" (((((unsigned long) 0)<<4)+((4 +1)<<3))));     /* load Local Descriptor Table Register LDTR 记录当前选择符为 gdt 第5项 */\n    /* 给8253芯片编程，每 10ms 发起一次时钟中断(下面3行的工作) */\n    __asm__ ("outb %%al,%%dx\\n" "\\tjmp 1f\\n" "1:\\tjmp 1f\\n" "1:"::"a" (0x36),"d" (0x43));   \n    __asm__ ("outb %%al,%%dx\\n" "\\tjmp 1f\\n" "1:\\tjmp 1f\\n" "1:"::"a" ((1193180/100) & 0xff),"d" (0x40));\n    __asm__ ("outb %%al,%%dx"::"a" ((1193180/100) >> 8),"d" (0x40));\n    __asm__ ("movw %%dx,%%ax\\n\\t" "movw %0,%%dx\\n\\t" "movl %%eax,%1\\n\\t" "movl %%edx,%2" : : "i" ((short) (0x8000+(0<<13)+(14<<8))), "o" (*((char *) (&idt[0x20]))), "o" (*(4+(char *) (&idt[0x20]))), "d" ((char *) (&timer_interrupt)),"a" (0x00080000)); /* 在 IDT 中设置时钟中断描述符项，第32项为时钟中断*/\n    __asm__ ("outb %%al,%%dx"::"a" (({ unsigned char _v; __asm__ volatile ("inb %%dx,%%al\\n" "\\tjmp 1f\\n" "1:\\tjmp 1f\\n" "1:":"=a" (_v):"d" (0x21)); _v; })&~0x01),"d" (0x21)); /*重新设置时钟中断的可屏蔽属性，这样就可在调用 hlt 后被时钟中断唤醒 */\n    __asm__ ("movw %%dx,%%ax\\n\\t" "movw %0,%%dx\\n\\t" "movl %%eax,%1\\n\\t" "movl %%edx,%2" : : "i" ((short) (0x8000+(3<<13)+(15<<8))), "o" (*((char *) (&idt[0x80]))), "o" (*(4+(char *) (&idt[0x80]))), "d" ((char *) (&system_call)),"a" (0x00080000)); /* 在 IDT 中设置系统中断，第128项为时钟中断 */\n}\n```\n\n通过执行 `sched_init()` ，操作系统开始有了任务的概念。并且把当前任务作为任务 0 来加以认识。\n\n同时，预置了 64 个任务状态数组，用来辅助任务调度器完成未来调度任务时确认目前所有任务的基础性支持。\n\n最重要的，当然是对 8253 芯片的编程，使其每 10ms 向 CPU 发起一个硬件时钟中断。由此将把系统暂时性的带入**内核态** 来完成 CPU 下一个 10ms 需要进行的任务的决策工作。\n\n最后的设置时钟中断描述符和系统中断描述符自不用说。不设置的话，对于接收到的中断根本就没办法确认处理中断的代码在哪(毕竟中断处理逻辑也是由 CPU 执行指令来解决的)\n\n## 任务调度实施阶段\n\n由于时钟中断是由硬件芯片进行控制，根本不会顾及当前 CPU 正在执行的任务已经执行到了哪个指令 (哈哈，这不得是当然的嘛，不然要任务调度做什么，所有任务流水线作业得了)。\n\n因此，下面的描述将借着一次时钟中断，来看一下整一个任务调度操作。\n\n### 定位时钟中断处理逻辑\n\nIntel 8253芯片发起时钟中断之后，CPU 立即开始处理该中断\n\n1. 通过 IDTR 芯片查找中断描述符表(IDT, 最多256项，每项8字节) 的基址。\n\n2. 结合中断号作为偏移量，定位表中某一项具体的中断描述符 (时钟中断是0x20，因此偏移就是 0x20 * 8 = 256)\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fw51zkvo2nj313q0mm3z3.jpg)\n<small>Copied from Intel® 64 and IA-32 Architectures Software Developer’s Manual</small>\n\n3. 每一个中断描述符项都将是任务门，中断门，陷阱门三类中的一类，其所占用的 8 字节数据将按如下的形式进行存储\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fw527o8903j314614ita0.jpg)\n<small>Copied from Intel® 64 and IA-32 Architectures Software Developer’s Manual</small>\n\n4. 时钟中断是一种中断门，可以看到低 0~15 位和高 48~63 位共同组成了段内偏移量，而低16~31位组成了一个段选择符(可以去 GDT 找到相应的段)。\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fw52a4jbe0j31440zeq3j.jpg)\n<small>Copied from Intel® 64 and IA-32 Architectures Software Developer’s Manual</small>\n\n5. 至此，我们就可以定位到处理时钟中断的代码究竟在呢。之后也就是普通的 CPU 继续执行指令的过程(当然，需要注意，这个时候需要注意当前段选择符所表示的 DPL=0 ，即已经进入了内核态)\n\n### 模板式的保存现场 timer\\_interrupt\n\n在上一小节第 5 步定位时钟中断的代码时，由于发生了特权级的切换，因此中断处理流程会自动地在新的栈(这里指处理时钟中断使用的内核栈)中保存原来任务的信息，依次入新栈的数据有原任务的 SS, ESP, EFLAGS, CS, EIP, (Error Code) 。\n\n然后将正式进入到 IDT 定位的时钟中断处理逻辑的开始位置 (当然了，到这里也还是在保存现场。毕竟还有好多寄存器的数据要保存的)\n\n```assembly\n.align 4\n_timer_interrupt:\n\tpush %ds\t\t# save ds,es and put kernel data space\n\tpush %es\t\t# into them. %fs is used by _system_call\n\tpush %fs\n\tpushl %edx\t\t# we save %eax,%ecx,%edx as gcc doesn\'t\n\tpushl %ecx\t\t# save those across function calls. %ebx\n\tpushl %ebx\t\t# is saved as we use that in ret_sys_call\n\tpushl %eax\n\tmovl $0x10,%eax # 0x10 是内核数据段选择符，即 GDT 第二项\n\tmov %ax,%ds\n\tmov %ax,%es\n\tmovl $0x17,%eax # 0x17 是当前任务数据段选择符，LDT 第二项 (区分选择符是使用 GDT or LDT ，看 val & 0x4 的结果，如果为 1 使用 LDT，否则 GDT\n\tmov %ax,%fs\n\tincl _jiffies   # 反正每次时钟中断 +1 ，想不到合适的中文翻译\n\tmovb $0x20,%al\t\t# EOI to interrupt controller #1 发送指令请求硬件结束这次时钟中断的报告\n\toutb %al,$0x20\n\tmovl CS(%esp),%eax  # 这个 CS 是个常量，取出内核栈暂存的原来正在执行的任务的代码段选择符\n\tandl $3,%eax\t\t# %eax is CPL (0 or 3, 0=supervisor)    判断一下在中断开始前代码的特权级 0 是内核态，3 是用户态\n\tpushl %eax\n\tcall _do_timer\t\t# 调用 do_timer(long CPL) 。真正的处理时钟中断\n\taddl $4,%esp\t\t# task switching to accounting ...\n\tjmp ret_from_sys_call\n```\n\n### 任务调度 do\\_timer\n\n```c\nvoid do_timer(long cpl)     /* 这个 cpl 是上一小节获取的原任务正在执行的指令的特权级 */\n{\n    extern int beepcount;       /* 扬声器发声计数 */\n    extern void sysbeepstop(void);  /* 关闭扬声器的函数声明 */\n\n    if (beepcount)              /* 这段逻辑作用很不清晰，可能是富有年代感的产物 */\n        if (!--beepcount)\n            sysbeepstop();\n\n    if (cpl)                    /* 判断特权级 然后给当前任务的用户态/内核态用时计数 */\n        current->utime++;\n    else\n        current->stime++;\n\n    /* 这段逻辑是给操作系统定时任务用的，用兴趣的欢迎自己学习 */\n    if (next_timer) {\n        next_timer->jiffies--;\n        while (next_timer && next_timer->jiffies <= 0) {\n            void (*fn)(void);\n\n            fn = next_timer->fn;\n            next_timer->fn = ((void *) 0);\n            next_timer = next_timer->next;\n            (fn)();\n        }\n    }\n    if (current_DOR & 0xf0)\n        do_floppy_timer();\n    if ((--current->counter)>0) return;     /* 分配给当前任务的时间片 -1 。如果不为0，那么直接退出时钟中断，让任务继续执行 */\n    current->counter=0;     /* 否则，当前任务的时间片记为 0 */\n    if (!cpl) return;       /* 如果当前任务正处于内核态(比如用户程序中使用了一些系统调用)，那么先让这个任务继续执行，避免任务切换引起的麻烦 */\n    schedule();             /* 任务调用，决定下一个时间片的主人 */\n}\n```\n\n### 任务调度 schedule()\n\nschedule() 就开始对 CPU 之后要把时间片分配给哪个任务做一次决策了。\n\n但是，在开始之前，我们有必要先了解一下结构体 task\\_struct \n\n```c\nstruct task_struct {\n\tlong state;\t/* -1 unrunnable, 0 runnable, >0 stopped */\n\tlong counter;\n\tlong priority;\n\tlong signal;\n\tstruct sigaction sigaction[32];\n\tlong blocked;\t/* bitmap of masked signals */\n/* various fields */\n\tint exit_code;\n\tunsigned long start_code,end_code,end_data,brk,start_stack;\n\tlong pid,father,pgrp,session,leader;\n\tunsigned short uid,euid,suid;\n\tunsigned short gid,egid,sgid;\n\tlong alarm;\n\tlong utime,stime,cutime,cstime,start_time;\n\tunsigned short used_math;\n/* file system info */\n\tint tty;\t\t/* -1 if no tty, so it must be signed */\n\tunsigned short umask;\n\tstruct m_inode * pwd;\n\tstruct m_inode * root;\n\tstruct m_inode * executable;\n\tunsigned long close_on_exec;\n\tstruct file * filp[NR_OPEN];\n/* ldt for this task 0 - zero 1 - cs 2 - ds&ss */\n\tstruct desc_struct ldt[3];\n/* tss for this task */\n\tstruct tss_struct tss;\n};\n```\n\n匆匆一瞥，不过是不是觉得有些变量名还是很熟悉的，比如说 priority, utime, uid, eid, gid 等等。\n但是暂时还用不上这么多。只要有个概念就好。操作系统通过上述这些值共同维护起了一个任务的方方面面的信息。\n\n其中，需要再次注意的是，Linux0.11 版本最多只支持 64 个任务 (这是硬编码决定的上限，因为这个 task\\_struct 结构实例只声明了 64 个)\n\n```c\n/*\n *  \'schedule()\' is the scheduler function. This is GOOD CODE! There\n * probably won\'t be any reason to change this, as it should work well\n * in all circumstances (ie gives IO-bound processes good response etc).\n * The one thing you might take a look at is the signal-handler code here.\n *\n *   NOTE!!  Task 0 is the \'idle\' task, which gets called when no other\n * tasks can run. It can not be killed, and it cannot sleep. The \'state\'\n * information in task[0] is never used.\n */\nvoid schedule(void)\n{\n\tint i,next,c;\n\tstruct task_struct ** p;\n\n/* check alarm, wake up any interruptible tasks that have got a signal */\n/* 检测 alarm (任务定时报警信号)，并唤醒可中断的任务来完成预定义的工作, 好像自己用得少，还不太了解 alarm(xxx) 的细节\n * 从任务 63 号开始(总共 64 个任务, 0~63) ，倒着遍历所有任务，检测 alarm \n */\n\tfor(p = &LAST_TASK ; p > &FIRST_TASK ; --p)\n\t\tif (*p) {\n\t\t\tif ((*p)->alarm && (*p)->alarm < jiffies) {\n\t\t\t\t\t(*p)->signal |= (1<<(SIGALRM-1));\n\t\t\t\t\t(*p)->alarm = 0;\n\t\t\t\t}\n\t\t\tif (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&\n\t\t\t(*p)->state==TASK_INTERRUPTIBLE)\n\t\t\t\t(*p)->state=TASK_RUNNING;\n\t\t}\n\n/* this is the scheduler proper: */\n\n\twhile (1) {\n\t\tc = -1;\n\t\tnext = 0;\n\t\ti = NR_TASKS;   /* 这里的宏 NR_TASKS = 64 */\n\t\tp = &task[NR_TASKS];\n\t\twhile (--i) {\n\t\t\tif (!*--p)\n\t\t\t\tcontinue;\n            /* 选择任务状态为 就绪态，且 counter 值最大的任务号作为下一个占用 CPU 的任务\n\t\t\tif ((*p)->state == TASK_RUNNING && (*p)->counter > c) \n\t\t\t\tc = (*p)->counter, next = i;\n\t\t}\n        /* 如果没有其它任务，那么 next = 0 ，即接下来占用 cpu 的任务就是 0号任务(0号任务一定存在，不能被 kill ) */\n\t\tif (c) break;\n        /* 如果 1~63 号任务(不存在或不在就绪态)至少存在一个任务，且时间片都为 0 ，那么重新计算分配给每个任务的 counter 值 */\n\t\tfor(p = &LAST_TASK ; p > &FIRST_TASK ; --p)\n\t\t\tif (*p)\n\t\t\t\t(*p)->counter = ((*p)->counter >> 1) + (*p)->priority;\n\t}\n    /* 将当前任务切换为 next ，然后就可以一切就绪，退出时钟中断，就变成新的占用cpu的任务来执行了 */\n\tswitch_to(next);\n}\n```\n\n**switch\\_to(next)**\n\nswitch\\_to(next) 这个函数，是通过内嵌汇编写的。下面我们来看看细节(这里选用 GCC 编译出来的汇编指令，不直接使用内嵌汇编)\n\n```assembly\n# 这里的汇编指令紧跟在 if(c) break; 之后\n.L36:\n\tmovl\t%ebx, %edx          # 这里 ebx 存储的是 next 变量的值，现在复制到 edx 上\n\tsall\t$4, %edx            # sall、addl 两行的目的是计算得到一个 TSS 选择符，TSS0 在 GDT 是第4项，TSS1 在 GDT 是第 6 项，类推...其中选择符后3位为DPL和 GDTR/LDTR 选项\n\taddl\t$32, %edx\n\tmovl\t_task(,%ebx,4), %ecx    # 找到 next 号任务的 task_struct 的指针 (存储在 task[64] 的数组中)\n#APP\n# 141 "sched.c" 1\n\tcmpl %ecx,_current          # 确认是不是原任务\n\tje 1f                       # 是的话直接跳出 (跳到最近的标签 1 )\n\tmovw %dx,8(%esp)\n\txchgl %ecx,_current         # 交换 ecx 和 _current 存储的值\n\tljmp 4(%esp)                # 通过间接跳转完成任务切换。通用的形式是 jmp CS:IP，但是使用间接跳转，在内存中的值先读取 32 位偏移量，再读 16 位段选择符\n\tcmpl %ecx,_last_task_used_math\n\tjne 1f\n\tclts                        # 清除 CR0 寄存器中的 TS Flag \n1:\n# 0 "" 2\n#NO_AP\n```\n\n上面这段程序有必要将它割裂成两部分来看待，以 `ljmp 4(%esp)` 为界。\n\n`jmp` ，这是一个相当明显的程序跳转。这里 jmp 给出的选择符是 GDT 上某个任务的 TSS 描述符\n\n通过 `jmp` CPU 将完成老的任务所有寄存器的保存现场，以及新的任务所有寄存器暂存结果的载入。\n\nCPU 执行的下一条指令，将是新的任务 CS:EIP 所指明的指令。\n\n相应的，`ljmp` 之后的指令将在该任务重新获得占用 CPU 后获得执行。\n\n## 任务调度的结束阶段\n\n这段就比较绕了，现在假设一个前提，就是任务 A 也是在时钟中断重新进行任务调度的时候被替换掉的，现在 CPU 分配的时间片又轮到了任务 A 。\n\n也就是紧随着上一小节 `ljmp` 看看从任务内核态回到用户态的流程。\n\n```asm\n    # 这段与上面一段指令是直接承接的\n\tmovl\t12(%esp), %eax\n\txorl\t%gs:20, %eax\n\tje\t.L40\n\tcall\t___stack_chk_fail\n.L40:\n\taddl\t$24, %esp           # 这里返还这次 call 额外申请的内核栈空间\n\t.cfi_def_cfa_offset 8\n\tpopl\t%ebx                # 恢复进入 call 的时候暂存的 ebx\n\t.cfi_restore 3\n\t.cfi_def_cfa_offset 4\n\tret                         # return 跳转回到当初调用的地方\n\t.cfi_endproc\n```\n\n还是从汇编指令来看\n\n```asm\n\tcall\t_schedule           # 原先调用 schedule() 的地方\n.L93:\n    # return 跳转回来，直接承接的指令\n\taddl\t$8, %esp\n\t.cfi_def_cfa_offset 8\n\tpopl\t%ebx\n\t.cfi_restore 3\n\t.cfi_def_cfa_offset 4\n\tret                         # 继续 return ，跳出 do_timer() \n\t.cfi_endproc\n```\n\n```asm\n    call _do_timer\t\t# \'do_timer(long CPL)\' does everything from\n\taddl $4,%esp\t\t# task switching to accounting ...\n\tjmp ret_from_sys_call\n```\n\n**ret\\_from\\_sys\\_call**\n\n这里就打算正式结束由于这次时钟中断所引发的内核态指令执行的流程，正式回归用户态了。\n\n```asm\nret_from_sys_call:\n    # 这 3 行来判断是不是任务0，如果是就不进行信号量的处理了\n\tmovl _current,%eax\t\t# task[0] cannot have signals\n\tcmpl _task,%eax\n\tje 3f\n    # 判断在发生时钟中断前，CS 表示的是不是 LDT 第 1 项 (局部变量表的代码段)\n    # 否则 CS 就应该内核态代码段了，不进行信号量处理\n\tcmpw $0x0f,CS(%esp)\t\t# was old code segment supervisor ?\n\tjne 3f\n    # 判断在发生时钟中断前，SS 表示的是不是 LDT 第 2 项 (局部变量表的数据段)\n    # 否则认为程序还处在内核态，不进行信号量处理\n\tcmpw $0x17,OLDSS(%esp)\t\t# was stack segment = 0x17 ?\n\tjne 3f\n    # 设置信号量 (不清楚，先挖个坑)\n\tmovl signal(%eax),%ebx\n\tmovl blocked(%eax),%ecx\n\tnotl %ecx\n\tandl %ebx,%ecx\n\tbsfl %ecx,%ecx\n\tje 3f\n\tbtrl %ecx,%ebx\n\tmovl %ebx,signal(%eax)\n\tincl %ecx\n\tpushl %ecx\n\tcall _do_signal\n\tpopl %eax\n3:\tpopl %eax\n\tpopl %ebx\n\tpopl %ecx\n\tpopl %edx\n\tpop %fs\n\tpop %es\n\tpop %ds\n\tiret\n```\n\n至此，通过 iret 将跳转回到用户态代码被中断的位置，并继续执行\n\n## 补充\n\n### pause() \n\n[Linux Kernel(3) - 操作系统启动](https://dormouse-none.github.io/2018-10-06-understand-Kernel-3/) 中，描述过任务0在完成了整个操作系统的启动流程之后，唯一在做的事情，就是调用 `for(;;) pause();` \n\nCPU 每次把时间片分配给它，它就开始浪费权力，直接不要了这个时间片。\n\n之前一直以为 pause() 会选择执行 `HLT` 指令让 CPU 暂时地陷入停止状态。但是出乎意料，并不是这个结果(当然，最终是不是还是另一个说法。毕竟代码都是人写的，每个人都可以各自有一套实现)。\n\n当 CPU 把执行指令的权力交个任务 0 时，选择让 CPU 停止，直到接收到硬件中断为止也不失为一种选择。当然，不论其它，Linux0.11版本的代码不是这样的。\n\n通过 `INT 0x80` 配合系统调用函数查表，最后定位到的就是 sys\\_pause() 了\n```\n_sys_pause:\n.LFB13:\n\t.cfi_startproc\n\tsubl\t$12, %esp\n\t.cfi_def_cfa_offset 16\n\tmovl\t_current, %eax\n\tmovl\t$1, (%eax)\n\tcall\t_schedule       # 调用 schedule() 重新划分时间片\n\tmovl\t$0, %eax\n\taddl\t$12, %esp\n\t.cfi_def_cfa_offset 4\n\tret\n\t.cfi_endproc\n```\n\n### timer 定时器\n\n之前在 `do_timer()` 函数中也看过了每次时钟中断，都会检查一遍定时器，并决定是否触发预置的定时器处理函数。\n\n当然了，既然是触发定时器，总是要有一个前提——设置定时器\n\n```c\nvoid add_timer(long jiffies, void (*fn)(void))\n{\n\tstruct timer_list * p;\n\n\tif (!fn)\n\t\treturn;\n\tcli();\n\tif (jiffies <= 0)\n\t\t(fn)();\n\telse {\n\t\tfor (p = timer_list ; p < timer_list + TIME_REQUESTS ; p++)\n\t\t\tif (!p->fn)\n\t\t\t\tbreak;\n\t\tif (p >= timer_list + TIME_REQUESTS)\n\t\t\tpanic("No more time requests free");\n\t\tp->fn = fn;\n\t\tp->jiffies = jiffies;\n\t\tp->next = next_timer;\n\t\tnext_timer = p;\n\t\twhile (p->next && p->next->jiffies < p->jiffies) {\n\t\t\tp->jiffies -= p->next->jiffies;\n\t\t\tfn = p->fn;\n\t\t\tp->fn = p->next->fn;\n\t\t\tp->next->fn = fn;\n\t\t\tjiffies = p->jiffies;\n\t\t\tp->jiffies = p->next->jiffies;\n\t\t\tp->next->jiffies = jiffies;\n\t\t\tp = p->next;\n\t\t}\n\t}\n\tsti();\n}\n```\n\n## 小结\n\n对于任务调度，更难的是对一个时间断层的理解。在调度过程中，旧任务被暂停，新的任务被重新启动, 直到旧的任务又被启动。这里就必须人为地将被中断的任务主动的连接起来看待。\n\n早期版本的任务调度模块确实比较简单，累计不过百行 C 代码。哈哈。一点一点继续来吧。\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<p>前面几节已经描述过，对于单核 CPU 来说。CPU 就处于不断地执行指令的过程(或者通过 <code>hlt</code> 指令直接停止工作)。</p>\n<p>针对于每一个程序来说，这个程序执行流程是通过 CPU 中几组寄存器(通用寄存器、段寄存器、控制寄存器等) 和存储在内存中的代码和数据协作完成的。</p>\n<p>如果要达到单核多任务的目的，首先要做的就是完成对几组寄存器中当前值的保存(我称之为保存现场)。而对于内存来说，多个任务的代码、数据同时存在内存是完全合理且可行的。毕竟相较于有限的寄存器，内存实在是太大了(相对而言)。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>任务调度的宏观描述</h2>\n<p>从宏观上来说，操作系统维护了若干个任务(假设有 0, 1, 5, 6)。</p>\n<p>下面以一个假象的例子来对任务调度做一些形象的说明:</p>\n<ol>\n<li>\n<p>假设当前任务是任务 5 ，操作系统分配给它的 CPU 使用时间是 30ms。</p>\n</li>\n<li>\n<p>每 10ms 计时器(Intel 8253, 可编程计数器/定时器) 向 CPU 发起一个时钟中断。</p>\n</li>\n<li>\n<p>CPU 开始处理时钟中断(此时是<strong>内核态</strong>)。当前任务剩余可用时间 -10ms。</p>\n</li>\n<li>\n<p>检查当前任务的剩余时间片，有剩余 -&gt; 步骤 5 ; 否则 -&gt; 步骤 6</p>\n</li>\n<li>\n<p>直接退出对时钟中断的处理函数(回到 <strong>用户态</strong>), 重复步骤 1</p>\n</li>\n<li>\n<p>根据每个任务的优先级及其它一些因素确定把接下来的一段时间分配给哪个任务。(假设分配给任务 6 ，30ms 的 CPU 使用时间) -&gt; 重复步骤 2 。</p>\n</li>\n</ol>\n<p>当然，上面的描述中忽略了很多的因素。</p>\n<h2>任务调度准备阶段</h2>\n<p>这里都将以 Linux 0.11 版本代码作为实例。当然，其中一些代码为了适应现在的 GCC 做了一些修改，另外还可能直接摆出 GCC 编译后的汇编代码来解释说明。</p>\n<p>首先，内核代码在经过一系列的准备流程(包括设置一些寄存器以及在内存中暂存某些值，读取计算机的硬件配置等)。真正开始出现任务 0 始于下列这段代码:</p>\n<pre><code class="hljs"><span class="hljs-comment">/* 来自 Linux0.11 init/main.c */</span>\n<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\t\n</span>{\n    ...\n\n\tsched_init();       <span class="hljs-comment">/* schedule, 顾名思义就是时间安排咯 */</span>\n    \n    ...\n\tsti();\n\tmove_to_user_mode();\n\t<span class="hljs-keyword">if</span> (!fork()) {\t\n\t\tinit();\n\t}\n\t<span class="hljs-keyword">for</span>(;;) pause();\n}</code></pre><p>在操作系统的主函数中，开始对任务调度进行一定的准备工作。看看具体代码吧</p>\n<pre><code class="hljs"><span class="hljs-comment">/* 这里给出的是 Linux0.11 kernel/sched.c 经过预编译的函数(里面有一些内联汇编) */</span>\n<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sched_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n    <span class="hljs-keyword">int</span> i;\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">desc_struct</span> * <span class="hljs-title">p</span>;</span>    <span class="hljs-comment">/* 声明一个描述符指针 */</span>\n\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sizeof</span>(struct sigaction) != <span class="hljs-number">16</span>)\n        panic(<span class="hljs-string">"Struct sigaction MUST be 16 bytes"</span>);\n    __asm__ (                           <span class="hljs-comment">/* 这段是为了设置全局描述符表GDT的第4项，是一个 0 号任务(当前任务)的任务调用门*/</span>\n            <span class="hljs-string">"movw $104,%1\\n\\t"</span> \n            <span class="hljs-string">"movw %%ax,%2\\n\\t"</span> \n            <span class="hljs-string">"rorl $16,%%eax\\n\\t"</span> \n            <span class="hljs-string">"movb %%al,%3\\n\\t"</span> \n            <span class="hljs-string">"movb $"</span> <span class="hljs-string">"0x89"</span> <span class="hljs-string">",%4\\n\\t"</span> \n            <span class="hljs-string">"movb $0x00,%5\\n\\t"</span> \n            <span class="hljs-string">"movb %%ah,%6\\n\\t"</span> \n            <span class="hljs-string">"rorl $16,%%eax"</span> \n            ::<span class="hljs-string">"a"</span> (&amp;(init_task.task.tss)), <span class="hljs-string">"m"</span> (*(((<span class="hljs-keyword">char</span> *) (gdt+<span class="hljs-number">4</span>)))), <span class="hljs-string">"m"</span> (*(((<span class="hljs-keyword">char</span> *) (gdt+<span class="hljs-number">4</span>))+<span class="hljs-number">2</span>)), <span class="hljs-string">"m"</span> (*(((<span class="hljs-keyword">char</span> *) (gdt+<span class="hljs-number">4</span>))+<span class="hljs-number">4</span>)), <span class="hljs-string">"m"</span> (*(((<span class="hljs-keyword">char</span> *) (gdt+<span class="hljs-number">4</span>))+<span class="hljs-number">5</span>)), <span class="hljs-string">"m"</span> (*(((<span class="hljs-keyword">char</span> *) (gdt+<span class="hljs-number">4</span>))+<span class="hljs-number">6</span>)), <span class="hljs-string">"m"</span> (*(((<span class="hljs-keyword">char</span> *) (gdt+<span class="hljs-number">4</span>))+<span class="hljs-number">7</span>)) \n            );\n    __asm__ (                           <span class="hljs-comment">/* 这里设置全局描述符表的第5项，0号任务的局部描述符表基址选择符 */</span>\n            <span class="hljs-string">"movw $104,%1\\n\\t"</span> \n            <span class="hljs-string">"movw %%ax,%2\\n\\t"</span> \n            <span class="hljs-string">"rorl $16,%%eax\\n\\t"</span> \n            <span class="hljs-string">"movb %%al,%3\\n\\t"</span> \n            <span class="hljs-string">"movb $"</span> <span class="hljs-string">"0x82"</span> <span class="hljs-string">",%4\\n\\t"</span> \n            <span class="hljs-string">"movb $0x00,%5\\n\\t"</span> \n            <span class="hljs-string">"movb %%ah,%6\\n\\t"</span> \n            <span class="hljs-string">"rorl $16,%%eax"</span> \n            ::<span class="hljs-string">"a"</span> (&amp;(init_task.task.ldt)), <span class="hljs-string">"m"</span> (*(((<span class="hljs-keyword">char</span> *) (gdt+(<span class="hljs-number">4</span> +<span class="hljs-number">1</span>))))), <span class="hljs-string">"m"</span> (*(((<span class="hljs-keyword">char</span> *) (gdt+(<span class="hljs-number">4</span> +<span class="hljs-number">1</span>)))+<span class="hljs-number">2</span>)), <span class="hljs-string">"m"</span> (*(((<span class="hljs-keyword">char</span> *) (gdt+(<span class="hljs-number">4</span> +<span class="hljs-number">1</span>)))+<span class="hljs-number">4</span>)), <span class="hljs-string">"m"</span> (*(((<span class="hljs-keyword">char</span> *) (gdt+(<span class="hljs-number">4</span> +<span class="hljs-number">1</span>)))+<span class="hljs-number">5</span>)), <span class="hljs-string">"m"</span> (*(((<span class="hljs-keyword">char</span> *) (gdt+(<span class="hljs-number">4</span> +<span class="hljs-number">1</span>)))+<span class="hljs-number">6</span>)), <span class="hljs-string">"m"</span> (*(((<span class="hljs-keyword">char</span> *) (gdt+(<span class="hljs-number">4</span> +<span class="hljs-number">1</span>)))+<span class="hljs-number">7</span>)) \n            );\n    p = gdt+<span class="hljs-number">2</span>+<span class="hljs-number">4</span>;        <span class="hljs-comment">/* 描述符指针指向 GDT 第6项。因为前面已经占用了第4，5项。由内核占用了 0，1，2，3。*/</span>\n    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">64</span>;i++) {         <span class="hljs-comment">/* 循环 63 次，这是 Linux0.11 最大支持 64 个任务同时存在。当前任务已经占了一个任务了*/</span>\n        task[i] = ((<span class="hljs-keyword">void</span> *) <span class="hljs-number">0</span>); <span class="hljs-comment">/* 63个任务指针全部值为 NULL */</span>\n        p-&gt;a=p-&gt;b=<span class="hljs-number">0</span>;            <span class="hljs-comment">/* GDT 累积 126 项(126 * 8 字节)全部置为 0 。每个任务占用 GDT 两项，一为任务门，一为局部描述符表选择符*/</span>\n        p++;\n        p-&gt;a=p-&gt;b=<span class="hljs-number">0</span>;\n        p++;\n    }\n\n    __asm__(<span class="hljs-string">"pushfl ; andl $0xffffbfff,(%esp) ; popfl"</span>);\n    __asm__(<span class="hljs-string">"ltr %%ax"</span>::<span class="hljs-string">"a"</span> (((((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) <span class="hljs-number">0</span>)&lt;&lt;<span class="hljs-number">4</span>)+(<span class="hljs-number">4</span>&lt;&lt;<span class="hljs-number">3</span>))));           <span class="hljs-comment">/* load Task Register TR 记录当前任务门为 gdt 第4项 */</span>\n    __asm__(<span class="hljs-string">"lldt %%ax"</span>::<span class="hljs-string">"a"</span> (((((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) <span class="hljs-number">0</span>)&lt;&lt;<span class="hljs-number">4</span>)+((<span class="hljs-number">4</span> +<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">3</span>))));     <span class="hljs-comment">/* load Local Descriptor Table Register LDTR 记录当前选择符为 gdt 第5项 */</span>\n    <span class="hljs-comment">/* 给8253芯片编程，每 10ms 发起一次时钟中断(下面3行的工作) */</span>\n    __asm__ (<span class="hljs-string">"outb %%al,%%dx\\n"</span> <span class="hljs-string">"\\tjmp 1f\\n"</span> <span class="hljs-string">"1:\\tjmp 1f\\n"</span> <span class="hljs-string">"1:"</span>::<span class="hljs-string">"a"</span> (<span class="hljs-number">0x36</span>),<span class="hljs-string">"d"</span> (<span class="hljs-number">0x43</span>));   \n    __asm__ (<span class="hljs-string">"outb %%al,%%dx\\n"</span> <span class="hljs-string">"\\tjmp 1f\\n"</span> <span class="hljs-string">"1:\\tjmp 1f\\n"</span> <span class="hljs-string">"1:"</span>::<span class="hljs-string">"a"</span> ((<span class="hljs-number">1193180</span>/<span class="hljs-number">100</span>) &amp; <span class="hljs-number">0xff</span>),<span class="hljs-string">"d"</span> (<span class="hljs-number">0x40</span>));\n    __asm__ (<span class="hljs-string">"outb %%al,%%dx"</span>::<span class="hljs-string">"a"</span> ((<span class="hljs-number">1193180</span>/<span class="hljs-number">100</span>) &gt;&gt; <span class="hljs-number">8</span>),<span class="hljs-string">"d"</span> (<span class="hljs-number">0x40</span>));\n    __asm__ (<span class="hljs-string">"movw %%dx,%%ax\\n\\t"</span> <span class="hljs-string">"movw %0,%%dx\\n\\t"</span> <span class="hljs-string">"movl %%eax,%1\\n\\t"</span> <span class="hljs-string">"movl %%edx,%2"</span> : : <span class="hljs-string">"i"</span> ((<span class="hljs-keyword">short</span>) (<span class="hljs-number">0x8000</span>+(<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">13</span>)+(<span class="hljs-number">14</span>&lt;&lt;<span class="hljs-number">8</span>))), <span class="hljs-string">"o"</span> (*((<span class="hljs-keyword">char</span> *) (&amp;idt[<span class="hljs-number">0x20</span>]))), <span class="hljs-string">"o"</span> (*(<span class="hljs-number">4</span>+(<span class="hljs-keyword">char</span> *) (&amp;idt[<span class="hljs-number">0x20</span>]))), <span class="hljs-string">"d"</span> ((<span class="hljs-keyword">char</span> *) (&amp;timer_interrupt)),<span class="hljs-string">"a"</span> (<span class="hljs-number">0x00080000</span>)); <span class="hljs-comment">/* 在 IDT 中设置时钟中断描述符项，第32项为时钟中断*/</span>\n    __asm__ (<span class="hljs-string">"outb %%al,%%dx"</span>::<span class="hljs-string">"a"</span> (({ <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> _v; __asm__ <span class="hljs-keyword">volatile</span> (<span class="hljs-string">"inb %%dx,%%al\\n"</span> <span class="hljs-string">"\\tjmp 1f\\n"</span> <span class="hljs-string">"1:\\tjmp 1f\\n"</span> <span class="hljs-string">"1:"</span>:<span class="hljs-string">"=a"</span> (_v):<span class="hljs-string">"d"</span> (<span class="hljs-number">0x21</span>)); _v; })&amp;~<span class="hljs-number">0x01</span>),<span class="hljs-string">"d"</span> (<span class="hljs-number">0x21</span>)); <span class="hljs-comment">/*重新设置时钟中断的可屏蔽属性，这样就可在调用 hlt 后被时钟中断唤醒 */</span>\n    __asm__ (<span class="hljs-string">"movw %%dx,%%ax\\n\\t"</span> <span class="hljs-string">"movw %0,%%dx\\n\\t"</span> <span class="hljs-string">"movl %%eax,%1\\n\\t"</span> <span class="hljs-string">"movl %%edx,%2"</span> : : <span class="hljs-string">"i"</span> ((<span class="hljs-keyword">short</span>) (<span class="hljs-number">0x8000</span>+(<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">13</span>)+(<span class="hljs-number">15</span>&lt;&lt;<span class="hljs-number">8</span>))), <span class="hljs-string">"o"</span> (*((<span class="hljs-keyword">char</span> *) (&amp;idt[<span class="hljs-number">0x80</span>]))), <span class="hljs-string">"o"</span> (*(<span class="hljs-number">4</span>+(<span class="hljs-keyword">char</span> *) (&amp;idt[<span class="hljs-number">0x80</span>]))), <span class="hljs-string">"d"</span> ((<span class="hljs-keyword">char</span> *) (&amp;system_call)),<span class="hljs-string">"a"</span> (<span class="hljs-number">0x00080000</span>)); <span class="hljs-comment">/* 在 IDT 中设置系统中断，第128项为时钟中断 */</span>\n}</code></pre><p>通过执行 <code>sched_init()</code> ，操作系统开始有了任务的概念。并且把当前任务作为任务 0 来加以认识。</p>\n<p>同时，预置了 64 个任务状态数组，用来辅助任务调度器完成未来调度任务时确认目前所有任务的基础性支持。</p>\n<p>最重要的，当然是对 8253 芯片的编程，使其每 10ms 向 CPU 发起一个硬件时钟中断。由此将把系统暂时性的带入<strong>内核态</strong> 来完成 CPU 下一个 10ms 需要进行的任务的决策工作。</p>\n<p>最后的设置时钟中断描述符和系统中断描述符自不用说。不设置的话，对于接收到的中断根本就没办法确认处理中断的代码在哪(毕竟中断处理逻辑也是由 CPU 执行指令来解决的)</p>\n<h2>任务调度实施阶段</h2>\n<p>由于时钟中断是由硬件芯片进行控制，根本不会顾及当前 CPU 正在执行的任务已经执行到了哪个指令 (哈哈，这不得是当然的嘛，不然要任务调度做什么，所有任务流水线作业得了)。</p>\n<p>因此，下面的描述将借着一次时钟中断，来看一下整一个任务调度操作。</p>\n<h3>定位时钟中断处理逻辑</h3>\n<p>Intel 8253芯片发起时钟中断之后，CPU 立即开始处理该中断</p>\n<ol>\n<li>\n<p>通过 IDTR 芯片查找中断描述符表(IDT, 最多256项，每项8字节) 的基址。</p>\n</li>\n<li>\n<p>结合中断号作为偏移量，定位表中某一项具体的中断描述符 (时钟中断是0x20，因此偏移就是 0x20 * 8 = 256)</p>\n</li>\n</ol>\n<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fw51zkvo2nj313q0mm3z3.jpg" alt="">\n&lt;small&gt;Copied from Intel® 64 and IA-32 Architectures Software Developer’s Manual&lt;/small&gt;</p>\n<ol start="3">\n<li>每一个中断描述符项都将是任务门，中断门，陷阱门三类中的一类，其所占用的 8 字节数据将按如下的形式进行存储</li>\n</ol>\n<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fw527o8903j314614ita0.jpg" alt="">\n&lt;small&gt;Copied from Intel® 64 and IA-32 Architectures Software Developer’s Manual&lt;/small&gt;</p>\n<ol start="4">\n<li>时钟中断是一种中断门，可以看到低 0~15 位和高 48~63 位共同组成了段内偏移量，而低16~31位组成了一个段选择符(可以去 GDT 找到相应的段)。</li>\n</ol>\n<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fw52a4jbe0j31440zeq3j.jpg" alt="">\n&lt;small&gt;Copied from Intel® 64 and IA-32 Architectures Software Developer’s Manual&lt;/small&gt;</p>\n<ol start="5">\n<li>至此，我们就可以定位到处理时钟中断的代码究竟在呢。之后也就是普通的 CPU 继续执行指令的过程(当然，需要注意，这个时候需要注意当前段选择符所表示的 DPL=0 ，即已经进入了内核态)</li>\n</ol>\n<h3>模板式的保存现场 timer_interrupt</h3>\n<p>在上一小节第 5 步定位时钟中断的代码时，由于发生了特权级的切换，因此中断处理流程会自动地在新的栈(这里指处理时钟中断使用的内核栈)中保存原来任务的信息，依次入新栈的数据有原任务的 SS, ESP, EFLAGS, CS, EIP, (Error Code) 。</p>\n<p>然后将正式进入到 IDT 定位的时钟中断处理逻辑的开始位置 (当然了，到这里也还是在保存现场。毕竟还有好多寄存器的数据要保存的)</p>\n<pre><code class="hljs">.align 4\n_timer_interrupt:\n\tpush %ds\t\t# save ds,es and put kernel data space\n\tpush %es\t\t# into them. %fs is used by _system_call\n\tpush %fs\n\tpushl %edx\t\t# we save %eax,%ecx,%edx as gcc doesn\'t\n\tpushl %ecx\t\t# save those across function calls. %ebx\n\tpushl %ebx\t\t# is saved as we use that in ret_sys_call\n\tpushl %eax\n\tmovl $0x10,%eax # 0x10 是内核数据段选择符，即 GDT 第二项\n\tmov %ax,%ds\n\tmov %ax,%es\n\tmovl $0x17,%eax # 0x17 是当前任务数据段选择符，LDT 第二项 (区分选择符是使用 GDT or LDT ，看 val &amp; 0x4 的结果，如果为 1 使用 LDT，否则 GDT\n\tmov %ax,%fs\n\tincl _jiffies   # 反正每次时钟中断 +1 ，想不到合适的中文翻译\n\tmovb $0x20,%al\t\t# EOI to interrupt controller #1 发送指令请求硬件结束这次时钟中断的报告\n\toutb %al,$0x20\n\tmovl CS(%esp),%eax  # 这个 CS 是个常量，取出内核栈暂存的原来正在执行的任务的代码段选择符\n\tandl $3,%eax\t\t# %eax is CPL (0 or 3, 0=supervisor)    判断一下在中断开始前代码的特权级 0 是内核态，3 是用户态\n\tpushl %eax\n\tcall _do_timer\t\t# 调用 do_timer(long CPL) 。真正的处理时钟中断\n\taddl $4,%esp\t\t# task switching to accounting ...\n\tjmp ret_from_sys_call</code></pre><h3>任务调度 do_timer</h3>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_timer</span><span class="hljs-params">(<span class="hljs-keyword">long</span> cpl)</span>     <span class="hljs-comment">/* 这个 cpl 是上一小节获取的原任务正在执行的指令的特权级 */</span>\n</span>{\n    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> beepcount;       <span class="hljs-comment">/* 扬声器发声计数 */</span>\n    <span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sysbeepstop</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;  <span class="hljs-comment">/* 关闭扬声器的函数声明 */</span>\n\n    <span class="hljs-keyword">if</span> (beepcount)              <span class="hljs-comment">/* 这段逻辑作用很不清晰，可能是富有年代感的产物 */</span>\n        <span class="hljs-keyword">if</span> (!--beepcount)\n            sysbeepstop();\n\n    <span class="hljs-keyword">if</span> (cpl)                    <span class="hljs-comment">/* 判断特权级 然后给当前任务的用户态/内核态用时计数 */</span>\n        current-&gt;utime++;\n    <span class="hljs-keyword">else</span>\n        current-&gt;stime++;\n\n    <span class="hljs-comment">/* 这段逻辑是给操作系统定时任务用的，用兴趣的欢迎自己学习 */</span>\n    <span class="hljs-keyword">if</span> (next_timer) {\n        next_timer-&gt;jiffies--;\n        <span class="hljs-keyword">while</span> (next_timer &amp;&amp; next_timer-&gt;jiffies &lt;= <span class="hljs-number">0</span>) {\n            <span class="hljs-keyword">void</span> (*fn)(<span class="hljs-keyword">void</span>);\n\n            fn = next_timer-&gt;fn;\n            next_timer-&gt;fn = ((<span class="hljs-keyword">void</span> *) <span class="hljs-number">0</span>);\n            next_timer = next_timer-&gt;next;\n            (fn)();\n        }\n    }\n    <span class="hljs-keyword">if</span> (current_DOR &amp; <span class="hljs-number">0xf0</span>)\n        do_floppy_timer();\n    <span class="hljs-keyword">if</span> ((--current-&gt;counter)&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;     <span class="hljs-comment">/* 分配给当前任务的时间片 -1 。如果不为0，那么直接退出时钟中断，让任务继续执行 */</span>\n    current-&gt;counter=<span class="hljs-number">0</span>;     <span class="hljs-comment">/* 否则，当前任务的时间片记为 0 */</span>\n    <span class="hljs-keyword">if</span> (!cpl) <span class="hljs-keyword">return</span>;       <span class="hljs-comment">/* 如果当前任务正处于内核态(比如用户程序中使用了一些系统调用)，那么先让这个任务继续执行，避免任务切换引起的麻烦 */</span>\n    schedule();             <span class="hljs-comment">/* 任务调用，决定下一个时间片的主人 */</span>\n}</code></pre><h3>任务调度 schedule()</h3>\n<p>schedule() 就开始对 CPU 之后要把时间片分配给哪个任务做一次决策了。</p>\n<p>但是，在开始之前，我们有必要先了解一下结构体 task_struct</p>\n<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> {</span>\n\t<span class="hljs-keyword">long</span> state;\t<span class="hljs-comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span>\n\t<span class="hljs-keyword">long</span> counter;\n\t<span class="hljs-keyword">long</span> priority;\n\t<span class="hljs-keyword">long</span> signal;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sigaction</span>[32];</span>\n\t<span class="hljs-keyword">long</span> blocked;\t<span class="hljs-comment">/* bitmap of masked signals */</span>\n<span class="hljs-comment">/* various fields */</span>\n\t<span class="hljs-keyword">int</span> exit_code;\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> start_code,end_code,end_data,brk,start_stack;\n\t<span class="hljs-keyword">long</span> pid,father,pgrp,session,leader;\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> uid,euid,suid;\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> gid,egid,sgid;\n\t<span class="hljs-keyword">long</span> alarm;\n\t<span class="hljs-keyword">long</span> utime,stime,cutime,cstime,start_time;\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> used_math;\n<span class="hljs-comment">/* file system info */</span>\n\t<span class="hljs-keyword">int</span> tty;\t\t<span class="hljs-comment">/* -1 if no tty, so it must be signed */</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> umask;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">pwd</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">root</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">executable</span>;</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> close_on_exec;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">filp</span>[<span class="hljs-title">NR_OPEN</span>];</span>\n<span class="hljs-comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">desc_struct</span> <span class="hljs-title">ldt</span>[3];</span>\n<span class="hljs-comment">/* tss for this task */</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss_struct</span> <span class="hljs-title">tss</span>;</span>\n};</code></pre><p>匆匆一瞥，不过是不是觉得有些变量名还是很熟悉的，比如说 priority, utime, uid, eid, gid 等等。\n但是暂时还用不上这么多。只要有个概念就好。操作系统通过上述这些值共同维护起了一个任务的方方面面的信息。</p>\n<p>其中，需要再次注意的是，Linux0.11 版本最多只支持 64 个任务 (这是硬编码决定的上限，因为这个 task_struct 结构实例只声明了 64 个)</p>\n<pre><code class="hljs"><span class="hljs-comment">/*\n *  \'schedule()\' is the scheduler function. This is GOOD CODE! There\n * probably won\'t be any reason to change this, as it should work well\n * in all circumstances (ie gives IO-bound processes good response etc).\n * The one thing you might take a look at is the signal-handler code here.\n *\n *   NOTE!!  Task 0 is the \'idle\' task, which gets called when no other\n * tasks can run. It can not be killed, and it cannot sleep. The \'state\'\n * information in task[0] is never used.\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n\t<span class="hljs-keyword">int</span> i,next,c;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> ** <span class="hljs-title">p</span>;</span>\n\n<span class="hljs-comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span>\n<span class="hljs-comment">/* 检测 alarm (任务定时报警信号)，并唤醒可中断的任务来完成预定义的工作, 好像自己用得少，还不太了解 alarm(xxx) 的细节\n * 从任务 63 号开始(总共 64 个任务, 0~63) ，倒着遍历所有任务，检测 alarm \n */</span>\n\t<span class="hljs-keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)\n\t\t<span class="hljs-keyword">if</span> (*p) {\n\t\t\t<span class="hljs-keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) {\n\t\t\t\t\t(*p)-&gt;signal |= (<span class="hljs-number">1</span>&lt;&lt;(SIGALRM<span class="hljs-number">-1</span>));\n\t\t\t\t\t(*p)-&gt;alarm = <span class="hljs-number">0</span>;\n\t\t\t\t}\n\t\t\t<span class="hljs-keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;\n\t\t\t(*p)-&gt;state==TASK_INTERRUPTIBLE)\n\t\t\t\t(*p)-&gt;state=TASK_RUNNING;\n\t\t}\n\n<span class="hljs-comment">/* this is the scheduler proper: */</span>\n\n\t<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {\n\t\tc = <span class="hljs-number">-1</span>;\n\t\tnext = <span class="hljs-number">0</span>;\n\t\ti = NR_TASKS;   <span class="hljs-comment">/* 这里的宏 NR_TASKS = 64 */</span>\n\t\tp = &amp;task[NR_TASKS];\n\t\t<span class="hljs-keyword">while</span> (--i) {\n\t\t\t<span class="hljs-keyword">if</span> (!*--p)\n\t\t\t\t<span class="hljs-keyword">continue</span>;\n            <span class="hljs-comment">/* 选择任务状态为 就绪态，且 counter 值最大的任务号作为下一个占用 CPU 的任务\n\t\t\tif ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) \n\t\t\t\tc = (*p)-&gt;counter, next = i;\n\t\t}\n        /* 如果没有其它任务，那么 next = 0 ，即接下来占用 cpu 的任务就是 0号任务(0号任务一定存在，不能被 kill ) */</span>\n\t\t<span class="hljs-keyword">if</span> (c) <span class="hljs-keyword">break</span>;\n        <span class="hljs-comment">/* 如果 1~63 号任务(不存在或不在就绪态)至少存在一个任务，且时间片都为 0 ，那么重新计算分配给每个任务的 counter 值 */</span>\n\t\t<span class="hljs-keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)\n\t\t\t<span class="hljs-keyword">if</span> (*p)\n\t\t\t\t(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="hljs-number">1</span>) + (*p)-&gt;priority;\n\t}\n    <span class="hljs-comment">/* 将当前任务切换为 next ，然后就可以一切就绪，退出时钟中断，就变成新的占用cpu的任务来执行了 */</span>\n\tswitch_to(next);\n}</code></pre><p><strong>switch_to(next)</strong></p>\n<p>switch_to(next) 这个函数，是通过内嵌汇编写的。下面我们来看看细节(这里选用 GCC 编译出来的汇编指令，不直接使用内嵌汇编)</p>\n<pre><code class="hljs"># 这里的汇编指令紧跟在 if(c) break; 之后\n.L36:\n\tmovl\t%ebx, %edx          # 这里 ebx 存储的是 next 变量的值，现在复制到 edx 上\n\tsall\t$4, %edx            # sall、addl 两行的目的是计算得到一个 TSS 选择符，TSS0 在 GDT 是第4项，TSS1 在 GDT 是第 6 项，类推...其中选择符后3位为DPL和 GDTR/LDTR 选项\n\taddl\t$32, %edx\n\tmovl\t_task(,%ebx,4), %ecx    # 找到 next 号任务的 task_struct 的指针 (存储在 task[64] 的数组中)\n#APP\n# 141 "sched.c" 1\n\tcmpl %ecx,_current          # 确认是不是原任务\n\tje 1f                       # 是的话直接跳出 (跳到最近的标签 1 )\n\tmovw %dx,8(%esp)\n\txchgl %ecx,_current         # 交换 ecx 和 _current 存储的值\n\tljmp 4(%esp)                # 通过间接跳转完成任务切换。通用的形式是 jmp CS:IP，但是使用间接跳转，在内存中的值先读取 32 位偏移量，再读 16 位段选择符\n\tcmpl %ecx,_last_task_used_math\n\tjne 1f\n\tclts                        # 清除 CR0 寄存器中的 TS Flag \n1:\n# 0 "" 2\n#NO_AP</code></pre><p>上面这段程序有必要将它割裂成两部分来看待，以 <code>ljmp 4(%esp)</code> 为界。</p>\n<p><code>jmp</code> ，这是一个相当明显的程序跳转。这里 jmp 给出的选择符是 GDT 上某个任务的 TSS 描述符</p>\n<p>通过 <code>jmp</code> CPU 将完成老的任务所有寄存器的保存现场，以及新的任务所有寄存器暂存结果的载入。</p>\n<p>CPU 执行的下一条指令，将是新的任务 CS:EIP 所指明的指令。</p>\n<p>相应的，<code>ljmp</code> 之后的指令将在该任务重新获得占用 CPU 后获得执行。</p>\n<h2>任务调度的结束阶段</h2>\n<p>这段就比较绕了，现在假设一个前提，就是任务 A 也是在时钟中断重新进行任务调度的时候被替换掉的，现在 CPU 分配的时间片又轮到了任务 A 。</p>\n<p>也就是紧随着上一小节 <code>ljmp</code> 看看从任务内核态回到用户态的流程。</p>\n<pre><code class="hljs"># 这段与上面一段指令是直接承接的\n\tmovl\t12(%esp), %eax\n\txorl\t%gs:20, %eax\n\tje\t.L40\n\tcall\t___stack_chk_fail\n.L40:\n\taddl\t$24, %esp           # 这里返还这次 call 额外申请的内核栈空间\n\t.cfi_def_cfa_offset 8\n\tpopl\t%ebx                # 恢复进入 call 的时候暂存的 ebx\n\t.cfi_restore 3\n\t.cfi_def_cfa_offset 4\n\tret                         # return 跳转回到当初调用的地方\n\t.cfi_endproc</code></pre><p>还是从汇编指令来看</p>\n<pre><code class="hljs">call\t_schedule           # 原先调用 schedule() 的地方\n.L93:\n    # return 跳转回来，直接承接的指令\n\taddl\t$8, %esp\n\t.cfi_def_cfa_offset 8\n\tpopl\t%ebx\n\t.cfi_restore 3\n\t.cfi_def_cfa_offset 4\n\tret                         # 继续 return ，跳出 do_timer() \n\t.cfi_endproc</code></pre><pre><code class="hljs">call _do_timer\t\t# \'do_timer(long CPL)\' does everything from\n\taddl $4,%esp\t\t# task switching to accounting ...\n\tjmp ret_from_sys_call</code></pre><p><strong>ret_from_sys_call</strong></p>\n<p>这里就打算正式结束由于这次时钟中断所引发的内核态指令执行的流程，正式回归用户态了。</p>\n<pre><code class="hljs">ret_from_sys_call:\n    # 这 3 行来判断是不是任务0，如果是就不进行信号量的处理了\n\tmovl _current,%eax\t\t# task[0] cannot have signals\n\tcmpl _task,%eax\n\tje 3f\n    # 判断在发生时钟中断前，CS 表示的是不是 LDT 第 1 项 (局部变量表的代码段)\n    # 否则 CS 就应该内核态代码段了，不进行信号量处理\n\tcmpw $0x0f,CS(%esp)\t\t# was old code segment supervisor ?\n\tjne 3f\n    # 判断在发生时钟中断前，SS 表示的是不是 LDT 第 2 项 (局部变量表的数据段)\n    # 否则认为程序还处在内核态，不进行信号量处理\n\tcmpw $0x17,OLDSS(%esp)\t\t# was stack segment = 0x17 ?\n\tjne 3f\n    # 设置信号量 (不清楚，先挖个坑)\n\tmovl signal(%eax),%ebx\n\tmovl blocked(%eax),%ecx\n\tnotl %ecx\n\tandl %ebx,%ecx\n\tbsfl %ecx,%ecx\n\tje 3f\n\tbtrl %ecx,%ebx\n\tmovl %ebx,signal(%eax)\n\tincl %ecx\n\tpushl %ecx\n\tcall _do_signal\n\tpopl %eax\n3:\tpopl %eax\n\tpopl %ebx\n\tpopl %ecx\n\tpopl %edx\n\tpop %fs\n\tpop %es\n\tpop %ds\n\tiret</code></pre><p>至此，通过 iret 将跳转回到用户态代码被中断的位置，并继续执行</p>\n<h2>补充</h2>\n<h3>pause()</h3>\n<p><a href="https://dormouse-none.github.io/2018-10-06-understand-Kernel-3/">Linux Kernel(3) - 操作系统启动</a> 中，描述过任务0在完成了整个操作系统的启动流程之后，唯一在做的事情，就是调用 <code>for(;;) pause();</code></p>\n<p>CPU 每次把时间片分配给它，它就开始浪费权力，直接不要了这个时间片。</p>\n<p>之前一直以为 pause() 会选择执行 <code>HLT</code> 指令让 CPU 暂时地陷入停止状态。但是出乎意料，并不是这个结果(当然，最终是不是还是另一个说法。毕竟代码都是人写的，每个人都可以各自有一套实现)。</p>\n<p>当 CPU 把执行指令的权力交个任务 0 时，选择让 CPU 停止，直到接收到硬件中断为止也不失为一种选择。当然，不论其它，Linux0.11版本的代码不是这样的。</p>\n<p>通过 <code>INT 0x80</code> 配合系统调用函数查表，最后定位到的就是 sys_pause() 了</p>\n<pre><code>_sys_pause:\n.LFB13:\n\t.cfi_startproc\n\tsubl\t$12, %esp\n\t.cfi_def_cfa_offset 16\n\tmovl\t_current, %eax\n\tmovl\t$1, (%eax)\n\tcall\t_schedule       # 调用 schedule() 重新划分时间片\n\tmovl\t$0, %eax\n\taddl\t$12, %esp\n\t.cfi_def_cfa_offset 4\n\tret\n\t.cfi_endproc\n</code></pre>\n<h3>timer 定时器</h3>\n<p>之前在 <code>do_timer()</code> 函数中也看过了每次时钟中断，都会检查一遍定时器，并决定是否触发预置的定时器处理函数。</p>\n<p>当然了，既然是触发定时器，总是要有一个前提——设置定时器</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_timer</span><span class="hljs-params">(<span class="hljs-keyword">long</span> jiffies, <span class="hljs-keyword">void</span> (*fn)(<span class="hljs-keyword">void</span>))</span>\n</span>{\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> * <span class="hljs-title">p</span>;</span>\n\n\t<span class="hljs-keyword">if</span> (!fn)\n\t\t<span class="hljs-keyword">return</span>;\n\tcli();\n\t<span class="hljs-keyword">if</span> (jiffies &lt;= <span class="hljs-number">0</span>)\n\t\t(fn)();\n\t<span class="hljs-keyword">else</span> {\n\t\t<span class="hljs-keyword">for</span> (p = timer_list ; p &lt; timer_list + TIME_REQUESTS ; p++)\n\t\t\t<span class="hljs-keyword">if</span> (!p-&gt;fn)\n\t\t\t\t<span class="hljs-keyword">break</span>;\n\t\t<span class="hljs-keyword">if</span> (p &gt;= timer_list + TIME_REQUESTS)\n\t\t\tpanic(<span class="hljs-string">"No more time requests free"</span>);\n\t\tp-&gt;fn = fn;\n\t\tp-&gt;jiffies = jiffies;\n\t\tp-&gt;next = next_timer;\n\t\tnext_timer = p;\n\t\t<span class="hljs-keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;jiffies &lt; p-&gt;jiffies) {\n\t\t\tp-&gt;jiffies -= p-&gt;next-&gt;jiffies;\n\t\t\tfn = p-&gt;fn;\n\t\t\tp-&gt;fn = p-&gt;next-&gt;fn;\n\t\t\tp-&gt;next-&gt;fn = fn;\n\t\t\tjiffies = p-&gt;jiffies;\n\t\t\tp-&gt;jiffies = p-&gt;next-&gt;jiffies;\n\t\t\tp-&gt;next-&gt;jiffies = jiffies;\n\t\t\tp = p-&gt;next;\n\t\t}\n\t}\n\tsti();\n}</code></pre><h2>小结</h2>\n<p>对于任务调度，更难的是对一个时间断层的理解。在调度过程中，旧任务被暂停，新的任务被重新启动, 直到旧的任务又被启动。这里就必须人为地将被中断的任务主动的连接起来看待。</p>\n<p>早期版本的任务调度模块确实比较简单，累计不过百行 C 代码。哈哈。一点一点继续来吧。</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-10-12-understand-Kernel-4.json",ext:".json",sourceBase:"2018-10-12-understand-Kernel-4.md",sourceExt:".md"}},CrC2:function(n){n.exports={title:"Understand MAIL",author:"fangfeng",date:"2018-09-27T00:00:00.000Z",tags:["mail","SMTP","TCP"],bodyContent:"在网络协议上，高层协议确实比底层协议更容易理解，也更加的人性化。\n传输层的 TCP, UDP 都还停留在各种字节内容的整合和校验上，而更上层的应用层协议就已经能够直观到通过直接解读就能理解其每条消息的含义了。\n\n\x3c!-- more --\x3e\n\n## SMTP 协议\n\nSMTP，简单邮件传输协议。单从协议内容上来说确实没有太多的学习难度。但是，扭转“常识”恰恰是巨大的绊脚石。\n直接就进入了网页邮件系统 or 客户端邮件系统的时代。图形化的界面配合上一些关键字的内容 (比如收件人，主题等)。\n点击发送就觉得一封邮件已经发出去了。\n\n但是，究竟这中间做了什么呢？\n163，GMAIL, QQ 等邮箱究竟又在其中扮演着怎样的一个角色？\n\n首先，SMTP 是为了高效、可靠地传递邮件而存在的。\n\n下面先给一段演示。通过 telnet 连接到 183.57.48.34 (这个是腾讯企业邮其中一台机器的 IP) 25 (SMTP 服务端口) ，以本机作为 SMTP 的客户端，而将 183.XXX 作为 SMTP 的服务端，来完成邮件信息的一次交互。 (当然，最后失败了。被企业邮识别为垃圾邮件了...)\n\n下列每行 `#` 开始及之后的内容是个人添加的注释，其它内容是 telnet 交互的内容。\n同时，`--` 标志该行内容由\n\n```\n$ telnet 183.57.48.34 25\nTrying 183.57.48.34...\nConnected to 183.57.48.34.\nEscape character is '^]'.\n220 bizmx17.qq.com MX QQ Mail Server\nHELO test                               -- # MEANS HELLO <domain> 在每次建立连接通道后，发送的第一条消息\n250 bizmx17.qq.com                         # 服务器的回复值 Code 250 \nMAIL FROM: <from@test.net>              -- # MAIL 表示邮件的发起方，用于退信等其他邮件反向事件\n250 Ok                                   \nRCPT TO: <to@xxx.xxx>                   -- # RCPT 表示邮件的接收方，用于投递邮件等正向事件\n250 Ok\nDATA                                    -- # DATA 表示之后的内容将作为邮件正文 (正文这个描述可能不太恰当，更应该是等同于信封内的所有内容)\n354 End data with <CR><LF>.<CR><LF>\n                                        --\nIt's a fake mail.                       -- # 邮件正文，其实还可以写上诸如 'Subject: XXX' 'Cc: XXX' 的内容\n.                                       -- # 正文内容结束的标志，<CR><LF>.<CR><LF>\n550 Mail content denied. http://service.exmail.qq.com/cgi-bin/help?subtype=1&&id=20022&&no=1000726 # 这里很无奈，没腾讯给拦了，没发出去。不过反正是假的，邮件信息不全。\n```\n\n### 几个主要的 SMTP 交互指令\n\n- HELO: (HELLO)\n    主要用于让 SMTP 服务器对当前连接的 SMTP 客户端(上例是 telnet 模拟的) 建立一个身份标志 (一般是当前的主机名)\n- MAIL:\n    用法 MAIL FROM: <xx@xx.xx> (不区分大小写)\n    可以将其与普通信件的信封等同。毕竟都是要写上发信人，如果没人收信，也就可以根据这个声明将信件退回。\n- RCPT: (RECIPIENT)\n    用法 RCPT TO: <xx@xx.xx> (可多次重复声明，即将一封信件复制多次投送给每次声明的对象)\n    相当于普通信件的收信人。不过也有点区别，毕竟普通信件没法一件多发嘛。\n- DATA:\n    `DATA` 之后到 `<CR><LF>.<CR><LF>` 之前的所有内容都作为邮件的正文内容。等同于普通信件信封内的信纸(当然了，信纸上在写上 `To XXX:` `Yours XXX` 也是很正常的嘛)，类似的也就是 DATA 数据中也可以包括 `Subject:` (主题), `From:` (写信人), `Date:` (日期), `To:`(收件人)等内容。\n\n---\n\n### 几个次要的 SMTP 交互指令\n\n- RSET: (Reset)\n    重置，丢弃之前针对邮件所描述的所有内容，重新开始。\n\n- VRFY: (VERIFY)\n    用于确认收件人是否存在，以及收件人的完整地址\n\n- NOOP: \n    强制服务器做出一个回应，没有实际意义。\n\n- QUIT:\n    要求收信服务器返回一个邮件接收成功的信号，之后释放连接通道。\n\n## SMTP 扩展\n\n前面描述了这么多，应该来说找一些支持 TCP (或者其他稳定的传输层连接也是可以的) 连接的命令就完全可以支持一次邮件发送的需求。\n\n但是，如果想要发送一些中文字符之类的，马上就出现了问题。\n\n这里有几种方式，但本人还没有理解透彻。仅列出知道的可行方案。\n\n- 通过 IMF (Internet Message Format) 进行发件\n- 通过 ESMTP \n\n## SMTP 安全\n\n出于 SMTP 本身协议的设计，没有一个有效的身份认证机制。\n\n纵使通过 `MAIL FROM: <A@test.net>` 在信封上写明了是由 A 发出的信件。\n但是，装在信封内的信纸却可以属上另一个人的名字。\n\n利用这种规则，也就出现了伪装发信人这样的操作。当然，现在的大量邮箱服务提供商都会对这种情况进行标记。\n\n![“代发”标记](https://ws1.sinaimg.cn/large/006tNc79gy1fvpbzedf67j315e01q0sp.jpg)\n\n\n## 参考\n\n1. [SIMPLE MAIL TRANSFER PROTOCOL](https://tools.ietf.org/html/rfc821)\n2. [MIME](http://www.ruanyifeng.com/blog/2008/06/mime.html)\n\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```",bodyHtml:'<p>在网络协议上，高层协议确实比底层协议更容易理解，也更加的人性化。\n传输层的 TCP, UDP 都还停留在各种字节内容的整合和校验上，而更上层的应用层协议就已经能够直观到通过直接解读就能理解其每条消息的含义了。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>SMTP 协议</h2>\n<p>SMTP，简单邮件传输协议。单从协议内容上来说确实没有太多的学习难度。但是，扭转“常识”恰恰是巨大的绊脚石。\n直接就进入了网页邮件系统 or 客户端邮件系统的时代。图形化的界面配合上一些关键字的内容 (比如收件人，主题等)。\n点击发送就觉得一封邮件已经发出去了。</p>\n<p>但是，究竟这中间做了什么呢？\n163，GMAIL, QQ 等邮箱究竟又在其中扮演着怎样的一个角色？</p>\n<p>首先，SMTP 是为了高效、可靠地传递邮件而存在的。</p>\n<p>下面先给一段演示。通过 telnet 连接到 183.57.48.34 (这个是腾讯企业邮其中一台机器的 IP) 25 (SMTP 服务端口) ，以本机作为 SMTP 的客户端，而将 183.XXX 作为 SMTP 的服务端，来完成邮件信息的一次交互。 (当然，最后失败了。被企业邮识别为垃圾邮件了...)</p>\n<p>下列每行 <code>#</code> 开始及之后的内容是个人添加的注释，其它内容是 telnet 交互的内容。\n同时，<code>--</code> 标志该行内容由</p>\n<pre><code>$ telnet 183.57.48.34 25\nTrying 183.57.48.34...\nConnected to 183.57.48.34.\nEscape character is \'^]\'.\n220 bizmx17.qq.com MX QQ Mail Server\nHELO test                               -- # MEANS HELLO &lt;domain&gt; 在每次建立连接通道后，发送的第一条消息\n250 bizmx17.qq.com                         # 服务器的回复值 Code 250 \nMAIL FROM: &lt;from@test.net&gt;              -- # MAIL 表示邮件的发起方，用于退信等其他邮件反向事件\n250 Ok                                   \nRCPT TO: &lt;to@xxx.xxx&gt;                   -- # RCPT 表示邮件的接收方，用于投递邮件等正向事件\n250 Ok\nDATA                                    -- # DATA 表示之后的内容将作为邮件正文 (正文这个描述可能不太恰当，更应该是等同于信封内的所有内容)\n354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;\n                                        --\nIt\'s a fake mail.                       -- # 邮件正文，其实还可以写上诸如 \'Subject: XXX\' \'Cc: XXX\' 的内容\n.                                       -- # 正文内容结束的标志，&lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;\n550 Mail content denied. http://service.exmail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=20022&amp;&amp;no=1000726 # 这里很无奈，没腾讯给拦了，没发出去。不过反正是假的，邮件信息不全。\n</code></pre>\n<h3>几个主要的 SMTP 交互指令</h3>\n<ul>\n<li>HELO: (HELLO)\n主要用于让 SMTP 服务器对当前连接的 SMTP 客户端(上例是 telnet 模拟的) 建立一个身份标志 (一般是当前的主机名)</li>\n<li>MAIL:\n用法 MAIL FROM: <a href="mailto:xx@xx.xx">xx@xx.xx</a> (不区分大小写)\n可以将其与普通信件的信封等同。毕竟都是要写上发信人，如果没人收信，也就可以根据这个声明将信件退回。</li>\n<li>RCPT: (RECIPIENT)\n用法 RCPT TO: <a href="mailto:xx@xx.xx">xx@xx.xx</a> (可多次重复声明，即将一封信件复制多次投送给每次声明的对象)\n相当于普通信件的收信人。不过也有点区别，毕竟普通信件没法一件多发嘛。</li>\n<li>DATA:\n<code>DATA</code> 之后到 <code>&lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</code> 之前的所有内容都作为邮件的正文内容。等同于普通信件信封内的信纸(当然了，信纸上在写上 <code>To XXX:</code> <code>Yours XXX</code> 也是很正常的嘛)，类似的也就是 DATA 数据中也可以包括 <code>Subject:</code> (主题), <code>From:</code> (写信人), <code>Date:</code> (日期), <code>To:</code>(收件人)等内容。</li>\n</ul>\n<hr>\n<h3>几个次要的 SMTP 交互指令</h3>\n<ul>\n<li>\n<p>RSET: (Reset)\n重置，丢弃之前针对邮件所描述的所有内容，重新开始。</p>\n</li>\n<li>\n<p>VRFY: (VERIFY)\n用于确认收件人是否存在，以及收件人的完整地址</p>\n</li>\n<li>\n<p>NOOP:\n强制服务器做出一个回应，没有实际意义。</p>\n</li>\n<li>\n<p>QUIT:\n要求收信服务器返回一个邮件接收成功的信号，之后释放连接通道。</p>\n</li>\n</ul>\n<h2>SMTP 扩展</h2>\n<p>前面描述了这么多，应该来说找一些支持 TCP (或者其他稳定的传输层连接也是可以的) 连接的命令就完全可以支持一次邮件发送的需求。</p>\n<p>但是，如果想要发送一些中文字符之类的，马上就出现了问题。</p>\n<p>这里有几种方式，但本人还没有理解透彻。仅列出知道的可行方案。</p>\n<ul>\n<li>通过 IMF (Internet Message Format) 进行发件</li>\n<li>通过 ESMTP</li>\n</ul>\n<h2>SMTP 安全</h2>\n<p>出于 SMTP 本身协议的设计，没有一个有效的身份认证机制。</p>\n<p>纵使通过 <code>MAIL FROM: &lt;A@test.net&gt;</code> 在信封上写明了是由 A 发出的信件。\n但是，装在信封内的信纸却可以属上另一个人的名字。</p>\n<p>利用这种规则，也就出现了伪装发信人这样的操作。当然，现在的大量邮箱服务提供商都会对这种情况进行标记。</p>\n<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fvpbzedf67j315e01q0sp.jpg" alt="“代发”标记"></p>\n<h2>参考</h2>\n<ol>\n<li><a href="https://tools.ietf.org/html/rfc821">SIMPLE MAIL TRANSFER PROTOCOL</a></li>\n<li><a href="http://www.ruanyifeng.com/blog/2008/06/mime.html">MIME</a></li>\n</ol>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-09-27-mail.json",ext:".json",sourceBase:"2018-09-27-mail.md",sourceExt:".md"}},EhLH:function(n,s,a){"use strict";a.r(s);var e=a("q1tI"),t=a.n(e),l=a("nOHt");s.default=Object(l.withRouter)(function(n){var s=a("U5sb")("./content"+n.router.query.fullUrl+".json");return t.a.createElement("div",{dangerouslySetInnerHTML:{__html:s.bodyContent}})})},GuZ5:function(n){n.exports={title:"TCP SYN 包模拟",author:"fangfeng",date:"2018-09-18T00:00:00.000Z",tags:["TCP"],bodyContent:'写了两天，几乎是从零开始，C 语言搞了一个发 TCP SYN 包的小程序。\n从协议到程序代码的转换，确实没有花费太多的时间，但是为了字节序(byteorder)的问题简直折腾得...\n\n\x3c!-- more --\x3e\n\n## TCP 首部格式 \n\n从 RFC 793 了解到基础的 TCP 首部格式(当然，模拟三次握手的 SYN 包也根本不需要填充任何数据)。\n\n```\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |          Source Port          |       Destination Port        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                        Sequence Number                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Acknowledgment Number                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Data |           |U|A|P|R|S|F|                               |\n   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n   |       |           |G|K|H|T|N|N|                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |           Checksum            |         Urgent Pointer        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Options                    |    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                             data                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\n对于仅仅模拟一个 SYN 包而言，似乎无需关心 Sequence Number, Ack Number, Window 等信息，毕竟都不关心服务器端给的返回。\n最低的要求，仅仅是发一个合法的 TCP 报文，得到服务器端的反馈，而非直接被服务器端丢弃(如果被验证到报文非法或者数据出错等)。\n\n那么，最为重要的细节就是 Checksum (校验和) 了。服务器端会对接收到的数据流进行校验，如果有差错，则直接丢弃，而无任何结果。\n\n## 校验和\n\n从细节上来说，网络协议中的校验和显得比较简单。以 TCP 协议的 Checksum 字段举例，就是为了让伪首部(TCP 首部 + source IP + destination IP 等一些额外信息)\n以每 16 位 (2 字节) 为一个单位，循环累加和最终达到 0xFFFF 的效果。\n\n下面以一个由 Source IP: 172.16.2.101 -> Destination IP: 172.16.2.127 的 TCP 首部为例进行细节描述:\n\n```\n# 总长为 20 字节的 TCP 报文首部\n27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 1d 2c 00 00\n\nsrc Port: 0x2711 -> 10001\ndst Port: 0x0fa0 -> 4000\nSeq nr: 0x00000000 -> 0\nAck nr: 0x00000000 -> 0\nData off: 5 -> 32 bits 数量是 5 -> 20 字节 (即 TCP 首部长度为 20 字节)\nFLAG: 0x02 -> urg ack psh rst SYN fin \nWindow: 0xFF00 (窗口大小为 65280 字节)\nchk sum: 0x1d2c\nurg pointer: 0x0000\n```\n\n在计算之前，TCP 校验和还将涉及到伪首部的概念\n\n```\n+--------+--------+--------+--------+\n|           Source Address          |\n+--------+--------+--------+--------+\n|         Destination Address       |\n+--------+--------+--------+--------+\n|  zero  |  PTCL  |    TCP Length   |\n+--------+--------+--------+--------+\n\n在此例中:\nSource Address: 172.16.2.101 -> 0xAC100265\nDestination Address: 172.16.2.127 -> 0XAC10027F\nzero: 0x00\nPTCL(protocol): TCP(6) -> 0x06\nTCP Length: 20 bytes -> 0x0014\n```\n\n即加上伪首部的内容，需要共同进行校验的数据流如下\n```\nac 10 02 65 ac 10 02 7f 00 06 00 14 27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 1d 2c 00 00\n```\n\n### 服务器端校验\n\n服务器端接收到 TCP 报文后，将对整个需要校验的数据流，按 16 bits (2字节) 为单位，进行累加。\n\n即: `0xac10+0x0265+0xac10+0x027f+0x0006+0x0014+0x2711+0x0fa0+0x0000+0x0000+0x0000+0x0000+0x5002+0xff00+0x1d2c+0x0000 = 0x2fffd`\n\n对于超长计算结果 (超出 0xFFFF) ，循环将高位右移 16 位与低位进行累加，直到结果 <= 0xFFFF ，即 `0x20000 >> 16 + 0xfffd = 0xffff`\n\n如果最终结果 `=0xffff`(全为 1) ，则认为 TCP 首部没有问题，服务器端接收报文，并回复 ACK SYN 包。\n\n### 客户端构造校验和\n\n与服务器端相对，显然客户端必须通过 Check sum ，使得最终的结果服务器端校验的条件。\n\n作为反向问题，同样以上面为例子，假设 check sum 还未确定具体的值。则计算方式如下:\n\n加上伪首部, 校验和暂时置零的数据流\n\n```\nac 10 02 65 ac 10 02 7f 00 06 00 14 27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 00 00 00 00\n```\n\n作为逆过程，按 16 bits 为单位，进行累加。即: `0xac10+0x0265+0xac10+0x027f+0x0006+0x0014+0x2711+0x0fa0+0x0000+0x0000+0x0000+0x0000+0x5002+0xff00+0x0000+0x0000 = 0x2e2d1`\n\n超长部分循环累加，`0x20000 >> 16 + 0xe2d1 = 0xe2d3`\n\n结果取反，`~ 0xe2d3 = 0x1d2c`\n\n即认为 `0x1d2c` 为校验和\n\n## HBO 与 NBO \n\nHBO: host byte order\nNBO: network byte order \n\n说起字节序简直能够把人逼疯，说实话虽然有一定的历史原因，但是不做统一真的对底层编程相当得不友好。\n\n不过，再厌烦也不能改变什么。总还得继续写代码不是嘛。\n\n### 主机字节序 (HBO, Host Byte Order)\n\n采用小端字节排序方式。简单描述为 高位字节存放在内存的高地址处，低位字节存储在内存的低地址处。\n\n以 4 字节 int 型数据 0xAB1267EF 为例:\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fvdu3zhh92j31040newel.jpg)\n\n而程序读取数据的顺序，如果不考虑数据类型，按字节读取，普遍将采用字节递增序读取，则优先将读到 0xEF 等低位字节数据\n\n### 网络字节序 (NBO, Network Byte Order)\n\n采用大端字节排序方式。简单描述为通过网络接收到数据时将优先接收到数据的高位字节，然后再得到低位字节。\n\n还是以 4 字节 int 型数据 0xAB1267EF 为例:\n\n则通过网络得到的数据流将是 `0xEF 0x67 0x12 0xAB`\n\n### 实际使用\n\nC 语言，BSD 平台的 netinet/tcp.h 定义了 tcp header 结构体。\n\n```c\nstruct tcphdr {\n\tunsigned short\tth_sport;\t/* source port */\n\tunsigned short\tth_dport;\t/* destination port */\n\ttcp_seq\tth_seq;\t\t\t/* sequence number */\n\ttcp_seq\tth_ack;\t\t\t/* acknowledgement number */\n#if __DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIAN\n\tunsigned int\tth_x2:4,\t/* (unused) */\n\t\t\tth_off:4;\t/* data offset */\n#endif\n#if __DARWIN_BYTE_ORDER == __DARWIN_BIG_ENDIAN\n\tunsigned int\tth_off:4,\t/* data offset */\n\t\t\tth_x2:4;\t/* (unused) */\n#endif\n\tunsigned char\tth_flags;\n#define\tTH_FIN\t0x01\n#define\tTH_SYN\t0x02\n#define\tTH_RST\t0x04\n#define\tTH_PUSH\t0x08\n#define\tTH_ACK\t0x10\n#define\tTH_URG\t0x20\n#define\tTH_ECE\t0x40\n#define\tTH_CWR\t0x80\n#define\tTH_FLAGS\t(TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)\n\n\tunsigned short\tth_win;\t\t/* window */\n\tunsigned short\tth_sum;\t\t/* checksum */\n\tunsigned short\tth_urp;\t\t/* urgent pointer */\n};\n```\n\n对于 `unsigned char` 之类的单字节数据，将不存在任何问题。但是，诸如 `unsigned short` 等多字节数据，将涉及到字节序的转换。\n\n比如，虽然令 `th_sport = 0x2711 (10001)` 看似合理。但是，从内存的角度来看，数据将被存储为 \n\n```\n# 假设起始物理内存地址为 0x00007c000\n0x00007c01: 0x27 \n0x00007c00: 0x11\n```\n\n等到构造完 TCP 首部，顺次地发送数据时，呈现的数据流将形如: `0x11 0x27...` 即使用里 HBO (小端字节序) 的数据无法满足 NBO (大端字节序) 的要求。\n毕竟，两者相互对立。\n\n因此，需要特别注意字节序的问题。当然，C 语言还是想当友好地提供了字节序转换的工具 `htons`, `htonl`, `ntohs`, `ntohl` 。详情请通过 `man byteorder` 查看。\n\n## TCP SYN 的简单例程\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n\n/**\n * +--------+--------+--------+--------+\n * |           Source Address          |\n * +--------+--------+--------+--------+\n * |         Destination Address       |\n * +--------+--------+--------+--------+\n * |  zero  |  PTCL  |    TCP Length   |\n * +--------+--------+--------+--------+\n */\nstruct pseudohdr {\n    unsigned int src_addr;\n    unsigned int dst_addr;\n    unsigned short zero:8;\n    unsigned short protocol:8;\n    unsigned short tcp_length;\n\n    struct tcphdr tcpHdr;\n};\n\nunsigned short check_sum(unsigned short *ptr, size_t nbytes) \n{\n    unsigned int sum = 0;\n\n    while(nbytes > 0) \n    {\n        sum += htons(*ptr++);\n        nbytes -= 2;\n    }\n\n    sum = (sum >> 16) + (sum & 0xFFFF);\n    sum = (sum >> 16) + (sum & 0xFFFF);\n\n    sum = ~sum;\n    return (unsigned short) sum;\n}\n\nstruct tcphdr * init_tcp_header(int sport) \n{\n    struct tcphdr * header = (struct tcphdr *) malloc(sizeof(struct tcphdr));\n    header->th_sport = htons(sport);    // 源端口\n    header->th_dport = htons(4000);     // 目标端口\n    header->th_seq = 0;                // 序列号\n    header->th_ack = 0;                // 确认序号 | ACK 置位时有效\n    header->th_off = sizeof(struct tcphdr) / 4;   // TCP 首部长度 (字节)\n    header->th_flags = TH_SYN;      // 标志位\n    header->th_win = 255;           // 数据窗口大小\n    header->th_sum = 0;             // 校验值 (先置为 0, 等会再修正)\n    header->th_urp = 0;\n    return header;\n}\n\nvoid tcp_syn(int tcp_sock, struct tcphdr *header)\n{\n    struct sockaddr_in *addr = (struct sockaddr_in *) malloc(sizeof(struct sockaddr_in));\n    addr->sin_family = PF_INET;\n    addr->sin_port = htons(4000);\n    addr->sin_addr.s_addr = inet_addr("172.16.2.127");\n    ssize_t size = sendto(tcp_sock, header, sizeof(struct tcphdr), 0, (struct sockaddr *)addr, sizeof(addr));\n}\n\nint main(int argc, char **argv)\n{\n    int tcp_sock = socket(PF_INET, SOCK_RAW, IPPROTO_TCP);\n    if(tcp_sock == -1) \n    {\n        fprintf(stderr, "Open Socket Failed: %s(errno: %d)\\n", strerror(errno), errno);\n        exit(0);\n    }\n\n    struct tcphdr *tcpHdr = init_tcp_header(10001);\n\n    struct pseudohdr *psdHdr = (struct pseudohdr *) malloc(sizeof(struct pseudohdr));\n    psdHdr->src_addr = inet_addr("172.16.2.101");\n    psdHdr->dst_addr = inet_addr("172.16.2.127");\n    psdHdr->zero = 0;\n    psdHdr->protocol = 6;\n    psdHdr->tcp_length = htons(sizeof(struct tcphdr));\n    memcpy(&psdHdr->tcpHdr, tcpHdr, sizeof(struct tcphdr));\n    tcpHdr->th_sum = htons(check_sum((unsigned short *) psdHdr, sizeof(struct pseudohdr)));\n    free(psdHdr);\n\n    tcp_syn(tcp_sock, tcpHdr);\n    free(tcpHdr);\n}\n```\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<p>写了两天，几乎是从零开始，C 语言搞了一个发 TCP SYN 包的小程序。\n从协议到程序代码的转换，确实没有花费太多的时间，但是为了字节序(byteorder)的问题简直折腾得...</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>TCP 首部格式</h2>\n<p>从 RFC 793 了解到基础的 TCP 首部格式(当然，模拟三次握手的 SYN 包也根本不需要填充任何数据)。</p>\n<pre><code>    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |          Source Port          |       Destination Port        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                        Sequence Number                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Acknowledgment Number                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Data |           |U|A|P|R|S|F|                               |\n   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n   |       |           |G|K|H|T|N|N|                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |           Checksum            |         Urgent Pointer        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Options                    |    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                             data                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n<p>对于仅仅模拟一个 SYN 包而言，似乎无需关心 Sequence Number, Ack Number, Window 等信息，毕竟都不关心服务器端给的返回。\n最低的要求，仅仅是发一个合法的 TCP 报文，得到服务器端的反馈，而非直接被服务器端丢弃(如果被验证到报文非法或者数据出错等)。</p>\n<p>那么，最为重要的细节就是 Checksum (校验和) 了。服务器端会对接收到的数据流进行校验，如果有差错，则直接丢弃，而无任何结果。</p>\n<h2>校验和</h2>\n<p>从细节上来说，网络协议中的校验和显得比较简单。以 TCP 协议的 Checksum 字段举例，就是为了让伪首部(TCP 首部 + source IP + destination IP 等一些额外信息)\n以每 16 位 (2 字节) 为一个单位，循环累加和最终达到 0xFFFF 的效果。</p>\n<p>下面以一个由 Source IP: 172.16.2.101 -&gt; Destination IP: 172.16.2.127 的 TCP 首部为例进行细节描述:</p>\n<pre><code># 总长为 20 字节的 TCP 报文首部\n27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 1d 2c 00 00\n\nsrc Port: 0x2711 -&gt; 10001\ndst Port: 0x0fa0 -&gt; 4000\nSeq nr: 0x00000000 -&gt; 0\nAck nr: 0x00000000 -&gt; 0\nData off: 5 -&gt; 32 bits 数量是 5 -&gt; 20 字节 (即 TCP 首部长度为 20 字节)\nFLAG: 0x02 -&gt; urg ack psh rst SYN fin \nWindow: 0xFF00 (窗口大小为 65280 字节)\nchk sum: 0x1d2c\nurg pointer: 0x0000\n</code></pre>\n<p>在计算之前，TCP 校验和还将涉及到伪首部的概念</p>\n<pre><code>+--------+--------+--------+--------+\n|           Source Address          |\n+--------+--------+--------+--------+\n|         Destination Address       |\n+--------+--------+--------+--------+\n|  zero  |  PTCL  |    TCP Length   |\n+--------+--------+--------+--------+\n\n在此例中:\nSource Address: 172.16.2.101 -&gt; 0xAC100265\nDestination Address: 172.16.2.127 -&gt; 0XAC10027F\nzero: 0x00\nPTCL(protocol): TCP(6) -&gt; 0x06\nTCP Length: 20 bytes -&gt; 0x0014\n</code></pre>\n<p>即加上伪首部的内容，需要共同进行校验的数据流如下</p>\n<pre><code>ac 10 02 65 ac 10 02 7f 00 06 00 14 27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 1d 2c 00 00\n</code></pre>\n<h3>服务器端校验</h3>\n<p>服务器端接收到 TCP 报文后，将对整个需要校验的数据流，按 16 bits (2字节) 为单位，进行累加。</p>\n<p>即: <code>0xac10+0x0265+0xac10+0x027f+0x0006+0x0014+0x2711+0x0fa0+0x0000+0x0000+0x0000+0x0000+0x5002+0xff00+0x1d2c+0x0000 = 0x2fffd</code></p>\n<p>对于超长计算结果 (超出 0xFFFF) ，循环将高位右移 16 位与低位进行累加，直到结果 &lt;= 0xFFFF ，即 <code>0x20000 &gt;&gt; 16 + 0xfffd = 0xffff</code></p>\n<p>如果最终结果 <code>=0xffff</code>(全为 1) ，则认为 TCP 首部没有问题，服务器端接收报文，并回复 ACK SYN 包。</p>\n<h3>客户端构造校验和</h3>\n<p>与服务器端相对，显然客户端必须通过 Check sum ，使得最终的结果服务器端校验的条件。</p>\n<p>作为反向问题，同样以上面为例子，假设 check sum 还未确定具体的值。则计算方式如下:</p>\n<p>加上伪首部, 校验和暂时置零的数据流</p>\n<pre><code>ac 10 02 65 ac 10 02 7f 00 06 00 14 27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 00 00 00 00\n</code></pre>\n<p>作为逆过程，按 16 bits 为单位，进行累加。即: <code>0xac10+0x0265+0xac10+0x027f+0x0006+0x0014+0x2711+0x0fa0+0x0000+0x0000+0x0000+0x0000+0x5002+0xff00+0x0000+0x0000 = 0x2e2d1</code></p>\n<p>超长部分循环累加，<code>0x20000 &gt;&gt; 16 + 0xe2d1 = 0xe2d3</code></p>\n<p>结果取反，<code>~ 0xe2d3 = 0x1d2c</code></p>\n<p>即认为 <code>0x1d2c</code> 为校验和</p>\n<h2>HBO 与 NBO</h2>\n<p>HBO: host byte order\nNBO: network byte order</p>\n<p>说起字节序简直能够把人逼疯，说实话虽然有一定的历史原因，但是不做统一真的对底层编程相当得不友好。</p>\n<p>不过，再厌烦也不能改变什么。总还得继续写代码不是嘛。</p>\n<h3>主机字节序 (HBO, Host Byte Order)</h3>\n<p>采用小端字节排序方式。简单描述为 高位字节存放在内存的高地址处，低位字节存储在内存的低地址处。</p>\n<p>以 4 字节 int 型数据 0xAB1267EF 为例:</p>\n<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvdu3zhh92j31040newel.jpg" alt=""></p>\n<p>而程序读取数据的顺序，如果不考虑数据类型，按字节读取，普遍将采用字节递增序读取，则优先将读到 0xEF 等低位字节数据</p>\n<h3>网络字节序 (NBO, Network Byte Order)</h3>\n<p>采用大端字节排序方式。简单描述为通过网络接收到数据时将优先接收到数据的高位字节，然后再得到低位字节。</p>\n<p>还是以 4 字节 int 型数据 0xAB1267EF 为例:</p>\n<p>则通过网络得到的数据流将是 <code>0xEF 0x67 0x12 0xAB</code></p>\n<h3>实际使用</h3>\n<p>C 语言，BSD 平台的 netinet/tcp.h 定义了 tcp header 结构体。</p>\n<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> {</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>\tth_sport;\t<span class="hljs-comment">/* source port */</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>\tth_dport;\t<span class="hljs-comment">/* destination port */</span>\n\ttcp_seq\tth_seq;\t\t\t<span class="hljs-comment">/* sequence number */</span>\n\ttcp_seq\tth_ack;\t\t\t<span class="hljs-comment">/* acknowledgement number */</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIAN</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>\tth_x2:<span class="hljs-number">4</span>,\t<span class="hljs-comment">/* (unused) */</span>\n\t\t\tth_off:<span class="hljs-number">4</span>;\t<span class="hljs-comment">/* data offset */</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __DARWIN_BYTE_ORDER == __DARWIN_BIG_ENDIAN</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>\tth_off:<span class="hljs-number">4</span>,\t<span class="hljs-comment">/* data offset */</span>\n\t\t\tth_x2:<span class="hljs-number">4</span>;\t<span class="hljs-comment">/* (unused) */</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>\tth_flags;\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>\tTH_FIN\t0x01</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>\tTH_SYN\t0x02</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>\tTH_RST\t0x04</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>\tTH_PUSH\t0x08</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>\tTH_ACK\t0x10</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>\tTH_URG\t0x20</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>\tTH_ECE\t0x40</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>\tTH_CWR\t0x80</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>\tTH_FLAGS\t(TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)</span>\n\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>\tth_win;\t\t<span class="hljs-comment">/* window */</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>\tth_sum;\t\t<span class="hljs-comment">/* checksum */</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>\tth_urp;\t\t<span class="hljs-comment">/* urgent pointer */</span>\n};</code></pre><p>对于 <code>unsigned char</code> 之类的单字节数据，将不存在任何问题。但是，诸如 <code>unsigned short</code> 等多字节数据，将涉及到字节序的转换。</p>\n<p>比如，虽然令 <code>th_sport = 0x2711 (10001)</code> 看似合理。但是，从内存的角度来看，数据将被存储为</p>\n<pre><code># 假设起始物理内存地址为 0x00007c000\n0x00007c01: 0x27 \n0x00007c00: 0x11\n</code></pre>\n<p>等到构造完 TCP 首部，顺次地发送数据时，呈现的数据流将形如: <code>0x11 0x27...</code> 即使用里 HBO (小端字节序) 的数据无法满足 NBO (大端字节序) 的要求。\n毕竟，两者相互对立。</p>\n<p>因此，需要特别注意字节序的问题。当然，C 语言还是想当友好地提供了字节序转换的工具 <code>htons</code>, <code>htonl</code>, <code>ntohs</code>, <code>ntohl</code> 。详情请通过 <code>man byteorder</code> 查看。</p>\n<h2>TCP SYN 的简单例程</h2>\n<pre><code class="hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/tcp.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/ip.h&gt;</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span>\n\n<span class="hljs-comment">/**\n * +--------+--------+--------+--------+\n * |           Source Address          |\n * +--------+--------+--------+--------+\n * |         Destination Address       |\n * +--------+--------+--------+--------+\n * |  zero  |  PTCL  |    TCP Length   |\n * +--------+--------+--------+--------+\n */</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pseudohdr</span> {</span>\n    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> src_addr;\n    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> dst_addr;\n    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> zero:<span class="hljs-number">8</span>;\n    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> protocol:<span class="hljs-number">8</span>;\n    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> tcp_length;\n\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> <span class="hljs-title">tcpHdr</span>;</span>\n};\n\n<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-title">check_sum</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *ptr, <span class="hljs-keyword">size_t</span> nbytes)</span> \n</span>{\n    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;\n\n    <span class="hljs-keyword">while</span>(nbytes &gt; <span class="hljs-number">0</span>) \n    {\n        sum += htons(*ptr++);\n        nbytes -= <span class="hljs-number">2</span>;\n    }\n\n    sum = (sum &gt;&gt; <span class="hljs-number">16</span>) + (sum &amp; <span class="hljs-number">0xFFFF</span>);\n    sum = (sum &gt;&gt; <span class="hljs-number">16</span>) + (sum &amp; <span class="hljs-number">0xFFFF</span>);\n\n    sum = ~sum;\n    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>) sum;\n}\n\n<span class="hljs-function">struct tcphdr * <span class="hljs-title">init_tcp_header</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sport)</span> \n</span>{\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> * <span class="hljs-title">header</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">tcphdr</span> *) <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">tcphdr</span>));</span>\n    header-&gt;th_sport = htons(sport);    <span class="hljs-comment">// 源端口</span>\n    header-&gt;th_dport = htons(<span class="hljs-number">4000</span>);     <span class="hljs-comment">// 目标端口</span>\n    header-&gt;th_seq = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 序列号</span>\n    header-&gt;th_ack = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 确认序号 | ACK 置位时有效</span>\n    header-&gt;th_off = <span class="hljs-keyword">sizeof</span>(struct tcphdr) / <span class="hljs-number">4</span>;   <span class="hljs-comment">// TCP 首部长度 (字节)</span>\n    header-&gt;th_flags = TH_SYN;      <span class="hljs-comment">// 标志位</span>\n    header-&gt;th_win = <span class="hljs-number">255</span>;           <span class="hljs-comment">// 数据窗口大小</span>\n    header-&gt;th_sum = <span class="hljs-number">0</span>;             <span class="hljs-comment">// 校验值 (先置为 0, 等会再修正)</span>\n    header-&gt;th_urp = <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">return</span> header;\n}\n\n<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tcp_syn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tcp_sock, struct tcphdr *header)</span>\n</span>{\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">sockaddr_in</span> *) <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">sockaddr_in</span>));</span>\n    addr-&gt;sin_family = PF_INET;\n    addr-&gt;sin_port = htons(<span class="hljs-number">4000</span>);\n    addr-&gt;sin_addr.s_addr = inet_addr(<span class="hljs-string">"172.16.2.127"</span>);\n    <span class="hljs-keyword">ssize_t</span> size = sendto(tcp_sock, header, <span class="hljs-keyword">sizeof</span>(struct tcphdr), <span class="hljs-number">0</span>, (struct sockaddr *)addr, <span class="hljs-keyword">sizeof</span>(addr));\n}\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span>\n</span>{\n    <span class="hljs-keyword">int</span> tcp_sock = socket(PF_INET, SOCK_RAW, IPPROTO_TCP);\n    <span class="hljs-keyword">if</span>(tcp_sock == <span class="hljs-number">-1</span>) \n    {\n        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Open Socket Failed: %s(errno: %d)\\n"</span>, strerror(errno), errno);\n        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);\n    }\n\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcpHdr</span> = <span class="hljs-title">init_tcp_header</span>(10001);</span>\n\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pseudohdr</span> *<span class="hljs-title">psdHdr</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">pseudohdr</span> *) <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">pseudohdr</span>));</span>\n    psdHdr-&gt;src_addr = inet_addr(<span class="hljs-string">"172.16.2.101"</span>);\n    psdHdr-&gt;dst_addr = inet_addr(<span class="hljs-string">"172.16.2.127"</span>);\n    psdHdr-&gt;zero = <span class="hljs-number">0</span>;\n    psdHdr-&gt;protocol = <span class="hljs-number">6</span>;\n    psdHdr-&gt;tcp_length = htons(<span class="hljs-keyword">sizeof</span>(struct tcphdr));\n    <span class="hljs-built_in">memcpy</span>(&amp;psdHdr-&gt;tcpHdr, tcpHdr, <span class="hljs-keyword">sizeof</span>(struct tcphdr));\n    tcpHdr-&gt;th_sum = htons(check_sum((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *) psdHdr, <span class="hljs-keyword">sizeof</span>(struct pseudohdr)));\n    <span class="hljs-built_in">free</span>(psdHdr);\n\n    tcp_syn(tcp_sock, tcpHdr);\n    <span class="hljs-built_in">free</span>(tcpHdr);\n}</code></pre><pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-09-18-TCP-SYN.json",ext:".json",sourceBase:"2018-09-18-TCP-SYN.md",sourceExt:".md"}},H67F:function(n){n.exports={title:"理解 Linux Kernel (5) - 文件系统(宏观描述)",author:"fangfeng",date:"2018-10-14T00:00:00.000Z",tags:["Kernel","Linux","File System"],bodyContent:"用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。\n\n```shell\n$ ls\nApplications Network      Users        bin          data         etc          net          sbin         usr\nLibrary      System       Volumes      cores        dev          home         private      tmp          var\n```\n\n但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?\n\n\x3c!-- more --\x3e\n\n## 文件系统的形式 \n\n首先我们假设文件是简单地存储在存储设备(硬盘等)某一块连续区域的。\n\n那么如何在小则几百G，大则几十T甚至更大的存储设备上找到具体的某一文件，并读取的内存中呢?\n\n最普通的，就只能在存储设备上一字节一字节的查找，直到找到相应的目标文件。是不是可以想象，这会很慢很慢。\n\n有没有快一点的？很容易想到，参考类似字典的形式就可以了。\n\n**目录形式**\n\n文件内容可能很大，但相比之下，文件名就小了很多(就算不同目录下同名文件很多，但是记录全路径名也代价不大。当然了，如果都是小文件、空文件，那就不一样了)\n\n通过为所有文件通过文件名编一个目录，指明每个文件在存储设备上的具体位置。这样需要扫描的内容就会小很多，也能更快地定位到文件内容。\n\n**逐级目录**\n\n仅仅只编制一个目录，那么层次目录又有什么实际意义吗？只是为了方便用户分类不同功能、目的的文件吗？\n\n利用逐级目录，可以考虑对次级目录的内容编制上一级目录。通过顶级目录定位次级目录的内容，次级目录定位再次级目录，最后对应目录下的文件的内容。\n\n## 文件系统的组织\n\n在之前的理解里，文件系统是接管了整个存储设备。似乎文件系统和存储设备就是直接关联的，两个不可分割。没有建立文件系统的硬盘就不能使用，而没有硬盘，文件系统就没有了载体。\n\n但是，在学习 Linux 的过程中，似乎发现也并不是这么一回事。没有直接硬盘，文件系统一样可以存在。一直都有在使用 `.img` 磁盘映像文件，只是没有意识到，这意识文件系统的一种载体。同样的，没有文件系统，在操作系统启动的过程中，一样是可以加载各种内容，乃至预置的文件信息。\n\n在 Linux 中，最常见的文件系统就是 ext2, ext3, ext4 之流了。偶尔也有听过用过，比如说准备接入新的硬盘的时候。但是，真正里面是什么样的。还真不了解，ext2,3,4 的区别，也根本不知道。\n\n当然了，本次也并不会对这些内容进行描述。由于一直在学习 Linux 0.11 版本的源码，接下来要描述的文件系统，也就是 0.11 版本直接使用的 minix 文件系统了。\n\n最开始，当然是应该有一个感官的印象，才能更方便地来理解文件系统的组织形式啦!\n\n### 创建文件系统\n\n这里我们创建一个 512 KB 大小的文件系统\n\n`mkfs` 应该是最简单的方式了。\n\n```shell\n$ touch disk.img            # 磁盘映像文件 (由于没有额外的磁盘，就以此作为新创建的 minix 文件系统的载体)\n$ dd if=/dev/zero of=disk.img bs=1024 count=512     # 先将文件的大小扩展到 512 KB ，否则在创建文件系统的时候会失败\n512+0 records in\n512+0 records out\n524288 bytes (524 kB, 512 KiB) copied, 0.00216049 s, 243 MB/s\n$ mkfs.minix disk.img 512   # 创建文件系统\n192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode\n512 blocks                  # 总共 512 个磁盘块\nFirstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的\nZonesize=1024               # 每个磁盘块的大小为 1024 B\nMaxsize=268966912           # 单一文件的最大大小\n```\n\n先来看看目前 disk.img 里面的内容\n\n```shell\n$ hexdump disk.img\n0000000 0000 0000 0000 0000 0000 0000 0000 0000\n*                                                   # * 表示这段数据全为 0\n0000400 00c0 0200 0001 0001 000a 0000 1c00 1008\n0000410 138f 0001 0000 0000 0000 0000 0000 0000\n0000420 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000800 0003 0000 0000 0000 0000 0000 0000 0000\n0000810 0000 0000 0000 0000 fffe ffff ffff ffff\n0000820 ffff ffff ffff ffff ffff ffff ffff ffff\n*                                                   # * 表示这段数据全为 ff ( * 总是表示与前一段数据一致的省略)\n0000c00 0003 0000 0000 0000 0000 0000 0000 0000\n0000c10 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000c30 0000 0000 0000 0000 0000 0000 0000 ff80\n0000c40 ffff ffff ffff ffff ffff ffff ffff ffff\n*\n0001000 41ed 0000 0040 0000 cf12 5bd3 0200 000a\n0001010 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0002800 0001 002e 0000 0000 0000 0000 0000 0000\n0002810 0000 0000 0000 0000 0000 0000 0000 0000\n0002820 0001 2e2e 0000 0000 0000 0000 0000 0000\n0002830 0000 0000 0000 0000 0000 0000 0000 0000\n0002840 0000 622e 6461 6c62 636f 736b 0000 0000\n0002850 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0080000                                             # 截止字节，0x80000 = 512 KB 并不存在\n```\n\n似乎并没有太多的感觉，现在我们往 disk.img 这个磁盘映像文件中添些内容再来看看。\n\n```shell\n$ mount disk.img /mnt   # 把 disk.img 挂载到 /mnt 目录下\n$ cd /mnt\n$ echo \"#include <stdio.h>\" > hello.c       # 创建 hello.c 文件，并写入 #include <stdio.h> \n$ umount /mnt           # 解挂 disk.img\n$ hexdump -C disk.img\n00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|\n00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000420  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|\n00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|\n*\n00000c00  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000c10  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000c30  00 00 00 00 00 00 00 00  00 00 00 00 00 00 80 ff  |................|\n00000c40  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|\n*\n00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|\n00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|\n00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|\n00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include <stdio.|\n00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h>..............|\n00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00080000\n```\n\n很明显，我们看到了 `#include <stdio.h>` 字样的内容，同时也出现了 `hello.c` 的文件名。\n\n需要注意，文件名和文件内容是相互割裂的，并没有直接存储在一起。\n\n### 文件系统存储结构\n\n那么，配合着上面的内容来看看文件系统的组织结构。\n\n首先可以注意到的是，每一段非零的数据的开始地址，基本都是在 `0x0000, 0x0400, 0x0800, 0x0c00, 0x1000` 。间隔了 0x0400 = 1KB，这就是最基本的块的大小。\n\nMinix 文件系统将 1024 B 作为基本块的大小。`disk.img` 这个 512 KB 的磁盘映像文件，也就恰好被分割成 512 块。\n\n```shell\n$ mkfs.minix disk.img 512   # 创建文件系统\n192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode\n512 blocks                  # 总共 512 个磁盘块\nFirstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的\nZonesize=1024               # 每个磁盘块的大小为 1024 B\nMaxsize=268966912           # 单一文件的最大大小\n```\n\n在回过头来看看前面创建文件系统的时候的信息，相信也就能够看懂一部分了。\n\n**块的作用划分**\n\n那么，每个块如何进行使用呢？\n\n首先，最开始的一个块并不会直接使用。我们知道引导程序应该出现在引导盘最开始 512 B。但是，有些盘有引导程序，有些盘又没有，如何处理呢？\n\n文件系统结构中，默认地不对第一个 1024 B 的块进行操作，即原本是什么数据就是什么数据，与文件系统并不相干。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fwnnc753epj31kw04tq35.jpg)\n\n除了引导块，之后还有超级块，inode 位图，逻辑块位图，inode 区块，数据区块\n\n**超级块**\n\n真正对 MINIX 文件系统起着统领性作用的，是超级块(第二个块)。\n\n```c\nstruct super_block {\n unsigned short s_ninodes;          /* i 节点的数量 */\n unsigned short s_nzones;           /* 总区块数量 */\n unsigned short s_imap_blocks;      /* i 节点位图的数量 */\n unsigned short s_zmap_blocks;      /* 区块位图的数量 */\n unsigned short s_firstdatazone;    /* 第一个数据块的编号 */\n unsigned short s_log_zone_size;    /* log2(磁盘块大小 / 逻辑块大小) */\n unsigned long s_max_size;          /* 单文件的最大长度 */\n unsigned short s_magic;            /* 文件系统的魔数 */\n\n /* 下面的内容是在内存中使用的，并不会在磁盘上进行读写 */\n struct buffer_head * s_imap[8];\n struct buffer_head * s_zmap[8];\n unsigned short s_dev;\n struct m_inode * s_isup;\n struct m_inode * s_imount;\n unsigned long s_time;\n struct task_struct * s_wait;\n unsigned char s_lock;\n unsigned char s_rd_only;\n unsigned char s_dirt;\n};\n```\n结合着 `disk.img` 的数据来看看。\n\n```sh\n00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|\n00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n\n0x00c0  -> 192 个 i 节点\n0x0200  -> 512 个逻辑块\n0x0001  -> 一个i节点位图\n0x0001  -> 一个逻辑块位图\n0x000a  -> 第一个数据块编号为 10 \n0x0000  -> log2(磁盘块大小 / 逻辑块大小) = 0 ，即磁盘块大小 = 逻辑块大小 = 1024 B\n0x10081c00 -> 单文件最大 268966912 B \n```\n\n**inode 位图**\n\ninode 位图的数据比较简单，是通过设置比特位 0、1 的方式，来直接表明相应编号的 i 节点是否存在。\n默认 i 节点从 1 号开始编号，0 号节点在 inode 位图上一定设置为 1 \n\n```sh\n00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|\n00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|\n```\n\n总共 192 个 i 节点，加上 0 号节点总计需占用 193 位 ( = 193 / 8 = 24 字节 + 1 位)\n\n其余多余的位，全部置位为 1 。\n\n位图存储的最初数据 0x07 (注意，小端存储法) = 0b111\n\n由此，总共有1号和2号i节点。\n\n**逻辑块位图**\n\n类似的，逻辑块位图是为了表明第n个逻辑块存储有数据，或处于空闲状态。\n\n**inode 区块**\n\n参照前面讲过的字典目录的形式，inode 就是一种分级编排后的目录。\n\n当然，说目录可能还会引发误解。这里无论是对于操作系统下的目录或是文件，每一个都对应着一个独特的 inode\n\n```c\nstruct d_inode {\n unsigned short i_mode;     /* 文件类型和属性 (rwx 位) */\n unsigned short i_uid;      /* 文件所有者 id */\n unsigned long i_size;      /* 文件大小 */\n unsigned long i_time;      /* 修改时间 */\n unsigned char i_gid;       /* 文件所在组 id */\n unsigned char i_nlinks;    /* 有多少个链接数 (有多少个文件目录项指向该 i 节点) */\n unsigned short i_zone[9];  /* 文件数据所占用数据盘的指针 */\n};\n```\n\n每个i节点的数据分别 32 字节\n\n同样的，结合 `disk.img` 的数据来看\n\n```\n00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|\n00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|\n00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n\n0x41ed  -> \n0x0000  ->  文件所有者为 0 即 root\n0x00000060  ->  文件大小为 96 B\n0x5bd40de5  ->  文件最后修改时间为 Unix TimeStamp 1540623845 => 2018/10/27 15:4:5\n0x00    ->  文件所在组 id\n0x02    ->  有两个文件目录项指向1号i节点\n0x000a  ->  1 号 i 节点指向的第0块数据为第10个逻辑块(即第1个数据块)\n0x0000  =>  由于数据比较小，后面的 i_zone[1] ~ i_zone[8] 均为 0\n```\n\ni\\_zone 指向的是数据实际存储的数据块的位置。\n\n但是，仅仅只有 9 个指针，每个数据块能存储 1024 B ，是远远达不到之前所描述的单文件 `0x10081c00 = 268966912 B` 的上限的。\n\n事实上，minix 在实际处理的过程中，把前7个指针作为直接数据块指针，最多存储 7168 B 数据。\n\ni\\_zone[7] 表示一次间接指针，指向某一个数据块，但是该数据块每2字节作为一个指针，指向真正的数据块。\n\ni\\_zone[8] 表示二次间接指针。\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fwnu3zrwuij310y0m6abj.jpg)\n<small>Copied from Linux 内核完全注释V3.0</small>\n\n**数据块**\n\n最后，我们看看数据块的内容，也希望能够更好地来理解 Linux 目录和文件的异同。\n\n```\n00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|\n00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include <stdio.|\n00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h>..............|\n00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n```\n\n在i节点区块上，我们看到有1号i节点和2号i节点已经被使用了。\n\n0x2800 ~ 0x2860 的位置表示的就是 1 号i节点的数据。事实上这是一个目录(当然，怎么区分目录还是文件，在i节点区块的 i_mode 字段已经描述过了)\n\n对于目录文件，当然是用来记载目录项的，每个目录项占用 32 字节。\n\n> 这里需要进行说明，MINIX 1.0 版本的文件系统似乎是对每个目录项占用 16 字节的。\n> \n> 这里提供一个 Linux 0.11 版本的仿真运行结果以供证明\n> ![](https://ws4.sinaimg.cn/large/006tNbRwly1fwnuexcwx7j30nw0c8745.jpg)\n> \n> 上面描述的 `disk.img` 是在 Ubuntu 16.04 LTS 下跑出来的结果，所有确实出现了一些差别。\n> 至于具体的一个规范，目前还没有找到，所有这部分只能做模糊处理了，勿怪。\n\n前2个字节用来表示该目录项所对应的 i 节点编号。之后的30个字节用来描述该目录项的名字。\n\n因此，对 0x2800 ~ 0x2860 的数据进行重建的结果就是 `. .. hello.c` 三个目录项了。其中，由于是根目录，`.` 和 `..` 所指向的i节点的相同的，都是1号i节点。\n\n而 hello.c 文件指向的是 2 号i节点。\n\n哈哈，2号i节点的数据内容就在 0x2c00 开始的位置。通过右侧的 ASCII 结果我们也可以看到。\n\n当然，之前说过每个数据块是 1024 B ，那么数据块多余的部分，就是留空咯，而不会被其它i节点占用(除非该文件or目录被完全移除了)\n\n## 小结\n\n到此为止，文件系统宏观的描述就已经完结了。\n\n下一节将对操作系统如何使用文件系统进行描述。\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```",bodyHtml:'<p>用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。</p>\n<pre><code class="hljs"><span class="hljs-meta">$</span><span class="bash"> ls</span>\nApplications Network      Users        bin          data         etc          net          sbin         usr\nLibrary      System       Volumes      cores        dev          home         private      tmp          var</code></pre><p>但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>文件系统的形式</h2>\n<p>首先我们假设文件是简单地存储在存储设备(硬盘等)某一块连续区域的。</p>\n<p>那么如何在小则几百G，大则几十T甚至更大的存储设备上找到具体的某一文件，并读取的内存中呢?</p>\n<p>最普通的，就只能在存储设备上一字节一字节的查找，直到找到相应的目标文件。是不是可以想象，这会很慢很慢。</p>\n<p>有没有快一点的？很容易想到，参考类似字典的形式就可以了。</p>\n<p><strong>目录形式</strong></p>\n<p>文件内容可能很大，但相比之下，文件名就小了很多(就算不同目录下同名文件很多，但是记录全路径名也代价不大。当然了，如果都是小文件、空文件，那就不一样了)</p>\n<p>通过为所有文件通过文件名编一个目录，指明每个文件在存储设备上的具体位置。这样需要扫描的内容就会小很多，也能更快地定位到文件内容。</p>\n<p><strong>逐级目录</strong></p>\n<p>仅仅只编制一个目录，那么层次目录又有什么实际意义吗？只是为了方便用户分类不同功能、目的的文件吗？</p>\n<p>利用逐级目录，可以考虑对次级目录的内容编制上一级目录。通过顶级目录定位次级目录的内容，次级目录定位再次级目录，最后对应目录下的文件的内容。</p>\n<h2>文件系统的组织</h2>\n<p>在之前的理解里，文件系统是接管了整个存储设备。似乎文件系统和存储设备就是直接关联的，两个不可分割。没有建立文件系统的硬盘就不能使用，而没有硬盘，文件系统就没有了载体。</p>\n<p>但是，在学习 Linux 的过程中，似乎发现也并不是这么一回事。没有直接硬盘，文件系统一样可以存在。一直都有在使用 <code>.img</code> 磁盘映像文件，只是没有意识到，这意识文件系统的一种载体。同样的，没有文件系统，在操作系统启动的过程中，一样是可以加载各种内容，乃至预置的文件信息。</p>\n<p>在 Linux 中，最常见的文件系统就是 ext2, ext3, ext4 之流了。偶尔也有听过用过，比如说准备接入新的硬盘的时候。但是，真正里面是什么样的。还真不了解，ext2,3,4 的区别，也根本不知道。</p>\n<p>当然了，本次也并不会对这些内容进行描述。由于一直在学习 Linux 0.11 版本的源码，接下来要描述的文件系统，也就是 0.11 版本直接使用的 minix 文件系统了。</p>\n<p>最开始，当然是应该有一个感官的印象，才能更方便地来理解文件系统的组织形式啦!</p>\n<h3>创建文件系统</h3>\n<p>这里我们创建一个 512 KB 大小的文件系统</p>\n<p><code>mkfs</code> 应该是最简单的方式了。</p>\n<pre><code class="hljs"><span class="hljs-meta">$</span><span class="bash"> touch disk.img            <span class="hljs-comment"># 磁盘映像文件 (由于没有额外的磁盘，就以此作为新创建的 minix 文件系统的载体)</span></span>\n<span class="hljs-meta">$</span><span class="bash"> dd <span class="hljs-keyword">if</span>=/dev/zero of=disk.img bs=1024 count=512     <span class="hljs-comment"># 先将文件的大小扩展到 512 KB ，否则在创建文件系统的时候会失败</span></span>\n512+0 records in\n512+0 records out\n524288 bytes (524 kB, 512 KiB) copied, 0.00216049 s, 243 MB/s\n<span class="hljs-meta">$</span><span class="bash"> mkfs.minix disk.img 512   <span class="hljs-comment"># 创建文件系统</span></span>\n192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode\n512 blocks                  # 总共 512 个磁盘块\nFirstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的\nZonesize=1024               # 每个磁盘块的大小为 1024 B\nMaxsize=268966912           # 单一文件的最大大小</code></pre><p>先来看看目前 disk.img 里面的内容</p>\n<pre><code class="hljs"><span class="hljs-meta">$</span><span class="bash"> hexdump disk.img</span>\n0000000 0000 0000 0000 0000 0000 0000 0000 0000\n*                                                   # * 表示这段数据全为 0\n0000400 00c0 0200 0001 0001 000a 0000 1c00 1008\n0000410 138f 0001 0000 0000 0000 0000 0000 0000\n0000420 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000800 0003 0000 0000 0000 0000 0000 0000 0000\n0000810 0000 0000 0000 0000 fffe ffff ffff ffff\n0000820 ffff ffff ffff ffff ffff ffff ffff ffff\n*                                                   # * 表示这段数据全为 ff ( * 总是表示与前一段数据一致的省略)\n0000c00 0003 0000 0000 0000 0000 0000 0000 0000\n0000c10 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000c30 0000 0000 0000 0000 0000 0000 0000 ff80\n0000c40 ffff ffff ffff ffff ffff ffff ffff ffff\n*\n0001000 41ed 0000 0040 0000 cf12 5bd3 0200 000a\n0001010 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0002800 0001 002e 0000 0000 0000 0000 0000 0000\n0002810 0000 0000 0000 0000 0000 0000 0000 0000\n0002820 0001 2e2e 0000 0000 0000 0000 0000 0000\n0002830 0000 0000 0000 0000 0000 0000 0000 0000\n0002840 0000 622e 6461 6c62 636f 736b 0000 0000\n0002850 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0080000                                             # 截止字节，0x80000 = 512 KB 并不存在</code></pre><p>似乎并没有太多的感觉，现在我们往 disk.img 这个磁盘映像文件中添些内容再来看看。</p>\n<pre><code class="hljs"><span class="hljs-meta">$</span><span class="bash"> mount disk.img /mnt   <span class="hljs-comment"># 把 disk.img 挂载到 /mnt 目录下</span></span>\n<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /mnt</span>\n<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"#include &lt;stdio.h&gt;"</span> &gt; hello.c       <span class="hljs-comment"># 创建 hello.c 文件，并写入 #include &lt;stdio.h&gt; </span></span>\n<span class="hljs-meta">$</span><span class="bash"> umount /mnt           <span class="hljs-comment"># 解挂 disk.img</span></span>\n<span class="hljs-meta">$</span><span class="bash"> hexdump -C disk.img</span>\n00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|\n00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000420  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|\n00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|\n*\n00000c00  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000c10  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000c30  00 00 00 00 00 00 00 00  00 00 00 00 00 00 80 ff  |................|\n00000c40  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|\n*\n00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|\n00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|\n00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|\n00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include &lt;stdio.|\n00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h&gt;..............|\n00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00080000</code></pre><p>很明显，我们看到了 <code>#include &lt;stdio.h&gt;</code> 字样的内容，同时也出现了 <code>hello.c</code> 的文件名。</p>\n<p>需要注意，文件名和文件内容是相互割裂的，并没有直接存储在一起。</p>\n<h3>文件系统存储结构</h3>\n<p>那么，配合着上面的内容来看看文件系统的组织结构。</p>\n<p>首先可以注意到的是，每一段非零的数据的开始地址，基本都是在 <code>0x0000, 0x0400, 0x0800, 0x0c00, 0x1000</code> 。间隔了 0x0400 = 1KB，这就是最基本的块的大小。</p>\n<p>Minix 文件系统将 1024 B 作为基本块的大小。<code>disk.img</code> 这个 512 KB 的磁盘映像文件，也就恰好被分割成 512 块。</p>\n<pre><code class="hljs"><span class="hljs-meta">$</span><span class="bash"> mkfs.minix disk.img 512   <span class="hljs-comment"># 创建文件系统</span></span>\n192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode\n512 blocks                  # 总共 512 个磁盘块\nFirstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的\nZonesize=1024               # 每个磁盘块的大小为 1024 B\nMaxsize=268966912           # 单一文件的最大大小</code></pre><p>在回过头来看看前面创建文件系统的时候的信息，相信也就能够看懂一部分了。</p>\n<p><strong>块的作用划分</strong></p>\n<p>那么，每个块如何进行使用呢？</p>\n<p>首先，最开始的一个块并不会直接使用。我们知道引导程序应该出现在引导盘最开始 512 B。但是，有些盘有引导程序，有些盘又没有，如何处理呢？</p>\n<p>文件系统结构中，默认地不对第一个 1024 B 的块进行操作，即原本是什么数据就是什么数据，与文件系统并不相干。</p>\n<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwnnc753epj31kw04tq35.jpg" alt=""></p>\n<p>除了引导块，之后还有超级块，inode 位图，逻辑块位图，inode 区块，数据区块</p>\n<p><strong>超级块</strong></p>\n<p>真正对 MINIX 文件系统起着统领性作用的，是超级块(第二个块)。</p>\n<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> {</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> s_ninodes;          <span class="hljs-comment">/* i 节点的数量 */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> s_nzones;           <span class="hljs-comment">/* 总区块数量 */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> s_imap_blocks;      <span class="hljs-comment">/* i 节点位图的数量 */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> s_zmap_blocks;      <span class="hljs-comment">/* 区块位图的数量 */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> s_firstdatazone;    <span class="hljs-comment">/* 第一个数据块的编号 */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> s_log_zone_size;    <span class="hljs-comment">/* log2(磁盘块大小 / 逻辑块大小) */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> s_max_size;          <span class="hljs-comment">/* 单文件的最大长度 */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> s_magic;            <span class="hljs-comment">/* 文件系统的魔数 */</span>\n\n <span class="hljs-comment">/* 下面的内容是在内存中使用的，并不会在磁盘上进行读写 */</span>\n <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">s_imap</span>[8];</span>\n <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">s_zmap</span>[8];</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> s_dev;\n <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">s_isup</span>;</span>\n <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">s_imount</span>;</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> s_time;\n <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> * <span class="hljs-title">s_wait</span>;</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> s_lock;\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> s_rd_only;\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> s_dirt;\n};</code></pre><p>结合着 <code>disk.img</code> 的数据来看看。</p>\n<pre><code class="hljs">00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|\n00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n\n0x00c0  -&gt; 192 个 i 节点\n0x0200  -&gt; 512 个逻辑块\n0x0001  -&gt; 一个i节点位图\n0x0001  -&gt; 一个逻辑块位图\n0x000a  -&gt; 第一个数据块编号为 10 \n0x0000  -&gt; log2(磁盘块大小 / 逻辑块大小) = 0 ，即磁盘块大小 = 逻辑块大小 = 1024 B\n0x10081c00 -&gt; 单文件最大 268966912 B</code></pre><p><strong>inode 位图</strong></p>\n<p>inode 位图的数据比较简单，是通过设置比特位 0、1 的方式，来直接表明相应编号的 i 节点是否存在。\n默认 i 节点从 1 号开始编号，0 号节点在 inode 位图上一定设置为 1</p>\n<pre><code class="hljs">00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|\n00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</code></pre><p>总共 192 个 i 节点，加上 0 号节点总计需占用 193 位 ( = 193 / 8 = 24 字节 + 1 位)</p>\n<p>其余多余的位，全部置位为 1 。</p>\n<p>位图存储的最初数据 0x07 (注意，小端存储法) = 0b111</p>\n<p>由此，总共有1号和2号i节点。</p>\n<p><strong>逻辑块位图</strong></p>\n<p>类似的，逻辑块位图是为了表明第n个逻辑块存储有数据，或处于空闲状态。</p>\n<p><strong>inode 区块</strong></p>\n<p>参照前面讲过的字典目录的形式，inode 就是一种分级编排后的目录。</p>\n<p>当然，说目录可能还会引发误解。这里无论是对于操作系统下的目录或是文件，每一个都对应着一个独特的 inode</p>\n<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">d_inode</span> {</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> i_mode;     <span class="hljs-comment">/* 文件类型和属性 (rwx 位) */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> i_uid;      <span class="hljs-comment">/* 文件所有者 id */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> i_size;      <span class="hljs-comment">/* 文件大小 */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> i_time;      <span class="hljs-comment">/* 修改时间 */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> i_gid;       <span class="hljs-comment">/* 文件所在组 id */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> i_nlinks;    <span class="hljs-comment">/* 有多少个链接数 (有多少个文件目录项指向该 i 节点) */</span>\n <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> i_zone[<span class="hljs-number">9</span>];  <span class="hljs-comment">/* 文件数据所占用数据盘的指针 */</span>\n};</code></pre><p>每个i节点的数据分别 32 字节</p>\n<p>同样的，结合 <code>disk.img</code> 的数据来看</p>\n<pre><code>00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|\n00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|\n00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n\n0x41ed  -&gt; \n0x0000  -&gt;  文件所有者为 0 即 root\n0x00000060  -&gt;  文件大小为 96 B\n0x5bd40de5  -&gt;  文件最后修改时间为 Unix TimeStamp 1540623845 =&gt; 2018/10/27 15:4:5\n0x00    -&gt;  文件所在组 id\n0x02    -&gt;  有两个文件目录项指向1号i节点\n0x000a  -&gt;  1 号 i 节点指向的第0块数据为第10个逻辑块(即第1个数据块)\n0x0000  =&gt;  由于数据比较小，后面的 i_zone[1] ~ i_zone[8] 均为 0\n</code></pre>\n<p>i_zone 指向的是数据实际存储的数据块的位置。</p>\n<p>但是，仅仅只有 9 个指针，每个数据块能存储 1024 B ，是远远达不到之前所描述的单文件 <code>0x10081c00 = 268966912 B</code> 的上限的。</p>\n<p>事实上，minix 在实际处理的过程中，把前7个指针作为直接数据块指针，最多存储 7168 B 数据。</p>\n<p>i_zone[7] 表示一次间接指针，指向某一个数据块，但是该数据块每2字节作为一个指针，指向真正的数据块。</p>\n<p>i_zone[8] 表示二次间接指针。</p>\n<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwnu3zrwuij310y0m6abj.jpg" alt="">\n&lt;small&gt;Copied from Linux 内核完全注释V3.0&lt;/small&gt;</p>\n<p><strong>数据块</strong></p>\n<p>最后，我们看看数据块的内容，也希望能够更好地来理解 Linux 目录和文件的异同。</p>\n<pre><code>00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|\n00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include &lt;stdio.|\n00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h&gt;..............|\n00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n</code></pre>\n<p>在i节点区块上，我们看到有1号i节点和2号i节点已经被使用了。</p>\n<p>0x2800 ~ 0x2860 的位置表示的就是 1 号i节点的数据。事实上这是一个目录(当然，怎么区分目录还是文件，在i节点区块的 i_mode 字段已经描述过了)</p>\n<p>对于目录文件，当然是用来记载目录项的，每个目录项占用 32 字节。</p>\n<blockquote>\n<p>这里需要进行说明，MINIX 1.0 版本的文件系统似乎是对每个目录项占用 16 字节的。</p>\n<p>这里提供一个 Linux 0.11 版本的仿真运行结果以供证明\n<img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwnuexcwx7j30nw0c8745.jpg" alt=""></p>\n<p>上面描述的 <code>disk.img</code> 是在 Ubuntu 16.04 LTS 下跑出来的结果，所有确实出现了一些差别。\n至于具体的一个规范，目前还没有找到，所有这部分只能做模糊处理了，勿怪。</p>\n</blockquote>\n<p>前2个字节用来表示该目录项所对应的 i 节点编号。之后的30个字节用来描述该目录项的名字。</p>\n<p>因此，对 0x2800 ~ 0x2860 的数据进行重建的结果就是 <code>. .. hello.c</code> 三个目录项了。其中，由于是根目录，<code>.</code> 和 <code>..</code> 所指向的i节点的相同的，都是1号i节点。</p>\n<p>而 hello.c 文件指向的是 2 号i节点。</p>\n<p>哈哈，2号i节点的数据内容就在 0x2c00 开始的位置。通过右侧的 ASCII 结果我们也可以看到。</p>\n<p>当然，之前说过每个数据块是 1024 B ，那么数据块多余的部分，就是留空咯，而不会被其它i节点占用(除非该文件or目录被完全移除了)</p>\n<h2>小结</h2>\n<p>到此为止，文件系统宏观的描述就已经完结了。</p>\n<p>下一节将对操作系统如何使用文件系统进行描述。</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-10-14-understand-Kernel-5.json",ext:".json",sourceBase:"2018-10-14-understand-Kernel-5.md",sourceExt:".md"}},IBPC:function(n){n.exports={title:"【Java】API 参数误定义的后果",author:"fangfeng",date:"2019-02-27T00:00:00.000Z",tags:["Java","API"],bodyContent:'工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。\n\n想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！\n\n想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把`void add(int)` API 改写成 `int add(int)`，可能得到的大多数回答都是可以。\n\n\x3c!-- more --\x3e\n\n## 看山是山\n\n首先举一个具体点的例子来描述（为了方便，就不定义`CountService`的接口类了）\n\n```java\npackage com.ffutop.signature;\n\n/**\n * 主类\n * @author fangfeng\n * @since 2019-02-26\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        CountService countService = new CountService();\n        countService.add(1);\n        System.out.println(String.format("currentValue = %d", countService.getCurrentValue()));\n    }\n}\n```\n\n```java\npackage com.ffutop.signature;\n\n/**\n * @author fangfeng\n * @since 2019-02-26\n */\npublic class CountService {\n\n    private int currentValue = 0;\n\n    /**\n     * 请把 add(int) 理解成 API\n     * 虽然已经做了实现\n     */\n    public void add(int addend) {\n        currentValue += addend;\n    }\n\n    public int getCurrentValue() {\n        return currentValue;\n    }\n}\n```\n\n现在已经有 `void add(int)` 方法，完成的工作是累加。现在要把 API 改成 `int add(int)`，是否可以呢？看似本来没有返回值，现在只是加上一个返回值，对于原来的代码没有任何问题，而新代码又能拿到int类型的返回值，皆大欢喜啊。\n\n## 看山不是山\n\n先给大家执行下代码吧！（请严格按照顺序，且避免使用IDE，否则将得不到预想的结果）\n\n```shell\n$ # 准备好两个类的代码（CountService的API是 `void add(int)`）\n$ # 编译Main类\n$ javac com/ffutop/signature/Main.java\n$  \n$ # 修改CountService的API为`int add(int)`\n$ # 编译 CountService 类\n$ javac com/ffutop/signature/CountService.java\n$ \n$ # 执行主程序\n$ java com.ffutop.signature.Main\nException in thread "main" java.lang.NoSuchMethodError: com.ffutop.signature.CountService.add(I)V\n\tat com.ffutop.signature.Main.main(Main.java:11)\n```\n\n很遗憾，执行失败了，报了个Error（没有这样的方法）。方法写的是 `com.ffutop.signature.CountService.add(I)V` 。简单的翻译一下就是需要`类名+方法名=x.y.CountService.add`，且入参为int，出参为void的方法（想了解更多请优先学习[Java ClassFile Format](https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4)）。\n\n那么，现在得到的结论是不行。\n\n## 看山还是山\n\n那么，就一定不行吗？都是同名方法，不同参数。凭什么改个入参是可以的，改个出参就不行了。\n\n从 Java 的角度来说，一定不行。“同一类中不能存在两个名字及描述符完全相同的方法”\n\n但是，如果从 JVM 的角度来说，完全是可行的。“在class文件中，两个方法可以拥有完全相同的特征签名，前提是返回值不能相同”\n\n什么意思呢？我们都知道建立在 JVM 之上的语言不只有 Java。像 Groovy、Kotlin 等语言都实现了各自的区别于 Java 独有的特征。这些特征的实现都是依赖于 JVM，但为什么 Java 没有呢？只能说 Java 语言的规范是 JVM 的子集（好像这话有点不严谨啊）\n\n通过直接操作字节码，就能够达到在同一个类中建立两个同名、相同入参，但返回值不同的方法。\n先通过`javap`命令看看最终提供的`CountService.class`\n\n```shell\n$ javap com.ffutop.signature.CountService\npublic class com.ffutop.signature.CountService {\n  public int add(int);\n  public com.ffutop.signature.CountService();\n  public void add(int);\n  public int getCurrentValue();\n}\n```\n\n有两个同名的方法`add(int)`，至于执行，也会相当顺利。\n\n还是写个程序来说明，在原有 `Main.java` 的基础上，再创建一个全限定名为 `com.ffutop.signature.other.Main2` 的类\n\n```java\npackage com.ffutop.signature.other;\nimport com.ffutop.signature.CountService;\n\n/**\n * @author fangfeng\n * @since 2019-02-27\n */\npublic class Main2 {\n\n    public static void main(String[] args) {\n        CountService countService = new CountService();\n        System.out.println(String.format("currentValue = %d", countService.add(1)));\n    }\n}\n```\n\n与 Main.java 比较，很明显的就是一个调用了 `CountService` 的 `int add(int)` 方法，而另一个调用 `void add(int)` 方法。\n\n那么是否有效呢？先来验证一下（这里要模拟的一个场景是，CountService 类(只有 `void add(int)` 方法)作为二方库C.jar version 1.0 的主要服务类。CountService 类(同时有 `void add(int)` 和 `int add(int)` 方法)作为二方库C.jar version 2.0 的主要服务类。Main 类根据 C.jar version 1.0 做的编译，而 Main2 类根据 C.jar version 2.0 做的编译。在 Main 和 Main2 类运行时只提供 C.jar version 2.0）\n\n```shell\n$ # 编译 Main 类和 CountService 类\n$ javac com/ffutop/signature/Main.java\n$\n$ # 操作 CountService.class 字节码，增加方法 `int add(int)` \n$ # 通过 ASM 实现，详见附录源码 com/ffutop/signature/support/Generator.java\n$ \n$ # 编译 Main2 类 (提供 classpath，即根据 CountService.class 编译)\n$ javac com/ffutop/signature/other/Main2.java -classpath .\n$\n$ # 验证\n$ java com.ffutop.signature.Main\ncurrentValue = 1\n$ java com.ffutop.signature.other.Main2\ncurrentValue = 1\n$ # OK，验证通过\n```\n\n## 总结\n\n一旦 API 定义错误，并已经作为二方库提供给调用方。后果必然是灾难性的。至少，只能重新定义 API 。如果对于入参定义错误，Java 语言级别也能够支持。但如果是返回值，如果非要保持方法名一致，那就不得不下沉到 JVM 级别来进行处理了。当然，在工程项目中是否应该直接操作字节码？至少个人还没直接接触过。\n\n做个记录，未来可以翻一翻，至少是一种可行的解决方案。\n\nUpdate: 如果直接操作字节码为添加了不同返回值的同名同参数方法，可能引起调用方静态编译失败。此操作需慎之又慎。也许提供类加载器加载时的字节码操作能更加完美地解决这个问题。\n\n## 参考\n\n[源码.zip](https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/signature.zip)\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<p>工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。</p>\n<p>想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！</p>\n<p>想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把<code>void add(int)</code> API 改写成 <code>int add(int)</code>，可能得到的大多数回答都是可以。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>看山是山</h2>\n<p>首先举一个具体点的例子来描述（为了方便，就不定义<code>CountService</code>的接口类了）</p>\n<pre><code class="hljs"><span class="hljs-keyword">package</span> com.ffutop.signature;\n\n<span class="hljs-comment">/**\n * 主类\n * <span class="hljs-doctag">@author</span> fangfeng\n * <span class="hljs-doctag">@since</span> 2019-02-26\n */</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n        CountService countService = <span class="hljs-keyword">new</span> CountService();\n        countService.add(<span class="hljs-number">1</span>);\n        System.out.println(String.format(<span class="hljs-string">"currentValue = %d"</span>, countService.getCurrentValue()));\n    }\n}</code></pre><pre><code class="hljs"><span class="hljs-keyword">package</span> com.ffutop.signature;\n\n<span class="hljs-comment">/**\n * <span class="hljs-doctag">@author</span> fangfeng\n * <span class="hljs-doctag">@since</span> 2019-02-26\n */</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountService</span> </span>{\n\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentValue = <span class="hljs-number">0</span>;\n\n    <span class="hljs-comment">/**\n     * 请把 add(int) 理解成 API\n     * 虽然已经做了实现\n     */</span>\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> addend)</span> </span>{\n        currentValue += addend;\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCurrentValue</span><span class="hljs-params">()</span> </span>{\n        <span class="hljs-keyword">return</span> currentValue;\n    }\n}</code></pre><p>现在已经有 <code>void add(int)</code> 方法，完成的工作是累加。现在要把 API 改成 <code>int add(int)</code>，是否可以呢？看似本来没有返回值，现在只是加上一个返回值，对于原来的代码没有任何问题，而新代码又能拿到int类型的返回值，皆大欢喜啊。</p>\n<h2>看山不是山</h2>\n<p>先给大家执行下代码吧！（请严格按照顺序，且避免使用IDE，否则将得不到预想的结果）</p>\n<pre><code class="hljs"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 准备好两个类的代码（CountService的API是 `void add(int)`）</span></span>\n<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 编译Main类</span></span>\n<span class="hljs-meta">$</span><span class="bash"> javac com/ffutop/signature/Main.java</span>\n<span class="hljs-meta">$</span><span class="bash">  </span>\n<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 修改CountService的API为`int add(int)`</span></span>\n<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 编译 CountService 类</span></span>\n<span class="hljs-meta">$</span><span class="bash"> javac com/ffutop/signature/CountService.java</span>\n<span class="hljs-meta">$</span><span class="bash"> </span>\n<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 执行主程序</span></span>\n<span class="hljs-meta">$</span><span class="bash"> java com.ffutop.signature.Main</span>\nException in thread "main" java.lang.NoSuchMethodError: com.ffutop.signature.CountService.add(I)V\n\tat com.ffutop.signature.Main.main(Main.java:11)</code></pre><p>很遗憾，执行失败了，报了个Error（没有这样的方法）。方法写的是 <code>com.ffutop.signature.CountService.add(I)V</code> 。简单的翻译一下就是需要<code>类名+方法名=x.y.CountService.add</code>，且入参为int，出参为void的方法（想了解更多请优先学习<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4">Java ClassFile Format</a>）。</p>\n<p>那么，现在得到的结论是不行。</p>\n<h2>看山还是山</h2>\n<p>那么，就一定不行吗？都是同名方法，不同参数。凭什么改个入参是可以的，改个出参就不行了。</p>\n<p>从 Java 的角度来说，一定不行。“同一类中不能存在两个名字及描述符完全相同的方法”</p>\n<p>但是，如果从 JVM 的角度来说，完全是可行的。“在class文件中，两个方法可以拥有完全相同的特征签名，前提是返回值不能相同”</p>\n<p>什么意思呢？我们都知道建立在 JVM 之上的语言不只有 Java。像 Groovy、Kotlin 等语言都实现了各自的区别于 Java 独有的特征。这些特征的实现都是依赖于 JVM，但为什么 Java 没有呢？只能说 Java 语言的规范是 JVM 的子集（好像这话有点不严谨啊）</p>\n<p>通过直接操作字节码，就能够达到在同一个类中建立两个同名、相同入参，但返回值不同的方法。\n先通过<code>javap</code>命令看看最终提供的<code>CountService.class</code></p>\n<pre><code class="hljs"><span class="hljs-meta">$</span><span class="bash"> javap com.ffutop.signature.CountService</span>\npublic class com.ffutop.signature.CountService {\n  public int add(int);\n  public com.ffutop.signature.CountService();\n  public void add(int);\n  public int getCurrentValue();\n}</code></pre><p>有两个同名的方法<code>add(int)</code>，至于执行，也会相当顺利。</p>\n<p>还是写个程序来说明，在原有 <code>Main.java</code> 的基础上，再创建一个全限定名为 <code>com.ffutop.signature.other.Main2</code> 的类</p>\n<pre><code class="hljs"><span class="hljs-keyword">package</span> com.ffutop.signature.other;\n<span class="hljs-keyword">import</span> com.ffutop.signature.CountService;\n\n<span class="hljs-comment">/**\n * <span class="hljs-doctag">@author</span> fangfeng\n * <span class="hljs-doctag">@since</span> 2019-02-27\n */</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main2</span> </span>{\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n        CountService countService = <span class="hljs-keyword">new</span> CountService();\n        System.out.println(String.format(<span class="hljs-string">"currentValue = %d"</span>, countService.add(<span class="hljs-number">1</span>)));\n    }\n}</code></pre><p>与 Main.java 比较，很明显的就是一个调用了 <code>CountService</code> 的 <code>int add(int)</code> 方法，而另一个调用 <code>void add(int)</code> 方法。</p>\n<p>那么是否有效呢？先来验证一下（这里要模拟的一个场景是，CountService 类(只有 <code>void add(int)</code> 方法)作为二方库C.jar version 1.0 的主要服务类。CountService 类(同时有 <code>void add(int)</code> 和 <code>int add(int)</code> 方法)作为二方库C.jar version 2.0 的主要服务类。Main 类根据 C.jar version 1.0 做的编译，而 Main2 类根据 C.jar version 2.0 做的编译。在 Main 和 Main2 类运行时只提供 C.jar version 2.0）</p>\n<pre><code class="hljs"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 编译 Main 类和 CountService 类</span></span>\n<span class="hljs-meta">$</span><span class="bash"> javac com/ffutop/signature/Main.java</span>\n<span class="hljs-meta">$</span><span class="bash"></span>\n<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 操作 CountService.class 字节码，增加方法 `int add(int)` </span></span>\n<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 通过 ASM 实现，详见附录源码 com/ffutop/signature/support/Generator.java</span></span>\n<span class="hljs-meta">$</span><span class="bash"> </span>\n<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 编译 Main2 类 (提供 classpath，即根据 CountService.class 编译)</span></span>\n<span class="hljs-meta">$</span><span class="bash"> javac com/ffutop/signature/other/Main2.java -classpath .</span>\n<span class="hljs-meta">$</span><span class="bash"></span>\n<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 验证</span></span>\n<span class="hljs-meta">$</span><span class="bash"> java com.ffutop.signature.Main</span>\ncurrentValue = 1\n<span class="hljs-meta">$</span><span class="bash"> java com.ffutop.signature.other.Main2</span>\ncurrentValue = 1\n<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># OK，验证通过</span></span></code></pre><h2>总结</h2>\n<p>一旦 API 定义错误，并已经作为二方库提供给调用方。后果必然是灾难性的。至少，只能重新定义 API 。如果对于入参定义错误，Java 语言级别也能够支持。但如果是返回值，如果非要保持方法名一致，那就不得不下沉到 JVM 级别来进行处理了。当然，在工程项目中是否应该直接操作字节码？至少个人还没直接接触过。</p>\n<p>做个记录，未来可以翻一翻，至少是一种可行的解决方案。</p>\n<p>Update: 如果直接操作字节码为添加了不同返回值的同名同参数方法，可能引起调用方静态编译失败。此操作需慎之又慎。也许提供类加载器加载时的字节码操作能更加完美地解决这个问题。</p>\n<h2>参考</h2>\n<p><a href="https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/signature.zip">源码.zip</a></p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2019-02-27-Java-Fatal-API.json",ext:".json",sourceBase:"2019-02-27-Java-Fatal-API.md",sourceExt:".md"}},KZDG:function(n){n.exports={title:"ASM 核心包基本内容漫谈",author:"fangfeng",date:"2018-06-25T00:00:00.000Z",tags:["Java","ASM","Visitor Pattern"],bodyContent:"> 本文描述的 ASM 指的是 OW2 ASM\n\n## ASM-Core 的结构\n\n*首先是一些概述性的内容。*\n\n由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。\n因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)\n\n从核心包声明的类来看，主要包括:\n\n1. ClassReader - 作为结构化对象，将接收(accept)访问者的访问\n\n2. 几种访问者抽象类以及相应的实现类\n- AnnotationVisitor -> AnnotationWriter\n- ClassVisitor -> ClassWriter\n- FieldVisitor -> FieldWriter\n- MethodVisitor -> MethodWriter\n- ModuleVisitor -> ModuleWriter\n\n3. Opcodes & Constants - ClassFile 中描述的大量常量符号与值\n\n4. 其它一些辅助的类\n- Attribute - 用于处理非标准化的属性(ClassFile 允许[JVMS](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html) 中未定义的 Attribute)\n- ByteArray - 动态可自适应的 byte\\[\\] (字节数组)\n- Context - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象\n- Symbol - 用于表示 ClassFile 中描述的 Constant 的基类\n- SymbolTable - 用于存储常量池对象\n- 其它内容省略\n\n\x3c!-- more --\x3e\n\n## ClassFile 文件格式\n\n本节的内容可以参阅 [ClassFile 文件格式](https://dormouse-none.github.io/2018-06-11-ASM-ClassReader/)\n\nClassFile 是 ASM 操作字节码的基础与前提。在 JVMS 定义了 .class 文件格式之后，ASM 才在此基础上进行了对 ClassFile 的字节码操作。\n\n因此，无论如何，个人认为在真正开始了解 ASM 之前，通读一遍 ClassFile 文件格式是完全有必要的。并且，在基本了解 ClassFile 内容的基础上，\n尝试对某个 .class 文件进行手工解析也不失为一种加深理解的途径。\n\n## Visitor Pattern\n\n由于 ASM 的实现采用了偏门的访问者模式。因此，了解访问者模式也是一个必不可少的重要环节。同时在了解后也将为源码阅读者提供更清晰的解读思路。\n\n《设计模式：可复用面向对象软件的基础》一书的“5.11 VISITOR(访问者)——对象行为型模式”提供了很详尽的解释。\n\n本人对这方面的不甚了解，推荐自行查找资料。\n\n## ClassReader\n\nClassReader 是解析现有的 .class 文件的基本工具。同时，ClassReader 也作为一个内容的持有者，与 SymboleTable 配合，来满足访问者基本的访问需求。\n\n刨除大量的内部私有方法，ClassReader 对外开放的接口相当简单。最核心的方法仅包括 ClassReader(...) 以及 accetp(...)\n\n### ClassReader(...) 构造方法\n\n顾名思义，构造方法用于实例化 ClassReader 对象，包括一些必须的变量的初始化。\n\n在构造函数中完成的初始化内容包括:\n  - 校验版本号\n  - 存储每个常量池项目的起始偏移量 cpInfoOffsets\n  - 存储每个引导方法的起始偏移量 bootstrapMethodOffsets\n  - 存储最长字符串常量的大小 maxStringLength\n\n```java\n  ClassReader(final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {\n    this.b = classFileBuffer;   // .class 文件缓存\n    // 检查主版本号, 第6,7个字节(从0字节开始计数)\n    if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V11) {\n      throw new IllegalArgumentException(\n          \"Unsupported class file major version \" + readShort(classFileOffset + 6));\n    }\n    // 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节\n    int constantPoolCount = readUnsignedShort(classFileOffset + 8);     // 读取无符号short, 即读取连续两字节作为一个short值\n    cpInfoOffsets = new int[constantPoolCount];                         // 每个常量的偏移位置\n    cpInfoValues = new Object[constantPoolCount];                       // 每个常量的实例对象\n    int currentCpInfoIndex = 1;\n    int currentCpInfoOffset = classFileOffset + 10;\n    int currentMaxStringLength = 0;                                     // 最长字符串常量\n    while (currentCpInfoIndex < constantPoolCount) {\n      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;\n      int cpInfoSize;\n      switch (classFileBuffer[currentCpInfoOffset]) {\n        case Symbol.CONSTANT_FIELDREF_TAG:\n        case Symbol.CONSTANT_METHODREF_TAG:\n        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n        case Symbol.CONSTANT_INTEGER_TAG:\n        case Symbol.CONSTANT_FLOAT_TAG:\n        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n        case Symbol.CONSTANT_DYNAMIC_TAG:\n          cpInfoSize = 5;\n          break;\n        case Symbol.CONSTANT_LONG_TAG:\n        case Symbol.CONSTANT_DOUBLE_TAG:\n          cpInfoSize = 9;\n          currentCpInfoIndex++;\n          break;\n        case Symbol.CONSTANT_UTF8_TAG:\n          cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);\n          if (cpInfoSize > currentMaxStringLength) {\n            // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate\n            // of the length in characters of the corresponding string, and is much cheaper to\n            // compute than this exact length.\n            currentMaxStringLength = cpInfoSize;\n          }\n          break;\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n          cpInfoSize = 4;\n          break;\n        case Symbol.CONSTANT_CLASS_TAG:\n        case Symbol.CONSTANT_STRING_TAG:\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\n        case Symbol.CONSTANT_PACKAGE_TAG:\n        case Symbol.CONSTANT_MODULE_TAG:\n          cpInfoSize = 3;\n          break;\n        default:\n          throw new IllegalArgumentException();\n      }\n      currentCpInfoOffset += cpInfoSize;\n    }\n    this.maxStringLength = currentMaxStringLength;\n    // The Classfile's access_flags field is just after the last constant pool entry.\n    this.header = currentCpInfoOffset;\n\n    // 读取 BootstrapMethods 属性(如果存在)\n    int currentAttributeOffset = getFirstAttributeOffset();\n    int[] currentBootstrapMethodOffsets = null;\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n      // 读取每个 attribute_info 的属性名和属性长度\n      String attributeName = readUTF8(currentAttributeOffset, new char[maxStringLength]);\n      int attributeLength = readInt(currentAttributeOffset + 2);\n      currentAttributeOffset += 6;\n      // 如果当前属性名为 BootstrapMethods ，则进入处理逻辑\n      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        // Read the num_bootstrap_methods field and create an array of this size.\n        currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];\n        // Compute and store the offset of each 'bootstrap_methods' array field entry.\n        int currentBootstrapMethodOffset = currentAttributeOffset + 2;\n        for (int j = 0; j < currentBootstrapMethodOffsets.length; ++j) {\n          currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;\n          // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\n          // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\n          currentBootstrapMethodOffset +=\n              4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\n        }\n      }\n      currentAttributeOffset += attributeLength;\n    }\n    this.bootstrapMethodOffsets = currentBootstrapMethodOffsets;\n  }\n```\n\n到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。\n但是，诸如 field\\_info, method\\_info, attribute\\_info 等仍然没有得到处理。\n\n### accept(...)\n\n访问者模式的核心操作就是结构化对象接受(accept)访问者对象实例的访问，并将结构化内容完全暴露给访问者。\n\n从抽象的方法角度看，可以理解成:\n\n```java\n\n  // --- 结构化对象的 accept() 方法 ---\n  public void accept(Visitor visitor) {\n    visitor.visit(this);\n  }\n\n  // --- 访问者对象的 visit() 方法 ---\n  public Xxx visit(Element element) {\n    // 若干关于 element 的读操作 + 其它操作\n  }\n```\n\n```java\npublic void accept(\n      final ClassVisitor classVisitor,\n      final Attribute[] attributePrototypes,\n      final int parsingOptions) {\n    // 定义 Context 作为辅助类，暂存被访问过程的“累积状态”\n    Context context = new Context();\n    context.attributePrototypes = attributePrototypes;\n    /**\n     * 解析选项: \n     * 1. SKIP_CODE - 不解析 CODE 属性 \n     * 2. SKIP_DEBUG - 不解析 DEBUG 相关的属性(例如SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable, LineNumberTable)\n     * 4. SKIP_FRAMES - 跳过对 StackMap 和 StackMapTable 属性的解析\n     * ...\n     */\n    context.parsingOptions = parsingOptions;\n    // 从常量池读取常量所使用的缓冲数字\n    context.charBuffer = new char[maxStringLength];\n\n    // Read the access_flags, this_class, super_class, interface_count and interfaces fields.\n    // 解析访问控制, 当前类, 父类, 接口数量与接口值等\n    char[] charBuffer = context.charBuffer;\n    int currentOffset = header;\n    int accessFlags = readUnsignedShort(currentOffset);\n    String thisClass = readClass(currentOffset + 2, charBuffer);\n    String superClass = readClass(currentOffset + 4, charBuffer);\n    String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];\n    currentOffset += 8;\n    for (int i = 0; i < interfaces.length; ++i) {\n      interfaces[i] = readClass(currentOffset, charBuffer);\n      currentOffset += 2;\n    }\n\n    // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n    // - The offset of the InnerClasses attribute, or 0.\n    int innerClassesOffset = 0;\n    // - The offset of the EnclosingMethod attribute, or 0.\n    int enclosingMethodOffset = 0;\n    // - The string corresponding to the Signature attribute, or null.\n    String signature = null;\n    // - The string corresponding to the SourceFile attribute, or null.\n    String sourceFile = null;\n    // - The string corresponding to the SourceDebugExtension attribute, or null.\n    String sourceDebugExtension = null;\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n    int runtimeVisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n    int runtimeInvisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n    int runtimeVisibleTypeAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\n    // - The offset of the Module attribute, or 0.\n    int moduleOffset = 0;\n    // - The offset of the ModulePackages attribute, or 0.\n    int modulePackagesOffset = 0;\n    // - The string corresponding to the ModuleMainClass attribute, or null.\n    String moduleMainClass = null;\n    // - The string corresponding to the NestHost attribute, or null.\n    String nestHostClass = null;\n    // - The offset of the NestMembers attribute, or 0.\n    int nestMembersOffset = 0;\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n    Attribute attributes = null;\n\n    // 解析 Class 持有的属性\n    int currentAttributeOffset = getFirstAttributeOffset();\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n      // Read the attribute_info's attribute_name and attribute_length fields.\n      String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n      int attributeLength = readInt(currentAttributeOffset + 2);\n      currentAttributeOffset += 6;\n      // The tests are sorted in decreasing frequency order (based on frequencies observed on\n      // typical classes).\n      if (Constants.SOURCE_FILE.equals(attributeName)) {\n        sourceFile = readUTF8(currentAttributeOffset, charBuffer);\n      } else if (Constants.INNER_CLASSES.equals(attributeName)) {\n        innerClassesOffset = currentAttributeOffset;\n      } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {\n        enclosingMethodOffset = currentAttributeOffset;\n      } else if (Constants.NEST_HOST.equals(attributeName)) {\n        nestHostClass = readClass(currentAttributeOffset, charBuffer);\n      } else if (Constants.NEST_MEMBERS.equals(attributeName)) {\n        nestMembersOffset = currentAttributeOffset;\n      } else if (Constants.SIGNATURE.equals(attributeName)) {\n        signature = readUTF8(currentAttributeOffset, charBuffer);\n      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.DEPRECATED.equals(attributeName)) {\n        accessFlags |= Opcodes.ACC_DEPRECATED;\n      } else if (Constants.SYNTHETIC.equals(attributeName)) {\n        accessFlags |= Opcodes.ACC_SYNTHETIC;\n      } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {\n        sourceDebugExtension =\n            readUTF(currentAttributeOffset, attributeLength, new char[attributeLength]);\n      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.MODULE.equals(attributeName)) {\n        moduleOffset = currentAttributeOffset;\n      } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {\n        moduleMainClass = readClass(currentAttributeOffset, charBuffer);\n      } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {\n        modulePackagesOffset = currentAttributeOffset;\n      } else if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        // This attribute is read in the constructor.\n      } else {\n        Attribute attribute =\n            readAttribute(\n                attributePrototypes,\n                attributeName,\n                currentAttributeOffset,\n                attributeLength,\n                charBuffer,\n                -1,\n                null);\n        attribute.nextAttribute = attributes;\n        attributes = attribute;\n      }\n      currentAttributeOffset += attributeLength;\n    }\n\n    // 第一个 .visit() 。让 ClassVisitor 的实现类处理当前类的版本号, 访问控制标志, 当前类, 结构, 父类, 接口\n    // 具体 visit() 由实现类随意定制。例如，针对于那些有打印功能的访问者实现类，直接打印也不失为一种有效的访问操作\n    // Visit the class declaration. The minor_version and major_version fields start 6 bytes before\n    // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).\n    classVisitor.visit(\n        readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);\n\n    // 访问 SourceFile 和 SourceDebugExtenstion 属性\n    // Visit the SourceFile and SourceDebugExtenstion attributes.\n    if ((parsingOptions & SKIP_DEBUG) == 0\n        && (sourceFile != null || sourceDebugExtension != null)) {\n      classVisitor.visitSource(sourceFile, sourceDebugExtension);\n    }\n\n    // Visit the Module, ModulePackages and ModuleMainClass attributes.\n    if (moduleOffset != 0) {\n      readModule(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);\n    }\n\n    // Visit the NestHost attribute.\n    if (nestHostClass != null) {\n      classVisitor.visitNestHostExperimental(nestHostClass);\n    }\n\n    // Visit the EnclosingMethod attribute.\n    if (enclosingMethodOffset != 0) {\n      String className = readClass(enclosingMethodOffset, charBuffer);\n      int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);\n      String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);\n      String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);\n      classVisitor.visitOuterClass(className, name, type);\n    }\n\n    // Visit the RuntimeVisibleAnnotations attribute.\n    if (runtimeVisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),\n                currentAnnotationOffset,\n                /* named = */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleAnnotations attribute.\n    if (runtimeInvisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),\n                currentAnnotationOffset,\n                /* named = */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible = */ true),\n                currentAnnotationOffset,\n                /* named = */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible = */ false),\n                currentAnnotationOffset,\n                /* named = */ true,\n                charBuffer);\n      }\n    }\n\n    // 访问非标准的属性\n    // Visit the non standard attributes.\n    while (attributes != null) {\n      // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.\n      Attribute nextAttribute = attributes.nextAttribute;\n      attributes.nextAttribute = null;\n      classVisitor.visitAttribute(attributes);\n      attributes = nextAttribute;\n    }\n\n    // Visit the NestedMembers attribute.\n    if (nestMembersOffset != 0) {\n      int numberOfNestMembers = readUnsignedShort(nestMembersOffset);\n      int currentNestMemberOffset = nestMembersOffset + 2;\n      while (numberOfNestMembers-- > 0) {\n        classVisitor.visitNestMemberExperimental(readClass(currentNestMemberOffset, charBuffer));\n        currentNestMemberOffset += 2;\n      }\n    }\n\n    // Visit the InnerClasses attribute.\n    if (innerClassesOffset != 0) {\n      int numberOfClasses = readUnsignedShort(innerClassesOffset);\n      int currentClassesOffset = innerClassesOffset + 2;\n      while (numberOfClasses-- > 0) {\n        classVisitor.visitInnerClass(\n            readClass(currentClassesOffset, charBuffer),\n            readClass(currentClassesOffset + 2, charBuffer),\n            readUTF8(currentClassesOffset + 4, charBuffer),\n            readUnsignedShort(currentClassesOffset + 6));\n        currentClassesOffset += 8;\n      }\n    }\n\n    // 访问字段和方法\n    // Visit the fields and methods.\n    int fieldsCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (fieldsCount-- > 0) {\n      currentOffset = readField(classVisitor, context, currentOffset);\n    }\n    int methodsCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (methodsCount-- > 0) {\n      currentOffset = readMethod(classVisitor, context, currentOffset);\n    }\n\n    // Visit the end of the class.\n    classVisitor.visitEnd();\n  }\n```\n\n### 小结\n\n其实，将整个 ClassReader 理解成一个对 .class 字节文件的解析器不失为一种可行的认知。\n\n1. 在构造方法中完成对 .class 文件 minor\\_version, major\\_version 的确认。\n2. 继而完成对整个 Constants\\_pool 的解析\n3. 以及 BootstarpMethod 属性的定位\n4. 之后在 accept(...) 方法中逐一调用相应的访问者实现类实现对不同内容的访问。\n\n但是，要注意的是，ClassReader 绝对不会涉及到对其解析的 .class 文件内容的写操作。\n所有的写操作都基于不同的目的，在 ClassVisitor 中实现。\n\n## ClassVisitor\n\nJava .class 的访问者，按照严格的顺序规范逐一调用 \n\nvisit\n\\[ visitSource \\] \\[ visitModule \\]\\[ visitNestHost \\]\\[ visitOuterClass \\]\n\\( visitAnnotation | visitTypeAnnotation | visitAttribute \\)*\n\\( visitNestMember | visitInnerClass | visitField | visitMethod \\)*\nvisitEnd.\n\n各个 visitXXX 方法\n\n```java\n\npublic abstract class ClassVisitor {\n\n  /**\n   * 访问类的首部\n      */\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {}\n\n  /**\n   * 访问类的源文件名等\n      */\n    public void visitSource(final String source, final String debug) {}\n\n  /**\n   * 访问与类关联的模块\n      */\n    public ModuleVisitor visitModule(final String name, final int access, final String version) {}\n\n  public void visitOuterClass(final String owner, final String name, final String descriptor) {}\n\n  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {}\n\n  public AnnotationVisitor visitTypeAnnotation(\n      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {}\n\n  public void visitAttribute(final Attribute attribute) {}\n\n  public void visitInnerClass(\n      final String name, final String outerName, final String innerName, final int access) {}\n\n  /**\n   * 访问类的变量\n      */\n    public FieldVisitor visitField(\n      final int access,\n      final String name,\n      final String descriptor,\n      final String signature,\n      final Object value) {}\n\n  /**\n   * 访问类的方法\n      */\n    public MethodVisitor visitMethod(\n      final int access,\n      final String name,\n      final String descriptor,\n      final String signature,\n      final String[] exceptions) {}\n\n  public void visitEnd() {}\n}\n```\n\n随着 visitXxx() 方法的逐一执行，ClassVisitor 将对当前的 .class 文件越来越熟悉，并逐渐补全常量池(由 SymbolTable 持有并维护)\n\n## 总结\n\n到此为止，对整个 ClassReader & ClassVisitor 将有一个基础而简单的印象。\n\nClassReader 通过对 .class 文件字节码的解析而获得对这个类的具体印象(更多的偏向是随意访问 .class 的各种细节)。\n\nClassVisitor 通过 visitXxx(...) 方法，由其它对象(可以是 ClassReader, 也可以直接是 Coder)逐渐对其开放一些 .class 的细节，\n但需要 ClassVisitor 自行维护获得的内容(如果有必要的话)。由此得到对 .class 全部内容的了解(当然，如果本身 visitXxx() 得到的内容不全，则了解的自然有限)。\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```",bodyHtml:'<blockquote>\n<p>本文描述的 ASM 指的是 OW2 ASM</p>\n</blockquote>\n<h2>ASM-Core 的结构</h2>\n<p><em>首先是一些概述性的内容。</em></p>\n<p>由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。\n因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)</p>\n<p>从核心包声明的类来看，主要包括:</p>\n<ol>\n<li>\n<p>ClassReader - 作为结构化对象，将接收(accept)访问者的访问</p>\n</li>\n<li>\n<p>几种访问者抽象类以及相应的实现类</p>\n</li>\n</ol>\n<ul>\n<li>AnnotationVisitor -&gt; AnnotationWriter</li>\n<li>ClassVisitor -&gt; ClassWriter</li>\n<li>FieldVisitor -&gt; FieldWriter</li>\n<li>MethodVisitor -&gt; MethodWriter</li>\n<li>ModuleVisitor -&gt; ModuleWriter</li>\n</ul>\n<ol start="3">\n<li>\n<p>Opcodes &amp; Constants - ClassFile 中描述的大量常量符号与值</p>\n</li>\n<li>\n<p>其它一些辅助的类</p>\n</li>\n</ol>\n<ul>\n<li>Attribute - 用于处理非标准化的属性(ClassFile 允许<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">JVMS</a> 中未定义的 Attribute)</li>\n<li>ByteArray - 动态可自适应的 byte[] (字节数组)</li>\n<li>Context - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象</li>\n<li>Symbol - 用于表示 ClassFile 中描述的 Constant 的基类</li>\n<li>SymbolTable - 用于存储常量池对象</li>\n<li>其它内容省略</li>\n</ul>\n<p>&lt;!-- more --&gt;</p>\n<h2>ClassFile 文件格式</h2>\n<p>本节的内容可以参阅 <a href="https://dormouse-none.github.io/2018-06-11-ASM-ClassReader/">ClassFile 文件格式</a></p>\n<p>ClassFile 是 ASM 操作字节码的基础与前提。在 JVMS 定义了 .class 文件格式之后，ASM 才在此基础上进行了对 ClassFile 的字节码操作。</p>\n<p>因此，无论如何，个人认为在真正开始了解 ASM 之前，通读一遍 ClassFile 文件格式是完全有必要的。并且，在基本了解 ClassFile 内容的基础上，\n尝试对某个 .class 文件进行手工解析也不失为一种加深理解的途径。</p>\n<h2>Visitor Pattern</h2>\n<p>由于 ASM 的实现采用了偏门的访问者模式。因此，了解访问者模式也是一个必不可少的重要环节。同时在了解后也将为源码阅读者提供更清晰的解读思路。</p>\n<p>《设计模式：可复用面向对象软件的基础》一书的“5.11 VISITOR(访问者)——对象行为型模式”提供了很详尽的解释。</p>\n<p>本人对这方面的不甚了解，推荐自行查找资料。</p>\n<h2>ClassReader</h2>\n<p>ClassReader 是解析现有的 .class 文件的基本工具。同时，ClassReader 也作为一个内容的持有者，与 SymboleTable 配合，来满足访问者基本的访问需求。</p>\n<p>刨除大量的内部私有方法，ClassReader 对外开放的接口相当简单。最核心的方法仅包括 ClassReader(...) 以及 accetp(...)</p>\n<h3>ClassReader(...) 构造方法</h3>\n<p>顾名思义，构造方法用于实例化 ClassReader 对象，包括一些必须的变量的初始化。</p>\n<p>在构造函数中完成的初始化内容包括:</p>\n<ul>\n<li>校验版本号</li>\n<li>存储每个常量池项目的起始偏移量 cpInfoOffsets</li>\n<li>存储每个引导方法的起始偏移量 bootstrapMethodOffsets</li>\n<li>存储最长字符串常量的大小 maxStringLength</li>\n</ul>\n<pre><code class="hljs">ClassReader(<span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] classFileBuffer, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> classFileOffset, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> checkClassVersion) {\n    <span class="hljs-keyword">this</span>.b = classFileBuffer;   <span class="hljs-comment">// .class 文件缓存</span>\n    <span class="hljs-comment">// 检查主版本号, 第6,7个字节(从0字节开始计数)</span>\n    <span class="hljs-keyword">if</span> (checkClassVersion &amp;&amp; readShort(classFileOffset + <span class="hljs-number">6</span>) &gt; Opcodes.V11) {\n      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(\n          <span class="hljs-string">"Unsupported class file major version "</span> + readShort(classFileOffset + <span class="hljs-number">6</span>));\n    }\n    <span class="hljs-comment">// 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节</span>\n    <span class="hljs-keyword">int</span> constantPoolCount = readUnsignedShort(classFileOffset + <span class="hljs-number">8</span>);     <span class="hljs-comment">// 读取无符号short, 即读取连续两字节作为一个short值</span>\n    cpInfoOffsets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[constantPoolCount];                         <span class="hljs-comment">// 每个常量的偏移位置</span>\n    cpInfoValues = <span class="hljs-keyword">new</span> Object[constantPoolCount];                       <span class="hljs-comment">// 每个常量的实例对象</span>\n    <span class="hljs-keyword">int</span> currentCpInfoIndex = <span class="hljs-number">1</span>;\n    <span class="hljs-keyword">int</span> currentCpInfoOffset = classFileOffset + <span class="hljs-number">10</span>;\n    <span class="hljs-keyword">int</span> currentMaxStringLength = <span class="hljs-number">0</span>;                                     <span class="hljs-comment">// 最长字符串常量</span>\n    <span class="hljs-keyword">while</span> (currentCpInfoIndex &lt; constantPoolCount) {\n      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + <span class="hljs-number">1</span>;\n      <span class="hljs-keyword">int</span> cpInfoSize;\n      <span class="hljs-keyword">switch</span> (classFileBuffer[currentCpInfoOffset]) {\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_FIELDREF_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_METHODREF_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_INTEGER_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_FLOAT_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_DYNAMIC_TAG:\n          cpInfoSize = <span class="hljs-number">5</span>;\n          <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_LONG_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_DOUBLE_TAG:\n          cpInfoSize = <span class="hljs-number">9</span>;\n          currentCpInfoIndex++;\n          <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_UTF8_TAG:\n          cpInfoSize = <span class="hljs-number">3</span> + readUnsignedShort(currentCpInfoOffset + <span class="hljs-number">1</span>);\n          <span class="hljs-keyword">if</span> (cpInfoSize &gt; currentMaxStringLength) {\n            <span class="hljs-comment">// The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate</span>\n            <span class="hljs-comment">// of the length in characters of the corresponding string, and is much cheaper to</span>\n            <span class="hljs-comment">// compute than this exact length.</span>\n            currentMaxStringLength = cpInfoSize;\n          }\n          <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_METHOD_HANDLE_TAG:\n          cpInfoSize = <span class="hljs-number">4</span>;\n          <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_CLASS_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_STRING_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_METHOD_TYPE_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_PACKAGE_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_MODULE_TAG:\n          cpInfoSize = <span class="hljs-number">3</span>;\n          <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">default</span>:\n          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();\n      }\n      currentCpInfoOffset += cpInfoSize;\n    }\n    <span class="hljs-keyword">this</span>.maxStringLength = currentMaxStringLength;\n    <span class="hljs-comment">// The Classfile\'s access_flags field is just after the last constant pool entry.</span>\n    <span class="hljs-keyword">this</span>.header = currentCpInfoOffset;\n\n    <span class="hljs-comment">// 读取 BootstrapMethods 属性(如果存在)</span>\n    <span class="hljs-keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();\n    <span class="hljs-keyword">int</span>[] currentBootstrapMethodOffsets = <span class="hljs-keyword">null</span>;\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="hljs-number">2</span>); i &gt; <span class="hljs-number">0</span>; --i) {\n      <span class="hljs-comment">// 读取每个 attribute_info 的属性名和属性长度</span>\n      String attributeName = readUTF8(currentAttributeOffset, <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[maxStringLength]);\n      <span class="hljs-keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="hljs-number">2</span>);\n      currentAttributeOffset += <span class="hljs-number">6</span>;\n      <span class="hljs-comment">// 如果当前属性名为 BootstrapMethods ，则进入处理逻辑</span>\n      <span class="hljs-keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        <span class="hljs-comment">// Read the num_bootstrap_methods field and create an array of this size.</span>\n        currentBootstrapMethodOffsets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[readUnsignedShort(currentAttributeOffset)];\n        <span class="hljs-comment">// Compute and store the offset of each \'bootstrap_methods\' array field entry.</span>\n        <span class="hljs-keyword">int</span> currentBootstrapMethodOffset = currentAttributeOffset + <span class="hljs-number">2</span>;\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; currentBootstrapMethodOffsets.length; ++j) {\n          currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;\n          <span class="hljs-comment">// Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),</span>\n          <span class="hljs-comment">// as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).</span>\n          currentBootstrapMethodOffset +=\n              <span class="hljs-number">4</span> + readUnsignedShort(currentBootstrapMethodOffset + <span class="hljs-number">2</span>) * <span class="hljs-number">2</span>;\n        }\n      }\n      currentAttributeOffset += attributeLength;\n    }\n    <span class="hljs-keyword">this</span>.bootstrapMethodOffsets = currentBootstrapMethodOffsets;\n  }</code></pre><p>到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。\n但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。</p>\n<h3>accept(...)</h3>\n<p>访问者模式的核心操作就是结构化对象接受(accept)访问者对象实例的访问，并将结构化内容完全暴露给访问者。</p>\n<p>从抽象的方法角度看，可以理解成:</p>\n<pre><code class="hljs"><span class="hljs-comment">// --- 结构化对象的 accept() 方法 ---</span>\n  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>{\n    visitor.visit(<span class="hljs-keyword">this</span>);\n  }\n\n  <span class="hljs-comment">// --- 访问者对象的 visit() 方法 ---</span>\n  <span class="hljs-function"><span class="hljs-keyword">public</span> Xxx <span class="hljs-title">visit</span><span class="hljs-params">(Element element)</span> </span>{\n    <span class="hljs-comment">// 若干关于 element 的读操作 + 其它操作</span>\n  }</code></pre><pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(\n      <span class="hljs-keyword">final</span> ClassVisitor classVisitor,\n      <span class="hljs-keyword">final</span> Attribute[] attributePrototypes,\n      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> parsingOptions)</span> </span>{\n    <span class="hljs-comment">// 定义 Context 作为辅助类，暂存被访问过程的“累积状态”</span>\n    Context context = <span class="hljs-keyword">new</span> Context();\n    context.attributePrototypes = attributePrototypes;\n    <span class="hljs-comment">/**\n     * 解析选项: \n     * 1. SKIP_CODE - 不解析 CODE 属性 \n     * 2. SKIP_DEBUG - 不解析 DEBUG 相关的属性(例如SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable, LineNumberTable)\n     * 4. SKIP_FRAMES - 跳过对 StackMap 和 StackMapTable 属性的解析\n     * ...\n     */</span>\n    context.parsingOptions = parsingOptions;\n    <span class="hljs-comment">// 从常量池读取常量所使用的缓冲数字</span>\n    context.charBuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[maxStringLength];\n\n    <span class="hljs-comment">// Read the access_flags, this_class, super_class, interface_count and interfaces fields.</span>\n    <span class="hljs-comment">// 解析访问控制, 当前类, 父类, 接口数量与接口值等</span>\n    <span class="hljs-keyword">char</span>[] charBuffer = context.charBuffer;\n    <span class="hljs-keyword">int</span> currentOffset = header;\n    <span class="hljs-keyword">int</span> accessFlags = readUnsignedShort(currentOffset);\n    String thisClass = readClass(currentOffset + <span class="hljs-number">2</span>, charBuffer);\n    String superClass = readClass(currentOffset + <span class="hljs-number">4</span>, charBuffer);\n    String[] interfaces = <span class="hljs-keyword">new</span> String[readUnsignedShort(currentOffset + <span class="hljs-number">6</span>)];\n    currentOffset += <span class="hljs-number">8</span>;\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; interfaces.length; ++i) {\n      interfaces[i] = readClass(currentOffset, charBuffer);\n      currentOffset += <span class="hljs-number">2</span>;\n    }\n\n    <span class="hljs-comment">// Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).</span>\n    <span class="hljs-comment">// Attribute offsets exclude the attribute_name_index and attribute_length fields.</span>\n    <span class="hljs-comment">// - The offset of the InnerClasses attribute, or 0.</span>\n    <span class="hljs-keyword">int</span> innerClassesOffset = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">// - The offset of the EnclosingMethod attribute, or 0.</span>\n    <span class="hljs-keyword">int</span> enclosingMethodOffset = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">// - The string corresponding to the Signature attribute, or null.</span>\n    String signature = <span class="hljs-keyword">null</span>;\n    <span class="hljs-comment">// - The string corresponding to the SourceFile attribute, or null.</span>\n    String sourceFile = <span class="hljs-keyword">null</span>;\n    <span class="hljs-comment">// - The string corresponding to the SourceDebugExtension attribute, or null.</span>\n    String sourceDebugExtension = <span class="hljs-keyword">null</span>;\n    <span class="hljs-comment">// - The offset of the RuntimeVisibleAnnotations attribute, or 0.</span>\n    <span class="hljs-keyword">int</span> runtimeVisibleAnnotationsOffset = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">// - The offset of the RuntimeInvisibleAnnotations attribute, or 0.</span>\n    <span class="hljs-keyword">int</span> runtimeInvisibleAnnotationsOffset = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">// - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.</span>\n    <span class="hljs-keyword">int</span> runtimeVisibleTypeAnnotationsOffset = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">// - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.</span>\n    <span class="hljs-keyword">int</span> runtimeInvisibleTypeAnnotationsOffset = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">// - The offset of the Module attribute, or 0.</span>\n    <span class="hljs-keyword">int</span> moduleOffset = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">// - The offset of the ModulePackages attribute, or 0.</span>\n    <span class="hljs-keyword">int</span> modulePackagesOffset = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">// - The string corresponding to the ModuleMainClass attribute, or null.</span>\n    String moduleMainClass = <span class="hljs-keyword">null</span>;\n    <span class="hljs-comment">// - The string corresponding to the NestHost attribute, or null.</span>\n    String nestHostClass = <span class="hljs-keyword">null</span>;\n    <span class="hljs-comment">// - The offset of the NestMembers attribute, or 0.</span>\n    <span class="hljs-keyword">int</span> nestMembersOffset = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">// - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).</span>\n    <span class="hljs-comment">//   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.</span>\n    Attribute attributes = <span class="hljs-keyword">null</span>;\n\n    <span class="hljs-comment">// 解析 Class 持有的属性</span>\n    <span class="hljs-keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="hljs-number">2</span>); i &gt; <span class="hljs-number">0</span>; --i) {\n      <span class="hljs-comment">// Read the attribute_info\'s attribute_name and attribute_length fields.</span>\n      String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n      <span class="hljs-keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="hljs-number">2</span>);\n      currentAttributeOffset += <span class="hljs-number">6</span>;\n      <span class="hljs-comment">// The tests are sorted in decreasing frequency order (based on frequencies observed on</span>\n      <span class="hljs-comment">// typical classes).</span>\n      <span class="hljs-keyword">if</span> (Constants.SOURCE_FILE.equals(attributeName)) {\n        sourceFile = readUTF8(currentAttributeOffset, charBuffer);\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.INNER_CLASSES.equals(attributeName)) {\n        innerClassesOffset = currentAttributeOffset;\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.ENCLOSING_METHOD.equals(attributeName)) {\n        enclosingMethodOffset = currentAttributeOffset;\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.NEST_HOST.equals(attributeName)) {\n        nestHostClass = readClass(currentAttributeOffset, charBuffer);\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.NEST_MEMBERS.equals(attributeName)) {\n        nestMembersOffset = currentAttributeOffset;\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.SIGNATURE.equals(attributeName)) {\n        signature = readUTF8(currentAttributeOffset, charBuffer);\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleAnnotationsOffset = currentAttributeOffset;\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.DEPRECATED.equals(attributeName)) {\n        accessFlags |= Opcodes.ACC_DEPRECATED;\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.SYNTHETIC.equals(attributeName)) {\n        accessFlags |= Opcodes.ACC_SYNTHETIC;\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {\n        sourceDebugExtension =\n            readUTF(currentAttributeOffset, attributeLength, <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[attributeLength]);\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleAnnotationsOffset = currentAttributeOffset;\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.MODULE.equals(attributeName)) {\n        moduleOffset = currentAttributeOffset;\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {\n        moduleMainClass = readClass(currentAttributeOffset, charBuffer);\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.MODULE_PACKAGES.equals(attributeName)) {\n        modulePackagesOffset = currentAttributeOffset;\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        <span class="hljs-comment">// This attribute is read in the constructor.</span>\n      } <span class="hljs-keyword">else</span> {\n        Attribute attribute =\n            readAttribute(\n                attributePrototypes,\n                attributeName,\n                currentAttributeOffset,\n                attributeLength,\n                charBuffer,\n                -<span class="hljs-number">1</span>,\n                <span class="hljs-keyword">null</span>);\n        attribute.nextAttribute = attributes;\n        attributes = attribute;\n      }\n      currentAttributeOffset += attributeLength;\n    }\n\n    <span class="hljs-comment">// 第一个 .visit() 。让 ClassVisitor 的实现类处理当前类的版本号, 访问控制标志, 当前类, 结构, 父类, 接口</span>\n    <span class="hljs-comment">// 具体 visit() 由实现类随意定制。例如，针对于那些有打印功能的访问者实现类，直接打印也不失为一种有效的访问操作</span>\n    <span class="hljs-comment">// Visit the class declaration. The minor_version and major_version fields start 6 bytes before</span>\n    <span class="hljs-comment">// the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).</span>\n    classVisitor.visit(\n        readInt(cpInfoOffsets[<span class="hljs-number">1</span>] - <span class="hljs-number">7</span>), accessFlags, thisClass, signature, superClass, interfaces);\n\n    <span class="hljs-comment">// 访问 SourceFile 和 SourceDebugExtenstion 属性</span>\n    <span class="hljs-comment">// Visit the SourceFile and SourceDebugExtenstion attributes.</span>\n    <span class="hljs-keyword">if</span> ((parsingOptions &amp; SKIP_DEBUG) == <span class="hljs-number">0</span>\n        &amp;&amp; (sourceFile != <span class="hljs-keyword">null</span> || sourceDebugExtension != <span class="hljs-keyword">null</span>)) {\n      classVisitor.visitSource(sourceFile, sourceDebugExtension);\n    }\n\n    <span class="hljs-comment">// Visit the Module, ModulePackages and ModuleMainClass attributes.</span>\n    <span class="hljs-keyword">if</span> (moduleOffset != <span class="hljs-number">0</span>) {\n      readModule(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);\n    }\n\n    <span class="hljs-comment">// Visit the NestHost attribute.</span>\n    <span class="hljs-keyword">if</span> (nestHostClass != <span class="hljs-keyword">null</span>) {\n      classVisitor.visitNestHostExperimental(nestHostClass);\n    }\n\n    <span class="hljs-comment">// Visit the EnclosingMethod attribute.</span>\n    <span class="hljs-keyword">if</span> (enclosingMethodOffset != <span class="hljs-number">0</span>) {\n      String className = readClass(enclosingMethodOffset, charBuffer);\n      <span class="hljs-keyword">int</span> methodIndex = readUnsignedShort(enclosingMethodOffset + <span class="hljs-number">2</span>);\n      String name = methodIndex == <span class="hljs-number">0</span> ? <span class="hljs-keyword">null</span> : readUTF8(cpInfoOffsets[methodIndex], charBuffer);\n      String type = methodIndex == <span class="hljs-number">0</span> ? <span class="hljs-keyword">null</span> : readUTF8(cpInfoOffsets[methodIndex] + <span class="hljs-number">2</span>, charBuffer);\n      classVisitor.visitOuterClass(className, name, type);\n    }\n\n    <span class="hljs-comment">// Visit the RuntimeVisibleAnnotations attribute.</span>\n    <span class="hljs-keyword">if</span> (runtimeVisibleAnnotationsOffset != <span class="hljs-number">0</span>) {\n      <span class="hljs-keyword">int</span> numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n      <span class="hljs-keyword">int</span> currentAnnotationOffset = runtimeVisibleAnnotationsOffset + <span class="hljs-number">2</span>;\n      <span class="hljs-keyword">while</span> (numAnnotations-- &gt; <span class="hljs-number">0</span>) {\n        <span class="hljs-comment">// Parse the type_index field.</span>\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += <span class="hljs-number">2</span>;\n        <span class="hljs-comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span>\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitAnnotation(annotationDescriptor, <span class="hljs-comment">/* visible = */</span> <span class="hljs-keyword">true</span>),\n                currentAnnotationOffset,\n                <span class="hljs-comment">/* named = */</span> <span class="hljs-keyword">true</span>,\n                charBuffer);\n      }\n    }\n\n    <span class="hljs-comment">// Visit the RuntimeInvisibleAnnotations attribute.</span>\n    <span class="hljs-keyword">if</span> (runtimeInvisibleAnnotationsOffset != <span class="hljs-number">0</span>) {\n      <span class="hljs-keyword">int</span> numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n      <span class="hljs-keyword">int</span> currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + <span class="hljs-number">2</span>;\n      <span class="hljs-keyword">while</span> (numAnnotations-- &gt; <span class="hljs-number">0</span>) {\n        <span class="hljs-comment">// Parse the type_index field.</span>\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += <span class="hljs-number">2</span>;\n        <span class="hljs-comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span>\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitAnnotation(annotationDescriptor, <span class="hljs-comment">/* visible = */</span> <span class="hljs-keyword">false</span>),\n                currentAnnotationOffset,\n                <span class="hljs-comment">/* named = */</span> <span class="hljs-keyword">true</span>,\n                charBuffer);\n      }\n    }\n\n    <span class="hljs-comment">// Visit the RuntimeVisibleTypeAnnotations attribute.</span>\n    <span class="hljs-keyword">if</span> (runtimeVisibleTypeAnnotationsOffset != <span class="hljs-number">0</span>) {\n      <span class="hljs-keyword">int</span> numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n      <span class="hljs-keyword">int</span> currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + <span class="hljs-number">2</span>;\n      <span class="hljs-keyword">while</span> (numAnnotations-- &gt; <span class="hljs-number">0</span>) {\n        <span class="hljs-comment">// Parse the target_type, target_info and target_path fields.</span>\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        <span class="hljs-comment">// Parse the type_index field.</span>\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += <span class="hljs-number">2</span>;\n        <span class="hljs-comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span>\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    <span class="hljs-comment">/* visible = */</span> <span class="hljs-keyword">true</span>),\n                currentAnnotationOffset,\n                <span class="hljs-comment">/* named = */</span> <span class="hljs-keyword">true</span>,\n                charBuffer);\n      }\n    }\n\n    <span class="hljs-comment">// Visit the RuntimeInvisibleTypeAnnotations attribute.</span>\n    <span class="hljs-keyword">if</span> (runtimeInvisibleTypeAnnotationsOffset != <span class="hljs-number">0</span>) {\n      <span class="hljs-keyword">int</span> numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n      <span class="hljs-keyword">int</span> currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + <span class="hljs-number">2</span>;\n      <span class="hljs-keyword">while</span> (numAnnotations-- &gt; <span class="hljs-number">0</span>) {\n        <span class="hljs-comment">// Parse the target_type, target_info and target_path fields.</span>\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        <span class="hljs-comment">// Parse the type_index field.</span>\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += <span class="hljs-number">2</span>;\n        <span class="hljs-comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span>\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    <span class="hljs-comment">/* visible = */</span> <span class="hljs-keyword">false</span>),\n                currentAnnotationOffset,\n                <span class="hljs-comment">/* named = */</span> <span class="hljs-keyword">true</span>,\n                charBuffer);\n      }\n    }\n\n    <span class="hljs-comment">// 访问非标准的属性</span>\n    <span class="hljs-comment">// Visit the non standard attributes.</span>\n    <span class="hljs-keyword">while</span> (attributes != <span class="hljs-keyword">null</span>) {\n      <span class="hljs-comment">// Copy and reset the nextAttribute field so that it can also be used in ClassWriter.</span>\n      Attribute nextAttribute = attributes.nextAttribute;\n      attributes.nextAttribute = <span class="hljs-keyword">null</span>;\n      classVisitor.visitAttribute(attributes);\n      attributes = nextAttribute;\n    }\n\n    <span class="hljs-comment">// Visit the NestedMembers attribute.</span>\n    <span class="hljs-keyword">if</span> (nestMembersOffset != <span class="hljs-number">0</span>) {\n      <span class="hljs-keyword">int</span> numberOfNestMembers = readUnsignedShort(nestMembersOffset);\n      <span class="hljs-keyword">int</span> currentNestMemberOffset = nestMembersOffset + <span class="hljs-number">2</span>;\n      <span class="hljs-keyword">while</span> (numberOfNestMembers-- &gt; <span class="hljs-number">0</span>) {\n        classVisitor.visitNestMemberExperimental(readClass(currentNestMemberOffset, charBuffer));\n        currentNestMemberOffset += <span class="hljs-number">2</span>;\n      }\n    }\n\n    <span class="hljs-comment">// Visit the InnerClasses attribute.</span>\n    <span class="hljs-keyword">if</span> (innerClassesOffset != <span class="hljs-number">0</span>) {\n      <span class="hljs-keyword">int</span> numberOfClasses = readUnsignedShort(innerClassesOffset);\n      <span class="hljs-keyword">int</span> currentClassesOffset = innerClassesOffset + <span class="hljs-number">2</span>;\n      <span class="hljs-keyword">while</span> (numberOfClasses-- &gt; <span class="hljs-number">0</span>) {\n        classVisitor.visitInnerClass(\n            readClass(currentClassesOffset, charBuffer),\n            readClass(currentClassesOffset + <span class="hljs-number">2</span>, charBuffer),\n            readUTF8(currentClassesOffset + <span class="hljs-number">4</span>, charBuffer),\n            readUnsignedShort(currentClassesOffset + <span class="hljs-number">6</span>));\n        currentClassesOffset += <span class="hljs-number">8</span>;\n      }\n    }\n\n    <span class="hljs-comment">// 访问字段和方法</span>\n    <span class="hljs-comment">// Visit the fields and methods.</span>\n    <span class="hljs-keyword">int</span> fieldsCount = readUnsignedShort(currentOffset);\n    currentOffset += <span class="hljs-number">2</span>;\n    <span class="hljs-keyword">while</span> (fieldsCount-- &gt; <span class="hljs-number">0</span>) {\n      currentOffset = readField(classVisitor, context, currentOffset);\n    }\n    <span class="hljs-keyword">int</span> methodsCount = readUnsignedShort(currentOffset);\n    currentOffset += <span class="hljs-number">2</span>;\n    <span class="hljs-keyword">while</span> (methodsCount-- &gt; <span class="hljs-number">0</span>) {\n      currentOffset = readMethod(classVisitor, context, currentOffset);\n    }\n\n    <span class="hljs-comment">// Visit the end of the class.</span>\n    classVisitor.visitEnd();\n  }</code></pre><h3>小结</h3>\n<p>其实，将整个 ClassReader 理解成一个对 .class 字节文件的解析器不失为一种可行的认知。</p>\n<ol>\n<li>在构造方法中完成对 .class 文件 minor_version, major_version 的确认。</li>\n<li>继而完成对整个 Constants_pool 的解析</li>\n<li>以及 BootstarpMethod 属性的定位</li>\n<li>之后在 accept(...) 方法中逐一调用相应的访问者实现类实现对不同内容的访问。</li>\n</ol>\n<p>但是，要注意的是，ClassReader 绝对不会涉及到对其解析的 .class 文件内容的写操作。\n所有的写操作都基于不同的目的，在 ClassVisitor 中实现。</p>\n<h2>ClassVisitor</h2>\n<p>Java .class 的访问者，按照严格的顺序规范逐一调用</p>\n<p>visit\n[ visitSource ] [ visitModule ][ visitNestHost ][ visitOuterClass ]\n( visitAnnotation | visitTypeAnnotation | visitAttribute )*\n( visitNestMember | visitInnerClass | visitField | visitMethod )*\nvisitEnd.</p>\n<p>各个 visitXXX 方法</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassVisitor</span> </span>{\n\n  <span class="hljs-comment">/**\n   * 访问类的首部\n      */</span>\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> version, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> access, <span class="hljs-keyword">final</span> String name, <span class="hljs-keyword">final</span> String signature, <span class="hljs-keyword">final</span> String superName, <span class="hljs-keyword">final</span> String[] interfaces)</span> </span>{}\n\n  <span class="hljs-comment">/**\n   * 访问类的源文件名等\n      */</span>\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitSource</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String source, <span class="hljs-keyword">final</span> String debug)</span> </span>{}\n\n  <span class="hljs-comment">/**\n   * 访问与类关联的模块\n      */</span>\n    <span class="hljs-function"><span class="hljs-keyword">public</span> ModuleVisitor <span class="hljs-title">visitModule</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> access, <span class="hljs-keyword">final</span> String version)</span> </span>{}\n\n  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitOuterClass</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String owner, <span class="hljs-keyword">final</span> String name, <span class="hljs-keyword">final</span> String descriptor)</span> </span>{}\n\n  <span class="hljs-function"><span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title">visitAnnotation</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String descriptor, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> visible)</span> </span>{}\n\n  <span class="hljs-function"><span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title">visitTypeAnnotation</span><span class="hljs-params">(\n      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> typeRef, <span class="hljs-keyword">final</span> TypePath typePath, <span class="hljs-keyword">final</span> String descriptor, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> visible)</span> </span>{}\n\n  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitAttribute</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Attribute attribute)</span> </span>{}\n\n  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitInnerClass</span><span class="hljs-params">(\n      <span class="hljs-keyword">final</span> String name, <span class="hljs-keyword">final</span> String outerName, <span class="hljs-keyword">final</span> String innerName, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> access)</span> </span>{}\n\n  <span class="hljs-comment">/**\n   * 访问类的变量\n      */</span>\n    <span class="hljs-function"><span class="hljs-keyword">public</span> FieldVisitor <span class="hljs-title">visitField</span><span class="hljs-params">(\n      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> access,\n      <span class="hljs-keyword">final</span> String name,\n      <span class="hljs-keyword">final</span> String descriptor,\n      <span class="hljs-keyword">final</span> String signature,\n      <span class="hljs-keyword">final</span> Object value)</span> </span>{}\n\n  <span class="hljs-comment">/**\n   * 访问类的方法\n      */</span>\n    <span class="hljs-function"><span class="hljs-keyword">public</span> MethodVisitor <span class="hljs-title">visitMethod</span><span class="hljs-params">(\n      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> access,\n      <span class="hljs-keyword">final</span> String name,\n      <span class="hljs-keyword">final</span> String descriptor,\n      <span class="hljs-keyword">final</span> String signature,\n      <span class="hljs-keyword">final</span> String[] exceptions)</span> </span>{}\n\n  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitEnd</span><span class="hljs-params">()</span> </span>{}\n}</code></pre><p>随着 visitXxx() 方法的逐一执行，ClassVisitor 将对当前的 .class 文件越来越熟悉，并逐渐补全常量池(由 SymbolTable 持有并维护)</p>\n<h2>总结</h2>\n<p>到此为止，对整个 ClassReader &amp; ClassVisitor 将有一个基础而简单的印象。</p>\n<p>ClassReader 通过对 .class 文件字节码的解析而获得对这个类的具体印象(更多的偏向是随意访问 .class 的各种细节)。</p>\n<p>ClassVisitor 通过 visitXxx(...) 方法，由其它对象(可以是 ClassReader, 也可以直接是 Coder)逐渐对其开放一些 .class 的细节，\n但需要 ClassVisitor 自行维护获得的内容(如果有必要的话)。由此得到对 .class 全部内容的了解(当然，如果本身 visitXxx() 得到的内容不全，则了解的自然有限)。</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-06-25-ASM-Core.json",ext:".json",sourceBase:"2018-06-25-ASM-Core.md",sourceExt:".md"}},LRZv:function(n){n.exports={title:"认证与授权·简述",author:"fangfeng",date:"2019-03-19T00:00:00.000Z",tags:["Authenticate","Authorize"],bodyContent:"## 概述\n\n> 在大多数系统中，都或多或少需要认证授权模型/系统的支持。\n\n认证/授权是什么？最简单的，我们的系统要求用户必须在“登录”之后才允许进行一些操作。“登录”的过程就是认证；而区别与未登录状态，只允许登录用户进行一些操作，这就是授权。认证与授权相互独立，有协同配合，共同支撑起系统对安全的基本要求。\n\n\x3c!-- more --\x3e\n\n## 认证与授权\n\n认证的目的在于认出用户。日常生活中，我们通过视觉、声音等因素认出一个人。但是就网络应用而言，应用最多只能够认识到发起请求的浏览器、手机APP、物联网设备等用户代理(User Agent)，也无法直接地将用户与用户代理进行绑定。因此，向应用证明操作这些用户代理的实体就成了至关重要的步骤。你需要通过密码、手机验证码、人脸识别或其它形式凭证来完成“登录”操作，即认证。\n\n当然了，我们也认识到，不是所有的操作都需要一个这般复制“登录”流程的，即使这些操作逻辑上也需要认出背后的用户是谁。这部分所使用到的技术就是“会话管理”了。在一定的有效期范围内，用户无需重复证明自己的身份，而用户-应用间保持最基本的信任。当然，一般来说，修改密码等危险操作还是需要再次进行认证。\n\n总而言之，无论是“登录”认证抑或是“会话”认证，其目的都是为了认出用户。\n\n完成认证之后，就要启用授权了。授权负责的是控制用户能干什么。管理员和普通员工所能进行的操作肯定是有所差别的。借助于前置认证提供用户身份信息，授权将对用户的操作进行决断。\n\n## 访问控制（权限控制）\n\n授权旨在界定用户能够进行哪些操作，而访问控制正是进行授权界定的措施、手段。该如何实施访问控制呢？看人下菜是最简单、最容易被接受的方式——为每个用户独立地分配权限。但是，就Web应用而言，如此行事的代价将是及其巨大的。动辄几十万、上百万...的用户量，又如何维护得起这般细致的控制呢。而且，每个用户独立设置权限，同时也意味着每个权限需要直接对接百十万的用户。\n\n撇开可行性，访问控制做的就是这种活计——控制主体（用户）对客体（系统、API等）的操作。\n\n主要的访问控制技术分为三类：自主访问控制、强制访问控制、基于角色的访问控制\n\n### 自主访问控制(Discretionary Access Control，DAC)\n\n- 每个客体都独立维护一张访问控制表(Access Control List, ACL)\n- 每个客体都有一个所有者\n- 所有者可以将其负责的客体访问权限分配给其它用户\n- 每次主体对客体的访问都面向ACL做确认后执行\n- 强依赖于所有者对安全要求的认知\n\n### 强制访问控制(Mandatory Access Control, MAC)\n\n- 预置相应的密级，例如绝密级、机密级和普通级。密级有强弱关系\n- 每个主体/客体都分配一个密级\n- 每次主体对客体的操作，判定主体密级 >= 客体密级即允许访问\n\n### 基于角色的访问控制(Role-Based Access Control, RBAC)\n\n- 角色作为一系列有较强相关性权限的持有者\n- 用户通过被分配一系列角色，从而间接地拥有权限集\n\n*一般来说，DAC、MAC都不太适合于Web应用的访问控制。因此，后续的讨论都将基于RBAC进行。*\n\n## 控制粒度\n\n如何定义一个客体，就涉及到控制粒度了。就Web应用而言，比较粗略的有数据粒度、方法粒度、URL粒度、系统粒度等等。任意粒度，都可以作为访问控制的组成部分，作为授权的一部分。但是，粒度的控制也会导致一些相当致命的问题。\n\n越权问题就是一种粒度控制下的问题。\n\n**纵向访问控制**\n\n顾名思义，纵向访问控制所控制的权限拥有一定的优先级概念，例如管理员操作与普通用户操作。特别适合于使用强制访问控制的解决方案，使用RBAC也并不困难，基本上只要定义两类角色也能解决。业内对于这类问题的解决方案相当成熟，需要的只是根据不同的业务场景进行适配。\n\n**横向访问控制**\n\n对于横向访问控制，问题就不再那么的简单。在方法粒度下的RBAC模型，很容易就会导致A用户事实上访问了B用户数据的问题发生，也就是横向越权。而想要实现数据粒度的通用模型，却又不可避免地将对业务代码进行侵入。\n\n控制粒度的取舍，就很大程度上取决于Web应用的实际需求。\n\n## 小结\n\n认证、授权的基本目的在于满足对安全的基本要求，其涉及的知识相当广泛。本篇的目的，仅仅在于阐释认证、授权两个术语的基本定义，并对访问控制技术做概要式的介绍。\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```",bodyHtml:"<h2>概述</h2>\n<blockquote>\n<p>在大多数系统中，都或多或少需要认证授权模型/系统的支持。</p>\n</blockquote>\n<p>认证/授权是什么？最简单的，我们的系统要求用户必须在“登录”之后才允许进行一些操作。“登录”的过程就是认证；而区别与未登录状态，只允许登录用户进行一些操作，这就是授权。认证与授权相互独立，有协同配合，共同支撑起系统对安全的基本要求。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>认证与授权</h2>\n<p>认证的目的在于认出用户。日常生活中，我们通过视觉、声音等因素认出一个人。但是就网络应用而言，应用最多只能够认识到发起请求的浏览器、手机APP、物联网设备等用户代理(User Agent)，也无法直接地将用户与用户代理进行绑定。因此，向应用证明操作这些用户代理的实体就成了至关重要的步骤。你需要通过密码、手机验证码、人脸识别或其它形式凭证来完成“登录”操作，即认证。</p>\n<p>当然了，我们也认识到，不是所有的操作都需要一个这般复制“登录”流程的，即使这些操作逻辑上也需要认出背后的用户是谁。这部分所使用到的技术就是“会话管理”了。在一定的有效期范围内，用户无需重复证明自己的身份，而用户-应用间保持最基本的信任。当然，一般来说，修改密码等危险操作还是需要再次进行认证。</p>\n<p>总而言之，无论是“登录”认证抑或是“会话”认证，其目的都是为了认出用户。</p>\n<p>完成认证之后，就要启用授权了。授权负责的是控制用户能干什么。管理员和普通员工所能进行的操作肯定是有所差别的。借助于前置认证提供用户身份信息，授权将对用户的操作进行决断。</p>\n<h2>访问控制（权限控制）</h2>\n<p>授权旨在界定用户能够进行哪些操作，而访问控制正是进行授权界定的措施、手段。该如何实施访问控制呢？看人下菜是最简单、最容易被接受的方式——为每个用户独立地分配权限。但是，就Web应用而言，如此行事的代价将是及其巨大的。动辄几十万、上百万...的用户量，又如何维护得起这般细致的控制呢。而且，每个用户独立设置权限，同时也意味着每个权限需要直接对接百十万的用户。</p>\n<p>撇开可行性，访问控制做的就是这种活计——控制主体（用户）对客体（系统、API等）的操作。</p>\n<p>主要的访问控制技术分为三类：自主访问控制、强制访问控制、基于角色的访问控制</p>\n<h3>自主访问控制(Discretionary Access Control，DAC)</h3>\n<ul>\n<li>每个客体都独立维护一张访问控制表(Access Control List, ACL)</li>\n<li>每个客体都有一个所有者</li>\n<li>所有者可以将其负责的客体访问权限分配给其它用户</li>\n<li>每次主体对客体的访问都面向ACL做确认后执行</li>\n<li>强依赖于所有者对安全要求的认知</li>\n</ul>\n<h3>强制访问控制(Mandatory Access Control, MAC)</h3>\n<ul>\n<li>预置相应的密级，例如绝密级、机密级和普通级。密级有强弱关系</li>\n<li>每个主体/客体都分配一个密级</li>\n<li>每次主体对客体的操作，判定主体密级 &gt;= 客体密级即允许访问</li>\n</ul>\n<h3>基于角色的访问控制(Role-Based Access Control, RBAC)</h3>\n<ul>\n<li>角色作为一系列有较强相关性权限的持有者</li>\n<li>用户通过被分配一系列角色，从而间接地拥有权限集</li>\n</ul>\n<p><em>一般来说，DAC、MAC都不太适合于Web应用的访问控制。因此，后续的讨论都将基于RBAC进行。</em></p>\n<h2>控制粒度</h2>\n<p>如何定义一个客体，就涉及到控制粒度了。就Web应用而言，比较粗略的有数据粒度、方法粒度、URL粒度、系统粒度等等。任意粒度，都可以作为访问控制的组成部分，作为授权的一部分。但是，粒度的控制也会导致一些相当致命的问题。</p>\n<p>越权问题就是一种粒度控制下的问题。</p>\n<p><strong>纵向访问控制</strong></p>\n<p>顾名思义，纵向访问控制所控制的权限拥有一定的优先级概念，例如管理员操作与普通用户操作。特别适合于使用强制访问控制的解决方案，使用RBAC也并不困难，基本上只要定义两类角色也能解决。业内对于这类问题的解决方案相当成熟，需要的只是根据不同的业务场景进行适配。</p>\n<p><strong>横向访问控制</strong></p>\n<p>对于横向访问控制，问题就不再那么的简单。在方法粒度下的RBAC模型，很容易就会导致A用户事实上访问了B用户数据的问题发生，也就是横向越权。而想要实现数据粒度的通用模型，却又不可避免地将对业务代码进行侵入。</p>\n<p>控制粒度的取舍，就很大程度上取决于Web应用的实际需求。</p>\n<h2>小结</h2>\n<p>认证、授权的基本目的在于满足对安全的基本要求，其涉及的知识相当广泛。本篇的目的，仅仅在于阐释认证、授权两个术语的基本定义，并对访问控制技术做概要式的介绍。</p>\n<pre><code class=\"hljs\">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>",preview:"",dir:"content",base:"2019-03-19-JANUS.json",ext:".json",sourceBase:"2019-03-19-JANUS.md",sourceExt:".md"}},MDTK:function(n,s,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/post",function(){var n=a("EhLH");return{page:n.default||n}}])},NctQ:function(n){n.exports={title:"ASM - ClassReader 与 Java ClassFile 文件格式",author:"fangfeng",date:"2018-06-11T00:00:00.000Z",bodyContent:'## Java ClassFile 文件格式\n\n读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。\n[The class File Format(Java SE 8)](https://docs.oracle.com/javase/specs/jvms/se8/html/index.html) \n\n> u1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)\n\n```c++\nClassFile {\n    u4             magic;                                   // 魔数(magic) 固定为 0xCAFEBABE\n    u2             minor_version;                           // 次版本号\n    u2             major_version;                           // 主版本号\n    u2             constant_pool_count;                     // 常量池 constant_pool 的数量 + 1, 最大为 (2<<16 - 1) = 65535\n    cp_info        constant_pool[constant_pool_count-1];    // 常量池 取值下标为 [1, constant_pool_count)\n    u2             access_flags;                            // 对类 or 接口的访问权限和属性的标志的掩码\n    u2             this_class;                              // 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)\n    u2             super_class;                             // 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标\n    u2             interfaces_count;                        // 直接父接口的数量\n    u2             interfaces[interfaces_count];            // 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i<interfaces_count), 指向的类型为 CONSTANT_Class_info)\n    u2             fields_count;                            // 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)\n    field_info     fields[fields_count];                    // 字段的详细声明, 不包含继承来的字段\n    u2             methods_count;                           // 方法数量\n    method_info    methods[methods_count];                  // 方法的详细声明, 不包括继承来的方法\n    u2             attributes_count;                        // 属性数量\n    attribute_info attributes[attributes_count];            // 属性的详细声明\n}\n```\n\x3c!-- more --\x3e\n\n通过 `javac Xxx.java` 命令得到的 `Xxx.class` 文件严格按照定义的 ClassFile 文件格式以8比特的字节为单位进行存储。\n\n**下面的例子都将通过 Trie.java (实际代码见本文最后) 以及其经编译后的文件 Trie.class 做基本的介绍。**\n\n### magic, minor_verion & major_version\n通过命令 `xxd Trie.class` 查看 Trie.class 的十六进制编码，前16字节的内容如下:\n```text\n00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.\n```\n可以看到前4字节的内容 `0xcafebabe`，没有实际意义，但是作为其是能否被JVM(Java Virtual Machine, Java虚拟机)接收的Class文件的一个校验。\n\n紧接着的4个字节包括`次版本号` 和 `主版本号`，暂时不做深入。\n\n### 常量池 constant_pool\n\n从第10个字节开始(从第0字节开始计数)，连续的两个字节表示常量池中各种 CONSTANT 的总个数+1 (constant_pool_count)。constant_pool_count 只有2字节也就意味着: 常量池的最大常量数量为 (2<<16 - 1) = 65535 (当然，貌似在这个量级上，也从没见过有谁能够维护这样一个大JAVA类文件了)。\n\n可以看到 constant_pool_count 的内容为 `0x008f = 143` ，即对于常量池的声明可以认为是 `cp_info constant_pool[142]`\n\n```text\ncp_info {\n    u1 tag;\n    u1 info[]; \n}\n```\n\n利用 JDK 自带的 `javap` 来查看 `Trie.class` 文件(`javap -v Trie.class`)，可以对 cp_info 的格式有一个粗浅但形象化的认识(结果见**附录2**)\n其中第一列的内容 `#? = ?` `#?`表示id，`= ?`表示一个 cp_info 的实际类型，有 `cp_info.tag` 指定，具体映射表为\n\n| Constant Type                 | Value |\n| ----------------------------- | ----- |\n| `CONSTANT_Class`              | 7     |\n| `CONSTANT_Fieldref`           | 9     |\n| `CONSTANT_Methodref`          | 10    |\n| `CONSTANT_InterfaceMethodref` | 11    |\n| `CONSTANT_String`             | 8     |\n| `CONSTANT_Integer`            | 3     |\n| `CONSTANT_Float`              | 4     |\n| `CONSTANT_Long`               | 5     |\n| `CONSTANT_Double`             | 6     |\n| `CONSTANT_NameAndType`        | 12    |\n| `CONSTANT_Utf8`               | 1     |\n| `CONSTANT_MethodHandle`       | 15    |\n| `CONSTANT_MethodType`         | 16    |\n| `CONSTANT_InvokeDynamic`      | 18    |\n| `CONSTANT_Module`             | 19    |\n| `CONSTANT_Package`            | 20    |\n\n在 Java ClassFile 的格式定义中，同时定义了每种 `CONSTANT` 的长度与格式。\n例如:\n```c++\nCONSTANT_Class_info {\n    u1 tag;\n    u2 name_index;\n}\n```\n```c++\nCONSTANT_Fieldref_info {\n     u1 tag;\n     u2 class_index;\n     u2 name_and_type_index;\n}\nCONSTANT_Methodref_info {\n  u1 tag;\n  u2 class_index;\n  u2 name_and_type_index;\n}\n```\n更多的 `CONSTANT_XXX` 的格式定义见 [ClassFile CONSTANT_XXX 结构](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4)\n\n简单解析一下 cp_info[1]。\n```text\n00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.\n\n#1 = Methodref          #36.#75       // java/lang/Object."<init>":()V\n```\n\n`cp_info[1].tag = 0x0a = 10`，即 cp_info[1] 的类型为 Methodref 。\n之后就直接套用 `CONSTANT_Methodref_info` 的数据结构定义的格式\n`cp_info[1].class_index = 0x0024 = 36`，即 cp_info[1].class_index 表示的类名指向常量池第 36 个元素表示的类\n`cp_info[1].name_and_type_index = 0x004b = 75`。表示指向的是常量池第 75 个元素表示的 NameAndType 结构\n\n对于这部分内容的理解，如果觉得有能够阅读英文文档，可以参考 [The Java® Virtual Machine Specification Chap 4.](https://docs.oracle.com/javase/specs/jvms/se8/html/index.html)\n否则，可以选择 [Java 虚拟机规范(Java SE 7 版) 第四章](http://icyfenix.iteye.com/blog/1256329)\n并尝试根据经编译后.class文件的二进制码进行人工解析，以加深对此的理解。\n\n### more... \n\n更多内容于此基本类似，均属于已经被严格预定义的规范化格式，对此进行解析即可得到相应的内容。\n\n## ASM 概览\n\n### 包结构\n\nasm, asm-analysis, asm-commons, asm-tree, asm-util, asm-xml 模块基于 Maven 的组织形式，并包含有单元测试的内容。\n\nasm-test 实现了对上述模块的单元测试的整合。\n\nbenchmarks 定义了一些基本的 JMH 基准测试来衡量ASM的表现\n\ngradle 包含了一些 Gradle 包装器，来辅助 Linux or Windows 脚本的调用请求\n\ntools 包含两个 Gradle 项目来帮助 ASM 生成 Artifacts 。\n\n![ASM Structure](https://ws1.sinaimg.cn/large/006tKfTcgy1frywra01upj308g0akmxr.jpg)\n\n### 代码组织形式\n\n![Code Organization](http://asm.ow2.io/asm-package-dependencies.svg)\n\n- org.objectweb.asm 作为核心包，定义了 ASM 访问者 API 以及两个核心类 ClassReader & ClassWriter 来读写编译后的 Java 类。该包不依赖于其他包，且可单独使用\n- org.objectweb.asm.signature 提供了读写泛型签名的 API\n- org.objectweb.asm.tree 提供了类 DOM API 与类 SAX API。\n- org.objectweb.asm.tree.analysis 基于 .tree 提供了静态字节码分析框架\n- org.objectweb.asm.commons 提供了一些基于 core 和 tree 包的类适配器。\n- org.objectweb.asm.util 提供了一些用于 DEBUG 的访问者类与适配器类\n- org.objectweb.asm.xml 目前已经被 @Deprecated 。提供了类文件与 XML 互相转换的能力\n\n综上，asm 核心包是最为复杂的一个模块，而其它诸如 tree, util, xml 等都只是提供了将 JAVA 类从一种高级表示形态转换为另一种的能力。signature 也相当简单，提供了解析和打印简单语法的能力。\n\n### 主要数据结构\n\n核心包由 28 个类(接口) 组成。如果不考虑 Opcodes 接口, 5 个抽象访问者类(AnnotationVistitor, ClassVisitor, FieldVisitor, MethodVisitor and ModuleVisitor), 6 个工具类(ConstantDynamic, Contants, Handle, Type, TypePath and TypeReference), 剩下 16 个类的由下图提供一个粗略的展示。\n\n![](http://asm.ow2.io/asm-package-overview.svg)\n\n编译类到访问事件的转换只由一个类 ClassReader 以及辅助类 Context 完成。其逆过程由以 ClassWriter 为核心的其它 14 个类完成。\n\n\n### ClassReader \n\nClassReader 作为 ASM 核心包解析现有 .class 的唯一工具，组织形式相当简单。\n\n- 在构造函数中完成对常量池和引导方法的解析\n    - 存储每个常量池项目的起始偏移量 cpInfoOffsets\n    - 存储每个引导方法的起始偏移量 bootstrapMethodOffsets\n    - 存储最长字符串常量的大小 maxStringLength\n\n```java\n  ClassReader(final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {\n    this.b = classFileBuffer;   // .class 文件缓存\n    // 检查主版本号, 第6,7个字节(从0字节开始计数)\n    if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V11) {\n      throw new IllegalArgumentException(\n          "Unsupported class file major version " + readShort(classFileOffset + 6));\n    }\n    // 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节\n    int constantPoolCount = readUnsignedShort(classFileOffset + 8);     // 读取无符号short, 即读取连续两字节作为一个short值\n    cpInfoOffsets = new int[constantPoolCount];                         // 每个常量的偏移位置\n    cpInfoValues = new Object[constantPoolCount];                       // 每个常量的实例对象\n    int currentCpInfoIndex = 1;\n    int currentCpInfoOffset = classFileOffset + 10;\n    int currentMaxStringLength = 0;                                     // 最长字符串常量\n    while (currentCpInfoIndex < constantPoolCount) {\n      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;\n      int cpInfoSize;\n      switch (classFileBuffer[currentCpInfoOffset]) {\n        case Symbol.CONSTANT_FIELDREF_TAG:\n        case Symbol.CONSTANT_METHODREF_TAG:\n        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n        case Symbol.CONSTANT_INTEGER_TAG:\n        case Symbol.CONSTANT_FLOAT_TAG:\n        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n        case Symbol.CONSTANT_DYNAMIC_TAG:\n          cpInfoSize = 5;\n          break;\n        case Symbol.CONSTANT_LONG_TAG:\n        case Symbol.CONSTANT_DOUBLE_TAG:\n          cpInfoSize = 9;\n          currentCpInfoIndex++;\n          break;\n        case Symbol.CONSTANT_UTF8_TAG:\n          cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);\n          if (cpInfoSize > currentMaxStringLength) {\n            // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate\n            // of the length in characters of the corresponding string, and is much cheaper to\n            // compute than this exact length.\n            currentMaxStringLength = cpInfoSize;\n          }\n          break;\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n          cpInfoSize = 4;\n          break;\n        case Symbol.CONSTANT_CLASS_TAG:\n        case Symbol.CONSTANT_STRING_TAG:\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\n        case Symbol.CONSTANT_PACKAGE_TAG:\n        case Symbol.CONSTANT_MODULE_TAG:\n          cpInfoSize = 3;\n          break;\n        default:\n          throw new IllegalArgumentException();\n      }\n      currentCpInfoOffset += cpInfoSize;\n    }\n    this.maxStringLength = currentMaxStringLength;\n    // The Classfile\'s access_flags field is just after the last constant pool entry.\n    this.header = currentCpInfoOffset;\n\n    // 读取 BootstrapMethods 属性(如果存在)\n    int currentAttributeOffset = getFirstAttributeOffset();\n    int[] currentBootstrapMethodOffsets = null;\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n      // 读取每个 attribute_info 的属性名和属性长度\n      String attributeName = readUTF8(currentAttributeOffset, new char[maxStringLength]);\n      int attributeLength = readInt(currentAttributeOffset + 2);\n      currentAttributeOffset += 6;\n      // 如果当前属性名为 BootstrapMethods ，则进入处理逻辑\n      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        // Read the num_bootstrap_methods field and create an array of this size.\n        currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];\n        // Compute and store the offset of each \'bootstrap_methods\' array field entry.\n        int currentBootstrapMethodOffset = currentAttributeOffset + 2;\n        for (int j = 0; j < currentBootstrapMethodOffsets.length; ++j) {\n          currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;\n          // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\n          // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\n          currentBootstrapMethodOffset +=\n              4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\n        }\n      }\n      currentAttributeOffset += attributeLength;\n    }\n    this.bootstrapMethodOffsets = currentBootstrapMethodOffsets;\n  }\n```\n\n到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。\n但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。\n\n这部分的内容在 accept(...) 和 readXXX(...) 中将得到解析。\n\n主要流程类似:\n\n1. 读取当前内容的偏移量(相较于整个 byte[])\n2. 解析当前的内容\n3. 调用 visitXXX 方法\n4. 在 visitXXX 方法中进行相关的处理\n5. visitEnd\n\n## 附录1 Trie.java\n\n```java\npackage me.fangfeng.filter;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\n\n/**\n * @author fangfeng\n * @since 2018/5/16\n */\npublic class Trie {\n    \n    private static int MAX_ITEM = 700000;\n    private static int AVG_LENGTH = 11;\n    private static int MAX_NODE = MAX_ITEM * AVG_LENGTH;\n    private static int CHAR_NUM = 10;\n\n    int[][] nxt = new int[MAX_NODE][CHAR_NUM];\n    boolean[] flag = new boolean[MAX_NODE];\n    int trieIndex = 0;\n\n    void insert(long number) {\n        int tmpIndex = 0;\n        for (;number != 0;number /= 10) {\n            if (nxt[tmpIndex][(int) (number % 10)] == 0) {\n                nxt[tmpIndex][(int) (number % 10)] = ++trieIndex;\n            }\n            tmpIndex = nxt[tmpIndex][(int) (number % 10)];\n        }\n        flag[tmpIndex] = true;\n    }\n\n    boolean query(long number) {\n        int tmpIndex = 0;\n        for (;number != 0;number /= 10) {\n            if (nxt[tmpIndex][(int) (number % 10)] == 0) {\n                return false;\n            }\n            tmpIndex = nxt[tmpIndex][(int) (number % 10)];\n        }\n        return flag[tmpIndex];\n    }\n\n    public static void main(String... args) throws FileNotFoundException, IOException {\n\n        long start = System.currentTimeMillis();\n\n        String ruleFilePath = args[0];\n        String sendFilePath = args[1];\n        String outFilePath = args[2];\n\n        BufferedReader ruleReader = new BufferedReader(new InputStreamReader(new FileInputStream(ruleFilePath)));\n        BufferedReader sendReader = new BufferedReader(new InputStreamReader(new FileInputStream(sendFilePath)));\n\n        BufferedWriter outWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outFilePath)));\n\n        Trie trie = new Trie();\n        String mobile;\n        while((mobile = ruleReader.readLine()) != null) {\n            trie.insert(Long.parseLong(mobile));\n        }\n        ruleReader.close();\n\n        while((mobile = sendReader.readLine()) != null) {\n            if(trie.query(Long.parseLong(mobile)) == false) {\n                outWriter.write(mobile);\n                outWriter.newLine();\n            }\n        }\n        sendReader.close();\n\n        outWriter.flush();\n        outWriter.close();\n\n        long end = System.currentTimeMillis();\n        System.out.println(String.format("exec success! used %d ms", end - start));\n    }\n}\n```\n\n\n## 附录2 Constant pool\n```\nConstant pool:\n    #1 = Methodref          #36.#75       // java/lang/Object."<init>":()V\n    #2 = Fieldref           #23.#76       // me/fangfeng/filter/Trie.MAX_NODE:I\n    #3 = Fieldref           #23.#77       // me/fangfeng/filter/Trie.CHAR_NUM:I\n    #4 = Class              #49           // "[[I"\n    #5 = Fieldref           #23.#78       // me/fangfeng/filter/Trie.nxt:[[I\n    #6 = Fieldref           #23.#79       // me/fangfeng/filter/Trie.flag:[Z\n    #7 = Fieldref           #23.#80       // me/fangfeng/filter/Trie.trieIndex:I\n    #8 = Long               10l\n   #10 = Methodref          #81.#82       // java/lang/System.currentTimeMillis:()J\n   #11 = Class              #83           // java/io/BufferedReader\n   #12 = Class              #84           // java/io/InputStreamReader\n   #13 = Class              #85           // java/io/FileInputStream\n   #14 = Methodref          #13.#86       // java/io/FileInputStream."<init>":(Ljava/lang/String;)V\n   #15 = Methodref          #12.#87       // java/io/InputStreamReader."<init>":(Ljava/io/InputStream;)V\n   #16 = Methodref          #11.#88       // java/io/BufferedReader."<init>":(Ljava/io/Reader;)V\n   #17 = Class              #89           // java/io/BufferedWriter\n   #18 = Class              #90           // java/io/OutputStreamWriter\n   #19 = Class              #91           // java/io/FileOutputStream\n   #20 = Methodref          #19.#86       // java/io/FileOutputStream."<init>":(Ljava/lang/String;)V\n   #21 = Methodref          #18.#92       // java/io/OutputStreamWriter."<init>":(Ljava/io/OutputStream;)V\n   #22 = Methodref          #17.#93       // java/io/BufferedWriter."<init>":(Ljava/io/Writer;)V\n   #23 = Class              #94           // me/fangfeng/filter/Trie\n   #24 = Methodref          #23.#75       // me/fangfeng/filter/Trie."<init>":()V\n   #25 = Methodref          #11.#95       // java/io/BufferedReader.readLine:()Ljava/lang/String;\n   #26 = Methodref          #96.#97       // java/lang/Long.parseLong:(Ljava/lang/String;)J\n   #27 = Methodref          #23.#98       // me/fangfeng/filter/Trie.insert:(J)V\n   #28 = Methodref          #11.#99       // java/io/BufferedReader.close:()V\n   #29 = Methodref          #23.#100      // me/fangfeng/filter/Trie.query:(J)Z\n   #30 = Methodref          #17.#101      // java/io/BufferedWriter.write:(Ljava/lang/String;)V\n   #31 = Methodref          #17.#102      // java/io/BufferedWriter.newLine:()V\n   #32 = Methodref          #17.#103      // java/io/BufferedWriter.flush:()V\n   #33 = Methodref          #17.#99       // java/io/BufferedWriter.close:()V\n   #34 = Fieldref           #81.#104      // java/lang/System.out:Ljava/io/PrintStream;\n   #35 = String             #105          // exec success! used %d ms\n   #36 = Class              #106          // java/lang/Object\n   #37 = Methodref          #96.#107      // java/lang/Long.valueOf:(J)Ljava/lang/Long;\n   #38 = Methodref          #108.#109     // java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n   #39 = Methodref          #110.#111     // java/io/PrintStream.println:(Ljava/lang/String;)V\n   #40 = Integer            700000\n   #41 = Fieldref           #23.#112      // me/fangfeng/filter/Trie.MAX_ITEM:I\n   #42 = Fieldref           #23.#113      // me/fangfeng/filter/Trie.AVG_LENGTH:I\n   #43 = Utf8               MAX_ITEM\n   #44 = Utf8               I\n   #45 = Utf8               AVG_LENGTH\n   #46 = Utf8               MAX_NODE\n   #47 = Utf8               CHAR_NUM\n   #48 = Utf8               nxt\n   #49 = Utf8               [[I\n   #50 = Utf8               flag\n   #51 = Utf8               [Z\n   #52 = Utf8               trieIndex\n   #53 = Utf8               <init>\n   #54 = Utf8               ()V\n   #55 = Utf8               Code\n   #56 = Utf8               LineNumberTable\n   #57 = Utf8               insert\n   #58 = Utf8               (J)V\n   #59 = Utf8               StackMapTable\n   #60 = Utf8               query\n   #61 = Utf8               (J)Z\n   #62 = Utf8               main\n   #63 = Utf8               ([Ljava/lang/String;)V\n   #64 = Class              #114          // "[Ljava/lang/String;"\n   #65 = Class              #115          // java/lang/String\n   #66 = Class              #83           // java/io/BufferedReader\n   #67 = Class              #89           // java/io/BufferedWriter\n   #68 = Class              #94           // me/fangfeng/filter/Trie\n   #69 = Utf8               Exceptions\n   #70 = Class              #116          // java/io/FileNotFoundException\n   #71 = Class              #117          // java/io/IOException\n   #72 = Utf8               <clinit>\n   #73 = Utf8               SourceFile\n   #74 = Utf8               Trie.java\n   #75 = NameAndType        #53:#54       // "<init>":()V\n   #76 = NameAndType        #46:#44       // MAX_NODE:I\n   #77 = NameAndType        #47:#44       // CHAR_NUM:I\n   #78 = NameAndType        #48:#49       // nxt:[[I\n   #79 = NameAndType        #50:#51       // flag:[Z\n   #80 = NameAndType        #52:#44       // trieIndex:I\n   #81 = Class              #118          // java/lang/System\n   #82 = NameAndType        #119:#120     // currentTimeMillis:()J\n   #83 = Utf8               java/io/BufferedReader\n   #84 = Utf8               java/io/InputStreamReader\n   #85 = Utf8               java/io/FileInputStream\n   #86 = NameAndType        #53:#121      // "<init>":(Ljava/lang/String;)V\n   #87 = NameAndType        #53:#122      // "<init>":(Ljava/io/InputStream;)V\n   #88 = NameAndType        #53:#123      // "<init>":(Ljava/io/Reader;)V\n   #89 = Utf8               java/io/BufferedWriter\n   #90 = Utf8               java/io/OutputStreamWriter\n   #91 = Utf8               java/io/FileOutputStream\n   #92 = NameAndType        #53:#124      // "<init>":(Ljava/io/OutputStream;)V\n   #93 = NameAndType        #53:#125      // "<init>":(Ljava/io/Writer;)V\n   #94 = Utf8               me/fangfeng/filter/Trie\n   #95 = NameAndType        #126:#127     // readLine:()Ljava/lang/String;\n   #96 = Class              #128          // java/lang/Long\n   #97 = NameAndType        #129:#130     // parseLong:(Ljava/lang/String;)J\n   #98 = NameAndType        #57:#58       // insert:(J)V\n   #99 = NameAndType        #131:#54      // close:()V\n  #100 = NameAndType        #60:#61       // query:(J)Z\n  #101 = NameAndType        #132:#121     // write:(Ljava/lang/String;)V\n  #102 = NameAndType        #133:#54      // newLine:()V\n  #103 = NameAndType        #134:#54      // flush:()V\n  #104 = NameAndType        #135:#136     // out:Ljava/io/PrintStream;\n  #105 = Utf8               exec success! used %d ms\n  #106 = Utf8               java/lang/Object\n  #107 = NameAndType        #137:#138     // valueOf:(J)Ljava/lang/Long;\n  #108 = Class              #115          // java/lang/String\n  #109 = NameAndType        #139:#140     // format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n  #110 = Class              #141          // java/io/PrintStream\n  #111 = NameAndType        #142:#121     // println:(Ljava/lang/String;)V\n  #112 = NameAndType        #43:#44       // MAX_ITEM:I\n  #113 = NameAndType        #45:#44       // AVG_LENGTH:I\n  #114 = Utf8               [Ljava/lang/String;\n  #115 = Utf8               java/lang/String\n  #116 = Utf8               java/io/FileNotFoundException\n  #117 = Utf8               java/io/IOException\n  #118 = Utf8               java/lang/System\n  #119 = Utf8               currentTimeMillis\n  #120 = Utf8               ()J\n  #121 = Utf8               (Ljava/lang/String;)V\n  #122 = Utf8               (Ljava/io/InputStream;)V\n  #123 = Utf8               (Ljava/io/Reader;)V\n  #124 = Utf8               (Ljava/io/OutputStream;)V\n  #125 = Utf8               (Ljava/io/Writer;)V\n  #126 = Utf8               readLine\n  #127 = Utf8               ()Ljava/lang/String;\n  #128 = Utf8               java/lang/Long\n  #129 = Utf8               parseLong\n  #130 = Utf8               (Ljava/lang/String;)J\n  #131 = Utf8               close\n  #132 = Utf8               write\n  #133 = Utf8               newLine\n  #134 = Utf8               flush\n  #135 = Utf8               out\n  #136 = Utf8               Ljava/io/PrintStream;\n  #137 = Utf8               valueOf\n  #138 = Utf8               (J)Ljava/lang/Long;\n  #139 = Utf8               format\n  #140 = Utf8               (Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n  #141 = Utf8               java/io/PrintStream\n  #142 = Utf8               println\n```\n\n## 参考\n\n\\[1\\]: https://docs.oracle.com/javase/specs/jvms/se8/html/index.html "Java Virtual Machine Specification"\n\\[2\\]: http://icyfenix.iteye.com/blog/1256329 "Java虚拟机规范（Java SE 7 中文版）"\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<h2>Java ClassFile 文件格式</h2>\n<p>读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。\n<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The class File Format(Java SE 8)</a></p>\n<blockquote>\n<p>u1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)</p>\n</blockquote>\n<pre><code class="hljs">ClassFile {\n    u4             magic;                                   <span class="hljs-comment">// 魔数(magic) 固定为 0xCAFEBABE</span>\n    u2             minor_version;                           <span class="hljs-comment">// 次版本号</span>\n    u2             major_version;                           <span class="hljs-comment">// 主版本号</span>\n    u2             constant_pool_count;                     <span class="hljs-comment">// 常量池 constant_pool 的数量 + 1, 最大为 (2&lt;&lt;16 - 1) = 65535</span>\n    cp_info        constant_pool[constant_pool_count<span class="hljs-number">-1</span>];    <span class="hljs-comment">// 常量池 取值下标为 [1, constant_pool_count)</span>\n    u2             access_flags;                            <span class="hljs-comment">// 对类 or 接口的访问权限和属性的标志的掩码</span>\n    u2             this_class;                              <span class="hljs-comment">// 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)</span>\n    u2             super_class;                             <span class="hljs-comment">// 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标</span>\n    u2             interfaces_count;                        <span class="hljs-comment">// 直接父接口的数量</span>\n    u2             interfaces[interfaces_count];            <span class="hljs-comment">// 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i&lt;interfaces_count), 指向的类型为 CONSTANT_Class_info)</span>\n    u2             fields_count;                            <span class="hljs-comment">// 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)</span>\n    field_info     fields[fields_count];                    <span class="hljs-comment">// 字段的详细声明, 不包含继承来的字段</span>\n    u2             methods_count;                           <span class="hljs-comment">// 方法数量</span>\n    method_info    methods[methods_count];                  <span class="hljs-comment">// 方法的详细声明, 不包括继承来的方法</span>\n    u2             attributes_count;                        <span class="hljs-comment">// 属性数量</span>\n    attribute_info attributes[attributes_count];            <span class="hljs-comment">// 属性的详细声明</span>\n}</code></pre><p>&lt;!-- more --&gt;</p>\n<p>通过 <code>javac Xxx.java</code> 命令得到的 <code>Xxx.class</code> 文件严格按照定义的 ClassFile 文件格式以8比特的字节为单位进行存储。</p>\n<p><strong>下面的例子都将通过 Trie.java (实际代码见本文最后) 以及其经编译后的文件 Trie.class 做基本的介绍。</strong></p>\n<h3>magic, minor_verion &amp; major_version</h3>\n<p>通过命令 <code>xxd Trie.class</code> 查看 Trie.class 的十六进制编码，前16字节的内容如下:</p>\n<pre><code class="hljs">00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.</code></pre><p>可以看到前4字节的内容 <code>0xcafebabe</code>，没有实际意义，但是作为其是能否被JVM(Java Virtual Machine, Java虚拟机)接收的Class文件的一个校验。</p>\n<p>紧接着的4个字节包括<code>次版本号</code> 和 <code>主版本号</code>，暂时不做深入。</p>\n<h3>常量池 constant_pool</h3>\n<p>从第10个字节开始(从第0字节开始计数)，连续的两个字节表示常量池中各种 CONSTANT 的总个数+1 (constant_pool_count)。constant_pool_count 只有2字节也就意味着: 常量池的最大常量数量为 (2&lt;&lt;16 - 1) = 65535 (当然，貌似在这个量级上，也从没见过有谁能够维护这样一个大JAVA类文件了)。</p>\n<p>可以看到 constant_pool_count 的内容为 <code>0x008f = 143</code> ，即对于常量池的声明可以认为是 <code>cp_info constant_pool[142]</code></p>\n<pre><code class="hljs">cp_info {\n    u1 tag;\n    u1 info[]; \n}</code></pre><p>利用 JDK 自带的 <code>javap</code> 来查看 <code>Trie.class</code> 文件(<code>javap -v Trie.class</code>)，可以对 cp_info 的格式有一个粗浅但形象化的认识(结果见<strong>附录2</strong>)\n其中第一列的内容 <code>#? = ?</code> <code>#?</code>表示id，<code>= ?</code>表示一个 cp_info 的实际类型，有 <code>cp_info.tag</code> 指定，具体映射表为</p>\n<table>\n<thead>\n<tr>\n<th>Constant Type</th>\n<th>Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>CONSTANT_Class</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code>CONSTANT_Fieldref</code></td>\n<td>9</td>\n</tr>\n<tr>\n<td><code>CONSTANT_Methodref</code></td>\n<td>10</td>\n</tr>\n<tr>\n<td><code>CONSTANT_InterfaceMethodref</code></td>\n<td>11</td>\n</tr>\n<tr>\n<td><code>CONSTANT_String</code></td>\n<td>8</td>\n</tr>\n<tr>\n<td><code>CONSTANT_Integer</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code>CONSTANT_Float</code></td>\n<td>4</td>\n</tr>\n<tr>\n<td><code>CONSTANT_Long</code></td>\n<td>5</td>\n</tr>\n<tr>\n<td><code>CONSTANT_Double</code></td>\n<td>6</td>\n</tr>\n<tr>\n<td><code>CONSTANT_NameAndType</code></td>\n<td>12</td>\n</tr>\n<tr>\n<td><code>CONSTANT_Utf8</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>CONSTANT_MethodHandle</code></td>\n<td>15</td>\n</tr>\n<tr>\n<td><code>CONSTANT_MethodType</code></td>\n<td>16</td>\n</tr>\n<tr>\n<td><code>CONSTANT_InvokeDynamic</code></td>\n<td>18</td>\n</tr>\n<tr>\n<td><code>CONSTANT_Module</code></td>\n<td>19</td>\n</tr>\n<tr>\n<td><code>CONSTANT_Package</code></td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n<p>在 Java ClassFile 的格式定义中，同时定义了每种 <code>CONSTANT</code> 的长度与格式。\n例如:</p>\n<pre><code class="hljs">CONSTANT_Class_info {\n    u1 tag;\n    u2 name_index;\n}</code></pre><pre><code class="hljs">CONSTANT_Fieldref_info {\n     u1 tag;\n     u2 class_index;\n     u2 name_and_type_index;\n}\nCONSTANT_Methodref_info {\n  u1 tag;\n  u2 class_index;\n  u2 name_and_type_index;\n}</code></pre><p>更多的 <code>CONSTANT_XXX</code> 的格式定义见 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">ClassFile CONSTANT_XXX 结构</a></p>\n<p>简单解析一下 cp_info[1]。</p>\n<pre><code class="hljs">00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.\n\n#1 = Methodref          #36.#75       // java/lang/Object."&lt;init&gt;":()V</code></pre><p><code>cp_info[1].tag = 0x0a = 10</code>，即 cp_info[1] 的类型为 Methodref 。\n之后就直接套用 <code>CONSTANT_Methodref_info</code> 的数据结构定义的格式\n<code>cp_info[1].class_index = 0x0024 = 36</code>，即 cp_info[1].class_index 表示的类名指向常量池第 36 个元素表示的类\n<code>cp_info[1].name_and_type_index = 0x004b = 75</code>。表示指向的是常量池第 75 个元素表示的 NameAndType 结构</p>\n<p>对于这部分内容的理解，如果觉得有能够阅读英文文档，可以参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification Chap 4.</a>\n否则，可以选择 <a href="http://icyfenix.iteye.com/blog/1256329">Java 虚拟机规范(Java SE 7 版) 第四章</a>\n并尝试根据经编译后.class文件的二进制码进行人工解析，以加深对此的理解。</p>\n<h3>more...</h3>\n<p>更多内容于此基本类似，均属于已经被严格预定义的规范化格式，对此进行解析即可得到相应的内容。</p>\n<h2>ASM 概览</h2>\n<h3>包结构</h3>\n<p>asm, asm-analysis, asm-commons, asm-tree, asm-util, asm-xml 模块基于 Maven 的组织形式，并包含有单元测试的内容。</p>\n<p>asm-test 实现了对上述模块的单元测试的整合。</p>\n<p>benchmarks 定义了一些基本的 JMH 基准测试来衡量ASM的表现</p>\n<p>gradle 包含了一些 Gradle 包装器，来辅助 Linux or Windows 脚本的调用请求</p>\n<p>tools 包含两个 Gradle 项目来帮助 ASM 生成 Artifacts 。</p>\n<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1frywra01upj308g0akmxr.jpg" alt="ASM Structure"></p>\n<h3>代码组织形式</h3>\n<p><img src="http://asm.ow2.io/asm-package-dependencies.svg" alt="Code Organization"></p>\n<ul>\n<li>org.objectweb.asm 作为核心包，定义了 ASM 访问者 API 以及两个核心类 ClassReader &amp; ClassWriter 来读写编译后的 Java 类。该包不依赖于其他包，且可单独使用</li>\n<li>org.objectweb.asm.signature 提供了读写泛型签名的 API</li>\n<li>org.objectweb.asm.tree 提供了类 DOM API 与类 SAX API。</li>\n<li>org.objectweb.asm.tree.analysis 基于 .tree 提供了静态字节码分析框架</li>\n<li>org.objectweb.asm.commons 提供了一些基于 core 和 tree 包的类适配器。</li>\n<li>org.objectweb.asm.util 提供了一些用于 DEBUG 的访问者类与适配器类</li>\n<li>org.objectweb.asm.xml 目前已经被 @Deprecated 。提供了类文件与 XML 互相转换的能力</li>\n</ul>\n<p>综上，asm 核心包是最为复杂的一个模块，而其它诸如 tree, util, xml 等都只是提供了将 JAVA 类从一种高级表示形态转换为另一种的能力。signature 也相当简单，提供了解析和打印简单语法的能力。</p>\n<h3>主要数据结构</h3>\n<p>核心包由 28 个类(接口) 组成。如果不考虑 Opcodes 接口, 5 个抽象访问者类(AnnotationVistitor, ClassVisitor, FieldVisitor, MethodVisitor and ModuleVisitor), 6 个工具类(ConstantDynamic, Contants, Handle, Type, TypePath and TypeReference), 剩下 16 个类的由下图提供一个粗略的展示。</p>\n<p><img src="http://asm.ow2.io/asm-package-overview.svg" alt=""></p>\n<p>编译类到访问事件的转换只由一个类 ClassReader 以及辅助类 Context 完成。其逆过程由以 ClassWriter 为核心的其它 14 个类完成。</p>\n<h3>ClassReader</h3>\n<p>ClassReader 作为 ASM 核心包解析现有 .class 的唯一工具，组织形式相当简单。</p>\n<ul>\n<li>在构造函数中完成对常量池和引导方法的解析\n<ul>\n<li>存储每个常量池项目的起始偏移量 cpInfoOffsets</li>\n<li>存储每个引导方法的起始偏移量 bootstrapMethodOffsets</li>\n<li>存储最长字符串常量的大小 maxStringLength</li>\n</ul>\n</li>\n</ul>\n<pre><code class="hljs">ClassReader(<span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] classFileBuffer, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> classFileOffset, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> checkClassVersion) {\n    <span class="hljs-keyword">this</span>.b = classFileBuffer;   <span class="hljs-comment">// .class 文件缓存</span>\n    <span class="hljs-comment">// 检查主版本号, 第6,7个字节(从0字节开始计数)</span>\n    <span class="hljs-keyword">if</span> (checkClassVersion &amp;&amp; readShort(classFileOffset + <span class="hljs-number">6</span>) &gt; Opcodes.V11) {\n      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(\n          <span class="hljs-string">"Unsupported class file major version "</span> + readShort(classFileOffset + <span class="hljs-number">6</span>));\n    }\n    <span class="hljs-comment">// 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节</span>\n    <span class="hljs-keyword">int</span> constantPoolCount = readUnsignedShort(classFileOffset + <span class="hljs-number">8</span>);     <span class="hljs-comment">// 读取无符号short, 即读取连续两字节作为一个short值</span>\n    cpInfoOffsets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[constantPoolCount];                         <span class="hljs-comment">// 每个常量的偏移位置</span>\n    cpInfoValues = <span class="hljs-keyword">new</span> Object[constantPoolCount];                       <span class="hljs-comment">// 每个常量的实例对象</span>\n    <span class="hljs-keyword">int</span> currentCpInfoIndex = <span class="hljs-number">1</span>;\n    <span class="hljs-keyword">int</span> currentCpInfoOffset = classFileOffset + <span class="hljs-number">10</span>;\n    <span class="hljs-keyword">int</span> currentMaxStringLength = <span class="hljs-number">0</span>;                                     <span class="hljs-comment">// 最长字符串常量</span>\n    <span class="hljs-keyword">while</span> (currentCpInfoIndex &lt; constantPoolCount) {\n      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + <span class="hljs-number">1</span>;\n      <span class="hljs-keyword">int</span> cpInfoSize;\n      <span class="hljs-keyword">switch</span> (classFileBuffer[currentCpInfoOffset]) {\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_FIELDREF_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_METHODREF_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_INTEGER_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_FLOAT_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_DYNAMIC_TAG:\n          cpInfoSize = <span class="hljs-number">5</span>;\n          <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_LONG_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_DOUBLE_TAG:\n          cpInfoSize = <span class="hljs-number">9</span>;\n          currentCpInfoIndex++;\n          <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_UTF8_TAG:\n          cpInfoSize = <span class="hljs-number">3</span> + readUnsignedShort(currentCpInfoOffset + <span class="hljs-number">1</span>);\n          <span class="hljs-keyword">if</span> (cpInfoSize &gt; currentMaxStringLength) {\n            <span class="hljs-comment">// The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate</span>\n            <span class="hljs-comment">// of the length in characters of the corresponding string, and is much cheaper to</span>\n            <span class="hljs-comment">// compute than this exact length.</span>\n            currentMaxStringLength = cpInfoSize;\n          }\n          <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_METHOD_HANDLE_TAG:\n          cpInfoSize = <span class="hljs-number">4</span>;\n          <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_CLASS_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_STRING_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_METHOD_TYPE_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_PACKAGE_TAG:\n        <span class="hljs-keyword">case</span> Symbol.CONSTANT_MODULE_TAG:\n          cpInfoSize = <span class="hljs-number">3</span>;\n          <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">default</span>:\n          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();\n      }\n      currentCpInfoOffset += cpInfoSize;\n    }\n    <span class="hljs-keyword">this</span>.maxStringLength = currentMaxStringLength;\n    <span class="hljs-comment">// The Classfile\'s access_flags field is just after the last constant pool entry.</span>\n    <span class="hljs-keyword">this</span>.header = currentCpInfoOffset;\n\n    <span class="hljs-comment">// 读取 BootstrapMethods 属性(如果存在)</span>\n    <span class="hljs-keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();\n    <span class="hljs-keyword">int</span>[] currentBootstrapMethodOffsets = <span class="hljs-keyword">null</span>;\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="hljs-number">2</span>); i &gt; <span class="hljs-number">0</span>; --i) {\n      <span class="hljs-comment">// 读取每个 attribute_info 的属性名和属性长度</span>\n      String attributeName = readUTF8(currentAttributeOffset, <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[maxStringLength]);\n      <span class="hljs-keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="hljs-number">2</span>);\n      currentAttributeOffset += <span class="hljs-number">6</span>;\n      <span class="hljs-comment">// 如果当前属性名为 BootstrapMethods ，则进入处理逻辑</span>\n      <span class="hljs-keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        <span class="hljs-comment">// Read the num_bootstrap_methods field and create an array of this size.</span>\n        currentBootstrapMethodOffsets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[readUnsignedShort(currentAttributeOffset)];\n        <span class="hljs-comment">// Compute and store the offset of each \'bootstrap_methods\' array field entry.</span>\n        <span class="hljs-keyword">int</span> currentBootstrapMethodOffset = currentAttributeOffset + <span class="hljs-number">2</span>;\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; currentBootstrapMethodOffsets.length; ++j) {\n          currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;\n          <span class="hljs-comment">// Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),</span>\n          <span class="hljs-comment">// as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).</span>\n          currentBootstrapMethodOffset +=\n              <span class="hljs-number">4</span> + readUnsignedShort(currentBootstrapMethodOffset + <span class="hljs-number">2</span>) * <span class="hljs-number">2</span>;\n        }\n      }\n      currentAttributeOffset += attributeLength;\n    }\n    <span class="hljs-keyword">this</span>.bootstrapMethodOffsets = currentBootstrapMethodOffsets;\n  }</code></pre><p>到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。\n但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。</p>\n<p>这部分的内容在 accept(...) 和 readXXX(...) 中将得到解析。</p>\n<p>主要流程类似:</p>\n<ol>\n<li>读取当前内容的偏移量(相较于整个 byte[])</li>\n<li>解析当前的内容</li>\n<li>调用 visitXXX 方法</li>\n<li>在 visitXXX 方法中进行相关的处理</li>\n<li>visitEnd</li>\n</ol>\n<h2>附录1 Trie.java</h2>\n<pre><code class="hljs"><span class="hljs-keyword">package</span> me.fangfeng.filter;\n\n<span class="hljs-keyword">import</span> java.io.BufferedReader;\n<span class="hljs-keyword">import</span> java.io.BufferedWriter;\n<span class="hljs-keyword">import</span> java.io.FileInputStream;\n<span class="hljs-keyword">import</span> java.io.FileOutputStream;\n<span class="hljs-keyword">import</span> java.io.FileNotFoundException;\n<span class="hljs-keyword">import</span> java.io.InputStreamReader;\n<span class="hljs-keyword">import</span> java.io.IOException;\n<span class="hljs-keyword">import</span> java.io.OutputStreamWriter;\n\n<span class="hljs-comment">/**\n * <span class="hljs-doctag">@author</span> fangfeng\n * <span class="hljs-doctag">@since</span> 2018/5/16\n */</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>{\n    \n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_ITEM = <span class="hljs-number">700000</span>;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> AVG_LENGTH = <span class="hljs-number">11</span>;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_NODE = MAX_ITEM * AVG_LENGTH;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CHAR_NUM = <span class="hljs-number">10</span>;\n\n    <span class="hljs-keyword">int</span>[][] nxt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAX_NODE][CHAR_NUM];\n    <span class="hljs-keyword">boolean</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[MAX_NODE];\n    <span class="hljs-keyword">int</span> trieIndex = <span class="hljs-number">0</span>;\n\n    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">long</span> number)</span> </span>{\n        <span class="hljs-keyword">int</span> tmpIndex = <span class="hljs-number">0</span>;\n        <span class="hljs-keyword">for</span> (;number != <span class="hljs-number">0</span>;number /= <span class="hljs-number">10</span>) {\n            <span class="hljs-keyword">if</span> (nxt[tmpIndex][(<span class="hljs-keyword">int</span>) (number % <span class="hljs-number">10</span>)] == <span class="hljs-number">0</span>) {\n                nxt[tmpIndex][(<span class="hljs-keyword">int</span>) (number % <span class="hljs-number">10</span>)] = ++trieIndex;\n            }\n            tmpIndex = nxt[tmpIndex][(<span class="hljs-keyword">int</span>) (number % <span class="hljs-number">10</span>)];\n        }\n        flag[tmpIndex] = <span class="hljs-keyword">true</span>;\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">long</span> number)</span> </span>{\n        <span class="hljs-keyword">int</span> tmpIndex = <span class="hljs-number">0</span>;\n        <span class="hljs-keyword">for</span> (;number != <span class="hljs-number">0</span>;number /= <span class="hljs-number">10</span>) {\n            <span class="hljs-keyword">if</span> (nxt[tmpIndex][(<span class="hljs-keyword">int</span>) (number % <span class="hljs-number">10</span>)] == <span class="hljs-number">0</span>) {\n                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;\n            }\n            tmpIndex = nxt[tmpIndex][(<span class="hljs-keyword">int</span>) (number % <span class="hljs-number">10</span>)];\n        }\n        <span class="hljs-keyword">return</span> flag[tmpIndex];\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException, IOException </span>{\n\n        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();\n\n        String ruleFilePath = args[<span class="hljs-number">0</span>];\n        String sendFilePath = args[<span class="hljs-number">1</span>];\n        String outFilePath = args[<span class="hljs-number">2</span>];\n\n        BufferedReader ruleReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(ruleFilePath)));\n        BufferedReader sendReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(sendFilePath)));\n\n        BufferedWriter outWriter = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(outFilePath)));\n\n        Trie trie = <span class="hljs-keyword">new</span> Trie();\n        String mobile;\n        <span class="hljs-keyword">while</span>((mobile = ruleReader.readLine()) != <span class="hljs-keyword">null</span>) {\n            trie.insert(Long.parseLong(mobile));\n        }\n        ruleReader.close();\n\n        <span class="hljs-keyword">while</span>((mobile = sendReader.readLine()) != <span class="hljs-keyword">null</span>) {\n            <span class="hljs-keyword">if</span>(trie.query(Long.parseLong(mobile)) == <span class="hljs-keyword">false</span>) {\n                outWriter.write(mobile);\n                outWriter.newLine();\n            }\n        }\n        sendReader.close();\n\n        outWriter.flush();\n        outWriter.close();\n\n        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();\n        System.out.println(String.format(<span class="hljs-string">"exec success! used %d ms"</span>, end - start));\n    }\n}</code></pre><h2>附录2 Constant pool</h2>\n<pre><code>Constant pool:\n    #1 = Methodref          #36.#75       // java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n    #2 = Fieldref           #23.#76       // me/fangfeng/filter/Trie.MAX_NODE:I\n    #3 = Fieldref           #23.#77       // me/fangfeng/filter/Trie.CHAR_NUM:I\n    #4 = Class              #49           // &quot;[[I&quot;\n    #5 = Fieldref           #23.#78       // me/fangfeng/filter/Trie.nxt:[[I\n    #6 = Fieldref           #23.#79       // me/fangfeng/filter/Trie.flag:[Z\n    #7 = Fieldref           #23.#80       // me/fangfeng/filter/Trie.trieIndex:I\n    #8 = Long               10l\n   #10 = Methodref          #81.#82       // java/lang/System.currentTimeMillis:()J\n   #11 = Class              #83           // java/io/BufferedReader\n   #12 = Class              #84           // java/io/InputStreamReader\n   #13 = Class              #85           // java/io/FileInputStream\n   #14 = Methodref          #13.#86       // java/io/FileInputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V\n   #15 = Methodref          #12.#87       // java/io/InputStreamReader.&quot;&lt;init&gt;&quot;:(Ljava/io/InputStream;)V\n   #16 = Methodref          #11.#88       // java/io/BufferedReader.&quot;&lt;init&gt;&quot;:(Ljava/io/Reader;)V\n   #17 = Class              #89           // java/io/BufferedWriter\n   #18 = Class              #90           // java/io/OutputStreamWriter\n   #19 = Class              #91           // java/io/FileOutputStream\n   #20 = Methodref          #19.#86       // java/io/FileOutputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V\n   #21 = Methodref          #18.#92       // java/io/OutputStreamWriter.&quot;&lt;init&gt;&quot;:(Ljava/io/OutputStream;)V\n   #22 = Methodref          #17.#93       // java/io/BufferedWriter.&quot;&lt;init&gt;&quot;:(Ljava/io/Writer;)V\n   #23 = Class              #94           // me/fangfeng/filter/Trie\n   #24 = Methodref          #23.#75       // me/fangfeng/filter/Trie.&quot;&lt;init&gt;&quot;:()V\n   #25 = Methodref          #11.#95       // java/io/BufferedReader.readLine:()Ljava/lang/String;\n   #26 = Methodref          #96.#97       // java/lang/Long.parseLong:(Ljava/lang/String;)J\n   #27 = Methodref          #23.#98       // me/fangfeng/filter/Trie.insert:(J)V\n   #28 = Methodref          #11.#99       // java/io/BufferedReader.close:()V\n   #29 = Methodref          #23.#100      // me/fangfeng/filter/Trie.query:(J)Z\n   #30 = Methodref          #17.#101      // java/io/BufferedWriter.write:(Ljava/lang/String;)V\n   #31 = Methodref          #17.#102      // java/io/BufferedWriter.newLine:()V\n   #32 = Methodref          #17.#103      // java/io/BufferedWriter.flush:()V\n   #33 = Methodref          #17.#99       // java/io/BufferedWriter.close:()V\n   #34 = Fieldref           #81.#104      // java/lang/System.out:Ljava/io/PrintStream;\n   #35 = String             #105          // exec success! used %d ms\n   #36 = Class              #106          // java/lang/Object\n   #37 = Methodref          #96.#107      // java/lang/Long.valueOf:(J)Ljava/lang/Long;\n   #38 = Methodref          #108.#109     // java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n   #39 = Methodref          #110.#111     // java/io/PrintStream.println:(Ljava/lang/String;)V\n   #40 = Integer            700000\n   #41 = Fieldref           #23.#112      // me/fangfeng/filter/Trie.MAX_ITEM:I\n   #42 = Fieldref           #23.#113      // me/fangfeng/filter/Trie.AVG_LENGTH:I\n   #43 = Utf8               MAX_ITEM\n   #44 = Utf8               I\n   #45 = Utf8               AVG_LENGTH\n   #46 = Utf8               MAX_NODE\n   #47 = Utf8               CHAR_NUM\n   #48 = Utf8               nxt\n   #49 = Utf8               [[I\n   #50 = Utf8               flag\n   #51 = Utf8               [Z\n   #52 = Utf8               trieIndex\n   #53 = Utf8               &lt;init&gt;\n   #54 = Utf8               ()V\n   #55 = Utf8               Code\n   #56 = Utf8               LineNumberTable\n   #57 = Utf8               insert\n   #58 = Utf8               (J)V\n   #59 = Utf8               StackMapTable\n   #60 = Utf8               query\n   #61 = Utf8               (J)Z\n   #62 = Utf8               main\n   #63 = Utf8               ([Ljava/lang/String;)V\n   #64 = Class              #114          // &quot;[Ljava/lang/String;&quot;\n   #65 = Class              #115          // java/lang/String\n   #66 = Class              #83           // java/io/BufferedReader\n   #67 = Class              #89           // java/io/BufferedWriter\n   #68 = Class              #94           // me/fangfeng/filter/Trie\n   #69 = Utf8               Exceptions\n   #70 = Class              #116          // java/io/FileNotFoundException\n   #71 = Class              #117          // java/io/IOException\n   #72 = Utf8               &lt;clinit&gt;\n   #73 = Utf8               SourceFile\n   #74 = Utf8               Trie.java\n   #75 = NameAndType        #53:#54       // &quot;&lt;init&gt;&quot;:()V\n   #76 = NameAndType        #46:#44       // MAX_NODE:I\n   #77 = NameAndType        #47:#44       // CHAR_NUM:I\n   #78 = NameAndType        #48:#49       // nxt:[[I\n   #79 = NameAndType        #50:#51       // flag:[Z\n   #80 = NameAndType        #52:#44       // trieIndex:I\n   #81 = Class              #118          // java/lang/System\n   #82 = NameAndType        #119:#120     // currentTimeMillis:()J\n   #83 = Utf8               java/io/BufferedReader\n   #84 = Utf8               java/io/InputStreamReader\n   #85 = Utf8               java/io/FileInputStream\n   #86 = NameAndType        #53:#121      // &quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V\n   #87 = NameAndType        #53:#122      // &quot;&lt;init&gt;&quot;:(Ljava/io/InputStream;)V\n   #88 = NameAndType        #53:#123      // &quot;&lt;init&gt;&quot;:(Ljava/io/Reader;)V\n   #89 = Utf8               java/io/BufferedWriter\n   #90 = Utf8               java/io/OutputStreamWriter\n   #91 = Utf8               java/io/FileOutputStream\n   #92 = NameAndType        #53:#124      // &quot;&lt;init&gt;&quot;:(Ljava/io/OutputStream;)V\n   #93 = NameAndType        #53:#125      // &quot;&lt;init&gt;&quot;:(Ljava/io/Writer;)V\n   #94 = Utf8               me/fangfeng/filter/Trie\n   #95 = NameAndType        #126:#127     // readLine:()Ljava/lang/String;\n   #96 = Class              #128          // java/lang/Long\n   #97 = NameAndType        #129:#130     // parseLong:(Ljava/lang/String;)J\n   #98 = NameAndType        #57:#58       // insert:(J)V\n   #99 = NameAndType        #131:#54      // close:()V\n  #100 = NameAndType        #60:#61       // query:(J)Z\n  #101 = NameAndType        #132:#121     // write:(Ljava/lang/String;)V\n  #102 = NameAndType        #133:#54      // newLine:()V\n  #103 = NameAndType        #134:#54      // flush:()V\n  #104 = NameAndType        #135:#136     // out:Ljava/io/PrintStream;\n  #105 = Utf8               exec success! used %d ms\n  #106 = Utf8               java/lang/Object\n  #107 = NameAndType        #137:#138     // valueOf:(J)Ljava/lang/Long;\n  #108 = Class              #115          // java/lang/String\n  #109 = NameAndType        #139:#140     // format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n  #110 = Class              #141          // java/io/PrintStream\n  #111 = NameAndType        #142:#121     // println:(Ljava/lang/String;)V\n  #112 = NameAndType        #43:#44       // MAX_ITEM:I\n  #113 = NameAndType        #45:#44       // AVG_LENGTH:I\n  #114 = Utf8               [Ljava/lang/String;\n  #115 = Utf8               java/lang/String\n  #116 = Utf8               java/io/FileNotFoundException\n  #117 = Utf8               java/io/IOException\n  #118 = Utf8               java/lang/System\n  #119 = Utf8               currentTimeMillis\n  #120 = Utf8               ()J\n  #121 = Utf8               (Ljava/lang/String;)V\n  #122 = Utf8               (Ljava/io/InputStream;)V\n  #123 = Utf8               (Ljava/io/Reader;)V\n  #124 = Utf8               (Ljava/io/OutputStream;)V\n  #125 = Utf8               (Ljava/io/Writer;)V\n  #126 = Utf8               readLine\n  #127 = Utf8               ()Ljava/lang/String;\n  #128 = Utf8               java/lang/Long\n  #129 = Utf8               parseLong\n  #130 = Utf8               (Ljava/lang/String;)J\n  #131 = Utf8               close\n  #132 = Utf8               write\n  #133 = Utf8               newLine\n  #134 = Utf8               flush\n  #135 = Utf8               out\n  #136 = Utf8               Ljava/io/PrintStream;\n  #137 = Utf8               valueOf\n  #138 = Utf8               (J)Ljava/lang/Long;\n  #139 = Utf8               format\n  #140 = Utf8               (Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n  #141 = Utf8               java/io/PrintStream\n  #142 = Utf8               println\n</code></pre>\n<h2>参考</h2>\n<p>[1]: https://docs.oracle.com/javase/specs/jvms/se8/html/index.html &quot;Java Virtual Machine Specification&quot;\n[2]: http://icyfenix.iteye.com/blog/1256329 &quot;Java虚拟机规范（Java SE 7 中文版）&quot;</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-06-11-ASM-ClassReader.json",ext:".json",sourceBase:"2018-06-11-ASM-ClassReader.md",sourceExt:".md"}},RrPW:function(n){n.exports={bodyContent:"title: 字符集与字符编码\nauthor: fangfeng\ndate: 2019-02-02\ntags:\n  - Unicode\n  - Character Encoding\n---\n\n{% pdf https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview %}",bodyHtml:"<p>title: 字符集与字符编码\nauthor: fangfeng\ndate: 2019-02-02\ntags:</p>\n<ul>\n<li>Unicode</li>\n<li>Character Encoding</li>\n</ul>\n<hr>\n<p>{% pdf https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview %}</p>\n",preview:"",title:"Unicode",dir:"content",base:"2019-02-02-unicode.json",ext:".json",sourceBase:"2019-02-02-unicode.md",sourceExt:".md"}},S4Mp:function(n){n.exports={title:"理解 Linux Kernel (0) - 概述",author:"fangfeng",date:"2018-08-19T00:00:00.000Z",tags:["Linux","Kernel"],bodyContent:"## 概述\n\n之所以想要了解 Linux Kernel，与前一个月的 JVM ClassFile 的学习有这很大的关联。\n\n说实话，刨除 JVM 的具体实现，Sun (或者现在该说是 Oracle) 确实将 Java 的底层逻辑设计得相当简单。\n\n1. 有限而统一的指令集(不超过 256 个，可以用 1 字节表示)\n2. 操作数栈+局部变量表共同实现的指令运算\n3. 高度封装的成员变量/方法的寻址方式\n3. ... (见识短浅，想不到了...以后再补充吧)\n\n但是，与 JVM 模拟的虚拟机不同，实体机器有着更为复杂的结构。\n最根本的，不同厂商的机器就带来了不同的 CPU 指令集，这就已经让人难以接受了。\n\n其实最初，是想要继续去看看 Hotspot 虚拟机的。但是，混杂的代码(C++, Java, 平台相关各种实现) 带来了很大的阅读障碍。\n最根本的，我甚至找不到一个学习的基本立足点，出发点(当然，也可能我根本就没仔细去看，哈哈)。\n\n借着一次机会，我开始看《程序员的自我修养——链接、装载与库》一书。确实无论是 ELF 格式，静态链接与动态链接甚至 Linux 的内建函数\n都给了我比较深刻的印象，向我展示了 C 更深入的一面。但是，macOS 给我带来了比较大的客观阻碍(即使用 Docker 容器得到了一个可用的 Linux 环境，但是否与直接建立在机器上的系统有所区别，此处还得打个问号)。\n同时，书中的部分内容上下不统一，缺少前后文也是一个重大的问题。总之，这并不完全适合我这种初学者逐一进行书中所描述的全部实验。\n\n最后，我决定展开对 Linux Kernel 的学习，试图通过对直接构架在硬件上的操作系统进行一番比较深入的学习。\n\n期间，找过一些资料，也了解到 Linus Torvals 直接领导着的 [Kernel 项目的官网](https://www.kernel.org/)；甚至，找到了各个版本的 kernel 源码(虽然确实地丢失了最早期 0.XX 的若干版本)。\n不得不说，就目前来讲，我觉得《Linux内核完全注释》是最适合(*打个问号，至少暂时是的*)我学习的一书。\n\n之后的若干博文，将都以《Linux内核完全注释》中的内容为基础，结合目前的实际需要，从而进行实操性的认知与学习。\n\n\x3c!-- more --\x3e\n\n## 软硬件描述\n\n进行这方面的描述，是因为 Linux Kernel 将直接与底层硬件打交道(当然，这方面使用的 Bochs 仿真器)。\n但是，准备诸如 .img (磁盘映像文件), 机器指令文件等都不得不借助于现有的平台。\n\n- 操作系统: macOS 10.13.6 , Ubuntu 16.04 (Docker 虚拟机容器)\n- 仿真器  : Bochs 2.6.9\\_2 (macOS 与 Ubuntu 上相同)\n- 更多    : 将直接在正文首次使用到时进行说明\n\n## Bochs\n\n[Bochs 官网](http://bochs.sourceforge.net/)\n\n[Bochs 下载链](https://sourceforge.net/projects/bochs/files/)\n\n说实话这一周都差不多要被 Bochs 折腾死，用源码进行编译出现各种各样的问题。(我猜新版本根本就没考虑对 macOS 做兼容)\n\n最后，不得不使用经编译后的二进制分发版。 `brew install bochs` 当然了，反正也能用，就不纠结非得自己编译了。(如果哪位能成功编译个 macOS 可用的应用，希望能把踩得坑整理整理，供后来者参考)\n\n### 目录结构\n\n```plain\n.\n├── CHANGES\n├── COPYING\n├── INSTALL_RECEIPT.json\n├── LICENSE\n├── README\n├── TODO\n├── bin\n│   ├── bochs                           // bochs 可执行文件\n│   └── bximage                         // 制作磁盘映像文件的工具\n├── lib                                 // 动态库目录\n│   └── bochs\n│       └── plugins\n│           ├── libbx_acpi.0.0.0.so\n│           ├── ... 略\n│           └── libbx_vga.so -> libbx_vga.0.0.0.so\n└── share                               // 与体系结构无关的文件放在此目录下\n    ├── bochs\n    │   ├── BIOS-bochs-latest\n    │   ├── BIOS-bochs-legacy\n    │   ├── SeaBIOS-README\n    │   ├── VGABIOS-elpin-2.40\n    │   ├── VGABIOS-elpin-LICENSE\n    │   ├── VGABIOS-lgpl-README\n    │   ├── VGABIOS-lgpl-latest\n    │   ├── VGABIOS-lgpl-latest-cirrus\n    │   ├── VGABIOS-lgpl-latest-cirrus-debug\n    │   ├── VGABIOS-lgpl-latest-debug\n    │   ├── bios.bin-1.7.5\n    │   └── keymaps\n    │       ├── sdl-pc-us.map\n    │       ├── ... 略\n    │       └── x11-pc-us.map\n    ├── doc\n    │   └── bochs\n    │       ├── CHANGES\n    │       ├── COPYING\n    │       ├── LICENSE\n    │       ├── README\n    │       ├── TODO\n    │       ├── bochsrc-sample.txt      // bochsrc 配置文件的示例样板\n    │       └── slirp.conf\n    └── man\n        ├── man1\n        │   ├── bochs-dlx.1.gz\n        │   ├── bochs.1.gz\n        │   └── bximage.1.gz\n        └── man5\n            └── bochsrc.5.gz\n```\n\n### 简单使用\n\nBochs 下载链提供了 Bochs 不同版本的源码的下载，同时也提供了一些可用的磁盘映像文件(都是一些已经经过处理，可用使用进行仿真运行的 OS )\n\n说实话，这是绝对有必要进行的一步，不仅仅是了解配置文件 bochsrc 的配置方式，更可用借此了解一下仿真器的使用方式。(在启动系统上，我也被坑了一天，后面细说)\n\n首先，这里演示的将是 DLX Linux 。\n\n1. 下载，解压，进入目录。\n\n2. 目录下文件如下\n\n```plain\n.\n├── bochsrc.txt         // bochs 启动时将默认通过这个文件读取仿真器配置\n├── hd10meg.img         // 磁盘映像文件\n├── readme.txt\n└── testform.txt\n```\n\n3. 启动仿真器\n\n在 DLX Linux 目录下键入命令 `bochs`, 观察到命令行输出:\n\n```plain\n========================================================================\n                       Bochs x86 Emulator 2.6.9\n               Built from SVN snapshot on April 9, 2017\n                  Compiled on May  2 2018 at 13:26:32\n========================================================================\n00000000000i[      ] LTDL_LIBRARY_PATH not set. using compile time default '/usr/local/Cellar/bochs/2.6.9_2/lib/bochs/plugins'\n00000000000i[      ] BXSHARE not set. using compile time default '/usr/local/Cellar/bochs/2.6.9_2/share/bochs'\n00000000000i[      ] lt_dlhandle is 0x7fef2252a500\n00000000000i[PLUGIN] loaded plugin libbx_usb_common.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252a8a0\n00000000000i[PLUGIN] loaded plugin libbx_unmapped.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252ad00\n00000000000i[PLUGIN] loaded plugin libbx_biosdev.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252b1e0\n00000000000i[PLUGIN] loaded plugin libbx_speaker.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252ba50\n00000000000i[PLUGIN] loaded plugin libbx_extfpuirq.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252be70\n00000000000i[PLUGIN] loaded plugin libbx_parallel.so\n00000000000i[      ] lt_dlhandle is 0x7fef238013c0\n00000000000i[PLUGIN] loaded plugin libbx_serial.so\n00000000000i[      ] lt_dlhandle is 0x7fef22706cd0\n00000000000i[PLUGIN] loaded plugin libbx_iodebug.so\n00000000000i[      ] reading configuration from bochsrc.txt\n------------------------------\nBochs Configuration: Main Menu\n------------------------------\n\nThis is the Bochs Configuration Interface, where you can describe the\nmachine that you want to simulate.  Bochs has already searched for a\nconfiguration file (typically called bochsrc.txt) and loaded it if it\ncould be found.  When you are satisfied with the configuration, go\nahead and start the simulation.\n\nYou can also start bochs with the -q option to skip these menus.\n\n1. Restore factory default configuration\n2. Read options from...\n3. Edit options\n4. Save options to...\n5. Restore the Bochs state from...\n6. Begin simulation\n7. Quit now\n\nPlease choose one: [6]\n```\n\nbochs 默认读取当前目录下 `bochsrc.txt` 文件，因此不需要其他配置。\n\n选择 6 或者直接 *回车*\n\n```plain\n00000000000i[      ] lt_dlhandle is 0x7fef22707270\n00000000000i[PLUGIN] loaded plugin libbx_sdl2.so\n00000000000i[      ] installing sdl2 module as the Bochs GUI\n00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800\n00000000000i[      ] using log file bochsout.txt\nNext at t=0\n(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0\n<bochs:1>\n```\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuevtktuh0j30zc0tcwfd.jpg)\n\n终端出现更多输出，同时 Bochs 开启了一个可视化终端(当然，现在还没有任何内容)。\n\n在这儿被坑了好久。本来以为 Bochs 会直接执行 BIOS 指令，启动操作系统，但是自始至终，停在这里就没动过...\n\n这边是由于 Bochs 本身是支持调试的(T\\_T，见鬼)，就像是 GDB 和 LLDB 一样，进入调试后，需要指令 `c` (continue) 来继续执行(当然，还有其它调试命令)\n\n4. 键入 `c` \n\n```plain\n<bochs:1> c\n```\n\n仿真器开始引导程序的加载\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuew9zoocuj313c0pstaw.jpg)\n\nOS Kernel 启动，等待用户登录 (默认的用户是 root , 没有密码)。\n之后就和普通的 Linux 机器类似，不过支持的命令比较少。毕竟是一个精简后的系统。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuewamqzm6j313q0pqjtw.jpg)\n\n5. 关机\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuewi9wjawj313q0q2gnc.jpg)\n\n仿真器仿真了许多实体机案件，右上角最后一个就是关机键\n\n## Docker 容器中运行 Ubuntu\n\n这部分不详述，作为一个热门的技术，这方面的资料很多。Ubuntu 系统只是为了来执行一些 macOS 上没有的命令的(比如 `as86`, `ld86`)\n\n简述两个 docker 容器和宿主机间复制文件的命令 \n\n在宿主机下执行命令:\n\n```sh\ndocker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-\ndocker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH [flags]\n```\n\n例如:\n\n```sh\ndocker cp linux:/root/hello.c ./hello.c         # 这里 linux 是 docker 容器名\ndocker cp 92dfc8ad70e1:/root/hello.c ./hello.c  # 这里 92dfc8ad70e1 是 docker 容器 ID\n```\n\n## 参考\n\n\\[1\\]. 俞甲子. 程序员的自我修养[M]. 电子工业出版社, 2009.\n\\[2\\]. 赵炯. Linux内核完全注释 内核版本0.11 V3.0[EB/OL]. http://www.oldlinux.org/, 2007\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```",bodyHtml:'<h2>概述</h2>\n<p>之所以想要了解 Linux Kernel，与前一个月的 JVM ClassFile 的学习有这很大的关联。</p>\n<p>说实话，刨除 JVM 的具体实现，Sun (或者现在该说是 Oracle) 确实将 Java 的底层逻辑设计得相当简单。</p>\n<ol>\n<li>有限而统一的指令集(不超过 256 个，可以用 1 字节表示)</li>\n<li>操作数栈+局部变量表共同实现的指令运算</li>\n<li>高度封装的成员变量/方法的寻址方式</li>\n<li>... (见识短浅，想不到了...以后再补充吧)</li>\n</ol>\n<p>但是，与 JVM 模拟的虚拟机不同，实体机器有着更为复杂的结构。\n最根本的，不同厂商的机器就带来了不同的 CPU 指令集，这就已经让人难以接受了。</p>\n<p>其实最初，是想要继续去看看 Hotspot 虚拟机的。但是，混杂的代码(C++, Java, 平台相关各种实现) 带来了很大的阅读障碍。\n最根本的，我甚至找不到一个学习的基本立足点，出发点(当然，也可能我根本就没仔细去看，哈哈)。</p>\n<p>借着一次机会，我开始看《程序员的自我修养——链接、装载与库》一书。确实无论是 ELF 格式，静态链接与动态链接甚至 Linux 的内建函数\n都给了我比较深刻的印象，向我展示了 C 更深入的一面。但是，macOS 给我带来了比较大的客观阻碍(即使用 Docker 容器得到了一个可用的 Linux 环境，但是否与直接建立在机器上的系统有所区别，此处还得打个问号)。\n同时，书中的部分内容上下不统一，缺少前后文也是一个重大的问题。总之，这并不完全适合我这种初学者逐一进行书中所描述的全部实验。</p>\n<p>最后，我决定展开对 Linux Kernel 的学习，试图通过对直接构架在硬件上的操作系统进行一番比较深入的学习。</p>\n<p>期间，找过一些资料，也了解到 Linus Torvals 直接领导着的 <a href="https://www.kernel.org/">Kernel 项目的官网</a>；甚至，找到了各个版本的 kernel 源码(虽然确实地丢失了最早期 0.XX 的若干版本)。\n不得不说，就目前来讲，我觉得《Linux内核完全注释》是最适合(<em>打个问号，至少暂时是的</em>)我学习的一书。</p>\n<p>之后的若干博文，将都以《Linux内核完全注释》中的内容为基础，结合目前的实际需要，从而进行实操性的认知与学习。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>软硬件描述</h2>\n<p>进行这方面的描述，是因为 Linux Kernel 将直接与底层硬件打交道(当然，这方面使用的 Bochs 仿真器)。\n但是，准备诸如 .img (磁盘映像文件), 机器指令文件等都不得不借助于现有的平台。</p>\n<ul>\n<li>操作系统: macOS 10.13.6 , Ubuntu 16.04 (Docker 虚拟机容器)</li>\n<li>仿真器  : Bochs 2.6.9_2 (macOS 与 Ubuntu 上相同)</li>\n<li>更多    : 将直接在正文首次使用到时进行说明</li>\n</ul>\n<h2>Bochs</h2>\n<p><a href="http://bochs.sourceforge.net/">Bochs 官网</a></p>\n<p><a href="https://sourceforge.net/projects/bochs/files/">Bochs 下载链</a></p>\n<p>说实话这一周都差不多要被 Bochs 折腾死，用源码进行编译出现各种各样的问题。(我猜新版本根本就没考虑对 macOS 做兼容)</p>\n<p>最后，不得不使用经编译后的二进制分发版。 <code>brew install bochs</code> 当然了，反正也能用，就不纠结非得自己编译了。(如果哪位能成功编译个 macOS 可用的应用，希望能把踩得坑整理整理，供后来者参考)</p>\n<h3>目录结构</h3>\n<pre><code class="hljs">.\n├── CHANGES\n├── COPYING\n├── INSTALL_RECEIPT.json\n├── LICENSE\n├── README\n├── TODO\n├── bin\n│   ├── bochs                           // bochs 可执行文件\n│   └── bximage                         // 制作磁盘映像文件的工具\n├── lib                                 // 动态库目录\n│   └── bochs\n│       └── plugins\n│           ├── libbx_acpi.0.0.0.so\n│           ├── ... 略\n│           └── libbx_vga.so -&gt; libbx_vga.0.0.0.so\n└── share                               // 与体系结构无关的文件放在此目录下\n    ├── bochs\n    │   ├── BIOS-bochs-latest\n    │   ├── BIOS-bochs-legacy\n    │   ├── SeaBIOS-README\n    │   ├── VGABIOS-elpin-2.40\n    │   ├── VGABIOS-elpin-LICENSE\n    │   ├── VGABIOS-lgpl-README\n    │   ├── VGABIOS-lgpl-latest\n    │   ├── VGABIOS-lgpl-latest-cirrus\n    │   ├── VGABIOS-lgpl-latest-cirrus-debug\n    │   ├── VGABIOS-lgpl-latest-debug\n    │   ├── bios.bin-1.7.5\n    │   └── keymaps\n    │       ├── sdl-pc-us.map\n    │       ├── ... 略\n    │       └── x11-pc-us.map\n    ├── doc\n    │   └── bochs\n    │       ├── CHANGES\n    │       ├── COPYING\n    │       ├── LICENSE\n    │       ├── README\n    │       ├── TODO\n    │       ├── bochsrc-sample.txt      // bochsrc 配置文件的示例样板\n    │       └── slirp.conf\n    └── man\n        ├── man1\n        │   ├── bochs-dlx.1.gz\n        │   ├── bochs.1.gz\n        │   └── bximage.1.gz\n        └── man5\n            └── bochsrc.5.gz</code></pre><h3>简单使用</h3>\n<p>Bochs 下载链提供了 Bochs 不同版本的源码的下载，同时也提供了一些可用的磁盘映像文件(都是一些已经经过处理，可用使用进行仿真运行的 OS )</p>\n<p>说实话，这是绝对有必要进行的一步，不仅仅是了解配置文件 bochsrc 的配置方式，更可用借此了解一下仿真器的使用方式。(在启动系统上，我也被坑了一天，后面细说)</p>\n<p>首先，这里演示的将是 DLX Linux 。</p>\n<ol>\n<li>\n<p>下载，解压，进入目录。</p>\n</li>\n<li>\n<p>目录下文件如下</p>\n</li>\n</ol>\n<pre><code class="hljs">.\n├── bochsrc.txt         // bochs 启动时将默认通过这个文件读取仿真器配置\n├── hd10meg.img         // 磁盘映像文件\n├── readme.txt\n└── testform.txt</code></pre><ol start="3">\n<li>启动仿真器</li>\n</ol>\n<p>在 DLX Linux 目录下键入命令 <code>bochs</code>, 观察到命令行输出:</p>\n<pre><code class="hljs">========================================================================\n                       Bochs x86 Emulator 2.6.9\n               Built from SVN snapshot on April 9, 2017\n                  Compiled on May  2 2018 at 13:26:32\n========================================================================\n00000000000i[      ] LTDL_LIBRARY_PATH not set. using compile time default \'/usr/local/Cellar/bochs/2.6.9_2/lib/bochs/plugins\'\n00000000000i[      ] BXSHARE not set. using compile time default \'/usr/local/Cellar/bochs/2.6.9_2/share/bochs\'\n00000000000i[      ] lt_dlhandle is 0x7fef2252a500\n00000000000i[PLUGIN] loaded plugin libbx_usb_common.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252a8a0\n00000000000i[PLUGIN] loaded plugin libbx_unmapped.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252ad00\n00000000000i[PLUGIN] loaded plugin libbx_biosdev.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252b1e0\n00000000000i[PLUGIN] loaded plugin libbx_speaker.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252ba50\n00000000000i[PLUGIN] loaded plugin libbx_extfpuirq.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252be70\n00000000000i[PLUGIN] loaded plugin libbx_parallel.so\n00000000000i[      ] lt_dlhandle is 0x7fef238013c0\n00000000000i[PLUGIN] loaded plugin libbx_serial.so\n00000000000i[      ] lt_dlhandle is 0x7fef22706cd0\n00000000000i[PLUGIN] loaded plugin libbx_iodebug.so\n00000000000i[      ] reading configuration from bochsrc.txt\n------------------------------\nBochs Configuration: Main Menu\n------------------------------\n\nThis is the Bochs Configuration Interface, where you can describe the\nmachine that you want to simulate.  Bochs has already searched for a\nconfiguration file (typically called bochsrc.txt) and loaded it if it\ncould be found.  When you are satisfied with the configuration, go\nahead and start the simulation.\n\nYou can also start bochs with the -q option to skip these menus.\n\n1. Restore factory default configuration\n2. Read options from...\n3. Edit options\n4. Save options to...\n5. Restore the Bochs state from...\n6. Begin simulation\n7. Quit now\n\nPlease choose one: [6]</code></pre><p>bochs 默认读取当前目录下 <code>bochsrc.txt</code> 文件，因此不需要其他配置。</p>\n<p>选择 6 或者直接 <em>回车</em></p>\n<pre><code class="hljs">00000000000i[      ] lt_dlhandle is 0x7fef22707270\n00000000000i[PLUGIN] loaded plugin libbx_sdl2.so\n00000000000i[      ] installing sdl2 module as the Bochs GUI\n00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800\n00000000000i[      ] using log file bochsout.txt\nNext at t=0\n(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0\n&lt;bochs:1&gt;</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fuevtktuh0j30zc0tcwfd.jpg" alt=""></p>\n<p>终端出现更多输出，同时 Bochs 开启了一个可视化终端(当然，现在还没有任何内容)。</p>\n<p>在这儿被坑了好久。本来以为 Bochs 会直接执行 BIOS 指令，启动操作系统，但是自始至终，停在这里就没动过...</p>\n<p>这边是由于 Bochs 本身是支持调试的(T_T，见鬼)，就像是 GDB 和 LLDB 一样，进入调试后，需要指令 <code>c</code> (continue) 来继续执行(当然，还有其它调试命令)</p>\n<ol start="4">\n<li>键入 <code>c</code></li>\n</ol>\n<pre><code class="hljs">&lt;bochs:1&gt; c</code></pre><p>仿真器开始引导程序的加载</p>\n<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuew9zoocuj313c0pstaw.jpg" alt=""></p>\n<p>OS Kernel 启动，等待用户登录 (默认的用户是 root , 没有密码)。\n之后就和普通的 Linux 机器类似，不过支持的命令比较少。毕竟是一个精简后的系统。</p>\n<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuewamqzm6j313q0pqjtw.jpg" alt=""></p>\n<ol start="5">\n<li>关机</li>\n</ol>\n<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fuewi9wjawj313q0q2gnc.jpg" alt=""></p>\n<p>仿真器仿真了许多实体机案件，右上角最后一个就是关机键</p>\n<h2>Docker 容器中运行 Ubuntu</h2>\n<p>这部分不详述，作为一个热门的技术，这方面的资料很多。Ubuntu 系统只是为了来执行一些 macOS 上没有的命令的(比如 <code>as86</code>, <code>ld86</code>)</p>\n<p>简述两个 docker 容器和宿主机间复制文件的命令</p>\n<p>在宿主机下执行命令:</p>\n<pre><code class="hljs">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-\ndocker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH [flags]</code></pre><p>例如:</p>\n<pre><code class="hljs">docker cp linux:/root/hello.c ./hello.c         <span class="hljs-comment"># 这里 linux 是 docker 容器名</span>\ndocker cp 92dfc8ad70e1:/root/hello.c ./hello.c  <span class="hljs-comment"># 这里 92dfc8ad70e1 是 docker 容器 ID</span></code></pre><h2>参考</h2>\n<p>[1]. 俞甲子. 程序员的自我修养[M]. 电子工业出版社, 2009.\n[2]. 赵炯. Linux内核完全注释 内核版本0.11 V3.0[EB/OL]. http://www.oldlinux.org/, 2007</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-08-19-understand-Kernel-0.json",ext:".json",sourceBase:"2018-08-19-understand-Kernel-0.md",sourceExt:".md"}},SqPm:function(n){n.exports={title:"正则表达式指数爆炸",author:"fangfeng",date:"2018-11-16T00:00:00.000Z",tags:["regular expression","指数爆炸"],mathjax:!0,bodyContent:'## 背景\n\n昨天接触到一个很有意思的问题, 公司测试环境一台机器 CPU 跑到了 400%，导致该机器上的所有服务都挂掉了。\n\n最后查到的原因竟然是正则表达式所引起的，大大出乎意料啊。虽然早就知道正则效率很差，但绝对没有想到会导致整个机器上服务崩溃的情况。\n\n先简单展示下问题正则:\n\n```java\nString regex = "(\\\\w+,?)+";\nString val = "abcdefghijklmno,abcdefghijklmno+";\nSystem.out.println(val.matches(regex));\n```\n\n最终的执行时间是 17s 左右。\n\n相反，如果改成 `String val = "abcdefghijklmno,abcdefghijklmno"` ，实际执行时间 1ms 左右。\n\n哈哈，完全不是一个量级的结果。\n\n最后，当然是要找原因了:< 当然，有其它重要的事在耽搁，没时间去看 Java Regex 源码。不过，从正则本身下手反而是个好事情。毕竟几乎所有的编程语言都有对正则的支持。而同样的，都存在着这样的问题。那就可以大胆猜想其实是和语言本身无关，而在于正则规范本身了。\n\n先给个结果，罪魁祸首就是`指数爆炸`\n\n\x3c!-- more --\x3e\n\n## 追本溯源\n\n这里并不准备一步一步地阐述正则的，如果真的是零基础的话，推荐先看一下 [学习正则](https://github.com/ziishaned/learn-regex/blob/master/README-cn.md)\n\n就事论事，还是以 `regex ::= (\\w+,?)+` 作为示例来进行说明。\n\n首先需要了解的是 `val.matches(regex)` 所要进行的工作是判断 `val` 全串是否符合 `regex` 正则模式。而正则所要做的工作就是尝试所有的匹配可能性(当然，对于 `val` 这个串来说，最后匹配到 `abcd..,abcd..mno+` 的 `+` 的时候一定是失败的，因为 `regex` 并不匹配 `+`)\n\n简单扩展一下对`尝试所有匹配可能性`这句话的描述:\n\n我们以 `()` 对应 `regex` 中的一组 `(\\w+,?)` ，而最后一个 `+` 表示一个或多个(即允许存在多个`()`)\n\n对 `val` 串的匹配可能性有\n\n- (abcdefghijklmno,)(abcdefghijklmno)+\n\n- (abcd)(efghijklmno,)(abcdefghijklmno)+\n\n- (abcdefghijklmno,)(abcdef)(ghijklmno)+\n\n- (abc)(defghijklmno,)(abcde)(fg)(hijklmno)+\n\n- ...\n\n有相当多的匹配可能，不再一一详述(事实上，光靠个人手工根本列举不完。\n\n那么到底会有多少中匹配可能性呢?\n\n下面我们就来简单计算一下:\n\n首先，我们把 `(\\w+,?)+` 这个正则扩展一下，它与下列这些串都是等价的 `(\\w+,|\\w+)+`, `(\\w+,)?(\\w+)?(\\w+,?)+`, `(\\w+,)?(\\w+)?(\\w+)?(\\w+,?)+` ...\n\n也就是说，我们能够至少把 `abcdefghijklmno,abcdefghijklmno+` 按照匹配串划分出1组，2组，3组...30组(因为每个组至少需要一个`\\w` )\n\n不过这个按照1组，2组...去计算可能性的话实在是费力不讨好的事情。用组合数学来考虑这个问题\n\n首先，整个 `abcdefghijklmno,abcdefghijklmno+` 的开始应该有一个左括号 `(`，即 `(abcdefghijklmno,abcdefghijklmno+`\n\n其次，到 `,` 为止至少应该有一个右左括号 `)(`，即 `(abcdefghijklmno,)(abcdefghijklmno+`\n\n再次，由于到 `o+` 为止一定匹配失败，因此，`+` 之前应该有一个 `)`, 即 `(abcdefghijklmno,)(abcdefghijklmno)+`\n\n至于其他字符间的空隙，除了 `o,` 之间不能存在右左括号 `)(` ，其他字符间都可以随意插入 `)(` (至于为什么是右左括号，表示前一个组的结束与新的组的开始)\n\n那么总共有多少种可能? \n\n- 插入零个右左括号 `)(` , $C\\_{28}^0$ = 1 种可行方案\n\n- 插入一个右左括号 `)(` , $C\\_{28}^1$ = 28 种可行方案 (总共 28 个可用字符间隙)\n\n- 插入两个右左括号 `)(` , $C\\_{28}^2$ 种可行方案\n\n- ...\n\n- 插入28个右左括号 `)(` , $C\\_{28}^{28}$ 种可行方案\n\n累加的结果为 $C\\_{28}^1 + C\\_{28}^2 + C\\_{28}^3 + ... + C\\_{28}^{28} = 2^{28}$\n\n可想而知为什么会花 17s 了吧。毕竟达到了 2500 万以上的计算量级，加上 regex 本身就是偏慢的。\n\n至于为什么把 `abcdefghijklmno,abcdefghijklmno+` 串的 `+` 去掉就变快了？理由也很简单，`matches(regex)` 在正则串与原串匹配上之后就会快速结束，因为结果只需要告知某次匹配成功了即可。而失败的匹配会不断地尝试所有的可能性。\n\n## 解决方案\n\n至于解决方案，从上面的原因就可以看到，拒绝在贪婪组模式下(`(...)+`) 的组内多模式匹配可能。即 `(a+a+)+` 是不能被允许的，而 `(a+b+)+` 是可靠的。\n\n写得仓促，如有根源性错误，欢迎指正。\n\n## 参考\n\n[Catastrophic Backtracking(灾难性回溯)](https://www.regular-expressions.info/catastrophic.html)\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<h2>背景</h2>\n<p>昨天接触到一个很有意思的问题, 公司测试环境一台机器 CPU 跑到了 400%，导致该机器上的所有服务都挂掉了。</p>\n<p>最后查到的原因竟然是正则表达式所引起的，大大出乎意料啊。虽然早就知道正则效率很差，但绝对没有想到会导致整个机器上服务崩溃的情况。</p>\n<p>先简单展示下问题正则:</p>\n<pre><code class="hljs">String regex = <span class="hljs-string">"(\\\\w+,?)+"</span>;\nString val = <span class="hljs-string">"abcdefghijklmno,abcdefghijklmno+"</span>;\nSystem.out.println(val.matches(regex));</code></pre><p>最终的执行时间是 17s 左右。</p>\n<p>相反，如果改成 <code>String val = &quot;abcdefghijklmno,abcdefghijklmno&quot;</code> ，实际执行时间 1ms 左右。</p>\n<p>哈哈，完全不是一个量级的结果。</p>\n<p>最后，当然是要找原因了:&lt; 当然，有其它重要的事在耽搁，没时间去看 Java Regex 源码。不过，从正则本身下手反而是个好事情。毕竟几乎所有的编程语言都有对正则的支持。而同样的，都存在着这样的问题。那就可以大胆猜想其实是和语言本身无关，而在于正则规范本身了。</p>\n<p>先给个结果，罪魁祸首就是<code>指数爆炸</code></p>\n<p>&lt;!-- more --&gt;</p>\n<h2>追本溯源</h2>\n<p>这里并不准备一步一步地阐述正则的，如果真的是零基础的话，推荐先看一下 <a href="https://github.com/ziishaned/learn-regex/blob/master/README-cn.md">学习正则</a></p>\n<p>就事论事，还是以 <code>regex ::= (\\w+,?)+</code> 作为示例来进行说明。</p>\n<p>首先需要了解的是 <code>val.matches(regex)</code> 所要进行的工作是判断 <code>val</code> 全串是否符合 <code>regex</code> 正则模式。而正则所要做的工作就是尝试所有的匹配可能性(当然，对于 <code>val</code> 这个串来说，最后匹配到 <code>abcd..,abcd..mno+</code> 的 <code>+</code> 的时候一定是失败的，因为 <code>regex</code> 并不匹配 <code>+</code>)</p>\n<p>简单扩展一下对<code>尝试所有匹配可能性</code>这句话的描述:</p>\n<p>我们以 <code>()</code> 对应 <code>regex</code> 中的一组 <code>(\\w+,?)</code> ，而最后一个 <code>+</code> 表示一个或多个(即允许存在多个<code>()</code>)</p>\n<p>对 <code>val</code> 串的匹配可能性有</p>\n<ul>\n<li>\n<p>(abcdefghijklmno,)(abcdefghijklmno)+</p>\n</li>\n<li>\n<p>(abcd)(efghijklmno,)(abcdefghijklmno)+</p>\n</li>\n<li>\n<p>(abcdefghijklmno,)(abcdef)(ghijklmno)+</p>\n</li>\n<li>\n<p>(abc)(defghijklmno,)(abcde)(fg)(hijklmno)+</p>\n</li>\n<li>\n<p>...</p>\n</li>\n</ul>\n<p>有相当多的匹配可能，不再一一详述(事实上，光靠个人手工根本列举不完。</p>\n<p>那么到底会有多少中匹配可能性呢?</p>\n<p>下面我们就来简单计算一下:</p>\n<p>首先，我们把 <code>(\\w+,?)+</code> 这个正则扩展一下，它与下列这些串都是等价的 <code>(\\w+,|\\w+)+</code>, <code>(\\w+,)?(\\w+)?(\\w+,?)+</code>, <code>(\\w+,)?(\\w+)?(\\w+)?(\\w+,?)+</code> ...</p>\n<p>也就是说，我们能够至少把 <code>abcdefghijklmno,abcdefghijklmno+</code> 按照匹配串划分出1组，2组，3组...30组(因为每个组至少需要一个<code>\\w</code> )</p>\n<p>不过这个按照1组，2组...去计算可能性的话实在是费力不讨好的事情。用组合数学来考虑这个问题</p>\n<p>首先，整个 <code>abcdefghijklmno,abcdefghijklmno+</code> 的开始应该有一个左括号 <code>(</code>，即 <code>(abcdefghijklmno,abcdefghijklmno+</code></p>\n<p>其次，到 <code>,</code> 为止至少应该有一个右左括号 <code>)(</code>，即 <code>(abcdefghijklmno,)(abcdefghijklmno+</code></p>\n<p>再次，由于到 <code>o+</code> 为止一定匹配失败，因此，<code>+</code> 之前应该有一个 <code>)</code>, 即 <code>(abcdefghijklmno,)(abcdefghijklmno)+</code></p>\n<p>至于其他字符间的空隙，除了 <code>o,</code> 之间不能存在右左括号 <code>)(</code> ，其他字符间都可以随意插入 <code>)(</code> (至于为什么是右左括号，表示前一个组的结束与新的组的开始)</p>\n<p>那么总共有多少种可能?</p>\n<ul>\n<li>\n<p>插入零个右左括号 <code>)(</code> , $C_{28}^0$ = 1 种可行方案</p>\n</li>\n<li>\n<p>插入一个右左括号 <code>)(</code> , $C_{28}^1$ = 28 种可行方案 (总共 28 个可用字符间隙)</p>\n</li>\n<li>\n<p>插入两个右左括号 <code>)(</code> , $C_{28}^2$ 种可行方案</p>\n</li>\n<li>\n<p>...</p>\n</li>\n<li>\n<p>插入28个右左括号 <code>)(</code> , $C_{28}^{28}$ 种可行方案</p>\n</li>\n</ul>\n<p>累加的结果为 $C_{28}^1 + C_{28}^2 + C_{28}^3 + ... + C_{28}^{28} = 2^{28}$</p>\n<p>可想而知为什么会花 17s 了吧。毕竟达到了 2500 万以上的计算量级，加上 regex 本身就是偏慢的。</p>\n<p>至于为什么把 <code>abcdefghijklmno,abcdefghijklmno+</code> 串的 <code>+</code> 去掉就变快了？理由也很简单，<code>matches(regex)</code> 在正则串与原串匹配上之后就会快速结束，因为结果只需要告知某次匹配成功了即可。而失败的匹配会不断地尝试所有的可能性。</p>\n<h2>解决方案</h2>\n<p>至于解决方案，从上面的原因就可以看到，拒绝在贪婪组模式下(<code>(...)+</code>) 的组内多模式匹配可能。即 <code>(a+a+)+</code> 是不能被允许的，而 <code>(a+b+)+</code> 是可靠的。</p>\n<p>写得仓促，如有根源性错误，欢迎指正。</p>\n<h2>参考</h2>\n<p><a href="https://www.regular-expressions.info/catastrophic.html">Catastrophic Backtracking(灾难性回溯)</a></p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-11-16-regex-exponential-explosion.json",ext:".json",sourceBase:"2018-11-16-regex-exponential-explosion.md",sourceExt:".md"}},U5sb:function(n,s,a){var e={"./content/2018-01-15-Spring-JDBC-Code-Reading.json":"6bZZ","./content/2018-03-01-区块链简单介绍.json":"cN4P","./content/2018-06-11-ASM-ClassReader.json":"NctQ","./content/2018-06-21-java-memory-model.json":"nYHc","./content/2018-06-25-ASM-Core.json":"KZDG","./content/2018-06-28-ASM-VerifyError.json":"BQvL","./content/2018-07-04-JDK-Permission.json":"W2Zs","./content/2018-07-10-CGlib-Enhancer.json":"hCSg","./content/2018-07-13-How-to-easily-get-CGlib-generated-code.json":"tpF5","./content/2018-07-20-Java-Proxy.json":"bzvy","./content/2018-07-24-JVM-Instruction.json":"xo5S","./content/2018-08-15-Java-Instrumentation.json":"hW3s","./content/2018-08-19-understand-Kernel-0.json":"S4Mp","./content/2018-08-19-understand-Kernel-1.json":"fuPZ","./content/2018-08-26-understand-Kernel-2.json":"B/bq","./content/2018-09-08-preprocessor-output.json":"fORH","./content/2018-09-18-TCP-SYN.json":"GuZ5","./content/2018-09-27-mail.json":"CrC2","./content/2018-10-06-understand-Kernel-3.json":"yEfC","./content/2018-10-12-understand-Kernel-4.json":"BX5X","./content/2018-10-14-understand-Kernel-5.json":"H67F","./content/2018-11-11-understand-Kernel-6.json":"5DNh","./content/2018-11-16-regex-exponential-explosion.json":"SqPm","./content/2018-12-15-sql-injection.json":"wCSB","./content/2018-12-28-understand-Kernel-7.json":"zZw6","./content/2019-01-15-understand-Kernel-8.json":"9vk+","./content/2019-02-02-unicode.json":"RrPW","./content/2019-02-27-Java-Fatal-API.json":"IBPC","./content/2019-03-05-understand-Kernel-9.json":"frAL","./content/2019-03-19-JANUS.json":"LRZv","./content/2019-03-25-mem-dump.json":"mF68","./content/2019-04-10-understand-Kernel-10.json":"U8rl","./content/summary.json":"2LNF"};function t(n){var s=l(n);return a(s)}function l(n){var s=e[n];if(!(s+1)){var a=new Error("Cannot find module '"+n+"'");throw a.code="MODULE_NOT_FOUND",a}return s}t.keys=function(){return Object.keys(e)},t.resolve=l,n.exports=t,t.id="U5sb"},U8rl:function(n){n.exports={title:"理解 Linux Kernel(10) - Context of Execution",author:"fangfeng",date:"2019-04-10T00:00:00.000Z",tags:["Linux","Kernel","COE"],bodyContent:"在进行[第四篇(任务调度)](https://www.ffutop.com/2018-10-12-understand-Kernel-4/)行文描述时，就一直闹不清内核所谓的`task`的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：**我们错误地将理论和实践不加区分地混淆了**。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，`task` 也就是 `Context of Execution` 概念在实现上的表征。\n\n\x3c!-- more --\x3e\n\n执行的上下文(Context of Execution, COE)，记录了所有程序执行中的状态，包括：CPU状态（寄存器信息等）、MMU状态（页映射）、权限状态（uid、gid等）和一些公共属性（打开的文件、信号处理函数等）。对比理论上的进程/线程概念，粗略地讲就是同一线程组的线程各自持有CPU状态而共享其它状态，而认为两进程不共享任何状态。当然，在内核的概念里，进程/线程只是COE共享部分状态中的一个特例。\n\n## fork, clone \n\n如果用进程/线程的概念来看，内核提供了 `fork` 来完成进程的复制，提供了 `clone` 来处理线程的拷贝，另外还有 `vfork` , `kernel_thread` 等。\n\n**syscall fork**\n```c\nasmlinkage int sys_fork(struct pt_regs regs)\n{\n    return do_fork(SIGCHLD, regs.esp, &regs, 0, NULL, NULL);\n}\n```\n\n**syscall clone**\n```c\nasmlinkage int sys_clone(struct pt_regs regs)\n{\n    unsigned long clone_flags;\n    unsigned long newsp;\n    int __user *parent_tidptr, *child_tidptr;\n    \n    clone_flags = regs.ebx;\n    newsp = regs.ecx;\n    parent_tidptr = (int __user *)regs.edx;\n    child_tidptr = (int __user *)regs.edi;\n    if (!newsp)\n        newsp = regs.esp;\n    return do_fork(clone_flags, newsp, &regs, 0, parent_tidptr, child_tidptr);\n}\n```\n\n**syscall vfork**\n```c\nasmlinkage int sys_vfork(struct pt_regs regs)\n{\n    return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.esp, &regs, 0, NULL, NULL);\n}\n```\n\n**kernel function: kernel\\_thread**\n```c\nint kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)\n{\n    // ...\n    return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);\n}\n```\n\n`fork`, `clone`, `vfork` 的入参怎么和日常使用的系统调用入参不同？且看：\n\n```c\n\t.macro PTREGSCALL label, func, arg\n\t.globl \\label\n\\label:\n\tleaq \\func(%rip),%rax\n\tleaq -ARGOFFSET+8(%rsp),\\arg\t/* 8 for return address */\n\tjmp  ia32_ptregs_common\n\t.endm\n\n\tCFI_STARTPROC32\n\n\tPTREGSCALL stub32_rt_sigreturn, sys32_rt_sigreturn, %rdi\n\tPTREGSCALL stub32_sigreturn, sys32_sigreturn, %rdi\n\tPTREGSCALL stub32_sigaltstack, sys32_sigaltstack, %rdx\n\tPTREGSCALL stub32_sigsuspend, sys32_sigsuspend, %rcx\n\tPTREGSCALL stub32_execve, sys32_execve, %rcx\n\tPTREGSCALL stub32_fork, sys_fork, %rdi\n\tPTREGSCALL stub32_clone, sys32_clone, %rdx\n\tPTREGSCALL stub32_vfork, sys_vfork, %rdi\n\tPTREGSCALL stub32_iopl, sys_iopl, %rsi\n\tPTREGSCALL stub32_rt_sigsuspend, sys_rt_sigsuspend, %rdx\n\nENTRY(ia32_ptregs_common)\n\tpopq %r11\n\tCFI_ENDPROC\n\tCFI_STARTPROC32\tsimple\n\tCFI_SIGNAL_FRAME\n\tCFI_DEF_CFA\trsp,SS+8-ARGOFFSET\n\tCFI_REL_OFFSET\trax,RAX-ARGOFFSET\n\tCFI_REL_OFFSET\trcx,RCX-ARGOFFSET\n\tCFI_REL_OFFSET\trdx,RDX-ARGOFFSET\n\tCFI_REL_OFFSET\trsi,RSI-ARGOFFSET\n\tCFI_REL_OFFSET\trdi,RDI-ARGOFFSET\n\tCFI_REL_OFFSET\trip,RIP-ARGOFFSET\n/*\tCFI_REL_OFFSET\tcs,CS-ARGOFFSET*/\n/*\tCFI_REL_OFFSET\trflags,EFLAGS-ARGOFFSET*/\n\tCFI_REL_OFFSET\trsp,RSP-ARGOFFSET\n/*\tCFI_REL_OFFSET\tss,SS-ARGOFFSET*/\n\tSAVE_REST\n\tcall *%rax\n\tRESTORE_REST\n\tjmp  ia32_sysret\t/* misbalances the return cache */\n\tCFI_ENDPROC\nEND(ia32_ptregs_common)\n```\n\n进行系统调用时的处理逻辑统一地将这些内容进行了整合，并将CPU状态（所有通用寄存器状态）维护到 `struct pt_regs` 数据块中。总结起来，三种系统调用最终都委托给 `do_fork` 进行实现，只是在参数的选择方面做了不同的预处理。这在用户层的函数原型上就更为明显，`fork` 和 `vfork` 都不允许参数的调用。\n\n```c\npid_t fork(void);\n\n/* for x86-32 */\nlong clone(unsigned long flags, void *child_stack,\n        int *ptid, unsigned long newtls,\n        int *ctid);\n\npid_t vfork(void);\n```\n\n再看看 `flags` 有哪些值可选。\n\n```c\n/*\n * cloning flags:\n */\n#define CSIGNAL\t\t0x000000ff\t/* signal mask to be sent at exit */\n#define CLONE_VM\t0x00000100\t/* set if VM shared between processes */\n#define CLONE_FS\t0x00000200\t/* set if fs info shared between processes */\n#define CLONE_FILES\t0x00000400\t/* set if open files shared between processes */\n#define CLONE_SIGHAND\t0x00000800\t/* set if signal handlers and blocked signals shared */\n#define CLONE_PTRACE\t0x00002000\t/* set if we want to let tracing continue on the child too */\n#define CLONE_VFORK\t0x00004000\t/* set if the parent wants the child to wake it up on mm_release */\n#define CLONE_PARENT\t0x00008000\t/* set if we want to have the same parent as the cloner */\n#define CLONE_THREAD\t0x00010000\t/* Same thread group? */\n#define CLONE_NEWNS\t0x00020000\t/* New namespace group? */\n#define CLONE_SYSVSEM\t0x00040000\t/* share system V SEM_UNDO semantics */\n#define CLONE_SETTLS\t0x00080000\t/* create a new TLS for the child */\n#define CLONE_PARENT_SETTID\t0x00100000\t/* set the TID in the parent */\n#define CLONE_CHILD_CLEARTID\t0x00200000\t/* clear the TID in the child */\n#define CLONE_DETACHED\t\t0x00400000\t/* Unused, ignored */\n#define CLONE_UNTRACED\t\t0x00800000\t/* set if the tracing process can't force CLONE_PTRACE on this clone */\n#define CLONE_CHILD_SETTID\t0x01000000\t/* set the TID in the child */\n#define CLONE_STOPPED\t\t0x02000000\t/* Start in stopped state */\n#define CLONE_NEWUTS\t\t0x04000000\t/* New utsname group? */\n#define CLONE_NEWIPC\t\t0x08000000\t/* New ipcs */\n#define CLONE_NEWUSER\t\t0x10000000\t/* New user namespace */\n#define CLONE_NEWPID\t\t0x20000000\t/* New pid namespace */\n#define CLONE_NEWNET\t\t0x40000000\t/* New network namespace */\n```\n\n`xxx shared between processes` ，描述即将被创建的新任务将进行哪些状态/资源的共享，而哪些状态需要进行拷贝。\n\n### `do_fork`\n\n先看看核心的 `do_fork` 的逻辑。\n\n*Hint: 下列代码经过大量的删减*\n```c\nlong do_fork(unsigned long clone_flags,\n        unsigned long stack_start,\n        struct pt_regs *regs,\n        unsigned long stack_size,\n        int __user *parent_tidptr,\n        int __user *child_tidptr)\n{\n    p = copy_process(clone_flags, stack_start, regs, stack_size, child_tidptr, NULL);\n    if (!IS_ERR(p)) {\n        nr = (clone_flags & CLONE_NEWPID) ?\n            task_pid_nr_ns(p, current->nsproxy->pid_ns) :\n                task_pid_vnr(p);\n        if (!(clone_flags & CLONE_STOPPED))\n            wake_up_new_task(p, clone_flags);\n        else\n            p->state = TASK_STOPPED;\n    } else {\n        nr = PTR_ERR(p);\n    }\n    return nr;\n}\n```\n\n```c\nstatic struct task_struct *copy_process(unsigned long clone_flags,\n                    unsigned long stack_start,\n                    struct pt_regs *regs,\n                    unsigned long stack_size,\n                    int __user *child_tidptr,\n                    struct pid *pid)\n{\n    /* 预分配 task_struct 数据结构空间 */\n    retval = security_task_create(clone_flags);\n    /* 复制 current 的 task_struct 数据结构 */\n    p = dup_task_struct(current);\n\n    if (nr_threads >= max_threads)\n    \tgoto bad_fork_cleanup_count;\n\n    /* 针对多核CPU，为新任务分配CPU */\n    sched_fork(p, clone_flags);\n    /* 复制 thread_info 数据结构及线程栈 */\n    retval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);\n\n    /* 分配新的 pid */\n    p->pid = pid_nr(pid);\n    /* thread group id = new pid */\n    p->tgid = p->pid;\n    /* 如果标志是 CLONE_THREAD，tgid = 父任务id */\n    if (clone_flags & CLONE_THREAD)\n    \tp->tgid = current->tgid;\n\n    p->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n    p->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;\n    /*\n     * sigaltstack should be cleared when sharing the same VM\n     */\n    if ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n    \tp->sas_ss_sp = p->sas_ss_size = 0;\n\n    /* ok, now we should be set up.. */\n    p->exit_signal = (clone_flags & CLONE_THREAD) ? -1 : (clone_flags & CSIGNAL);\n    p->pdeath_signal = 0;\n    p->exit_state = 0;\n\n    /*\n     * Ok, make it visible to the rest of the system.\n     * We dont wake it up yet.\n     */\n    p->group_leader = p;\n    INIT_LIST_HEAD(&p->thread_group);\n    INIT_LIST_HEAD(&p->ptrace_children);\n    INIT_LIST_HEAD(&p->ptrace_list);\n\n    p->cpus_allowed = current->cpus_allowed;\n    if (unlikely(!cpu_isset(task_cpu(p), p->cpus_allowed) ||\n    \t\t!cpu_online(task_cpu(p))))\n    \tset_task_cpu(p, smp_processor_id());\n\n    /* CLONE_PARENT re-uses the old parent */\n    if (clone_flags & (CLONE_PARENT|CLONE_THREAD))\n    \tp->real_parent = current->real_parent;\n    else\n    \tp->real_parent = current;\n    p->parent = p->real_parent;\n\n    spin_lock(&current->sighand->siglock);\n\n    if (clone_flags & CLONE_THREAD) {\n    \tp->group_leader = current->group_leader;\n    \tlist_add_tail_rcu(&p->thread_group, &p->group_leader->thread_group);\n\n    \tif (!cputime_eq(current->signal->it_virt_expires,\n    \t\t\tcputime_zero) ||\n    \t    !cputime_eq(current->signal->it_prof_expires,\n    \t\t\tcputime_zero) ||\n    \t    current->signal->rlim[RLIMIT_CPU].rlim_cur != RLIM_INFINITY ||\n    \t    !list_empty(&current->signal->cpu_timers[0]) ||\n    \t    !list_empty(&current->signal->cpu_timers[1]) ||\n    \t    !list_empty(&current->signal->cpu_timers[2])) {\n    \t\t/*\n    \t\t * Have child wake up on its first tick to check\n    \t\t * for process CPU timers.\n    \t\t */\n    \t\tp->it_prof_expires = jiffies_to_cputime(1);\n    \t}\n    }\n\n    if (likely(p->pid)) {\n    \tadd_parent(p);\n    \tif (unlikely(p->ptrace & PT_PTRACED))\n    \t\t__ptrace_link(p, current->parent);\n\n    \tif (thread_group_leader(p)) {\n    \t\tif (clone_flags & CLONE_NEWPID)\n    \t\t\tp->nsproxy->pid_ns->child_reaper = p;\n\n    \t\tp->signal->tty = current->signal->tty;\n    \t\tset_task_pgrp(p, task_pgrp_nr(current));\n    \t\tset_task_session(p, task_session_nr(current));\n    \t\tattach_pid(p, PIDTYPE_PGID, task_pgrp(current));\n    \t\tattach_pid(p, PIDTYPE_SID, task_session(current));\n    \t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n    \t\t__get_cpu_var(process_counts)++;\n    \t}\n    \tattach_pid(p, PIDTYPE_PID, pid);\n    \tnr_threads++;\n    }\n\n    total_forks++;\n    spin_unlock(&current->sighand->siglock);\n    write_unlock_irq(&tasklist_lock);\n    proc_fork_connector(p);\n    cgroup_post_fork(p);\n    return p;\n}\n```\n\n根据入参配置的 `flags` ，`copy_process` 确定了新任务与父任务共享的状态，以及一些需要拷贝的状态。\n\n- `fork` 产生一个新的任务，与父任务不存在任何资源共享的情况。\n- `clone` 可高度定制化的系统调用，几乎可以自由组合定制新的任务\n- `vfork` 历史原因而存在的系统调用，设计目的在于一般 `fork` 之后都将调用 `execve` 来执行全新的任务，也就导致了 `fork` 所做的拷贝全部白费，因此搞了个轻量级的 `vfork` 来避免做内存的拷贝。\n\n> **VFORK** \n> Historic description\n> Under Linux, fork(2) is implemented using copy-on-write pages, so the only penalty incurred by fork(2) is the time and memory required to duplicate the  parent's page tables, and to create a unique task structure for the child.  However, in the bad old days a fork(2) would require making a complete copy of the caller's data space, often needlessly, since usually immediately afterward an exec(3) is done.  Thus, for greater efficiency, BSD introduced  the  vfork() system call, which did not fully copy the address space of the parent process, but borrowed the parent's memory and thread of control until a call to execve(2) or an exit occurred.  The parent process was suspended while the child was using its resources.   The  use  of vfork() was tricky: for example, not modifying data in the parent process depended on knowing which variables were held in a register.\n\n## pid, tgid\n\n```c\n/* 分配新的 pid */\np->pid = pid_nr(pid);\n/* thread group id = new pid */\np->tgid = p->pid;\n/* 如果标志是 CLONE_THREAD，tgid = 父任务id */\nif (clone_flags & CLONE_THREAD)\n\tp->tgid = current->tgid;\n```\n\n`pid` 作为每个 `task` 的唯一标识符存在。`tgid` 用于指代线程组id，从代码上看也就是进程主线程id。（请原谅我又用了进程/线程的表述）\n\n看着没有问题？当然不可能。这段代码可是意味着 `pid` 唯一啊，这可不符合日常表述啊。对于系统的终端用户来讲，一个进程可以有一个或多个线程。`pid` 可是一直被翻译成进程ID(process id)。难道？\n\n这就是本质实现与表面功夫的差别啦。`pid_t getpid(void);`, `pid_t gettid(void);` 两个系统调用分别被用来提供进程ID和线程ID（请仔细思考下代码实现和对外展示的差距）。\n\n```c\n/**\n * sys_getpid - return the thread group id of the current process\n *\n * Note, despite the name, this returns the tgid not the pid.  The tgid and\n * the pid are identical unless CLONE_THREAD was specified on clone() in\n * which case the tgid is the same in all threads of the same group.\n *\n * This is SMP safe as current->tgid does not change.\n */\nasmlinkage long sys_getpid(void)\n{\n\treturn task_tgid_vnr(current);\n}\n```\n\n```c\n/* Thread ID - the internal kernel \"pid\" */\nasmlinkage long sys_gettid(void)\n{\n\treturn task_pid_vnr(current);\n}\n```\n\n这样就好懂多了吧。用户态通过系统调用取到的 `pid`, `tid` 已经经过了一层加工，分别映射着内核实现的 `tgid`, `pid` 。\n\n*额外地：想通过 `ps` 查看进程/线程可以使用 `ps -eLf`*\n\n## schedule\n\n再来回顾下任务调度是如何实现的。与[第四篇 任务调度](https://www.ffutop.com/2018-10-12-understand-Kernel-4/)描述的并无太大不同。要说最大的区分，就是早期版本与时下版本顺时的演进。当然，还有就是多核CPU下的SMP调度。\n\n至于多核下的所谓进程/线程如何调度。内核根本认识不到进程/线程的概念，唯一的只有任务(task, or COE)。而每个用户所认为的线程在内核的认识下也是一个任务。因此，所谓用户认识到的多线程并发执行在多核CPU下也就完全是可行的。\n\n## concept of Thread\n\n且不论Linux内核没有线程概念的前提，线程的定义总是存在的，而满足其定义的实现，也就可以被称为“线程”。哪些要素组成了线程呢？\n\n1. 线程是与其它代码共享进程地址空间的最小执行流\n2. 诸如栈、寄存器信息、本地线程数据需要保持独立\n3. 互斥锁(Mutex)、条件变量(Condition Variable)、线程间同步管理的支持\n4. ...\n\n既然都说了Linux内核没有线程概念，现在却又开始提，这不是打脸嘛？OK，具体情况是：内核本身不支持线程，甚至没有线程概念。但其通过GLIBC的NPTL(Native POSIX Thread Library)支持了线程。\n\n> 在Linux内核2.6出现之前任务是(最小)可调度的对象，当时的Linux不真正支持线程。但是Linux内核有一个系统调用指令`clone()`，这个指令将产生一个调用方任务的拷贝，而且这个拷贝可以与原任务使用同一地址空间。LinuxThreads计划使用这个系统调用来提供一个内核级别的线程支持。但是这个解决方法与真正的POSIX标准有一些不兼容的地方，尤其是在信号处理、进程调度和进程间同步原语方面。\n> *Copied From [Wikipedia NPTL](https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library)*\n\n![Linux 架构](https://ws4.sinaimg.cn/large/006tNc79ly1g1x9mjuahnj31400u0doi.jpg)\n\n## Thread Model\n\n最后，聊聊线程模型。相信各位不管懂或不懂，至少都听说过 1:1, N:1, M:N 线程模型。至于究竟这些模型是怎么回事呢？且看：\n\n![Thread Model](https://ws4.sinaimg.cn/large/006tNc79ly1g1xhulou5bj30go08zglv.jpg)\n\n### 1:1 Model\n\n最简单的线程模型，也是内核通过NPTL最容易实现的一种模型。每个通过 `clone` 产生的新任务（当然，至少要符合共享内存等线程定义）对应用程序来说就是一个新线程。所谓的用户级线程和内核级线程，在 1:1 模型中就是同一个任务，只是新任务在被内核 `clone` 之后，又由NPTL做了进一步的管理，因此在形式上看似有用户级/内核级之分。\n\n### N:1 Model\n\nN:1 线程模型又称为“用户级线程模型”。在这种模型下，线程的概念由用户态代码进行支持，包括用来管理线程的用户空间调度器以及以非阻塞模式捕捉和处理I/O机制。使用N:1模型的好处在于其上下文切换的代价几乎为零，毕竟这是纯用户态的。当然，缺点也比较明显：由于对内核来说，认为这只是单个任务，也就无法充分利用多核CPU的特性。\n\n### M:N Model\n\n有没有方式整合1:1模型和N:1模型，让内核意识到有几个任务，但又存在更多的线程在用户级执行呢？当然也是可行，但如何协调调度又是费事费力的实现了。\n\n## Threads vs Events\n\n线程怎么又和事件扯上关系了呢？先来回顾下任务调度的几种模式：\n\n1. 串行，每个任务依次执行，不存在任务调度\n2. 抢占式，通过时钟中断决定是否切换任务\n3. 协作式，只有当任务主动放弃对CPU的占用，才能轮到下一个任务。\n\n对于用户级线程来说，内核无法意识到这些线程的存在，硬件发起的所有中断又都被内核捕获。因此，想要实现抢占式是不可能完成的任务（至少以本人目前所知是不可能的）。故协作式线程调度是用户级线程的唯一选择。而协作式就意味着是由线程硬编码主动放弃任务执行（`yield` / `schedule` / etc.）。如此这般，与事件驱动下，不同代码片之间的调度又是何其相似。当然，只是开个玩笑，如果都一样了，直接用事件驱动不就OK了。线程之所以是线程，有其独特的定义在。不过不再细说，可以参考 [Threads vs Events](http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/Threads-VS-Events.pdf)\n\n## 参考\n\n\\[1\\]. Mauerer W. Professional Linux kernel architecture[M]. John Wiley & Sons, 2010.\n\\[2\\]. [Linus Torvalds. Re: proc fs and shared pids](http://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html)[EL/OL]. Aug 6th, 1996. \n\\[3\\]. [Multithreaded Programming (POSIX pthreads Tutorial)](https://randu.org/tutorials/threads/)[EL/OL].\n\\[4\\]. [线程模型](https://blog.csdn.net/u012432778/article/details/47378321)[EL/OL].\n\\[5\\]. [Implementing a Thread Library on Linux](https://www.evanjones.ca/software/threading.html)[EL/OL]. Dec 10th, 2003.\n\n## 用户级线程资料参考\n\n\\[1\\]. `man makecontext` & `man swapcontext`\n\\[2\\]. [Libfiber](https://github.com/brianwatling/libfiber)\n\\[3\\]. [**所谓的**抢占式用户线程实现](https://github.com/dramesh/GTThreads)\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```",bodyHtml:'<p>在进行<a href="https://www.ffutop.com/2018-10-12-understand-Kernel-4/">第四篇(任务调度)</a>行文描述时，就一直闹不清内核所谓的<code>task</code>的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：<strong>我们错误地将理论和实践不加区分地混淆了</strong>。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，<code>task</code> 也就是 <code>Context of Execution</code> 概念在实现上的表征。</p>\n<p>&lt;!-- more --&gt;</p>\n<p>执行的上下文(Context of Execution, COE)，记录了所有程序执行中的状态，包括：CPU状态（寄存器信息等）、MMU状态（页映射）、权限状态（uid、gid等）和一些公共属性（打开的文件、信号处理函数等）。对比理论上的进程/线程概念，粗略地讲就是同一线程组的线程各自持有CPU状态而共享其它状态，而认为两进程不共享任何状态。当然，在内核的概念里，进程/线程只是COE共享部分状态中的一个特例。</p>\n<h2>fork, clone</h2>\n<p>如果用进程/线程的概念来看，内核提供了 <code>fork</code> 来完成进程的复制，提供了 <code>clone</code> 来处理线程的拷贝，另外还有 <code>vfork</code> , <code>kernel_thread</code> 等。</p>\n<p><strong>syscall fork</strong></p>\n<pre><code class="hljs"><span class="hljs-function">asmlinkage <span class="hljs-keyword">int</span> <span class="hljs-title">sys_fork</span><span class="hljs-params">(struct pt_regs regs)</span>\n</span>{\n    <span class="hljs-keyword">return</span> do_fork(SIGCHLD, regs.esp, &amp;regs, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);\n}</code></pre><p><strong>syscall clone</strong></p>\n<pre><code class="hljs"><span class="hljs-function">asmlinkage <span class="hljs-keyword">int</span> <span class="hljs-title">sys_clone</span><span class="hljs-params">(struct pt_regs regs)</span>\n</span>{\n    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> clone_flags;\n    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> newsp;\n    <span class="hljs-keyword">int</span> __user *parent_tidptr, *child_tidptr;\n    \n    clone_flags = regs.ebx;\n    newsp = regs.ecx;\n    parent_tidptr = (<span class="hljs-keyword">int</span> __user *)regs.edx;\n    child_tidptr = (<span class="hljs-keyword">int</span> __user *)regs.edi;\n    <span class="hljs-keyword">if</span> (!newsp)\n        newsp = regs.esp;\n    <span class="hljs-keyword">return</span> do_fork(clone_flags, newsp, &amp;regs, <span class="hljs-number">0</span>, parent_tidptr, child_tidptr);\n}</code></pre><p><strong>syscall vfork</strong></p>\n<pre><code class="hljs"><span class="hljs-function">asmlinkage <span class="hljs-keyword">int</span> <span class="hljs-title">sys_vfork</span><span class="hljs-params">(struct pt_regs regs)</span>\n</span>{\n    <span class="hljs-keyword">return</span> do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.esp, &amp;regs, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);\n}</code></pre><p><strong>kernel function: kernel_thread</strong></p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kernel_thread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> * arg, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags)</span>\n</span>{\n    <span class="hljs-comment">// ...</span>\n    <span class="hljs-keyword">return</span> do_fork(flags | CLONE_VM | CLONE_UNTRACED, <span class="hljs-number">0</span>, &amp;regs, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);\n}</code></pre><p><code>fork</code>, <code>clone</code>, <code>vfork</code> 的入参怎么和日常使用的系统调用入参不同？且看：</p>\n<pre><code class="hljs">.macro PTREGSCALL label, func, arg\n\t.globl \\label\n\\label:\n\tleaq \\func(%rip),%rax\n\tleaq -ARGOFFSET+8(%rsp),\\arg\t/* 8 for return address */\n\tjmp  ia32_ptregs_common\n\t.endm\n\n\tCFI_STARTPROC32\n\n\tPTREGSCALL stub32_rt_sigreturn, sys32_rt_sigreturn, %rdi\n\tPTREGSCALL stub32_sigreturn, sys32_sigreturn, %rdi\n\tPTREGSCALL stub32_sigaltstack, sys32_sigaltstack, %rdx\n\tPTREGSCALL stub32_sigsuspend, sys32_sigsuspend, %rcx\n\tPTREGSCALL stub32_execve, sys32_execve, %rcx\n\tPTREGSCALL stub32_fork, sys_fork, %rdi\n\tPTREGSCALL stub32_clone, sys32_clone, %rdx\n\tPTREGSCALL stub32_vfork, sys_vfork, %rdi\n\tPTREGSCALL stub32_iopl, sys_iopl, %rsi\n\tPTREGSCALL stub32_rt_sigsuspend, sys_rt_sigsuspend, %rdx\n\nENTRY(ia32_ptregs_common)\n\tpopq %r11\n\tCFI_ENDPROC\n\tCFI_STARTPROC32\tsimple\n\tCFI_SIGNAL_FRAME\n\tCFI_DEF_CFA\trsp,SS+8-ARGOFFSET\n\tCFI_REL_OFFSET\trax,RAX-ARGOFFSET\n\tCFI_REL_OFFSET\trcx,RCX-ARGOFFSET\n\tCFI_REL_OFFSET\trdx,RDX-ARGOFFSET\n\tCFI_REL_OFFSET\trsi,RSI-ARGOFFSET\n\tCFI_REL_OFFSET\trdi,RDI-ARGOFFSET\n\tCFI_REL_OFFSET\trip,RIP-ARGOFFSET\n/*\tCFI_REL_OFFSET\tcs,CS-ARGOFFSET*/\n/*\tCFI_REL_OFFSET\trflags,EFLAGS-ARGOFFSET*/\n\tCFI_REL_OFFSET\trsp,RSP-ARGOFFSET\n/*\tCFI_REL_OFFSET\tss,SS-ARGOFFSET*/\n\tSAVE_REST\n\tcall *%rax\n\tRESTORE_REST\n\tjmp  ia32_sysret\t/* misbalances the return cache */\n\tCFI_ENDPROC\nEND(ia32_ptregs_common)</code></pre><p>进行系统调用时的处理逻辑统一地将这些内容进行了整合，并将CPU状态（所有通用寄存器状态）维护到 <code>struct pt_regs</code> 数据块中。总结起来，三种系统调用最终都委托给 <code>do_fork</code> 进行实现，只是在参数的选择方面做了不同的预处理。这在用户层的函数原型上就更为明显，<code>fork</code> 和 <code>vfork</code> 都不允许参数的调用。</p>\n<pre><code class="hljs"><span class="hljs-keyword">pid_t</span> fork(<span class="hljs-keyword">void</span>);\n\n<span class="hljs-comment">/* for x86-32 */</span>\n<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags, <span class="hljs-keyword">void</span> *child_stack,\n        <span class="hljs-keyword">int</span> *ptid, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> newtls,\n        <span class="hljs-keyword">int</span> *ctid)</span></span>;\n\n<span class="hljs-keyword">pid_t</span> vfork(<span class="hljs-keyword">void</span>);</code></pre><p>再看看 <code>flags</code> 有哪些值可选。</p>\n<pre><code class="hljs"><span class="hljs-comment">/*\n * cloning flags:\n */</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CSIGNAL\t\t0x000000ff\t<span class="hljs-comment">/* signal mask to be sent at exit */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_VM\t0x00000100\t<span class="hljs-comment">/* set if VM shared between processes */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_FS\t0x00000200\t<span class="hljs-comment">/* set if fs info shared between processes */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_FILES\t0x00000400\t<span class="hljs-comment">/* set if open files shared between processes */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_SIGHAND\t0x00000800\t<span class="hljs-comment">/* set if signal handlers and blocked signals shared */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_PTRACE\t0x00002000\t<span class="hljs-comment">/* set if we want to let tracing continue on the child too */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_VFORK\t0x00004000\t<span class="hljs-comment">/* set if the parent wants the child to wake it up on mm_release */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_PARENT\t0x00008000\t<span class="hljs-comment">/* set if we want to have the same parent as the cloner */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_THREAD\t0x00010000\t<span class="hljs-comment">/* Same thread group? */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_NEWNS\t0x00020000\t<span class="hljs-comment">/* New namespace group? */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_SYSVSEM\t0x00040000\t<span class="hljs-comment">/* share system V SEM_UNDO semantics */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_SETTLS\t0x00080000\t<span class="hljs-comment">/* create a new TLS for the child */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_PARENT_SETTID\t0x00100000\t<span class="hljs-comment">/* set the TID in the parent */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_CHILD_CLEARTID\t0x00200000\t<span class="hljs-comment">/* clear the TID in the child */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_DETACHED\t\t0x00400000\t<span class="hljs-comment">/* Unused, ignored */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_UNTRACED\t\t0x00800000\t<span class="hljs-comment">/* set if the tracing process can\'t force CLONE_PTRACE on this clone */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_CHILD_SETTID\t0x01000000\t<span class="hljs-comment">/* set the TID in the child */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_STOPPED\t\t0x02000000\t<span class="hljs-comment">/* Start in stopped state */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_NEWUTS\t\t0x04000000\t<span class="hljs-comment">/* New utsname group? */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_NEWIPC\t\t0x08000000\t<span class="hljs-comment">/* New ipcs */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_NEWUSER\t\t0x10000000\t<span class="hljs-comment">/* New user namespace */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_NEWPID\t\t0x20000000\t<span class="hljs-comment">/* New pid namespace */</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLONE_NEWNET\t\t0x40000000\t<span class="hljs-comment">/* New network namespace */</span></span></code></pre><p><code>xxx shared between processes</code> ，描述即将被创建的新任务将进行哪些状态/资源的共享，而哪些状态需要进行拷贝。</p>\n<h3><code>do_fork</code></h3>\n<p>先看看核心的 <code>do_fork</code> 的逻辑。</p>\n<p><em>Hint: 下列代码经过大量的删减</em></p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">do_fork</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> clone_flags,\n        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_start,\n        struct pt_regs *regs,\n        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_size,\n        <span class="hljs-keyword">int</span> __user *parent_tidptr,\n        <span class="hljs-keyword">int</span> __user *child_tidptr)</span>\n</span>{\n    p = copy_process(clone_flags, stack_start, regs, stack_size, child_tidptr, <span class="hljs-literal">NULL</span>);\n    <span class="hljs-keyword">if</span> (!IS_ERR(p)) {\n        nr = (clone_flags &amp; CLONE_NEWPID) ?\n            task_pid_nr_ns(p, current-&gt;nsproxy-&gt;pid_ns) :\n                task_pid_vnr(p);\n        <span class="hljs-keyword">if</span> (!(clone_flags &amp; CLONE_STOPPED))\n            wake_up_new_task(p, clone_flags);\n        <span class="hljs-keyword">else</span>\n            p-&gt;state = TASK_STOPPED;\n    } <span class="hljs-keyword">else</span> {\n        nr = PTR_ERR(p);\n    }\n    <span class="hljs-keyword">return</span> nr;\n}</code></pre><pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> struct task_struct *<span class="hljs-title">copy_process</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> clone_flags,\n                    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_start,\n                    struct pt_regs *regs,\n                    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_size,\n                    <span class="hljs-keyword">int</span> __user *child_tidptr,\n                    struct pid *pid)</span>\n</span>{\n    <span class="hljs-comment">/* 预分配 task_struct 数据结构空间 */</span>\n    retval = security_task_create(clone_flags);\n    <span class="hljs-comment">/* 复制 current 的 task_struct 数据结构 */</span>\n    p = dup_task_struct(current);\n\n    <span class="hljs-keyword">if</span> (nr_threads &gt;= max_threads)\n    \t<span class="hljs-keyword">goto</span> bad_fork_cleanup_count;\n\n    <span class="hljs-comment">/* 针对多核CPU，为新任务分配CPU */</span>\n    sched_fork(p, clone_flags);\n    <span class="hljs-comment">/* 复制 thread_info 数据结构及线程栈 */</span>\n    retval = copy_thread(<span class="hljs-number">0</span>, clone_flags, stack_start, stack_size, p, regs);\n\n    <span class="hljs-comment">/* 分配新的 pid */</span>\n    p-&gt;pid = pid_nr(pid);\n    <span class="hljs-comment">/* thread group id = new pid */</span>\n    p-&gt;tgid = p-&gt;pid;\n    <span class="hljs-comment">/* 如果标志是 CLONE_THREAD，tgid = 父任务id */</span>\n    <span class="hljs-keyword">if</span> (clone_flags &amp; CLONE_THREAD)\n    \tp-&gt;tgid = current-&gt;tgid;\n\n    p-&gt;set_child_tid = (clone_flags &amp; CLONE_CHILD_SETTID) ? child_tidptr : <span class="hljs-literal">NULL</span>;\n    p-&gt;clear_child_tid = (clone_flags &amp; CLONE_CHILD_CLEARTID) ? child_tidptr: <span class="hljs-literal">NULL</span>;\n    <span class="hljs-comment">/*\n     * sigaltstack should be cleared when sharing the same VM\n     */</span>\n    <span class="hljs-keyword">if</span> ((clone_flags &amp; (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n    \tp-&gt;sas_ss_sp = p-&gt;sas_ss_size = <span class="hljs-number">0</span>;\n\n    <span class="hljs-comment">/* ok, now we should be set up.. */</span>\n    p-&gt;exit_signal = (clone_flags &amp; CLONE_THREAD) ? <span class="hljs-number">-1</span> : (clone_flags &amp; CSIGNAL);\n    p-&gt;pdeath_signal = <span class="hljs-number">0</span>;\n    p-&gt;exit_state = <span class="hljs-number">0</span>;\n\n    <span class="hljs-comment">/*\n     * Ok, make it visible to the rest of the system.\n     * We dont wake it up yet.\n     */</span>\n    p-&gt;group_leader = p;\n    INIT_LIST_HEAD(&amp;p-&gt;thread_group);\n    INIT_LIST_HEAD(&amp;p-&gt;ptrace_children);\n    INIT_LIST_HEAD(&amp;p-&gt;ptrace_list);\n\n    p-&gt;cpus_allowed = current-&gt;cpus_allowed;\n    <span class="hljs-keyword">if</span> (unlikely(!cpu_isset(task_cpu(p), p-&gt;cpus_allowed) ||\n    \t\t!cpu_online(task_cpu(p))))\n    \tset_task_cpu(p, smp_processor_id());\n\n    <span class="hljs-comment">/* CLONE_PARENT re-uses the old parent */</span>\n    <span class="hljs-keyword">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD))\n    \tp-&gt;real_parent = current-&gt;real_parent;\n    <span class="hljs-keyword">else</span>\n    \tp-&gt;real_parent = current;\n    p-&gt;parent = p-&gt;real_parent;\n\n    spin_lock(&amp;current-&gt;sighand-&gt;siglock);\n\n    <span class="hljs-keyword">if</span> (clone_flags &amp; CLONE_THREAD) {\n    \tp-&gt;group_leader = current-&gt;group_leader;\n    \tlist_add_tail_rcu(&amp;p-&gt;thread_group, &amp;p-&gt;group_leader-&gt;thread_group);\n\n    \t<span class="hljs-keyword">if</span> (!cputime_eq(current-&gt;signal-&gt;it_virt_expires,\n    \t\t\tcputime_zero) ||\n    \t    !cputime_eq(current-&gt;signal-&gt;it_prof_expires,\n    \t\t\tcputime_zero) ||\n    \t    current-&gt;signal-&gt;rlim[RLIMIT_CPU].rlim_cur != RLIM_INFINITY ||\n    \t    !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[<span class="hljs-number">0</span>]) ||\n    \t    !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[<span class="hljs-number">1</span>]) ||\n    \t    !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[<span class="hljs-number">2</span>])) {\n    \t\t<span class="hljs-comment">/*\n    \t\t * Have child wake up on its first tick to check\n    \t\t * for process CPU timers.\n    \t\t */</span>\n    \t\tp-&gt;it_prof_expires = jiffies_to_cputime(<span class="hljs-number">1</span>);\n    \t}\n    }\n\n    <span class="hljs-keyword">if</span> (likely(p-&gt;pid)) {\n    \tadd_parent(p);\n    \t<span class="hljs-keyword">if</span> (unlikely(p-&gt;ptrace &amp; PT_PTRACED))\n    \t\t__ptrace_link(p, current-&gt;parent);\n\n    \t<span class="hljs-keyword">if</span> (thread_group_leader(p)) {\n    \t\t<span class="hljs-keyword">if</span> (clone_flags &amp; CLONE_NEWPID)\n    \t\t\tp-&gt;nsproxy-&gt;pid_ns-&gt;child_reaper = p;\n\n    \t\tp-&gt;signal-&gt;tty = current-&gt;signal-&gt;tty;\n    \t\tset_task_pgrp(p, task_pgrp_nr(current));\n    \t\tset_task_session(p, task_session_nr(current));\n    \t\tattach_pid(p, PIDTYPE_PGID, task_pgrp(current));\n    \t\tattach_pid(p, PIDTYPE_SID, task_session(current));\n    \t\tlist_add_tail_rcu(&amp;p-&gt;tasks, &amp;init_task.tasks);\n    \t\t__get_cpu_var(process_counts)++;\n    \t}\n    \tattach_pid(p, PIDTYPE_PID, pid);\n    \tnr_threads++;\n    }\n\n    total_forks++;\n    spin_unlock(&amp;current-&gt;sighand-&gt;siglock);\n    write_unlock_irq(&amp;tasklist_lock);\n    proc_fork_connector(p);\n    cgroup_post_fork(p);\n    <span class="hljs-keyword">return</span> p;\n}</code></pre><p>根据入参配置的 <code>flags</code> ，<code>copy_process</code> 确定了新任务与父任务共享的状态，以及一些需要拷贝的状态。</p>\n<ul>\n<li><code>fork</code> 产生一个新的任务，与父任务不存在任何资源共享的情况。</li>\n<li><code>clone</code> 可高度定制化的系统调用，几乎可以自由组合定制新的任务</li>\n<li><code>vfork</code> 历史原因而存在的系统调用，设计目的在于一般 <code>fork</code> 之后都将调用 <code>execve</code> 来执行全新的任务，也就导致了 <code>fork</code> 所做的拷贝全部白费，因此搞了个轻量级的 <code>vfork</code> 来避免做内存的拷贝。</li>\n</ul>\n<blockquote>\n<p><strong>VFORK</strong>\nHistoric description\nUnder Linux, fork(2) is implemented using copy-on-write pages, so the only penalty incurred by fork(2) is the time and memory required to duplicate the  parent\'s page tables, and to create a unique task structure for the child.  However, in the bad old days a fork(2) would require making a complete copy of the caller\'s data space, often needlessly, since usually immediately afterward an exec(3) is done.  Thus, for greater efficiency, BSD introduced  the  vfork() system call, which did not fully copy the address space of the parent process, but borrowed the parent\'s memory and thread of control until a call to execve(2) or an exit occurred.  The parent process was suspended while the child was using its resources.   The  use  of vfork() was tricky: for example, not modifying data in the parent process depended on knowing which variables were held in a register.</p>\n</blockquote>\n<h2>pid, tgid</h2>\n<pre><code class="hljs"><span class="hljs-comment">/* 分配新的 pid */</span>\np-&gt;pid = pid_nr(pid);\n<span class="hljs-comment">/* thread group id = new pid */</span>\np-&gt;tgid = p-&gt;pid;\n<span class="hljs-comment">/* 如果标志是 CLONE_THREAD，tgid = 父任务id */</span>\n<span class="hljs-keyword">if</span> (clone_flags &amp; CLONE_THREAD)\n\tp-&gt;tgid = current-&gt;tgid;</code></pre><p><code>pid</code> 作为每个 <code>task</code> 的唯一标识符存在。<code>tgid</code> 用于指代线程组id，从代码上看也就是进程主线程id。（请原谅我又用了进程/线程的表述）</p>\n<p>看着没有问题？当然不可能。这段代码可是意味着 <code>pid</code> 唯一啊，这可不符合日常表述啊。对于系统的终端用户来讲，一个进程可以有一个或多个线程。<code>pid</code> 可是一直被翻译成进程ID(process id)。难道？</p>\n<p>这就是本质实现与表面功夫的差别啦。<code>pid_t getpid(void);</code>, <code>pid_t gettid(void);</code> 两个系统调用分别被用来提供进程ID和线程ID（请仔细思考下代码实现和对外展示的差距）。</p>\n<pre><code class="hljs"><span class="hljs-comment">/**\n * sys_getpid - return the thread group id of the current process\n *\n * Note, despite the name, this returns the tgid not the pid.  The tgid and\n * the pid are identical unless CLONE_THREAD was specified on clone() in\n * which case the tgid is the same in all threads of the same group.\n *\n * This is SMP safe as current-&gt;tgid does not change.\n */</span>\n<span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">sys_getpid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n\t<span class="hljs-keyword">return</span> task_tgid_vnr(current);\n}</code></pre><pre><code class="hljs"><span class="hljs-comment">/* Thread ID - the internal kernel "pid" */</span>\n<span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">sys_gettid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n\t<span class="hljs-keyword">return</span> task_pid_vnr(current);\n}</code></pre><p>这样就好懂多了吧。用户态通过系统调用取到的 <code>pid</code>, <code>tid</code> 已经经过了一层加工，分别映射着内核实现的 <code>tgid</code>, <code>pid</code> 。</p>\n<p><em>额外地：想通过 <code>ps</code> 查看进程/线程可以使用 <code>ps -eLf</code></em></p>\n<h2>schedule</h2>\n<p>再来回顾下任务调度是如何实现的。与<a href="https://www.ffutop.com/2018-10-12-understand-Kernel-4/">第四篇 任务调度</a>描述的并无太大不同。要说最大的区分，就是早期版本与时下版本顺时的演进。当然，还有就是多核CPU下的SMP调度。</p>\n<p>至于多核下的所谓进程/线程如何调度。内核根本认识不到进程/线程的概念，唯一的只有任务(task, or COE)。而每个用户所认为的线程在内核的认识下也是一个任务。因此，所谓用户认识到的多线程并发执行在多核CPU下也就完全是可行的。</p>\n<h2>concept of Thread</h2>\n<p>且不论Linux内核没有线程概念的前提，线程的定义总是存在的，而满足其定义的实现，也就可以被称为“线程”。哪些要素组成了线程呢？</p>\n<ol>\n<li>线程是与其它代码共享进程地址空间的最小执行流</li>\n<li>诸如栈、寄存器信息、本地线程数据需要保持独立</li>\n<li>互斥锁(Mutex)、条件变量(Condition Variable)、线程间同步管理的支持</li>\n<li>...</li>\n</ol>\n<p>既然都说了Linux内核没有线程概念，现在却又开始提，这不是打脸嘛？OK，具体情况是：内核本身不支持线程，甚至没有线程概念。但其通过GLIBC的NPTL(Native POSIX Thread Library)支持了线程。</p>\n<blockquote>\n<p>在Linux内核2.6出现之前任务是(最小)可调度的对象，当时的Linux不真正支持线程。但是Linux内核有一个系统调用指令<code>clone()</code>，这个指令将产生一个调用方任务的拷贝，而且这个拷贝可以与原任务使用同一地址空间。LinuxThreads计划使用这个系统调用来提供一个内核级别的线程支持。但是这个解决方法与真正的POSIX标准有一些不兼容的地方，尤其是在信号处理、进程调度和进程间同步原语方面。\n<em>Copied From <a href="https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library">Wikipedia NPTL</a></em></p>\n</blockquote>\n<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1x9mjuahnj31400u0doi.jpg" alt="Linux 架构"></p>\n<h2>Thread Model</h2>\n<p>最后，聊聊线程模型。相信各位不管懂或不懂，至少都听说过 1:1, N:1, M:N 线程模型。至于究竟这些模型是怎么回事呢？且看：</p>\n<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1xhulou5bj30go08zglv.jpg" alt="Thread Model"></p>\n<h3>1:1 Model</h3>\n<p>最简单的线程模型，也是内核通过NPTL最容易实现的一种模型。每个通过 <code>clone</code> 产生的新任务（当然，至少要符合共享内存等线程定义）对应用程序来说就是一个新线程。所谓的用户级线程和内核级线程，在 1:1 模型中就是同一个任务，只是新任务在被内核 <code>clone</code> 之后，又由NPTL做了进一步的管理，因此在形式上看似有用户级/内核级之分。</p>\n<h3>N:1 Model</h3>\n<p>N:1 线程模型又称为“用户级线程模型”。在这种模型下，线程的概念由用户态代码进行支持，包括用来管理线程的用户空间调度器以及以非阻塞模式捕捉和处理I/O机制。使用N:1模型的好处在于其上下文切换的代价几乎为零，毕竟这是纯用户态的。当然，缺点也比较明显：由于对内核来说，认为这只是单个任务，也就无法充分利用多核CPU的特性。</p>\n<h3>M:N Model</h3>\n<p>有没有方式整合1:1模型和N:1模型，让内核意识到有几个任务，但又存在更多的线程在用户级执行呢？当然也是可行，但如何协调调度又是费事费力的实现了。</p>\n<h2>Threads vs Events</h2>\n<p>线程怎么又和事件扯上关系了呢？先来回顾下任务调度的几种模式：</p>\n<ol>\n<li>串行，每个任务依次执行，不存在任务调度</li>\n<li>抢占式，通过时钟中断决定是否切换任务</li>\n<li>协作式，只有当任务主动放弃对CPU的占用，才能轮到下一个任务。</li>\n</ol>\n<p>对于用户级线程来说，内核无法意识到这些线程的存在，硬件发起的所有中断又都被内核捕获。因此，想要实现抢占式是不可能完成的任务（至少以本人目前所知是不可能的）。故协作式线程调度是用户级线程的唯一选择。而协作式就意味着是由线程硬编码主动放弃任务执行（<code>yield</code> / <code>schedule</code> / etc.）。如此这般，与事件驱动下，不同代码片之间的调度又是何其相似。当然，只是开个玩笑，如果都一样了，直接用事件驱动不就OK了。线程之所以是线程，有其独特的定义在。不过不再细说，可以参考 <a href="http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/Threads-VS-Events.pdf">Threads vs Events</a></p>\n<h2>参考</h2>\n<p>[1]. Mauerer W. Professional Linux kernel architecture[M]. John Wiley &amp; Sons, 2010.\n[2]. <a href="http://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html">Linus Torvalds. Re: proc fs and shared pids</a>[EL/OL]. Aug 6th, 1996.\n[3]. <a href="https://randu.org/tutorials/threads/">Multithreaded Programming (POSIX pthreads Tutorial)</a>[EL/OL].\n[4]. <a href="https://blog.csdn.net/u012432778/article/details/47378321">线程模型</a>[EL/OL].\n[5]. <a href="https://www.evanjones.ca/software/threading.html">Implementing a Thread Library on Linux</a>[EL/OL]. Dec 10th, 2003.</p>\n<h2>用户级线程资料参考</h2>\n<p>[1]. <code>man makecontext</code> &amp; <code>man swapcontext</code>\n[2]. <a href="https://github.com/brianwatling/libfiber">Libfiber</a>\n[3]. <a href="https://github.com/dramesh/GTThreads"><strong>所谓的</strong>抢占式用户线程实现</a></p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2019-04-10-understand-Kernel-10.json",ext:".json",sourceBase:"2019-04-10-understand-Kernel-10.md",sourceExt:".md"}},W2Zs:function(n){n.exports={title:"Java 安全访问与权限控制",author:"fangfeng",date:"2018-07-04T00:00:00.000Z",tags:["Java","Security","Permission"],bodyContent:'## 绪论\n\n*本文只是对 Java 安全访问与权限控制的基础性探究。*\n\n**本节与全文内容无关，如无兴趣阅读，可以跳过**\n\n了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行"自动发现"和加载。\n这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要\n1. 在 `META-INF.services` 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容\n2. 由项目的注册管理器触发下列 Java 代码\n\n```java\n{\n    ServiceLoader<XxxPolicy> xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);\n    for (Iterator<XxxPolicy> it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) {\n        XxxPolicy xxxPolicy = it.next();\n        // ... more code ...\n    }\n}\n```\n就可以完成一个新的 SPI 策略的注册工作。\n\n但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-<version>.jar 在注册 Driver 相关的代码。\n发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:\n\n```java\nAccessController.doPrivileged(new PrivilegedAction<Void>() {\n    public Void run() {\n\n        ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);\n        Iterator<Driver> driversIterator = loadedDrivers.iterator();\n\n        try{\n            while(driversIterator.hasNext()) {\n            driversIterator.next();\n            }\n        } catch(Throwable t) {\n                // Do nothing\n        }\n        return null;\n    }\n});\n```\n\n诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。\n\n为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。\n\n\x3c!-- more --\x3e\n\n## 从现象开始...\n\n在通过 `java` 命令执行本地代码时，偶尔/经常会出现文件I/O操作。\n\n```java\npublic static void main(String... args) throws IOException {\n\n    System.out.println(System.getSecurityManager());\n\n    FileInputStream fis = new FileInputStream("/Users/fangfeng/test.in");\n    for (int chr; (chr = fis.read()) != -1;) {\n        System.out.print((char) chr);\n    }\n    fis.close();\n}\n```\n\n诸如上面这段代码，意在读取外部路径下 `test.in` 文件(不要放在项目路径下，文本内容为 `0123456789`)。当然，还包括打印 System.getSecurityManager().toString() 。\n\n正常情况下，这都是能够执行成功，结果为:\n\n```plain\nnull\n0123456789\n```\n\n但是，通过在命令行 `java` 中添加选项 `-Djava.security.manager`，再次执行代码，结果为:\n\n```plain\njava.lang.SecurityManager@4e25154f\nException in thread "main" java.security.AccessControlException: access denied ("java.io.FilePermission" "/Users/fangfeng/test.in" "read")\n\tat java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)\n\tat java.security.AccessController.checkPermission(AccessController.java:884)\n\tat java.lang.SecurityManager.checkPermission(SecurityManager.java:549)\n\tat java.lang.SecurityManager.checkRead(SecurityManager.java:888)\n\tat java.io.FileInputStream.<init>(FileInputStream.java:127)\n\tat java.io.FileInputStream.<init>(FileInputStream.java:93)\n\tat me.fangfeng.security.SecurityTest.main(SecurityTest.java:16)\n```\n\n现在已经能够获取到 `System.getSecuriryManager` 的实例。\n但是想要读取 `test.in` 文件却失败了，表现为 access denied（访问被拒绝）。\n\n现在，在用户目录下(这里是 /Users/fangfeng, 不同系统不同用户请做相应修改) 添加 `.java.policy` 文件，添加下列文本:\n\n```plain\ngrant {\n    permission java.io.FilePermission "/Users/fangfeng/test.in", "read";\n};\n```\n\n再次 `java -Djava.security.manager <class\'s path>`，不仅能够得到 SecurityManager 的实例，同时也读取到了文本内容。\n\n```plain\njava.lang.SecurityManager@3af49f1c\n0123456789\n```\n\n<hr/>\n\n到此为止，应该已经能够感受到 Java 对安全访问的控制在文件I/O上的体现了。\n\n## 安全控制下的操作\n\n**在开始下列内容之前，需要提前了解一个前提:** \n**Java 对操作权限的控制是通过检查当前线程操作上下文的代码是否存在要求的操作权限实现的(除了特权的声明以及其它还需要控制别的线程上下文权限的情况)**\n\n上一节演示了权限控制下本地代码对本地资源的访问。但是，安全控制真的有必要吗？\n- 就本地程序而言，不必要。事实上，Java 也确实是这么做的。平时在本地利用 `java` 命令执行程序，都不会受到任何限制。Java 启动时默认不会装载 SecurityManager，也就不会触发对各种操作的权限验证。\n- 可如果程序运行与网络上其它程序交互，甚至直接加载来自网络的字节码。那么，权限控制确实是有必要的。至少，如果不存在权限控制，来自网络的恶意代码访问整台机器的任意资源都将畅通无阻。\n\n### SecurityManager\n\nSecurityManager 是整个访问控制的管理器和基本入口。所有涉及到权限控制的代码，都会类似地存在下列这般的代码:\n\n```java\nSecurityManager security = System.getSecurityManager();\n// 如果系统存在安全管理器\nif (security != null) {\n    // 调用 SecurityManager 中以 check 开头的方法\n    security.checkXxx(...);\n}\n```\n\n`security.checkXxx(...)` 是没有返回值的(除了 checkTopLevelWindow)；对于没有操作权限的代码，直接抛出异常\n\n至于到底在 check 什么，Java 中定义了包括文件(File)、套接字(Socket)、网络(Net)、安全性(Security)、运行时(Runtime)、属性(Property)、AWT、反射(Reflect)和可序列化(Serializable) 九类权限。\n\n通常，security.checkXxx(...) 方法将构造一个 XxxPermission(...) 对象来调用 SecurityManager 提供的统一方法 checkPermission(Permission) 。\n\n```java\n// 以 checkRead(name) 为例\npublic void checkRead(String file) {\n    checkPermission(new FilePermission(file, SecurityConstants.FILE_READ_ACTION));\n}\n\n// 调用 checkPermission(Permission) 方法\npublic void checkPermission(Permission perm) {\n    // 直接调用 访问控制器 来对权限进行鉴别\n    java.security.AccessController.checkPermission(perm);\n}\n```\n\n### AccessController\n\nAccessController 用于与访问控制相关的操作和决定。\n\n> AccessController 类用于以下三个目的：\n> \n> 基于当前生效的安全策略决定是允许还是拒绝对关键系统资源的访问\n> 将代码标记为享有“特权”，从而影响后续访问决定，以及\n> 获取当前调用上下文的“快照”，这样便可以相对于已保存的上下文作出其他上下文的访问控制决定\n\n### 小结\n\n总的来说，Java 的访问控制就是通过针对不同的操作构建不同的 Permission 对象，然后通过与 AccessControllerContent 持有的各代码的权限进行比对，\n从而判断代码是否存在相应的访问权限。\n\n*所谓的Permission判断将是对当前线程的调用栈的每个调用者逐一倒序递归，判断是否拥有权限。如果其中的某个代码被声明为 Privileged，则直接认为是拥有权限*\n\n**更多的关于 checkPermission(...) 调用相关的内容，可以自行查阅资料进行学习，在此不做过多陈述。:)**\n\n## 为操作赋权\n\n上一节讲完了如果对当前项目配置了 SecurityManager ，将对各种敏感操作进行访问控制，并且将根据整个调用链被赋予的权限来决定是允许执行还是抛出 access denied。\n\n但是，究竟怎么才能够给 code 赋予权限呢？\n\n回顾前一节的内容，在基本探究中，其实一个能够看到 \n```java\ngrant {\n    permission java.io.FilePermission "/Users/fangfeng/test.in", "read";\n};\n```\n这就是一种赋权的操作。\n\n通过在指定的文件中写入符合特定规则的代码，来完成对 code 的赋权。[Default Policy Implementation and Policy File Syntax](https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html)\n\n在项目启动的时候，默认就会读取 $JAVA\\_HOME/jre/lib/security/java.policy 以及 ${user.home}/.java.policy 两个文件的赋权内容，并做缓存给后面代码使用。\n\n当然，Java 也提供指定自定义的赋权文件，通过 -Djava.security.policy=<policy file> 或者 -Djava.security.policy==<policy file> 。\n\n## 参考\n\n\\[1\\]. Java Document - Security. https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<h2>绪论</h2>\n<p><em>本文只是对 Java 安全访问与权限控制的基础性探究。</em></p>\n<p><strong>本节与全文内容无关，如无兴趣阅读，可以跳过</strong></p>\n<p>了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行&quot;自动发现&quot;和加载。\n这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要</p>\n<ol>\n<li>在 <code>META-INF.services</code> 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容</li>\n<li>由项目的注册管理器触发下列 Java 代码</li>\n</ol>\n<pre><code class="hljs">{\n    ServiceLoader&lt;XxxPolicy&gt; xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);\n    <span class="hljs-keyword">for</span> (Iterator&lt;XxxPolicy&gt; it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) {\n        XxxPolicy xxxPolicy = it.next();\n        <span class="hljs-comment">// ... more code ...</span>\n    }\n}</code></pre><p>就可以完成一个新的 SPI 策略的注册工作。</p>\n<p>但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-&lt;version&gt;.jar 在注册 Driver 相关的代码。\n发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:</p>\n<pre><code class="hljs">AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() {\n    <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{\n\n        ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);\n        Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();\n\n        <span class="hljs-keyword">try</span>{\n            <span class="hljs-keyword">while</span>(driversIterator.hasNext()) {\n            driversIterator.next();\n            }\n        } <span class="hljs-keyword">catch</span>(Throwable t) {\n                <span class="hljs-comment">// Do nothing</span>\n        }\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n    }\n});</code></pre><p>诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。</p>\n<p>为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>从现象开始...</h2>\n<p>在通过 <code>java</code> 命令执行本地代码时，偶尔/经常会出现文件I/O操作。</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> IOException </span>{\n\n    System.out.println(System.getSecurityManager());\n\n    FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"/Users/fangfeng/test.in"</span>);\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> chr; (chr = fis.read()) != -<span class="hljs-number">1</span>;) {\n        System.out.print((<span class="hljs-keyword">char</span>) chr);\n    }\n    fis.close();\n}</code></pre><p>诸如上面这段代码，意在读取外部路径下 <code>test.in</code> 文件(不要放在项目路径下，文本内容为 <code>0123456789</code>)。当然，还包括打印 System.getSecurityManager().toString() 。</p>\n<p>正常情况下，这都是能够执行成功，结果为:</p>\n<pre><code class="hljs">null\n0123456789</code></pre><p>但是，通过在命令行 <code>java</code> 中添加选项 <code>-Djava.security.manager</code>，再次执行代码，结果为:</p>\n<pre><code class="hljs">java.lang.SecurityManager@4e25154f\nException in thread "main" java.security.AccessControlException: access denied ("java.io.FilePermission" "/Users/fangfeng/test.in" "read")\n\tat java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)\n\tat java.security.AccessController.checkPermission(AccessController.java:884)\n\tat java.lang.SecurityManager.checkPermission(SecurityManager.java:549)\n\tat java.lang.SecurityManager.checkRead(SecurityManager.java:888)\n\tat java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:127)\n\tat java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93)\n\tat me.fangfeng.security.SecurityTest.main(SecurityTest.java:16)</code></pre><p>现在已经能够获取到 <code>System.getSecuriryManager</code> 的实例。\n但是想要读取 <code>test.in</code> 文件却失败了，表现为 access denied（访问被拒绝）。</p>\n<p>现在，在用户目录下(这里是 /Users/fangfeng, 不同系统不同用户请做相应修改) 添加 <code>.java.policy</code> 文件，添加下列文本:</p>\n<pre><code class="hljs">grant {\n    permission java.io.FilePermission "/Users/fangfeng/test.in", "read";\n};</code></pre><p>再次 <code>java -Djava.security.manager &lt;class\'s path&gt;</code>，不仅能够得到 SecurityManager 的实例，同时也读取到了文本内容。</p>\n<pre><code class="hljs">java.lang.SecurityManager@3af49f1c\n0123456789</code></pre><p>&lt;hr/&gt;</p>\n<p>到此为止，应该已经能够感受到 Java 对安全访问的控制在文件I/O上的体现了。</p>\n<h2>安全控制下的操作</h2>\n<p><strong>在开始下列内容之前，需要提前了解一个前提:</strong>\n<strong>Java 对操作权限的控制是通过检查当前线程操作上下文的代码是否存在要求的操作权限实现的(除了特权的声明以及其它还需要控制别的线程上下文权限的情况)</strong></p>\n<p>上一节演示了权限控制下本地代码对本地资源的访问。但是，安全控制真的有必要吗？</p>\n<ul>\n<li>就本地程序而言，不必要。事实上，Java 也确实是这么做的。平时在本地利用 <code>java</code> 命令执行程序，都不会受到任何限制。Java 启动时默认不会装载 SecurityManager，也就不会触发对各种操作的权限验证。</li>\n<li>可如果程序运行与网络上其它程序交互，甚至直接加载来自网络的字节码。那么，权限控制确实是有必要的。至少，如果不存在权限控制，来自网络的恶意代码访问整台机器的任意资源都将畅通无阻。</li>\n</ul>\n<h3>SecurityManager</h3>\n<p>SecurityManager 是整个访问控制的管理器和基本入口。所有涉及到权限控制的代码，都会类似地存在下列这般的代码:</p>\n<pre><code class="hljs">SecurityManager security = System.getSecurityManager();\n<span class="hljs-comment">// 如果系统存在安全管理器</span>\n<span class="hljs-keyword">if</span> (security != <span class="hljs-keyword">null</span>) {\n    <span class="hljs-comment">// 调用 SecurityManager 中以 check 开头的方法</span>\n    security.checkXxx(...);\n}</code></pre><p><code>security.checkXxx(...)</code> 是没有返回值的(除了 checkTopLevelWindow)；对于没有操作权限的代码，直接抛出异常</p>\n<p>至于到底在 check 什么，Java 中定义了包括文件(File)、套接字(Socket)、网络(Net)、安全性(Security)、运行时(Runtime)、属性(Property)、AWT、反射(Reflect)和可序列化(Serializable) 九类权限。</p>\n<p>通常，security.checkXxx(...) 方法将构造一个 XxxPermission(...) 对象来调用 SecurityManager 提供的统一方法 checkPermission(Permission) 。</p>\n<pre><code class="hljs"><span class="hljs-comment">// 以 checkRead(name) 为例</span>\n<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkRead</span><span class="hljs-params">(String file)</span> </span>{\n    checkPermission(<span class="hljs-keyword">new</span> FilePermission(file, SecurityConstants.FILE_READ_ACTION));\n}\n\n<span class="hljs-comment">// 调用 checkPermission(Permission) 方法</span>\n<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkPermission</span><span class="hljs-params">(Permission perm)</span> </span>{\n    <span class="hljs-comment">// 直接调用 访问控制器 来对权限进行鉴别</span>\n    java.security.AccessController.checkPermission(perm);\n}</code></pre><h3>AccessController</h3>\n<p>AccessController 用于与访问控制相关的操作和决定。</p>\n<blockquote>\n<p>AccessController 类用于以下三个目的：</p>\n<p>基于当前生效的安全策略决定是允许还是拒绝对关键系统资源的访问\n将代码标记为享有“特权”，从而影响后续访问决定，以及\n获取当前调用上下文的“快照”，这样便可以相对于已保存的上下文作出其他上下文的访问控制决定</p>\n</blockquote>\n<h3>小结</h3>\n<p>总的来说，Java 的访问控制就是通过针对不同的操作构建不同的 Permission 对象，然后通过与 AccessControllerContent 持有的各代码的权限进行比对，\n从而判断代码是否存在相应的访问权限。</p>\n<p><em>所谓的Permission判断将是对当前线程的调用栈的每个调用者逐一倒序递归，判断是否拥有权限。如果其中的某个代码被声明为 Privileged，则直接认为是拥有权限</em></p>\n<p><strong>更多的关于 checkPermission(...) 调用相关的内容，可以自行查阅资料进行学习，在此不做过多陈述。:)</strong></p>\n<h2>为操作赋权</h2>\n<p>上一节讲完了如果对当前项目配置了 SecurityManager ，将对各种敏感操作进行访问控制，并且将根据整个调用链被赋予的权限来决定是允许执行还是抛出 access denied。</p>\n<p>但是，究竟怎么才能够给 code 赋予权限呢？</p>\n<p>回顾前一节的内容，在基本探究中，其实一个能够看到</p>\n<pre><code class="hljs">grant {\n    permission java.io.FilePermission <span class="hljs-string">"/Users/fangfeng/test.in"</span>, <span class="hljs-string">"read"</span>;\n};</code></pre><p>这就是一种赋权的操作。</p>\n<p>通过在指定的文件中写入符合特定规则的代码，来完成对 code 的赋权。<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html">Default Policy Implementation and Policy File Syntax</a></p>\n<p>在项目启动的时候，默认就会读取 $JAVA_HOME/jre/lib/security/java.policy 以及 ${user.home}/.java.policy 两个文件的赋权内容，并做缓存给后面代码使用。</p>\n<p>当然，Java 也提供指定自定义的赋权文件，通过 -Djava.security.policy=&lt;policy file&gt; 或者 -Djava.security.policy==&lt;policy file&gt; 。</p>\n<h2>参考</h2>\n<p>[1]. Java Document - Security. https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-07-04-JDK-Permission.json",ext:".json",sourceBase:"2018-07-04-JDK-Permission.md",sourceExt:".md"}},bzvy:function(n){n.exports={title:"Java Proxy 源码解析",author:"fangfeng",date:"2018-07-20T00:00:00.000Z",tag:["Java","Proxy"],bodyContent:'在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。\n\n从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。\n而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。\n\n\x3c!-- more --\x3e\n\n## 从实例开始...\n\n下面，首先来了解一下 Java Proxy 的使用编码:\n\nICodeFactory 接口, 作为将被 Java 动态代理增强的基本接口\n```java\npublic interface ICodeFactory {\n\n    Code getCode();\n\n    void setCode(Code code);\n\n}\n```\n\nCodeFactory 类, 作为 ICodeFactory 接口的实现类。被视为是真正被动态代理增强的内容，:) 因为接口方法并不存在方法体(当然，Java 8 及以上的 default 请容我忽视)\n```java\npublic class CodeFactory implements ICodeFactory {\n\n    private Code code;\n\n    public Code getCode() {\n        return new Code();\n    }\n\n    @Override\n    public void setCode(Code code) {\n        this.code = code;\n    }\n}\n```\n\n辅助类 Code 的内容(简单写，请忽略不符合实际编程规范的一些内容):\n```java\npublic class Code {\n\n    public int codeA;\n\n    public String codeB;\n\n}\n```\n\n构建增强的代码逻辑:\n```java\n// main(String[]) 方法\npublic static void main(String[] args) throws Exception {\n\n    // 内部匿名类，用于动态代理生成类的构造方法及其它内容，后面讲。\n    InvocationHandler handler = new InvocationHandler() {\n\n        Object obj = new CodeFactory();\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n            if (method.getName() == "getCode") {\n                Code code = (Code) method.invoke(obj, args);\n                code.codeA = code.codeA + 100;\n                code.codeB = "Proxied: " + code.codeB;\n                return code;\n            } else {\n                return method.invoke(obj, args);\n            }\n        }\n    };\n\n    // 构建生成类实例\n    Class<?> clazz = Proxy.getProxyClass(ICodeFactory.class.getClassLoader(), ICodeFactory.class);\n    // 获取生成类对象\n    ICodeFactory factory = (ICodeFactory) clazz.getConstructor(new Class[] { InvocationHandler.class }).newInstance(new Object[] { handler });\n\n    // 调用 getCode() 方法\n    Code code = factory.getCode();\n    // 打印参数\n    System.out.println(code.codeA);\n    System.out.println(code.codeB);\n}\n```\n\n从默认预期来讲，我们是对接口进行增强。接口方法不存在方法体，也许将在 `factory.getCode()` 时执行失败？\n或者结合已有的认知，成功调用 `CodeFactory.getCode()` 方法，并获得 `new Code()` 。\n\n那么，`code.codeA` `code.codeB` 的具体值将是什么？\n\n执行结果将是:\n\n```plain\n100\nProxied: null\n```\n\n## 了解 Proxy 的内容逻辑\n\n从 `Proxy.getProxyClass(ClassLoader, Class<?>...)` 入手，下面将展开对 `Proxy` 具体执行逻辑的探究。\n\n```java\npublic static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces) throws IllegalArgumentException {\n    // 对 interfaces 数组的浅拷贝\n    final Class<?>[] intfs = interfaces.clone();\n    final SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        // 如果配置了安全管理器，那么需要确认 Proxy 有创建新的代理类的许可\n        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n    }\n\n    // 调用 \n    return getProxyClass0(loader, intfs);\n}\n```\n\n```java\nprivate static Class<?> getProxyClass0(ClassLoader loader, Class<?>... interfaces) {\n    // 确认需要进行增强的接口数量少于等于 65535，详细原因请去了解 ClassFile 规范(规范中的接口上限)\n    if (interfaces.length > 65535) {\n        throw new IllegalArgumentException("interface limit exceeded");\n    }\n\n    // 如果需要由指定 ClassLoader 加载, 实现给定 interfaces 的代理类已经存在, \n    // 将直接返回已经缓存过的拷贝\n    // 否则，通过 ProxyClassFactory 创建新的代理类\n    return proxyClassCache.get(loader, interfaces);\n}\n```\n\n现在需要额外来考察一下 proxyClassCache 的具体类型。\n\n```java\nprivate static final WeakCache<ClassLoader, Class<?>[], Class<?>>\n        proxyClassCache = new WeakCache<>(new KeyFactory(), new ProxyClassFactory());\n```\n\n`WeakCache`, 从名称来将，是一个缓存，同时应该使用了 WeakReference 技术\n\n进入 `WeakCache.get(...)` 方法体\n\n```java\npublic V get(K key, P parameter) {\n    // parameter 传入的是接口数组，要求不能为空\n    Objects.requireNonNull(parameter);\n\n    // 删除过期元素\n    expungeStaleEntries();\n\n    // 构建一个 WeakReference 对象(key 表示 ClassLoader)\n    Object cacheKey = CacheKey.valueOf(key, refQueue);\n\n    // lazily install the 2nd level valuesMap for the particular cacheKey\n    ConcurrentMap<Object, Supplier<V>> valuesMap = map.get(cacheKey);\n    if (valuesMap == null) {\n        ConcurrentMap<Object, Supplier<V>> oldValuesMap\n                = map.putIfAbsent(cacheKey,\n                valuesMap = new ConcurrentHashMap<>());\n        if (oldValuesMap != null) {\n            valuesMap = oldValuesMap;\n        }\n    }\n\n    // 创建次级 Key\n    // 同时检索是否存在过去有同一个 ClassLoader 加载的表示 Supplier<V>\n    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));\n    Supplier<V> supplier = valuesMap.get(subKey);\n    Factory factory = null;\n\n    while (true) {\n        if (supplier != null) {\n            // supplier might be a Factory or a CacheValue<V> instance\n            // 最终 supplier 将非空，同时调用 .get() 方法获取 Class 类\n            V value = supplier.get();\n            if (value != null) {\n                return value;\n            }\n        }\n        // else no supplier in cache\n        // or a supplier that returned null (could be a cleared CacheValue\n        // or a Factory that wasn\'t successful in installing the CacheValue)\n        // 未找到过去加载的记录\n\n        // 懒加载一个 Factory \n        if (factory == null) {\n            factory = new Factory(key, parameter, subKey, valuesMap);\n        }\n\n        if (supplier == null) {\n            supplier = valuesMap.putIfAbsent(subKey, factory);\n            if (supplier == null) {\n                // successfully installed Factory\n                supplier = factory;\n            }\n            // else retry with winning supplier\n        } else {\n            if (valuesMap.replace(subKey, supplier, factory)) {\n                // successfully replaced\n                // cleared CacheEntry / unsuccessful Factory\n                // with our Factory\n                supplier = factory;\n            } else {\n                // retry with current supplier\n                supplier = valuesMap.get(subKey);\n            }\n        }\n    }\n}\n```\n\n```java\n@Override\npublic synchronized V get() { // serialize access\n    // re-check\n    Supplier<V> supplier = valuesMap.get(subKey);\n    if (supplier != this) {\n        // something changed while we were waiting:\n        // might be that we were replaced by a CacheValue\n        // or were removed because of failure ->\n        // return null to signal WeakCache.get() to retry\n        // the loop\n        return null;\n    }\n    // else still us (supplier == this)\n\n    // create new value\n    V value = null;\n    try {\n        // 触发 valueFactory.apply() 真正的构建\n        value = Objects.requireNonNull(valueFactory.apply(key, parameter));\n    } finally {\n        if (value == null) { // remove us on failure\n            valuesMap.remove(subKey, this);\n        }\n    }\n    // the only path to reach here is with non-null value\n    assert value != null;\n\n    // wrap value with CacheValue (WeakReference)\n    CacheValue<V> cacheValue = new CacheValue<>(value);\n\n    // put into reverseMap\n    reverseMap.put(cacheValue, Boolean.TRUE);\n\n    // try replacing us with CacheValue (this should always succeed)\n    if (!valuesMap.replace(subKey, this, cacheValue)) {\n        throw new AssertionError("Should not reach here");\n    }\n\n    // successfully replaced us with new CacheValue -> return the value\n    // wrapped by it\n    return value;\n}\n```\n\n上面两段代码的内容，都是在反复确认将要构建的生成类是否在过去曾经创建过，如果是，则直接返回过去构建的类实例;\n否则才会尝试创建，并最终将这个构建的类也进行缓存。\n\n下面这段代码来自于 `Proxy` 的内部类 `ProxyClassFactory` \n这部分，也终于开始了对代理类字节码的统筹性构造的内容。\n\n```java\npublic Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {\n\n    Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);\n    for (Class<?> intf : interfaces) {\n        /*\n         * 校验当前接口是由同一个 ClassLoader (将要用来加载新的代理类)加载的\n         */\n        Class<?> interfaceClass = null;\n        try {\n            interfaceClass = Class.forName(intf.getName(), false, loader);\n        } catch (ClassNotFoundException e) {\n        }\n        if (interfaceClass != intf) {\n            throw new IllegalArgumentException(\n                    intf + " is not visible from class loader");\n        }\n        /*\n         * 校验当前 Class 对象确实是一个接口\n         */\n        if (!interfaceClass.isInterface()) {\n            throw new IllegalArgumentException(\n                    interfaceClass.getName() + " is not an interface");\n        }\n        /*\n         * 校验当前接口没有被要求重复进行代理增强\n         */\n        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {\n            throw new IllegalArgumentException(\n                    "repeated interface: " + interfaceClass.getName());\n        }\n    }\n\n    String proxyPkg = null;     // 生成的代理类所属的 package\n    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n\n    /*\n     * 如果代理的接口是非 PUBLIC ，那么生成的代理类的接口将与这个非 PUBLIC 接口\n     * 在同一个包下。\n     * 如果代理的接口有多个非 PUBLIC ，且分别位于不同的包下，那么抛出异常\n     */\n    for (Class<?> intf : interfaces) {\n        int flags = intf.getModifiers();\n        if (!Modifier.isPublic(flags)) {\n            accessFlags = Modifier.FINAL;\n            String name = intf.getName();\n            int n = name.lastIndexOf(\'.\');\n            String pkg = ((n == -1) ? "" : name.substring(0, n + 1));\n            if (proxyPkg == null) {\n                proxyPkg = pkg;\n            } else if (!pkg.equals(proxyPkg)) {\n                throw new IllegalArgumentException(\n                        "non-public interfaces from different packages");\n            }\n        }\n    }\n\n    // 如果代理的接口全是 PUBLIC 的，那么使用默认的包 com.sun.proxy\n    if (proxyPkg == null) {\n        // if no non-public proxy interfaces, use com.sun.proxy package\n        proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";\n    }\n\n    /*\n     * 为将要生成的代理类选择一个全限定名\n     * 规则是 包名 + "$Proxy" + <唯一递增的id, 从0开始编号>\n     */\n    long num = nextUniqueNumber.getAndIncrement();\n    String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n    /*\n     * 生成一个特殊的代理类的字节码\n     * byte[] proxyClassFile 就等同于 .class 文件的全部二进制内容。\n     * 与 .class 文件的区别就在于一个写在了外存上，另一个完全在内存中创建\n     */\n    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n            proxyName, interfaces, accessFlags);\n    try {\n        /**\n          * 调用 ClassLoader 的 defineClass0(...) 方法加载字节码内容，构造 Class 对象\n          * 本来 defineClass0(...) 方法是定义在 ClassLoader 中，但这里额外声明了一个本地方法 defineClass0(...)\n          * 想来实现也是类似的，最终的目的也是加载 Class \n          */\n        return defineClass0(loader, proxyName,\n                proxyClassFile, 0, proxyClassFile.length);\n    } catch (ClassFormatError e) {\n        /*\n         * A ClassFormatError here means that (barring bugs in the\n         * proxy class generation code) there was some other\n         * invalid aspect of the arguments supplied to the proxy\n         * class creation (such as virtual machine limitations\n         * exceeded).\n         */\n        throw new IllegalArgumentException(e.toString());\n    }\n}\n```\n\n在完成基础性的校验，并构造了生成类的类名等内容后，\n`ProxyGenerator.generateProxyClass` 将开始构造 [ClassFile](https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html) 的具体内容。\n\n关于这部分生成字节码的内容，请在了解了 ClassFile 的基础性内容之后，在自行学习，内容全部在 ProxyGenerator 类中。\n\n这部分的规则是(在构建新的代理生成类时):\n\n- 额外添加三个 Object 的方法 (`hashCode`, `equals`, `toString`)\n- 逐一读取所有需要增强的接口的方法，并对重复方法进行判断; 如果方法名相同，入参数量与类型相同，但返回参数不同，则抛出异常\n- 在遍历所有接口的方法的时候，同时也将为新的生成类构造新的字段(内容就是通过反射获取该方法)\n- 最后将新的生成类将要包含的所有字段与方法进行构造，同时维护一个常量池内容\n- 输出这些内容的二进制表示 byte[];\n\n## 如何对方法增强\n\n想必上了上一节，虽然对 Java 动态代理的调用链有了一定的了解。\n\n但是，究竟 Proxy 是如何完成对实现类方法的增强呢？\n\n也许我们需要先看一下生成类 .class 文件的一些内容来对这个命题形成基础性的影响。\n\n```java\npublic final Code getCode() throws  {\n    try {\n        return (Code)super.h.invoke(this, m4, (Object[])null);\n    } catch (RuntimeException | Error var2) {\n        throw var2;\n    } catch (Throwable var3) {\n        throw new UndeclaredThrowableException(var3);\n    }\n}\n```\n\n可以看到，生成类的 `getCode()` 方法几乎没有什么实质性的内容, 只是 `super.h.invoke(...)` 。\n\n`h` 实例变量是什么？`InvocationHandler` 的一个实例对象。\n\n事实上，Java Proxy 生成类的每个方法结构几乎都是类似的。方法体的内容就是通过实例持有的 `h` 变量分发实际的操作指令\n\n至于 h 的具体内容。:) 有编程者自定义，并在 Proxy 生成字节码，并被 ClassLoader 加载后，在准备实例化的时候作为构造参数进行传入。\n\n```java\nICodeFactory factory = (ICodeFactory) clazz.getConstructor(new Class[] { InvocationHandler.class }).newInstance(new Object[] { handler });\n```\n\n至于具体将做哪些增强，调用例如上例的 `ICodeFactory` 的那个实现类的方法，全部有使用者自定义。\n\n## 生成类的反编译结果\n\n仍然以本文开始的 ICodeFactory 的增强为例，看一下究竟通过 Java Proxy 动态代理生成的字节码的反编译结果究竟是什么？\n并以此来对这种动态代理机制形成更为直观的印象\n\n在 Java 源代码中，虽然默认不会输出生成类的二进制内容，但是，仍然预留了打印 .class 文件的可选项。\n\n有兴趣的同学可以看一下 `ProxyGenerator.saveGeneratedFiles` 字段的内容，这就决定是在构造代理类后是否存储到外存中。\n\n想要看到代理类的字节码，直接通过在 Java 执行程序中添加一行代码\n\n```java\nSystem.setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");\n```\n\n或者在启动程序的 `java` 命令下添加参数\n\n```sh\n-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true`\n```\n\n至于生成类将打印在哪，首先必然是在项目所属的目录下。有上一节中构造生成类全限定名的内容，根据包名的规则去寻找即可。(具体不再详述)\n\n直接通过 IDEA, Eclipse 或者其它工具，对生成类 .class 文件进行反编译可以查看到整个生成类的内容。\n\n```java\npackage com.sun.proxy;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\nimport me.fangfeng.jdk.proxy.Code;\nimport me.fangfeng.jdk.proxy.ICodeFactory;\n\npublic final class $Proxy0 extends Proxy implements ICodeFactory {\n    private static Method m1;\n    private static Method m2;\n    private static Method m4;\n    private static Method m3;\n    private static Method m0;\n\n    public $Proxy0(InvocationHandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        try {\n            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final String toString() throws  {\n        try {\n            return (String)super.h.invoke(this, m2, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final Code getCode() throws  {\n        try {\n            return (Code)super.h.invoke(this, m4, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final void setCode(Code var1) throws  {\n        try {\n            super.h.invoke(this, m3, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final int hashCode() throws  {\n        try {\n            return (Integer)super.h.invoke(this, m0, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    static {\n        try {\n            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));\n            m2 = Class.forName("java.lang.Object").getMethod("toString");\n            m4 = Class.forName("me.fangfeng.jdk.proxy.ICodeFactory").getMethod("getCode");\n            m3 = Class.forName("me.fangfeng.jdk.proxy.ICodeFactory").getMethod("setCode", Class.forName("me.fangfeng.jdk.proxy.Code"));\n            m0 = Class.forName("java.lang.Object").getMethod("hashCode");\n        } catch (NoSuchMethodException var2) {\n            throw new NoSuchMethodError(var2.getMessage());\n        } catch (ClassNotFoundException var3) {\n            throw new NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}\n```\n\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<p>在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。</p>\n<p>从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。\n而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>从实例开始...</h2>\n<p>下面，首先来了解一下 Java Proxy 的使用编码:</p>\n<p>ICodeFactory 接口, 作为将被 Java 动态代理增强的基本接口</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICodeFactory</span> </span>{\n\n    <span class="hljs-function">Code <span class="hljs-title">getCode</span><span class="hljs-params">()</span></span>;\n\n    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCode</span><span class="hljs-params">(Code code)</span></span>;\n\n}</code></pre><p>CodeFactory 类, 作为 ICodeFactory 接口的实现类。被视为是真正被动态代理增强的内容，:) 因为接口方法并不存在方法体(当然，Java 8 及以上的 default 请容我忽视)</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICodeFactory</span> </span>{\n\n    <span class="hljs-keyword">private</span> Code code;\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> Code <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>{\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Code();\n    }\n\n    <span class="hljs-meta">@Override</span>\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCode</span><span class="hljs-params">(Code code)</span> </span>{\n        <span class="hljs-keyword">this</span>.code = code;\n    }\n}</code></pre><p>辅助类 Code 的内容(简单写，请忽略不符合实际编程规范的一些内容):</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code</span> </span>{\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> codeA;\n\n    <span class="hljs-keyword">public</span> String codeB;\n\n}</code></pre><p>构建增强的代码逻辑:</p>\n<pre><code class="hljs"><span class="hljs-comment">// main(String[]) 方法</span>\n<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{\n\n    <span class="hljs-comment">// 内部匿名类，用于动态代理生成类的构造方法及其它内容，后面讲。</span>\n    InvocationHandler handler = <span class="hljs-keyword">new</span> InvocationHandler() {\n\n        Object obj = <span class="hljs-keyword">new</span> CodeFactory();\n\n        <span class="hljs-meta">@Override</span>\n        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{\n\n            <span class="hljs-keyword">if</span> (method.getName() == <span class="hljs-string">"getCode"</span>) {\n                Code code = (Code) method.invoke(obj, args);\n                code.codeA = code.codeA + <span class="hljs-number">100</span>;\n                code.codeB = <span class="hljs-string">"Proxied: "</span> + code.codeB;\n                <span class="hljs-keyword">return</span> code;\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-keyword">return</span> method.invoke(obj, args);\n            }\n        }\n    };\n\n    <span class="hljs-comment">// 构建生成类实例</span>\n    Class&lt;?&gt; clazz = Proxy.getProxyClass(ICodeFactory.class.getClassLoader(), ICodeFactory.class);\n    <span class="hljs-comment">// 获取生成类对象</span>\n    ICodeFactory factory = (ICodeFactory) clazz.getConstructor(<span class="hljs-keyword">new</span> Class[] { InvocationHandler.class }).newInstance(<span class="hljs-keyword">new</span> Object[] { handler });\n\n    <span class="hljs-comment">// 调用 getCode() 方法</span>\n    Code code = factory.getCode();\n    <span class="hljs-comment">// 打印参数</span>\n    System.out.println(code.codeA);\n    System.out.println(code.codeB);\n}</code></pre><p>从默认预期来讲，我们是对接口进行增强。接口方法不存在方法体，也许将在 <code>factory.getCode()</code> 时执行失败？\n或者结合已有的认知，成功调用 <code>CodeFactory.getCode()</code> 方法，并获得 <code>new Code()</code> 。</p>\n<p>那么，<code>code.codeA</code> <code>code.codeB</code> 的具体值将是什么？</p>\n<p>执行结果将是:</p>\n<pre><code class="hljs">100\nProxied: null</code></pre><h2>了解 Proxy 的内容逻辑</h2>\n<p>从 <code>Proxy.getProxyClass(ClassLoader, Class&lt;?&gt;...)</code> 入手，下面将展开对 <code>Proxy</code> 具体执行逻辑的探究。</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) <span class="hljs-keyword">throws</span> IllegalArgumentException {\n    <span class="hljs-comment">// 对 interfaces 数组的浅拷贝</span>\n    <span class="hljs-keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();\n    <span class="hljs-keyword">final</span> SecurityManager sm = System.getSecurityManager();\n    <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) {\n        <span class="hljs-comment">// 如果配置了安全管理器，那么需要确认 Proxy 有创建新的代理类的许可</span>\n        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n    }\n\n    <span class="hljs-comment">// 调用 </span>\n    <span class="hljs-keyword">return</span> getProxyClass0(loader, intfs);\n}</code></pre><pre><code class="hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) {\n    <span class="hljs-comment">// 确认需要进行增强的接口数量少于等于 65535，详细原因请去了解 ClassFile 规范(规范中的接口上限)</span>\n    <span class="hljs-keyword">if</span> (interfaces.length &gt; <span class="hljs-number">65535</span>) {\n        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"interface limit exceeded"</span>);\n    }\n\n    <span class="hljs-comment">// 如果需要由指定 ClassLoader 加载, 实现给定 interfaces 的代理类已经存在, </span>\n    <span class="hljs-comment">// 将直接返回已经缓存过的拷贝</span>\n    <span class="hljs-comment">// 否则，通过 ProxyClassFactory 创建新的代理类</span>\n    <span class="hljs-keyword">return</span> proxyClassCache.get(loader, interfaces);\n}</code></pre><p>现在需要额外来考察一下 proxyClassCache 的具体类型。</p>\n<pre><code class="hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;\n        proxyClassCache = <span class="hljs-keyword">new</span> WeakCache&lt;&gt;(<span class="hljs-keyword">new</span> KeyFactory(), <span class="hljs-keyword">new</span> ProxyClassFactory());</code></pre><p><code>WeakCache</code>, 从名称来将，是一个缓存，同时应该使用了 WeakReference 技术</p>\n<p>进入 <code>WeakCache.get(...)</code> 方法体</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key, P parameter)</span> </span>{\n    <span class="hljs-comment">// parameter 传入的是接口数组，要求不能为空</span>\n    Objects.requireNonNull(parameter);\n\n    <span class="hljs-comment">// 删除过期元素</span>\n    expungeStaleEntries();\n\n    <span class="hljs-comment">// 构建一个 WeakReference 对象(key 表示 ClassLoader)</span>\n    Object cacheKey = CacheKey.valueOf(key, refQueue);\n\n    <span class="hljs-comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span>\n    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);\n    <span class="hljs-keyword">if</span> (valuesMap == <span class="hljs-keyword">null</span>) {\n        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap\n                = map.putIfAbsent(cacheKey,\n                valuesMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;());\n        <span class="hljs-keyword">if</span> (oldValuesMap != <span class="hljs-keyword">null</span>) {\n            valuesMap = oldValuesMap;\n        }\n    }\n\n    <span class="hljs-comment">// 创建次级 Key</span>\n    <span class="hljs-comment">// 同时检索是否存在过去有同一个 ClassLoader 加载的表示 Supplier&lt;V&gt;</span>\n    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));\n    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);\n    Factory factory = <span class="hljs-keyword">null</span>;\n\n    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {\n        <span class="hljs-keyword">if</span> (supplier != <span class="hljs-keyword">null</span>) {\n            <span class="hljs-comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span>\n            <span class="hljs-comment">// 最终 supplier 将非空，同时调用 .get() 方法获取 Class 类</span>\n            V value = supplier.get();\n            <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) {\n                <span class="hljs-keyword">return</span> value;\n            }\n        }\n        <span class="hljs-comment">// else no supplier in cache</span>\n        <span class="hljs-comment">// or a supplier that returned null (could be a cleared CacheValue</span>\n        <span class="hljs-comment">// or a Factory that wasn\'t successful in installing the CacheValue)</span>\n        <span class="hljs-comment">// 未找到过去加载的记录</span>\n\n        <span class="hljs-comment">// 懒加载一个 Factory </span>\n        <span class="hljs-keyword">if</span> (factory == <span class="hljs-keyword">null</span>) {\n            factory = <span class="hljs-keyword">new</span> Factory(key, parameter, subKey, valuesMap);\n        }\n\n        <span class="hljs-keyword">if</span> (supplier == <span class="hljs-keyword">null</span>) {\n            supplier = valuesMap.putIfAbsent(subKey, factory);\n            <span class="hljs-keyword">if</span> (supplier == <span class="hljs-keyword">null</span>) {\n                <span class="hljs-comment">// successfully installed Factory</span>\n                supplier = factory;\n            }\n            <span class="hljs-comment">// else retry with winning supplier</span>\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) {\n                <span class="hljs-comment">// successfully replaced</span>\n                <span class="hljs-comment">// cleared CacheEntry / unsuccessful Factory</span>\n                <span class="hljs-comment">// with our Factory</span>\n                supplier = factory;\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-comment">// retry with current supplier</span>\n                supplier = valuesMap.get(subKey);\n            }\n        }\n    }\n}</code></pre><pre><code class="hljs"><span class="hljs-meta">@Override</span>\n<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// serialize access</span>\n    <span class="hljs-comment">// re-check</span>\n    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);\n    <span class="hljs-keyword">if</span> (supplier != <span class="hljs-keyword">this</span>) {\n        <span class="hljs-comment">// something changed while we were waiting:</span>\n        <span class="hljs-comment">// might be that we were replaced by a CacheValue</span>\n        <span class="hljs-comment">// or were removed because of failure -&gt;</span>\n        <span class="hljs-comment">// return null to signal WeakCache.get() to retry</span>\n        <span class="hljs-comment">// the loop</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n    }\n    <span class="hljs-comment">// else still us (supplier == this)</span>\n\n    <span class="hljs-comment">// create new value</span>\n    V value = <span class="hljs-keyword">null</span>;\n    <span class="hljs-keyword">try</span> {\n        <span class="hljs-comment">// 触发 valueFactory.apply() 真正的构建</span>\n        value = Objects.requireNonNull(valueFactory.apply(key, parameter));\n    } <span class="hljs-keyword">finally</span> {\n        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// remove us on failure</span>\n            valuesMap.remove(subKey, <span class="hljs-keyword">this</span>);\n        }\n    }\n    <span class="hljs-comment">// the only path to reach here is with non-null value</span>\n    <span class="hljs-keyword">assert</span> value != <span class="hljs-keyword">null</span>;\n\n    <span class="hljs-comment">// wrap value with CacheValue (WeakReference)</span>\n    CacheValue&lt;V&gt; cacheValue = <span class="hljs-keyword">new</span> CacheValue&lt;&gt;(value);\n\n    <span class="hljs-comment">// put into reverseMap</span>\n    reverseMap.put(cacheValue, Boolean.TRUE);\n\n    <span class="hljs-comment">// try replacing us with CacheValue (this should always succeed)</span>\n    <span class="hljs-keyword">if</span> (!valuesMap.replace(subKey, <span class="hljs-keyword">this</span>, cacheValue)) {\n        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">"Should not reach here"</span>);\n    }\n\n    <span class="hljs-comment">// successfully replaced us with new CacheValue -&gt; return the value</span>\n    <span class="hljs-comment">// wrapped by it</span>\n    <span class="hljs-keyword">return</span> value;\n}</code></pre><p>上面两段代码的内容，都是在反复确认将要构建的生成类是否在过去曾经创建过，如果是，则直接返回过去构建的类实例;\n否则才会尝试创建，并最终将这个构建的类也进行缓存。</p>\n<p>下面这段代码来自于 <code>Proxy</code> 的内部类 <code>ProxyClassFactory</code>\n这部分，也终于开始了对代理类字节码的统筹性构造的内容。</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {\n\n    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="hljs-keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);\n    <span class="hljs-keyword">for</span> (Class&lt;?&gt; intf : interfaces) {\n        <span class="hljs-comment">/*\n         * 校验当前接口是由同一个 ClassLoader (将要用来加载新的代理类)加载的\n         */</span>\n        Class&lt;?&gt; interfaceClass = <span class="hljs-keyword">null</span>;\n        <span class="hljs-keyword">try</span> {\n            interfaceClass = Class.forName(intf.getName(), <span class="hljs-keyword">false</span>, loader);\n        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {\n        }\n        <span class="hljs-keyword">if</span> (interfaceClass != intf) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(\n                    intf + <span class="hljs-string">" is not visible from class loader"</span>);\n        }\n        <span class="hljs-comment">/*\n         * 校验当前 Class 对象确实是一个接口\n         */</span>\n        <span class="hljs-keyword">if</span> (!interfaceClass.isInterface()) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(\n                    interfaceClass.getName() + <span class="hljs-string">" is not an interface"</span>);\n        }\n        <span class="hljs-comment">/*\n         * 校验当前接口没有被要求重复进行代理增强\n         */</span>\n        <span class="hljs-keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="hljs-keyword">null</span>) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(\n                    <span class="hljs-string">"repeated interface: "</span> + interfaceClass.getName());\n        }\n    }\n\n    String proxyPkg = <span class="hljs-keyword">null</span>;     <span class="hljs-comment">// 生成的代理类所属的 package</span>\n    <span class="hljs-keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n\n    <span class="hljs-comment">/*\n     * 如果代理的接口是非 PUBLIC ，那么生成的代理类的接口将与这个非 PUBLIC 接口\n     * 在同一个包下。\n     * 如果代理的接口有多个非 PUBLIC ，且分别位于不同的包下，那么抛出异常\n     */</span>\n    <span class="hljs-keyword">for</span> (Class&lt;?&gt; intf : interfaces) {\n        <span class="hljs-keyword">int</span> flags = intf.getModifiers();\n        <span class="hljs-keyword">if</span> (!Modifier.isPublic(flags)) {\n            accessFlags = Modifier.FINAL;\n            String name = intf.getName();\n            <span class="hljs-keyword">int</span> n = name.lastIndexOf(<span class="hljs-string">\'.\'</span>);\n            String pkg = ((n == -<span class="hljs-number">1</span>) ? <span class="hljs-string">""</span> : name.substring(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>));\n            <span class="hljs-keyword">if</span> (proxyPkg == <span class="hljs-keyword">null</span>) {\n                proxyPkg = pkg;\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!pkg.equals(proxyPkg)) {\n                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(\n                        <span class="hljs-string">"non-public interfaces from different packages"</span>);\n            }\n        }\n    }\n\n    <span class="hljs-comment">// 如果代理的接口全是 PUBLIC 的，那么使用默认的包 com.sun.proxy</span>\n    <span class="hljs-keyword">if</span> (proxyPkg == <span class="hljs-keyword">null</span>) {\n        <span class="hljs-comment">// if no non-public proxy interfaces, use com.sun.proxy package</span>\n        proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="hljs-string">"."</span>;\n    }\n\n    <span class="hljs-comment">/*\n     * 为将要生成的代理类选择一个全限定名\n     * 规则是 包名 + "$Proxy" + &lt;唯一递增的id, 从0开始编号&gt;\n     */</span>\n    <span class="hljs-keyword">long</span> num = nextUniqueNumber.getAndIncrement();\n    String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n    <span class="hljs-comment">/*\n     * 生成一个特殊的代理类的字节码\n     * byte[] proxyClassFile 就等同于 .class 文件的全部二进制内容。\n     * 与 .class 文件的区别就在于一个写在了外存上，另一个完全在内存中创建\n     */</span>\n    <span class="hljs-keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(\n            proxyName, interfaces, accessFlags);\n    <span class="hljs-keyword">try</span> {\n        <span class="hljs-comment">/**\n          * 调用 ClassLoader 的 defineClass0(...) 方法加载字节码内容，构造 Class 对象\n          * 本来 defineClass0(...) 方法是定义在 ClassLoader 中，但这里额外声明了一个本地方法 defineClass0(...)\n          * 想来实现也是类似的，最终的目的也是加载 Class \n          */</span>\n        <span class="hljs-keyword">return</span> defineClass0(loader, proxyName,\n                proxyClassFile, <span class="hljs-number">0</span>, proxyClassFile.length);\n    } <span class="hljs-keyword">catch</span> (ClassFormatError e) {\n        <span class="hljs-comment">/*\n         * A ClassFormatError here means that (barring bugs in the\n         * proxy class generation code) there was some other\n         * invalid aspect of the arguments supplied to the proxy\n         * class creation (such as virtual machine limitations\n         * exceeded).\n         */</span>\n        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(e.toString());\n    }\n}</code></pre><p>在完成基础性的校验，并构造了生成类的类名等内容后，\n<code>ProxyGenerator.generateProxyClass</code> 将开始构造 <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html">ClassFile</a> 的具体内容。</p>\n<p>关于这部分生成字节码的内容，请在了解了 ClassFile 的基础性内容之后，在自行学习，内容全部在 ProxyGenerator 类中。</p>\n<p>这部分的规则是(在构建新的代理生成类时):</p>\n<ul>\n<li>额外添加三个 Object 的方法 (<code>hashCode</code>, <code>equals</code>, <code>toString</code>)</li>\n<li>逐一读取所有需要增强的接口的方法，并对重复方法进行判断; 如果方法名相同，入参数量与类型相同，但返回参数不同，则抛出异常</li>\n<li>在遍历所有接口的方法的时候，同时也将为新的生成类构造新的字段(内容就是通过反射获取该方法)</li>\n<li>最后将新的生成类将要包含的所有字段与方法进行构造，同时维护一个常量池内容</li>\n<li>输出这些内容的二进制表示 byte[];</li>\n</ul>\n<h2>如何对方法增强</h2>\n<p>想必上了上一节，虽然对 Java 动态代理的调用链有了一定的了解。</p>\n<p>但是，究竟 Proxy 是如何完成对实现类方法的增强呢？</p>\n<p>也许我们需要先看一下生成类 .class 文件的一些内容来对这个命题形成基础性的影响。</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Code <span class="hljs-title">getCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>{\n    <span class="hljs-keyword">try</span> {\n        <span class="hljs-keyword">return</span> (Code)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m4, (Object[])<span class="hljs-keyword">null</span>);\n    } <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) {\n        <span class="hljs-keyword">throw</span> var2;\n    } <span class="hljs-keyword">catch</span> (Throwable var3) {\n        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);\n    }\n}</code></pre><p>可以看到，生成类的 <code>getCode()</code> 方法几乎没有什么实质性的内容, 只是 <code>super.h.invoke(...)</code> 。</p>\n<p><code>h</code> 实例变量是什么？<code>InvocationHandler</code> 的一个实例对象。</p>\n<p>事实上，Java Proxy 生成类的每个方法结构几乎都是类似的。方法体的内容就是通过实例持有的 <code>h</code> 变量分发实际的操作指令</p>\n<p>至于 h 的具体内容。:) 有编程者自定义，并在 Proxy 生成字节码，并被 ClassLoader 加载后，在准备实例化的时候作为构造参数进行传入。</p>\n<pre><code class="hljs">ICodeFactory factory = (ICodeFactory) clazz.getConstructor(<span class="hljs-keyword">new</span> Class[] { InvocationHandler.class }).newInstance(<span class="hljs-keyword">new</span> Object[] { handler });</code></pre><p>至于具体将做哪些增强，调用例如上例的 <code>ICodeFactory</code> 的那个实现类的方法，全部有使用者自定义。</p>\n<h2>生成类的反编译结果</h2>\n<p>仍然以本文开始的 ICodeFactory 的增强为例，看一下究竟通过 Java Proxy 动态代理生成的字节码的反编译结果究竟是什么？\n并以此来对这种动态代理机制形成更为直观的印象</p>\n<p>在 Java 源代码中，虽然默认不会输出生成类的二进制内容，但是，仍然预留了打印 .class 文件的可选项。</p>\n<p>有兴趣的同学可以看一下 <code>ProxyGenerator.saveGeneratedFiles</code> 字段的内容，这就决定是在构造代理类后是否存储到外存中。</p>\n<p>想要看到代理类的字节码，直接通过在 Java 执行程序中添加一行代码</p>\n<pre><code class="hljs">System.setProperty(<span class="hljs-string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="hljs-string">"true"</span>);</code></pre><p>或者在启动程序的 <code>java</code> 命令下添加参数</p>\n<pre><code class="hljs">-Dsun.misc.ProxyGenerator.saveGeneratedFiles=<span class="hljs-literal">true</span>`</code></pre><p>至于生成类将打印在哪，首先必然是在项目所属的目录下。有上一节中构造生成类全限定名的内容，根据包名的规则去寻找即可。(具体不再详述)</p>\n<p>直接通过 IDEA, Eclipse 或者其它工具，对生成类 .class 文件进行反编译可以查看到整个生成类的内容。</p>\n<pre><code class="hljs"><span class="hljs-keyword">package</span> com.sun.proxy;\n\n<span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;\n<span class="hljs-keyword">import</span> java.lang.reflect.Method;\n<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;\n<span class="hljs-keyword">import</span> java.lang.reflect.UndeclaredThrowableException;\n<span class="hljs-keyword">import</span> me.fangfeng.jdk.proxy.Code;\n<span class="hljs-keyword">import</span> me.fangfeng.jdk.proxy.ICodeFactory;\n\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICodeFactory</span> </span>{\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m4;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;\n\n    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler var1) <span class="hljs-keyword">throws</span>  {\n        <span class="hljs-keyword">super</span>(var1);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> <span class="hljs-keyword">throws</span>  </span>{\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m1, <span class="hljs-keyword">new</span> Object[]{var1});\n        } <span class="hljs-keyword">catch</span> (RuntimeException | Error var3) {\n            <span class="hljs-keyword">throw</span> var3;\n        } <span class="hljs-keyword">catch</span> (Throwable var4) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var4);\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>{\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m2, (Object[])<span class="hljs-keyword">null</span>);\n        } <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) {\n            <span class="hljs-keyword">throw</span> var2;\n        } <span class="hljs-keyword">catch</span> (Throwable var3) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Code <span class="hljs-title">getCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>{\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-keyword">return</span> (Code)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m4, (Object[])<span class="hljs-keyword">null</span>);\n        } <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) {\n            <span class="hljs-keyword">throw</span> var2;\n        } <span class="hljs-keyword">catch</span> (Throwable var3) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCode</span><span class="hljs-params">(Code var1)</span> <span class="hljs-keyword">throws</span>  </span>{\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, <span class="hljs-keyword">new</span> Object[]{var1});\n        } <span class="hljs-keyword">catch</span> (RuntimeException | Error var3) {\n            <span class="hljs-keyword">throw</span> var3;\n        } <span class="hljs-keyword">catch</span> (Throwable var4) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var4);\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>{\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m0, (Object[])<span class="hljs-keyword">null</span>);\n        } <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) {\n            <span class="hljs-keyword">throw</span> var2;\n        } <span class="hljs-keyword">catch</span> (Throwable var3) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);\n        }\n    }\n\n    <span class="hljs-keyword">static</span> {\n        <span class="hljs-keyword">try</span> {\n            m1 = Class.forName(<span class="hljs-string">"java.lang.Object"</span>).getMethod(<span class="hljs-string">"equals"</span>, Class.forName(<span class="hljs-string">"java.lang.Object"</span>));\n            m2 = Class.forName(<span class="hljs-string">"java.lang.Object"</span>).getMethod(<span class="hljs-string">"toString"</span>);\n            m4 = Class.forName(<span class="hljs-string">"me.fangfeng.jdk.proxy.ICodeFactory"</span>).getMethod(<span class="hljs-string">"getCode"</span>);\n            m3 = Class.forName(<span class="hljs-string">"me.fangfeng.jdk.proxy.ICodeFactory"</span>).getMethod(<span class="hljs-string">"setCode"</span>, Class.forName(<span class="hljs-string">"me.fangfeng.jdk.proxy.Code"</span>));\n            m0 = Class.forName(<span class="hljs-string">"java.lang.Object"</span>).getMethod(<span class="hljs-string">"hashCode"</span>);\n        } <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(var2.getMessage());\n        } <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}</code></pre><pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-07-20-Java-Proxy.json",ext:".json",sourceBase:"2018-07-20-Java-Proxy.md",sourceExt:".md"}},cN4P:function(n){n.exports={title:"区块链技术概述",layout:"post",author:"fangfeng",date:"2018-03-01T00:00:00.000Z",tags:["BlockChain","Smart Contract"],bodyContent:"![区块链简单结构](https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg)\n<center><small>图1. 区块链简单结构</small></center>\n\n\n\n![Merkle tree](https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg)\n\n<center><small>图2. 单个区块的抽象结构</small></center>\n\n\x3c!-- more --\x3e\n## 基本工作流程\n\n### 新交易发起流程\n\n1. 用户通过公/私钥与区块链网络进行交互\n2. 处理用户交易的节点向网络邻节点广播用户交易\n3. 邻节点验证交易的有效性；可信，继续向其它邻节点广播；不可信，丢弃。\n\n### 新区块产生流程\n\n1. 矿工尝试将一个时间区间内的交易进行打包形成新区块（怎么打包，看下文）\n2. 生产出新区块的矿工节点向网络广播新区块\n3. 收到新区块的网络节点验证该区块的有效性\n\n[比特币区块浏览器](https://blockchain.info/zh-cn)      更多[国际单位制前缀](https://en.wikipedia.org/wiki/Metric_prefix)\n\n## 网络共识\n\n所有区块链网络节点需要对交易以及其在新区块里面的顺序达成一致（交易的有效性以及交易的打包顺序）。\n\n\n\n可能出现：\n\n- 女巫攻击——单一实体以多重身份重复对新区块结果进行表决（少数人抓住了网络的投票权）\n- [拜占庭将军问题](https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98)——分布式对等网络的通信容错问题\n  - 不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动\n    - 成员计算机可能出错而发送错误信息\n    - 网络的不可靠性\n    - 从而影响网络共识的达成，破坏一致性。\n  - 不解决的话可能导致——区块链分叉\n\n解决方案：\n\n- 工作量证明（proof-of-work, PoW），权益证明(proof-of-stake, PoS)，白名单机制（仅适用于私有网络）等\n- 实用拜占庭容错算法\n\n\n### 局限\n\n网络共识机制的实现导致了：\n\n1. 交易吞吐量\n2. 更高的交易时延。交易确认时间（只有打包的新区块中才交易才会被承认）。\n\n共识机制的伸缩可以一定程度上解决上述问题\n\n\n\n\n## 资产交易\n\n简单交易状态描述，以集中式数据库为例\n\n假设初始状态为\n\n```\n-------------------------\n| 资产类型 | 所有者 | 数量 |\n-------------------------\n|   CNY   |  防风  |  10 |\n-------------------------\n|   CNY   |  红薯  |  0  |\n-------------------------\n```\n\n防风 向 红薯 转账 2 CNY \n\n```\n-------------------------\n| 资产类型 | 所有者 | 数量 |\n-------------------------\n|   CNY   |  防风  |  8  |\n-------------------------\n|   CNY   |  红薯  |  2  |\n-------------------------\n```\n\n数据库中相应记录的更改完成了资产的交易过程。\n\n在区块链中，仍然将分布式链看作是一个达成共识的集中式数据库\n\n那么现在的初始状态可以表示成\n\n```\n---------------------------------\n| 资产类型 |     所有者     | 数量 |\n---------------------------------\n|   IOTA  |  防风 pub_key  | 10  |\n---------------------------------\n```\n\n现在的所有者由公钥表示，想要修改记录必须提供对应的密钥。\n\n例如，防风 向 红薯 转账 2 IOTA ，需要提供防风的私钥和红薯的公钥。交易记录修改结果：\n\n```\n---------------------------------\n| 资产类型 |     所有者     | 数量 |\n---------------------------------\n                                 被删除了         |   IOTA  |  防风 pub_key  | 10  |\n---------------------------------\n|   IOTA  |  红薯 pub_key  |  2  |\n---------------------------------\n|   IOTA  |  防风 pub_key  |  8  |\n```\n\n交易的概念流程：\n\n1. 定位防风所有的资产记录行\n2. 删除该行前验证密钥\n3. 确认该记录没有被别的交易使用（双花问题，双重交易）\n4. 写入新的正确的记录（红薯获得的资产 & 防风剩余的资产），确保交易前与交易后资产总额不变\n\n上面的模型 —— 基于比特币的交易模型(UTXO *model*)\n\n**适合于数字标记资产的传输与追踪**\n\n- 概念：UTXO (unspent transaction outputs) 未花费的交易输出：数据库现有的记录\n\n\\---------------------------------\n\n另一种模型常用于智能合约 —— 基于账号的模型(account-based *model*)\n\n**提供了建立多步骤执行的基本机制** \n\n### 资产如何产生\n\n- 比特币：\n  - 矿工节点允许在挖出的新节点中加入一种 coinbase 类型的交易（不存在交易输入，新资产数额有比特币链提前定义）\n- 在创始新代币的时候全额发行\n- 其它机制\n\n## 区块链特性\n\n1. 一种健壮的、真正的分布式对等系统，它能容忍节点故障。\n2. 能够识别冲突和分叉并自动解决的网络，以便收敛到单一的、公认的唯一状态。（区块链永远选择最长的分支来达成网络上的共识）\n3. 网络活动的透明性、可验证性、可审计性。我们能获取可验证的过程，无论它们是否交换和跟踪数字资产，还是数据驱动的交互。每一个行为，都存有公开的与网络交互的记录，并以此来消除人为的矛盾。\n4. 这是一种可以标记不同信息的触发者的方法，并且能够在没有中央权威的情况下强制执行。\n5. 这是一个使得不信任双方根据可预测的、确定性的方式交互的系统。\n\n## 智能合约\n\n自动化地执行一系列合约条款的交易协议\n\n智能合约是存储在区块链中的脚本（认识上可以与关系型数据库的存储过程类似）。\n\n以基于账号的模型为例对合约执行进行描述：\n\n```\n假设定义一个合约，包括三个方法\n\n(1) “存储”——合约的“存款”功能允许 防风（通过防风的密钥验证）将若干单位的X存入合约中；\n(2) “交易”——“交易”功能允许任何人向合约发送5单位Y，并从合约持有的X中返回1单位给交易方；\n(3) “撤销”——“撤销”功能允许 防风 取出合约中存有的所有资产。\n\n\t请注意，上述“存款”和“撤销”功能被限制为只允许被 防风（实际上是防风的私钥）调用。当然，这只有由于上述合约由防风制定。若人为的制定一个所有人都能调用任何功能的合约也是允许的（虽然这在事实上没有意义）。\n\n```\n\n那么在基于账户的模型下，可以认为 拥有“存储”、“交易”、“撤销”方法的合约持有一个单独的账户（与用户所持有的账户等价）。\n\n在上述合约下，这个账户将可能持有一定数量的资产。除了只能按照预定的合约步骤对资产进行处置之外，其它与用户持有的账户别无二致。\n\n\n```text\n  __                    __\n / _| __ _ _ __   __ _ / _| ___ _ __   __ _\n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/\n```",bodyHtml:'<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg" alt="区块链简单结构">\n&lt;center&gt;&lt;small&gt;图1. 区块链简单结构&lt;/small&gt;&lt;/center&gt;</p>\n<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg" alt="Merkle tree"></p>\n<p>&lt;center&gt;&lt;small&gt;图2. 单个区块的抽象结构&lt;/small&gt;&lt;/center&gt;</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>基本工作流程</h2>\n<h3>新交易发起流程</h3>\n<ol>\n<li>用户通过公/私钥与区块链网络进行交互</li>\n<li>处理用户交易的节点向网络邻节点广播用户交易</li>\n<li>邻节点验证交易的有效性；可信，继续向其它邻节点广播；不可信，丢弃。</li>\n</ol>\n<h3>新区块产生流程</h3>\n<ol>\n<li>矿工尝试将一个时间区间内的交易进行打包形成新区块（怎么打包，看下文）</li>\n<li>生产出新区块的矿工节点向网络广播新区块</li>\n<li>收到新区块的网络节点验证该区块的有效性</li>\n</ol>\n<p><a href="https://blockchain.info/zh-cn">比特币区块浏览器</a>      更多<a href="https://en.wikipedia.org/wiki/Metric_prefix">国际单位制前缀</a></p>\n<h2>网络共识</h2>\n<p>所有区块链网络节点需要对交易以及其在新区块里面的顺序达成一致（交易的有效性以及交易的打包顺序）。</p>\n<p>可能出现：</p>\n<ul>\n<li>女巫攻击——单一实体以多重身份重复对新区块结果进行表决（少数人抓住了网络的投票权）</li>\n<li><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">拜占庭将军问题</a>——分布式对等网络的通信容错问题\n<ul>\n<li>不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动\n<ul>\n<li>成员计算机可能出错而发送错误信息</li>\n<li>网络的不可靠性</li>\n<li>从而影响网络共识的达成，破坏一致性。</li>\n</ul>\n</li>\n<li>不解决的话可能导致——区块链分叉</li>\n</ul>\n</li>\n</ul>\n<p>解决方案：</p>\n<ul>\n<li>工作量证明（proof-of-work, PoW），权益证明(proof-of-stake, PoS)，白名单机制（仅适用于私有网络）等</li>\n<li>实用拜占庭容错算法</li>\n</ul>\n<h3>局限</h3>\n<p>网络共识机制的实现导致了：</p>\n<ol>\n<li>交易吞吐量</li>\n<li>更高的交易时延。交易确认时间（只有打包的新区块中才交易才会被承认）。</li>\n</ol>\n<p>共识机制的伸缩可以一定程度上解决上述问题</p>\n<h2>资产交易</h2>\n<p>简单交易状态描述，以集中式数据库为例</p>\n<p>假设初始状态为</p>\n<pre><code>-------------------------\n| 资产类型 | 所有者 | 数量 |\n-------------------------\n|   CNY   |  防风  |  10 |\n-------------------------\n|   CNY   |  红薯  |  0  |\n-------------------------\n</code></pre>\n<p>防风 向 红薯 转账 2 CNY</p>\n<pre><code>-------------------------\n| 资产类型 | 所有者 | 数量 |\n-------------------------\n|   CNY   |  防风  |  8  |\n-------------------------\n|   CNY   |  红薯  |  2  |\n-------------------------\n</code></pre>\n<p>数据库中相应记录的更改完成了资产的交易过程。</p>\n<p>在区块链中，仍然将分布式链看作是一个达成共识的集中式数据库</p>\n<p>那么现在的初始状态可以表示成</p>\n<pre><code>---------------------------------\n| 资产类型 |     所有者     | 数量 |\n---------------------------------\n|   IOTA  |  防风 pub_key  | 10  |\n---------------------------------\n</code></pre>\n<p>现在的所有者由公钥表示，想要修改记录必须提供对应的密钥。</p>\n<p>例如，防风 向 红薯 转账 2 IOTA ，需要提供防风的私钥和红薯的公钥。交易记录修改结果：</p>\n<pre><code>---------------------------------\n| 资产类型 |     所有者     | 数量 |\n---------------------------------\n                                 被删除了         |   IOTA  |  防风 pub_key  | 10  |\n---------------------------------\n|   IOTA  |  红薯 pub_key  |  2  |\n---------------------------------\n|   IOTA  |  防风 pub_key  |  8  |\n</code></pre>\n<p>交易的概念流程：</p>\n<ol>\n<li>定位防风所有的资产记录行</li>\n<li>删除该行前验证密钥</li>\n<li>确认该记录没有被别的交易使用（双花问题，双重交易）</li>\n<li>写入新的正确的记录（红薯获得的资产 &amp; 防风剩余的资产），确保交易前与交易后资产总额不变</li>\n</ol>\n<p>上面的模型 —— 基于比特币的交易模型(UTXO <em>model</em>)</p>\n<p><strong>适合于数字标记资产的传输与追踪</strong></p>\n<ul>\n<li>概念：UTXO (unspent transaction outputs) 未花费的交易输出：数据库现有的记录</li>\n</ul>\n<p>---------------------------------</p>\n<p>另一种模型常用于智能合约 —— 基于账号的模型(account-based <em>model</em>)</p>\n<p><strong>提供了建立多步骤执行的基本机制</strong></p>\n<h3>资产如何产生</h3>\n<ul>\n<li>比特币：\n<ul>\n<li>矿工节点允许在挖出的新节点中加入一种 coinbase 类型的交易（不存在交易输入，新资产数额有比特币链提前定义）</li>\n</ul>\n</li>\n<li>在创始新代币的时候全额发行</li>\n<li>其它机制</li>\n</ul>\n<h2>区块链特性</h2>\n<ol>\n<li>一种健壮的、真正的分布式对等系统，它能容忍节点故障。</li>\n<li>能够识别冲突和分叉并自动解决的网络，以便收敛到单一的、公认的唯一状态。（区块链永远选择最长的分支来达成网络上的共识）</li>\n<li>网络活动的透明性、可验证性、可审计性。我们能获取可验证的过程，无论它们是否交换和跟踪数字资产，还是数据驱动的交互。每一个行为，都存有公开的与网络交互的记录，并以此来消除人为的矛盾。</li>\n<li>这是一种可以标记不同信息的触发者的方法，并且能够在没有中央权威的情况下强制执行。</li>\n<li>这是一个使得不信任双方根据可预测的、确定性的方式交互的系统。</li>\n</ol>\n<h2>智能合约</h2>\n<p>自动化地执行一系列合约条款的交易协议</p>\n<p>智能合约是存储在区块链中的脚本（认识上可以与关系型数据库的存储过程类似）。</p>\n<p>以基于账号的模型为例对合约执行进行描述：</p>\n<pre><code>假设定义一个合约，包括三个方法\n\n(1) “存储”——合约的“存款”功能允许 防风（通过防风的密钥验证）将若干单位的X存入合约中；\n(2) “交易”——“交易”功能允许任何人向合约发送5单位Y，并从合约持有的X中返回1单位给交易方；\n(3) “撤销”——“撤销”功能允许 防风 取出合约中存有的所有资产。\n\n\t请注意，上述“存款”和“撤销”功能被限制为只允许被 防风（实际上是防风的私钥）调用。当然，这只有由于上述合约由防风制定。若人为的制定一个所有人都能调用任何功能的合约也是允许的（虽然这在事实上没有意义）。\n\n</code></pre>\n<p>那么在基于账户的模型下，可以认为 拥有“存储”、“交易”、“撤销”方法的合约持有一个单独的账户（与用户所持有的账户等价）。</p>\n<p>在上述合约下，这个账户将可能持有一定数量的资产。除了只能按照预定的合约步骤对资产进行处置之外，其它与用户持有的账户别无二致。</p>\n<pre><code class="hljs">__                    __\n / _| __ _ _ __   __ _ / _| ___ _ __   __ _\n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-03-01-区块链简单介绍.json",ext:".json",sourceBase:"2018-03-01-区块链简单介绍.md",sourceExt:".md"}},fORH:function(n){n.exports={title:"Preprocessor Output",author:"fangfeng",date:"2018-09-08T00:00:00.000Z",tags:["C","CPP","GCC"],bodyContent:'最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。\n暂时告别一步到位的命令 `gcc main.c`，如果从 `.c` 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。\n但是，仅仅从第一个流程 **预编译** 而言，就已经遇到了一些麻烦。\n\n<small>program.i</small>\n```c\n# 1 "program.c"\n# 1 "<built-in>"\n# 1 "<command-line>"\n# 1 "/usr/include/stdc-predef.h" 1 3 4\n# 1 "<command-line>" 2\n# 1 "program.c"\n# 1 "header.h" 1\nchar *test(void);\n# 2 "program.c" 2\n\nint main(void)\n{\n}\n```\n\n预编译后的问题出现了诸如 `# 1 "program.c"` 的 *注释?* \n\n这里简单记录预处理输出文件的基本格式，方便今后回顾。\n\x3c!-- more --\x3e\n\n## Output File format\n\n首先，从预编译的结果看，`cpp (C preprocessor)` 程序主要是处理了所有的**宏指令**。然后添加上了一些所谓**线性标记**的内容。\n最终得到的就是类似 `program.i` 的结果。\n\n从细节上来说: \n首先，所有的宏指令，包括 `#include` (用于引入用户自定义及系统预定义的头文件)、`#define` (用于将使用到的宏进行替换)。\n当然，在替换完成后，这些指令所在的行将被替换成空行。同时，所有的注释行也将被替换成空行。\n\n此外，将添加上注入 `#1 "program.c"` 的**线性标记**。\n\n### 线性标记\n\n线性标记的标准格式:\n\n`# linenum filename flags`\n\nlinenum 是为了配合预定义宏 `__LINE__` 是使用的，用于定位紧随的下一行内容在原文件中所在的行。\n\nfilename 指出了接下来的内容来自哪个原文件\n\nflags 有如下几个取值:\n\n- 1 : 表示这是一个新的文件的开始\n- 2 : 表示回到文件 `filename` 的内容 (从其他的 *include* 的文件中)\n- 3 : 表示接下来的内容是从系统预定义头文件中来的，因此需要抑制某些警告\n- 4 : 表示接下来的内容需要被视作是被封装的隐式 `extern "C"` 块\n\n### 实例解读\n\n<small>program.c</small>\n```c\n#include "header.h"\nint main(void)\n{\n    puts(test());\n}\n```\n\n<small>header.h</small>\n```c\nchar *test(void);\n```\n\n接下来的演示都将以 **program.c** 和 **header.h** 两个文件作为标准示例。\n期间，将对 **program.c** or **header.h** 做不同程度的修改，已达到更好的展示效果。\n*注意:* 额外添加的注释由 `!` 开始到该行结束(并不符合 C 语言语法)，但是帮助理解\n\n**Sample 1**\n\n直接利用 program.c 与 header.h 进行预编译 `cpp -o program.i program.c`\n结果如下:\n\n```c\n# 1 "program.c"\n# 1 "<built-in>"\n# 1 "<command-line>"\n# 1 "/usr/include/stdc-predef.h" 1 3 4\n# 1 "<command-line>" 2\n# 1 "program.c"\n# 1 "header.h" 1            ! 下一行代码对应的是 header.h 文件第一行\nchar *test(void);\n# 2 "program.c" 2           ! flag=2 表示下列内容由回到了 program.c 中，下一行对应原文件第二行\n\nint main(void)\n{\n    puts(test());\n}\n```\n\n**Sample 2**\n\n接着，给 **program.c** 加点注释，在加点空行\n\n<small>program.c - sub 1<small>\n```c\n// This is comment          ! 这里添加了一行注释\n#include "header.h"\n\n                            ! 这里加了个空行\nint main(void)\n{\n    puts(test());\n}\n```\n\n再看看效果\n\n```c\n# 1 "program.c"\n# 1 "<built-in>"\n# 1 "<command-line>"\n# 1 "/usr/include/stdc-predef.h" 1 3 4\n# 1 "<command-line>" 2\n# 1 "program.c"             ! 下一行代码对应原代码中第 1 行，本来是注释，但会被预编译器处理成空行 (多行将逐一处理，但行数不会变)\n\n# 1 "header.h" 1            ! 下面将描述 header.h 的代码\nchar *test(void);\n# 3 "program.c" 2           ! 继续描述 program.c ，下一行对应原代码第 3 行。至于第 2 行，就是 #include "header.h" ，不会直接表现了\n\n\nint main(void)\n{\n    puts(test());\n}\n```\n\n**Sample 3**\n\n在改变一些\n\n<small>program.c - sub 2</small>\n```c\n// This is comment\n#include "header.h"\n#define TEN 10\n\nint main(void)\n{\n    puts(test());\n}\n```\n\n看看结果\n\n```c\n# 1 "program.c"\n# 1 "<built-in>"\n# 1 "<command-line>"\n# 1 "/usr/include/stdc-predef.h" 1 3 4\n# 1 "<command-line>" 2\n# 1 "program.c"\n\n# 1 "header.h" 1\nchar *test(void);\n# 3 "program.c" 2\n                        ! 原代码中对应行是宏 #define TEN 10 ，已经被空行替换掉了。\n\nint main(void)\n{\n    puts(test());\n}\n```\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<p>最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。\n暂时告别一步到位的命令 <code>gcc main.c</code>，如果从 <code>.c</code> 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。\n但是，仅仅从第一个流程 <strong>预编译</strong> 而言，就已经遇到了一些麻烦。</p>\n<p>&lt;small&gt;program.i&lt;/small&gt;</p>\n<pre><code class="hljs"># <span class="hljs-number">1</span> <span class="hljs-string">"program.c"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"&lt;built-in&gt;"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"&lt;command-line&gt;"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"/usr/include/stdc-predef.h"</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"&lt;command-line&gt;"</span> <span class="hljs-number">2</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"program.c"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"header.h"</span> <span class="hljs-number">1</span>\n<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;\n# <span class="hljs-number">2</span> <span class="hljs-string">"program.c"</span> <span class="hljs-number">2</span>\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n}</code></pre><p>预编译后的问题出现了诸如 <code># 1 &quot;program.c&quot;</code> 的 <em>注释?</em></p>\n<p>这里简单记录预处理输出文件的基本格式，方便今后回顾。\n&lt;!-- more --&gt;</p>\n<h2>Output File format</h2>\n<p>首先，从预编译的结果看，<code>cpp (C preprocessor)</code> 程序主要是处理了所有的<strong>宏指令</strong>。然后添加上了一些所谓<strong>线性标记</strong>的内容。\n最终得到的就是类似 <code>program.i</code> 的结果。</p>\n<p>从细节上来说:\n首先，所有的宏指令，包括 <code>#include</code> (用于引入用户自定义及系统预定义的头文件)、<code>#define</code> (用于将使用到的宏进行替换)。\n当然，在替换完成后，这些指令所在的行将被替换成空行。同时，所有的注释行也将被替换成空行。</p>\n<p>此外，将添加上注入 <code>#1 &quot;program.c&quot;</code> 的<strong>线性标记</strong>。</p>\n<h3>线性标记</h3>\n<p>线性标记的标准格式:</p>\n<p><code># linenum filename flags</code></p>\n<p>linenum 是为了配合预定义宏 <code>__LINE__</code> 是使用的，用于定位紧随的下一行内容在原文件中所在的行。</p>\n<p>filename 指出了接下来的内容来自哪个原文件</p>\n<p>flags 有如下几个取值:</p>\n<ul>\n<li>1 : 表示这是一个新的文件的开始</li>\n<li>2 : 表示回到文件 <code>filename</code> 的内容 (从其他的 <em>include</em> 的文件中)</li>\n<li>3 : 表示接下来的内容是从系统预定义头文件中来的，因此需要抑制某些警告</li>\n<li>4 : 表示接下来的内容需要被视作是被封装的隐式 <code>extern &quot;C&quot;</code> 块</li>\n</ul>\n<h3>实例解读</h3>\n<p>&lt;small&gt;program.c&lt;/small&gt;</p>\n<pre><code class="hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"header.h"</span></span>\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n    <span class="hljs-built_in">puts</span>(test());\n}</code></pre><p>&lt;small&gt;header.h&lt;/small&gt;</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><p>接下来的演示都将以 <strong>program.c</strong> 和 <strong>header.h</strong> 两个文件作为标准示例。\n期间，将对 <strong>program.c</strong> or <strong>header.h</strong> 做不同程度的修改，已达到更好的展示效果。\n<em>注意:</em> 额外添加的注释由 <code>!</code> 开始到该行结束(并不符合 C 语言语法)，但是帮助理解</p>\n<p><strong>Sample 1</strong></p>\n<p>直接利用 program.c 与 header.h 进行预编译 <code>cpp -o program.i program.c</code>\n结果如下:</p>\n<pre><code class="hljs"># <span class="hljs-number">1</span> <span class="hljs-string">"program.c"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"&lt;built-in&gt;"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"&lt;command-line&gt;"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"/usr/include/stdc-predef.h"</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"&lt;command-line&gt;"</span> <span class="hljs-number">2</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"program.c"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"header.h"</span> <span class="hljs-number">1</span>            ! 下一行代码对应的是 header.h 文件第一行\n<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;\n# <span class="hljs-number">2</span> <span class="hljs-string">"program.c"</span> <span class="hljs-number">2</span>           ! flag=<span class="hljs-number">2</span> 表示下列内容由回到了 program.c 中，下一行对应原文件第二行\n\n<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">void</span>)\n{\n    <span class="hljs-built_in">puts</span>(test());\n}</code></pre><p><strong>Sample 2</strong></p>\n<p>接着，给 <strong>program.c</strong> 加点注释，在加点空行</p>\n<p>&lt;small&gt;program.c - sub 1&lt;small&gt;</p>\n<pre><code class="hljs"><span class="hljs-comment">// This is comment          ! 这里添加了一行注释</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"header.h"</span></span>\n\n                            ! 这里加了个空行\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n    <span class="hljs-built_in">puts</span>(test());\n}</code></pre><p>再看看效果</p>\n<pre><code class="hljs"># <span class="hljs-number">1</span> <span class="hljs-string">"program.c"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"&lt;built-in&gt;"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"&lt;command-line&gt;"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"/usr/include/stdc-predef.h"</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"&lt;command-line&gt;"</span> <span class="hljs-number">2</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"program.c"</span>             ! 下一行代码对应原代码中第 <span class="hljs-number">1</span> 行，本来是注释，但会被预编译器处理成空行 (多行将逐一处理，但行数不会变)\n\n# <span class="hljs-number">1</span> <span class="hljs-string">"header.h"</span> <span class="hljs-number">1</span>            ! 下面将描述 header.h 的代码\n<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;\n# <span class="hljs-number">3</span> <span class="hljs-string">"program.c"</span> <span class="hljs-number">2</span>           ! 继续描述 program.c ，下一行对应原代码第 <span class="hljs-number">3</span> 行。至于第 <span class="hljs-number">2</span> 行，就是 <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"header.h"</span> ，不会直接表现了</span>\n\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n    <span class="hljs-built_in">puts</span>(test());\n}</code></pre><p><strong>Sample 3</strong></p>\n<p>在改变一些</p>\n<p>&lt;small&gt;program.c - sub 2&lt;/small&gt;</p>\n<pre><code class="hljs"><span class="hljs-comment">// This is comment</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"header.h"</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEN 10</span>\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n    <span class="hljs-built_in">puts</span>(test());\n}</code></pre><p>看看结果</p>\n<pre><code class="hljs"># <span class="hljs-number">1</span> <span class="hljs-string">"program.c"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"&lt;built-in&gt;"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"&lt;command-line&gt;"</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"/usr/include/stdc-predef.h"</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"&lt;command-line&gt;"</span> <span class="hljs-number">2</span>\n# <span class="hljs-number">1</span> <span class="hljs-string">"program.c"</span>\n\n# <span class="hljs-number">1</span> <span class="hljs-string">"header.h"</span> <span class="hljs-number">1</span>\n<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;\n# <span class="hljs-number">3</span> <span class="hljs-string">"program.c"</span> <span class="hljs-number">2</span>\n                        ! 原代码中对应行是宏 <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEN 10 ，已经被空行替换掉了。</span>\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n    <span class="hljs-built_in">puts</span>(test());\n}</code></pre><pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-09-08-preprocessor-output.json",ext:".json",sourceBase:"2018-09-08-preprocessor-output.md",sourceExt:".md"}},frAL:function(n){n.exports={title:"理解 Linux Kernel (9) - IO Multiplexing",author:"fangfeng",date:"2019-03-05T00:00:00.000Z",tags:["Linux","Kernel","IO Model"],bodyContent:'[前一篇](./2019-01-15-understand-Kernel-8/)已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet\\_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet\\_data 中的 `struct sock` 对象，将其逐级从网络接口层逐级提升到网络层、传输层...最终添加到接收队列 `sk_receive_queue` 中；用户进程通过 `read`、`recv`、`recvfrom` 等命令检查并获取 `sk_receive_queue` 中的数据。\n\n整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。\n\n那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（`select`, `poll`, `epoll`）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 `select` 和 `epoll` 两类系统调用的实现进行探究。\n\n\x3c!-- more --\x3e\n\n## SELECT \n\n`select` 是一种比较古老的系统调用方式，存在着许多的调用限制。当然，相对的也就比较容易理解。\n\n`select` 系统调用最初的逻辑就是对超时时间的相关操作，完成从用户数据段到内核数据段的数据拷贝工作，而使用 `copy_from_user` 的目的，虽然看似比较晦涩，不如大家在用户程序中普通调用的memcpy，但究其原因，是为了处理MMU相关的问题。将内核复制的数据timeval做一定的取整操作（因为硬件中断的精度可能达不到timeval所描述的粒度，故根据HZ做取整，恰好为时钟中断周期的整数倍）。调用 `core_sys_select` 进行真正的轮询操作（当然，好像也算不上真正的逻辑，还有一层核心的调用呢）。结束后的操作当然是准备更新timeval。因为进行轮询的结果有两种，一种是因为超时而结束 `core_sys_select` 函数调用；另一种是得到了一个或多个准备就绪的数据，才结束调用并返回。显然，因为第二种结果而更新timeval有着一定的实际意义——到底等待了多久。不过这里需要注意的是，不是所有的Linux系统都支持对timeval做更新。\n\n```c\nasmlinkage long sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t\tfd_set __user *exp, struct timeval __user *tvp)\n{\n\ts64 timeout = -1;\n\tstruct timeval tv;\n\tint ret;\n\n    /* 如果设置了超时时间 */\n\tif (tvp) {\n\t\tif (copy_from_user(&tv, tvp, sizeof(tv)))\n\t\t\treturn -EFAULT;\n\n        /* 计时器不能设置为负数 */\n\t\tif (tv.tv_sec < 0 || tv.tv_usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\t/* Cast to u64 to make GCC stop complaining */\n        /* 对 timeout 做一定的处理，根据时钟周期对 usec 进行取整 */\n\t\tif ((u64)tv.tv_sec >= (u64)MAX_INT64_SECONDS)\n\t\t\ttimeout = -1;\t/* 无限等待 */\n\t\telse {\n\t\t\ttimeout = DIV_ROUND_UP(tv.tv_usec, USEC_PER_SEC/HZ);\n\t\t\ttimeout += tv.tv_sec * HZ;\n\t\t}\n\t}\n\n    /* 核心的 select 实现逻辑 */\n\tret = core_sys_select(n, inp, outp, exp, &timeout);\n\n    /* 如果设置了超时时间 */\n\tif (tvp) {\n\t\tstruct timeval rtv;\n\n\t\tif (current->personality & STICKY_TIMEOUTS)\n\t\t\tgoto sticky;\n\t\trtv.tv_usec = jiffies_to_usecs(do_div((*(u64*)&timeout), HZ));\n\t\trtv.tv_sec = timeout;\n\t\tif (timeval_compare(&rtv, &tv) >= 0)\n\t\t\trtv = tv;\n        /* 内核数据->用户数据的拷贝，更新距离超时剩余的时间间隔 */\n\t\tif (copy_to_user(tvp, &rtv, sizeof(rtv))) {\nsticky:\n\t\t\t/*\n             * 如果应用程序把timeval放在只读内存中，内核就无需特别的更新它\n\t\t\t * If an application puts its timeval in read-only\n\t\t\t * memory, we don\'t want the Linux-specific update to\n\t\t\t * the timeval to cause a fault after the select has\n\t\t\t * completed successfully. However, because we\'re not\n\t\t\t * updating the timeval, we can\'t restart the system\n\t\t\t * call.\n\t\t\t */\n\t\t\tif (ret == -ERESTARTNOHAND)\n\t\t\t\tret = -EINTR;\n\t\t}\n\t}\n\n\treturn ret;\n}\n```\n\n`core_sys_select` 也没有太多核心操作，完全是在为三个位图——输入、输出、错误从用户数据段到内核数据段的拷贝工作，以及在结束 `do_select` 调用后的反向拷贝操作。不过，无论是 `sys_select` 还是 `core_sys_select` 都将各自需要完成的工作分割得非常清晰，一个完成timeval的处理工作，另一个完成位图的处理。\n\n```c\n/*\n * 内核数据-位图的准备，调用do_select完成核心的逻辑\n */\nstatic int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t\t   fd_set __user *exp, s64 *timeout)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint ret, max_fds;\n\tunsigned int size;\n\tstruct fdtable *fdt;\n    /*\n     * 在栈中定义较小的数组，减少堆内存的占用，同时可以更快；\n     * SELECT_STACK_ALLOC = 256\n     */\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tret = -EINVAL;\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n    /* max_fds 可能同时在增加，所以提前获取一份固定的拷贝避免竞争 */\n\trcu_read_lock();\n    /* 获取当前任务的文件描述符表 */\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words.\n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\t/* Not enough space in on-stack array; must use kmalloc */\n        /* 栈数组大小不足；使用 kmalloc 获取新的空间 */\n\t\tret = -ENOMEM;\n\t\tbits = kmalloc(6 * size, GFP_KERNEL);\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = bits;\n\tfds.out     = bits +   size;\n\tfds.ex      = bits + 2*size;\n\tfds.res_in  = bits + 3*size;\n\tfds.res_out = bits + 4*size;\n\tfds.res_ex  = bits + 5*size;\n\n    /* 用户数据段的数据 inp、outp、exp 往内核数据段 fds.xxx 拷贝 */\n\tif ((ret = get_fd_set(n, inp, fds.in)) ||\n\t    (ret = get_fd_set(n, outp, fds.out)) ||\n\t    (ret = get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n    /* fds.res_xxx 作为 do_select 的执行结果，预置为0，表示每一位相应的fd都未准备就绪 */\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n    /* 交由 do_select 完成真正核心的操作 */\n\tret = do_select(n, &fds, timeout);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n    /* 将结果集拷贝回用户数据段的 inp、outp、exp 中 */\n\tif (set_fd_set(n, inp, fds.res_in) ||\n\t    set_fd_set(n, outp, fds.res_out) ||\n\t    set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\n\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}\n```\n\n终于是核心的逻辑了，逐一地将当前任务挂到相应文件的等待队列上，并等待调用 `poll` 函数被唤醒\n\n```c\nint do_select(int n, fd_set_bits *fds, s64 *timeout)\n{\n\tstruct poll_wqueues table;\n\tpoll_table *wait;\n\tint retval, i;\n\n\trcu_read_lock();\n    /* 确认fds.xxx所需轮询的fd全部全部处于打开状态，同时返回最大的fd */\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\tif (retval < 0)\n\t\treturn retval;\n\tn = retval;\n\n    /* 把当前任务放入自己的等待队列中 */\n\tpoll_initwait(&table);\n\twait = &table.pt;\n    /* 如果超时时间为0，即无需等待 */\n\tif (!*timeout)\n\t\twait = NULL;\n\tretval = 0;\n    /* 无限循环 */\n\tfor (;;) {\n\t\tunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n\t\tlong __timeout;\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tinp = fds->in; outp = fds->out; exp = fds->ex;\n\t\trinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\n\n\t\tfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\n\t\t\tunsigned long in, out, ex, all_bits, bit = 1, mask, j;\n\t\t\tunsigned long res_in = 0, res_out = 0, res_ex = 0;\n\t\t\tconst struct file_operations *f_op = NULL;\n\t\t\tstruct file *file = NULL;\n\n\t\t\tin = *inp++; out = *outp++; ex = *exp++;\n\t\t\tall_bits = in | out | ex;\n\t\t\tif (all_bits == 0) {\n\t\t\t\ti += __NFDBITS;\n\t\t\t\tcontinue;\n\t\t\t}\n\n            /* 对 unsigned long 的每一位进行确认 */\n\t\t\tfor (j = 0; j < __NFDBITS; ++j, ++i, bit <<= 1) {\n\t\t\t\tint fput_needed;\n                /* 超过需检测的最大的文件描述符 */\n\t\t\t\tif (i >= n)\n\t\t\t\t\tbreak;\n                /* 该 fd 无需检测，直接下一个 */\n\t\t\t\tif (!(bit & all_bits))\n\t\t\t\t\tcontinue;\n                /* 获取相应的文件实例 */\n\t\t\t\tfile = fget_light(i, &fput_needed);\n\t\t\t\tif (file) {\n\t\t\t\t\tf_op = file->f_op;\n\t\t\t\t\tmask = DEFAULT_POLLMASK;\n                    /* 对于套接字，调用的是sock_poll，在poll成功时将唤醒wait队列的任务（即把当前任务唤醒）*/\n\t\t\t\t\tif (f_op && f_op->poll)\n\t\t\t\t\t\tmask = (*f_op->poll)(file, retval ? NULL : wait);\n\t\t\t\t\tfput_light(file, fput_needed);\n\t\t\t\t\tif ((mask & POLLIN_SET) && (in & bit)) {\n\t\t\t\t\t\tres_in |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLOUT_SET) && (out & bit)) {\n\t\t\t\t\t\tres_out |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLEX_SET) && (ex & bit)) {\n\t\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t}\n\t\t\t\t}\n                /* 主动让出CPU片，等待重新调度（提前设置了最高优先级PREEMPT_ACTIVE）*/\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\tif (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\tif (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t}\n\t\twait = NULL;\n\t\tif (retval || !*timeout || signal_pending(current))\n\t\t\tbreak;\n\t\tif(table.error) {\n\t\t\tretval = table.error;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*timeout < 0) {\n\t\t\t/* Wait indefinitely */\n\t\t\t__timeout = MAX_SCHEDULE_TIMEOUT;\n\t\t} else if (unlikely(*timeout >= (s64)MAX_SCHEDULE_TIMEOUT - 1)) {\n\t\t\t/* Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in a loop */\n\t\t\t__timeout = MAX_SCHEDULE_TIMEOUT - 1;\n\t\t\t*timeout -= __timeout;\n\t\t} else {\n\t\t\t__timeout = *timeout;\n\t\t\t*timeout = 0;\n\t\t}\n        /* 进入延时唤醒状态，待定预定的超时时间 */\n\t\t__timeout = schedule_timeout(__timeout);\n\t\tif (*timeout >= 0)\n\t\t\t*timeout += __timeout;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tpoll_freewait(&table);\n\n\treturn retval;\n}\n```\n\n总结来看，`select` 完全能够支持IO多路复用。至少比用户程序自行实现轮询优秀得多。但是，也存在着一些明显的缺陷：\n\n1. 支持的文件描述符存在上限，默认是1024。\n2. 每次陷入内核态 `select` 函数之后，都需要按位遍历所有的文件描述符（无论该fd是否存在），max(fd)越大，开销越大。\n3. 每次调用 `select` 都需要将fd集合从用户态复制到内核态，max(fd)越大，开销越大。\n\n## EPOLL\n\n简单地描述过 `select` 系统调用之后，我们着重来聊一聊 `epoll` 的实现。毕竟 `select` 和 `poll` 的复杂度是 $O(N)$，而 `epoll` 只是 $O(\\log{N})$ （当然，这里对时间复杂度的比较维度不同，稍候细讲）。`epoll` 区别于传统I/O复用模型的最大特色在于：它将创建并维护一个 `eventpoll` 实例，并通过注册请 `epoll` 对新的文件描述符进行监听，这意味着数据从用户数据区到内核数据区的拷贝只有一次；相对的，传统方式在每次轮询时，都需要全量地将数据从用户数据区拷贝到内核数据区。 \n\n### `epoll_create` \n\n`epoll_create` 负责创建一个新的 `eventpoll` 实例。这里的size并没有实际意义（由于历史原因而存在），传入的参数将被忽略。看源码总是件有意思的事，这个size被描述成了检查精神健全的标志...\n\n```c\nasmlinkage long sys_epoll_create(int size)\n{\n\tint error, fd = -1;\n\tstruct eventpoll *ep;\n\tstruct inode *inode;\n\tstruct file *file;\n\n\tDNPRINTK(3, (KERN_INFO "[%p] eventpoll: sys_epoll_create(%d)\\n",\n\t\t     current, size));\n\n\t/*\n     * 精神健全检测(size)；同时建立内部数据结构 struct eventpoll\n\t */\n\terror = -EINVAL;\n\tif (size <= 0 || (error = ep_alloc(&ep)) != 0)\n\t\tgoto error_return;\n\n\t/*\n     * 创建一个新的文件描述符，文件数据结构和i节点\n\t */\n\terror = anon_inode_getfd(&fd, &inode, &file, "[eventpoll]",\n\t\t\t\t &eventpoll_fops, ep);\n\tif (error)\n\t\tgoto error_free;\n\n\tDNPRINTK(3, (KERN_INFO "[%p] eventpoll: sys_epoll_create(%d) = %d\\n",\n\t\t     current, size, fd));\n\n\treturn fd;\n\nerror_free:\n\tep_free(ep);\nerror_return:\n\tDNPRINTK(3, (KERN_INFO "[%p] eventpoll: sys_epoll_create(%d) = %d\\n",\n\t\t     current, size, error));\n\treturn error;\n}\n```\n\n![Epoll Create | Model](https://ws3.sinaimg.cn/large/006tKfTcly1g0qi7lrtgzj31eu0u075i.jpg)\n\n### `epoll_ctl`\n\n`epoll_ctl` 顾名思义——`epoll`控制器，用于增加、修改、删除监听的事件。这里 `epfd` 用于找到 `eventpoll` 实例，`fd` 表示需要监听的文件描述符，`op` 区分增删改，`event` 表示监听的具体事件描述。\n\n```c\nasmlinkage long sys_epoll_ctl(int epfd, int op, int fd,\n\t\t\t      struct epoll_event __user *event)\n{\n\tint error;\n\tstruct file *file, *tfile;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\tstruct epoll_event epds;\n\n\tDNPRINTK(3, (KERN_INFO "[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)\\n",\n\t\t     current, epfd, op, fd, event));\n\n\terror = -EFAULT;\n    /* 如果是增改操作，需要把事件描述拷贝到内核数据区; 删除操作不需要 */\n\tif (ep_op_has_event(op) &&\n\t    copy_from_user(&epds, event, sizeof(struct epoll_event)))\n\t\tgoto error_return;\n\n\t/* Get the "struct file *" for the eventpoll file */\n\terror = -EBADF;\n\tfile = fget(epfd);\n\tif (!file)\n\t\tgoto error_return;\n\n\t/* Get the "struct file *" for the target file */\n\ttfile = fget(fd);\n\tif (!tfile)\n\t\tgoto error_fput;\n\n    /* 需要监听的文件描述符必须支持文件操作 poll */\n\terror = -EPERM;\n\tif (!tfile->f_op || !tfile->f_op->poll)\n\t\tgoto error_tgt_fput;\n\n    /* 需要确保不能把epfd作为被监听的fd加入 */\n\terror = -EINVAL;\n\tif (file == tfile || !is_file_epoll(file))\n\t\tgoto error_tgt_fput;\n\n    /* \n     * 这里的文件描述符一定是指eventpoll实例对应的文件描述符\n     * 因此直接从中拿私有数据--预定义的*eventpoll\n     */\n\tep = file->private_data;\n\n\tmutex_lock(&ep->mtx);\n\n\t/*\n     * 从RB树中查找已经维护起来的监听事件\n     * 当然，必须先把这个RB树结构锁定，防止查找时结构改变\n\t */\n\tepi = ep_find(ep, tfile, fd);\n\n\terror = -EINVAL;\n\tswitch (op) {\n\tcase EPOLL_CTL_ADD:     // 新增监听\n\t\tif (!epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\n\t\t\terror = ep_insert(ep, &epds, tfile, fd);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tbreak;\n\tcase EPOLL_CTL_DEL:     // 删除监听\n\t\tif (epi)\n\t\t\terror = ep_remove(ep, epi);\n\t\telse\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\tcase EPOLL_CTL_MOD:     // 修改监听\n\t\tif (epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_modify(ep, epi, &epds);\n\t\t} else\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ep->mtx);\n\nerror_tgt_fput:\n\tfput(tfile);\nerror_fput:\n\tfput(file);\nerror_return:\n\tDNPRINTK(3, (KERN_INFO "[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d\\n",\n\t\t     current, epfd, op, fd, event, error));\n\n\treturn error;\n}\n```\n\n这里的核心操作，就是往 `eventpoll` 实例中增删改监听的事件。以 `ep_insert` 为例，先看看怎么新增监听。\n\n```c\n/* 实例化 epitem */\nif (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))\n    goto error_return;\n/* 对 epitem 实例进行初始化数据 */\nep_rb_initnode(&epi->rbn);\nINIT_LIST_HEAD(&epi->rdllink);\nINIT_LIST_HEAD(&epi->fllink);\nINIT_LIST_HEAD(&epi->pwqlist);\nepi->ep = ep;\n/* 构建struct epoll_filefd，作为rb_tree比较不同的key */\nep_set_ffd(&epi->ffd, tfile, fd);\nepi->event = *event;\nepi->nwait = 0;\nepi->next = EP_UNACTIVE_PTR;\n```\n\n接下来要接触的就是一段比较烧脑的逻辑。\n\n`poll_table` 是在 VFS 实现中相当重要的一个数据结构，用来与`poll`配合（这里的`poll`是指文件操作中的，而不是`poll()`系统调用）\n\n```c\ntypedef struct poll_table_struct {\n\tpoll_queue_proc _qproc;\n} poll_table;\n```\n\n其中`poll_queue_proc`是一个函数指针\n\n```c\ntypedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);\n```\n\n为了让 `epitem` 更方便地追踪 `poll_queue_proc`，`epoll_ctl` 中使用了一个 `ep_pqueue` 的数据结构来包装 `poll_table`。\n\n```c\n/* 使用 queue 回调函数初始化 poll table */\nepq.epi = epi;\ninit_poll_funcptr(&epq.pt, ep_ptable_queue_proc);\n```\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1g0qwphhnz0j30xa0o6aan.jpg)\n\n之后就是把这个 `poll_table` 作为钩子方法挂载到被监控的文件上\n\n```c\nrevents = tfile->f_op->poll(tfile, &epq.pt);\n```\n\n这里以 `tcp_poll` 为例，先看看这段逻辑怎么实现的。\n\n```c\nstatic unsigned int sock_poll(struct file *file, poll_table *wait)\n{\n    struct socket *sock;\n    /* 获取 struct sock 内核套接字数据结构 */\n    sock = file->private_data;\n    return sock->ops->poll(file, sock, wait);\n}\n\nunsigned int tcp_poll(struct file *file, struct socket *sock, poll_table *wait)\n{\n\tunsigned int mask;\n\tstruct sock *sk = sock->sk;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n    /*\n     * 这里将调用 poll_table *wait 维护的回调函数\n     * 将持有 eventpoll 实例的进程注册到 sk 的等待队列中\n     */\n\tpoll_wait(file, sk->sk_sleep, wait);\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn inet_csk_listen_poll(sk);\n\n    /*\n     * 这里省略了部分逻辑，主要是负责处理 struct sock 接收到的事件\n     * 处理成 mask 并返回\n     */\n    ...\n\n    return mask;\n}\n\nstatic inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)\n{\n    if (p && wait_address)\n        p->qproc(filp, wait_address, p);\n}\n```\n\n再来看看epoll定义的回调函数的实现。\n\n```c\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt)\n{\n\tstruct epitem *epi = ep_item_from_epqueue(pt);\n\tstruct eppoll_entry *pwq;\n\n\tif (epi->nwait >= 0 && (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n\t\tinit_waitqueue_func_entry(&pwq->wait, ep_poll_callback);\n\t\tpwq->whead = whead;\n\t\tpwq->base = epi;\n        /* 添加到 struct sock 等待队列队首 */\n\t\tadd_wait_queue(whead, &pwq->wait);\n\t\tlist_add_tail(&pwq->llink, &epi->pwqlist);\n\t\tepi->nwait++;\n\t} else {\n\t\t/* We have to signal that an error occurred */\n\t\tepi->nwait = -1;\n\t}\n}\n```\n\n到此为止，`ep_insert` 核心的逻辑已经介绍完毕。主要就是将当前的 `eventpoll` 实例注册到监听目标（文件描述符）的等待队列上，并注册`ep_poll_callback`作为回调函数。回调函数实现是怎样呢？\n\n```c\nstatic int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tint pwake = 0;\n\tunsigned long flags;\n    /* 获取 wait 结构维护的 epitem 实例 */\n\tstruct epitem *epi = ep_item_from_wait(wait);\n\tstruct eventpoll *ep = epi->ep;\n\n    // ... code omitted...\n    /* \n     * 把当前的 epitem 实例添加到 eventpoll 实例的就绪队列中 \n     * 这是显然的，毕竟此回调函数只有在fd准备就绪后被回调\n     */\n\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\nis_linked:\n    /* 如果 wait 结构维护的进程处于Sleeping状态，则将其唤醒并加入任务就绪队列 */\n\tif (waitqueue_active(&ep->wq))\n\t\t__wake_up_locked(&ep->wq, TASK_UNINTERRUPTIBLE |\n\t\t\t\t TASK_INTERRUPTIBLE);\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tpwake++;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&psw, &ep->poll_wait);\n\n\treturn 1;\n}\n```\n\n### `epoll_wait`\n\n处理完所有的监听事件的维护，用户程序需要通过 `epoll_wait` 与 `eventpoll` 实例进行交互，并被告知所有正在监听中的事件是否发生。由于 `epoll_wait` 的整个逻辑基本上都是在进行错误检测，此处不表。我们只关注其中的核心逻辑，即调用的 `ep_poll` 函数。\n\n```c\nstatic int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,\n\t\t   int maxevents, long timeout)\n{\n\tint res, eavail;\n\tunsigned long flags;\n\tlong jtimeout;\n\twait_queue_t wait;\n\n\t/*\n\t * Calculate the timeout by checking for the "infinite" value ( -1 )\n\t * and the overflow condition. The passed timeout is in milliseconds,\n\t * that why (t * HZ) / 1000.\n\t */\n\tjtimeout = (timeout < 0 || timeout >= EP_MAX_MSTIMEO) ?\n\t\tMAX_SCHEDULE_TIMEOUT : (timeout * HZ + 999) / 1000;\n\nretry:\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\tres = 0;\n    /* \n     * 如果 eventpoll 实例的就绪队列为空，表明有没任何监听的事件发生。\n     * 主动让进程陷入Sleeping状态，知道被 ep_poll_callback() 唤醒\n\t */\n\tif (list_empty(&ep->rdllist)) {\n\t\tinit_waitqueue_entry(&wait, current);\n\t\twait.flags |= WQ_FLAG_EXCLUSIVE;\n\t\t__add_wait_queue(&ep->wq, &wait);\n\n\t\tfor (;;) {\n\t\t\t/*\n\t\t\t * We don\'t want to sleep if the ep_poll_callback() sends us\n\t\t\t * a wakeup in between. That\'s why we set the task state\n\t\t\t * to TASK_INTERRUPTIBLE before doing the checks.\n\t\t\t */\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (!list_empty(&ep->rdllist) || !jtimeout)\n\t\t\t\tbreak;\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&ep->lock, flags);\n            /* 主动陷入Sleeping状态 */\n\t\t\tjtimeout = schedule_timeout(jtimeout);\n\t\t\tspin_lock_irqsave(&ep->lock, flags);\n\t\t}\n\t\t__remove_wait_queue(&ep->wq, &wait);\n\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\t/* Is it worth to try to dig for events ? */\n\teavail = !list_empty(&ep->rdllist);\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/*\n     * 将监听到的事件拷贝到用户空间。如果没有事件就绪且还没超时，就再抱着\n     * 希望试一次。\n\t */\n\tif (!res && eavail &&\n\t    !(res = ep_send_events(ep, events, maxevents)) && jtimeout)\n\t\tgoto retry;\n\n\treturn res;\n}\n```\n\n### Extra \n\n这部分的数据结构配合着一些胶水代码比较难以理解，最好配合着类图看看（个人使用，不一定适合各位）\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1g0rmx65dzhj324y0t8di4.jpg)\n\n## 参考\n\n1. Linux Kernel 2.6.24\n2. [The Implementation of epoll(1)](https://idndx.com/2014/09/01/the-implementation-of-epoll-1/)\n3. [The Implementation of epoll(2)](https://idndx.com/2014/09/02/the-implementation-of-epoll-2/)\n4. [The Implementation of epoll(3)](https://idndx.com/2014/09/22/the-implementation-of-epoll-3/)\n5. [The Implementation of epoll(4)](https://idndx.com/2015/07/08/the-implementation-of-epoll-4/)\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<p><a href="./2019-01-15-understand-Kernel-8/">前一篇</a>已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 <code>struct sock</code> 对象，将其逐级从网络接口层逐级提升到网络层、传输层...最终添加到接收队列 <code>sk_receive_queue</code> 中；用户进程通过 <code>read</code>、<code>recv</code>、<code>recvfrom</code> 等命令检查并获取 <code>sk_receive_queue</code> 中的数据。</p>\n<p>整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。</p>\n<p>那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（<code>select</code>, <code>poll</code>, <code>epoll</code>）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 <code>select</code> 和 <code>epoll</code> 两类系统调用的实现进行探究。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>SELECT</h2>\n<p><code>select</code> 是一种比较古老的系统调用方式，存在着许多的调用限制。当然，相对的也就比较容易理解。</p>\n<p><code>select</code> 系统调用最初的逻辑就是对超时时间的相关操作，完成从用户数据段到内核数据段的数据拷贝工作，而使用 <code>copy_from_user</code> 的目的，虽然看似比较晦涩，不如大家在用户程序中普通调用的memcpy，但究其原因，是为了处理MMU相关的问题。将内核复制的数据timeval做一定的取整操作（因为硬件中断的精度可能达不到timeval所描述的粒度，故根据HZ做取整，恰好为时钟中断周期的整数倍）。调用 <code>core_sys_select</code> 进行真正的轮询操作（当然，好像也算不上真正的逻辑，还有一层核心的调用呢）。结束后的操作当然是准备更新timeval。因为进行轮询的结果有两种，一种是因为超时而结束 <code>core_sys_select</code> 函数调用；另一种是得到了一个或多个准备就绪的数据，才结束调用并返回。显然，因为第二种结果而更新timeval有着一定的实际意义——到底等待了多久。不过这里需要注意的是，不是所有的Linux系统都支持对timeval做更新。</p>\n<pre><code class="hljs"><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">sys_select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,\n\t\t\tfd_set __user *<span class="hljs-built_in">exp</span>, struct timeval __user *tvp)</span>\n</span>{\n\ts64 timeout = <span class="hljs-number">-1</span>;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tv</span>;</span>\n\t<span class="hljs-keyword">int</span> ret;\n\n    <span class="hljs-comment">/* 如果设置了超时时间 */</span>\n\t<span class="hljs-keyword">if</span> (tvp) {\n\t\t<span class="hljs-keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="hljs-keyword">sizeof</span>(tv)))\n\t\t\t<span class="hljs-keyword">return</span> -EFAULT;\n\n        <span class="hljs-comment">/* 计时器不能设置为负数 */</span>\n\t\t<span class="hljs-keyword">if</span> (tv.tv_sec &lt; <span class="hljs-number">0</span> || tv.tv_usec &lt; <span class="hljs-number">0</span>)\n\t\t\t<span class="hljs-keyword">return</span> -EINVAL;\n\n\t\t<span class="hljs-comment">/* Cast to u64 to make GCC stop complaining */</span>\n        <span class="hljs-comment">/* 对 timeout 做一定的处理，根据时钟周期对 usec 进行取整 */</span>\n\t\t<span class="hljs-keyword">if</span> ((u64)tv.tv_sec &gt;= (u64)MAX_INT64_SECONDS)\n\t\t\ttimeout = <span class="hljs-number">-1</span>;\t<span class="hljs-comment">/* 无限等待 */</span>\n\t\t<span class="hljs-keyword">else</span> {\n\t\t\ttimeout = DIV_ROUND_UP(tv.tv_usec, USEC_PER_SEC/HZ);\n\t\t\ttimeout += tv.tv_sec * HZ;\n\t\t}\n\t}\n\n    <span class="hljs-comment">/* 核心的 select 实现逻辑 */</span>\n\tret = core_sys_select(n, inp, outp, <span class="hljs-built_in">exp</span>, &amp;timeout);\n\n    <span class="hljs-comment">/* 如果设置了超时时间 */</span>\n\t<span class="hljs-keyword">if</span> (tvp) {\n\t\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">rtv</span>;</span>\n\n\t\t<span class="hljs-keyword">if</span> (current-&gt;personality &amp; STICKY_TIMEOUTS)\n\t\t\t<span class="hljs-keyword">goto</span> sticky;\n\t\trtv.tv_usec = jiffies_to_usecs(do_div((*(u64*)&amp;timeout), HZ));\n\t\trtv.tv_sec = timeout;\n\t\t<span class="hljs-keyword">if</span> (timeval_compare(&amp;rtv, &amp;tv) &gt;= <span class="hljs-number">0</span>)\n\t\t\trtv = tv;\n        <span class="hljs-comment">/* 内核数据-&gt;用户数据的拷贝，更新距离超时剩余的时间间隔 */</span>\n\t\t<span class="hljs-keyword">if</span> (copy_to_user(tvp, &amp;rtv, <span class="hljs-keyword">sizeof</span>(rtv))) {\nsticky:\n\t\t\t<span class="hljs-comment">/*\n             * 如果应用程序把timeval放在只读内存中，内核就无需特别的更新它\n\t\t\t * If an application puts its timeval in read-only\n\t\t\t * memory, we don\'t want the Linux-specific update to\n\t\t\t * the timeval to cause a fault after the select has\n\t\t\t * completed successfully. However, because we\'re not\n\t\t\t * updating the timeval, we can\'t restart the system\n\t\t\t * call.\n\t\t\t */</span>\n\t\t\t<span class="hljs-keyword">if</span> (ret == -ERESTARTNOHAND)\n\t\t\t\tret = -EINTR;\n\t\t}\n\t}\n\n\t<span class="hljs-keyword">return</span> ret;\n}</code></pre><p><code>core_sys_select</code> 也没有太多核心操作，完全是在为三个位图——输入、输出、错误从用户数据段到内核数据段的拷贝工作，以及在结束 <code>do_select</code> 调用后的反向拷贝操作。不过，无论是 <code>sys_select</code> 还是 <code>core_sys_select</code> 都将各自需要完成的工作分割得非常清晰，一个完成timeval的处理工作，另一个完成位图的处理。</p>\n<pre><code class="hljs"><span class="hljs-comment">/*\n * 内核数据-位图的准备，调用do_select完成核心的逻辑\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">core_sys_select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,\n\t\t\t   fd_set __user *<span class="hljs-built_in">exp</span>, s64 *timeout)</span>\n</span>{\n\tfd_set_bits fds;\n\t<span class="hljs-keyword">void</span> *bits;\n\t<span class="hljs-keyword">int</span> ret, max_fds;\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fdtable</span> *<span class="hljs-title">fdt</span>;</span>\n    <span class="hljs-comment">/*\n     * 在栈中定义较小的数组，减少堆内存的占用，同时可以更快；\n     * SELECT_STACK_ALLOC = 256\n     */</span>\n\t<span class="hljs-keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>)];\n\n\tret = -EINVAL;\n\t<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)\n\t\t<span class="hljs-keyword">goto</span> out_nofds;\n\n\t<span class="hljs-comment">/* max_fds can increase, so grab it once to avoid race */</span>\n    <span class="hljs-comment">/* max_fds 可能同时在增加，所以提前获取一份固定的拷贝避免竞争 */</span>\n\trcu_read_lock();\n    <span class="hljs-comment">/* 获取当前任务的文件描述符表 */</span>\n\tfdt = files_fdtable(current-&gt;files);\n\tmax_fds = fdt-&gt;max_fds;\n\trcu_read_unlock();\n\t<span class="hljs-keyword">if</span> (n &gt; max_fds)\n\t\tn = max_fds;\n\n\t<span class="hljs-comment">/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words.\n\t */</span>\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\t<span class="hljs-keyword">if</span> (size &gt; <span class="hljs-keyword">sizeof</span>(stack_fds) / <span class="hljs-number">6</span>) {\n\t\t<span class="hljs-comment">/* Not enough space in on-stack array; must use kmalloc */</span>\n        <span class="hljs-comment">/* 栈数组大小不足；使用 kmalloc 获取新的空间 */</span>\n\t\tret = -ENOMEM;\n\t\tbits = kmalloc(<span class="hljs-number">6</span> * size, GFP_KERNEL);\n\t\t<span class="hljs-keyword">if</span> (!bits)\n\t\t\t<span class="hljs-keyword">goto</span> out_nofds;\n\t}\n\tfds.in      = bits;\n\tfds.out     = bits +   size;\n\tfds.ex      = bits + <span class="hljs-number">2</span>*size;\n\tfds.res_in  = bits + <span class="hljs-number">3</span>*size;\n\tfds.res_out = bits + <span class="hljs-number">4</span>*size;\n\tfds.res_ex  = bits + <span class="hljs-number">5</span>*size;\n\n    <span class="hljs-comment">/* 用户数据段的数据 inp、outp、exp 往内核数据段 fds.xxx 拷贝 */</span>\n\t<span class="hljs-keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||\n\t    (ret = get_fd_set(n, outp, fds.out)) ||\n\t    (ret = get_fd_set(n, <span class="hljs-built_in">exp</span>, fds.ex)))\n\t\t<span class="hljs-keyword">goto</span> out;\n    <span class="hljs-comment">/* fds.res_xxx 作为 do_select 的执行结果，预置为0，表示每一位相应的fd都未准备就绪 */</span>\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n    <span class="hljs-comment">/* 交由 do_select 完成真正核心的操作 */</span>\n\tret = do_select(n, &amp;fds, timeout);\n\n\t<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)\n\t\t<span class="hljs-keyword">goto</span> out;\n\t<span class="hljs-keyword">if</span> (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\t<span class="hljs-keyword">if</span> (signal_pending(current))\n\t\t\t<span class="hljs-keyword">goto</span> out;\n\t\tret = <span class="hljs-number">0</span>;\n\t}\n\n    <span class="hljs-comment">/* 将结果集拷贝回用户数据段的 inp、outp、exp 中 */</span>\n\t<span class="hljs-keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||\n\t    set_fd_set(n, outp, fds.res_out) ||\n\t    set_fd_set(n, <span class="hljs-built_in">exp</span>, fds.res_ex))\n\t\tret = -EFAULT;\n\nout:\n\t<span class="hljs-keyword">if</span> (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\t<span class="hljs-keyword">return</span> ret;\n}</code></pre><p>终于是核心的逻辑了，逐一地将当前任务挂到相应文件的等待队列上，并等待调用 <code>poll</code> 函数被唤醒</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, fd_set_bits *fds, s64 *timeout)</span>\n</span>{\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_wqueues</span> <span class="hljs-title">table</span>;</span>\n\tpoll_table *wait;\n\t<span class="hljs-keyword">int</span> retval, i;\n\n\trcu_read_lock();\n    <span class="hljs-comment">/* 确认fds.xxx所需轮询的fd全部全部处于打开状态，同时返回最大的fd */</span>\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\t<span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)\n\t\t<span class="hljs-keyword">return</span> retval;\n\tn = retval;\n\n    <span class="hljs-comment">/* 把当前任务放入自己的等待队列中 */</span>\n\tpoll_initwait(&amp;table);\n\twait = &amp;table.pt;\n    <span class="hljs-comment">/* 如果超时时间为0，即无需等待 */</span>\n\t<span class="hljs-keyword">if</span> (!*timeout)\n\t\twait = <span class="hljs-literal">NULL</span>;\n\tretval = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">/* 无限循环 */</span>\n\t<span class="hljs-keyword">for</span> (;;) {\n\t\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="hljs-built_in">exp</span>;\n\t\t<span class="hljs-keyword">long</span> __timeout;\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tinp = fds-&gt;in; outp = fds-&gt;out; <span class="hljs-built_in">exp</span> = fds-&gt;ex;\n\t\trinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;\n\n\t\t<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) {\n\t\t\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> in, out, ex, all_bits, bit = <span class="hljs-number">1</span>, mask, j;\n\t\t\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> res_in = <span class="hljs-number">0</span>, res_out = <span class="hljs-number">0</span>, res_ex = <span class="hljs-number">0</span>;\n\t\t\t<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">f_op</span> = <span class="hljs-title">NULL</span>;</span>\n\t\t\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span> = <span class="hljs-title">NULL</span>;</span>\n\n\t\t\tin = *inp++; out = *outp++; ex = *<span class="hljs-built_in">exp</span>++;\n\t\t\tall_bits = in | out | ex;\n\t\t\t<span class="hljs-keyword">if</span> (all_bits == <span class="hljs-number">0</span>) {\n\t\t\t\ti += __NFDBITS;\n\t\t\t\t<span class="hljs-keyword">continue</span>;\n\t\t\t}\n\n            <span class="hljs-comment">/* 对 unsigned long 的每一位进行确认 */</span>\n\t\t\t<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= <span class="hljs-number">1</span>) {\n\t\t\t\t<span class="hljs-keyword">int</span> fput_needed;\n                <span class="hljs-comment">/* 超过需检测的最大的文件描述符 */</span>\n\t\t\t\t<span class="hljs-keyword">if</span> (i &gt;= n)\n\t\t\t\t\t<span class="hljs-keyword">break</span>;\n                <span class="hljs-comment">/* 该 fd 无需检测，直接下一个 */</span>\n\t\t\t\t<span class="hljs-keyword">if</span> (!(bit &amp; all_bits))\n\t\t\t\t\t<span class="hljs-keyword">continue</span>;\n                <span class="hljs-comment">/* 获取相应的文件实例 */</span>\n\t\t\t\tfile = fget_light(i, &amp;fput_needed);\n\t\t\t\t<span class="hljs-keyword">if</span> (file) {\n\t\t\t\t\tf_op = file-&gt;f_op;\n\t\t\t\t\tmask = DEFAULT_POLLMASK;\n                    <span class="hljs-comment">/* 对于套接字，调用的是sock_poll，在poll成功时将唤醒wait队列的任务（即把当前任务唤醒）*/</span>\n\t\t\t\t\t<span class="hljs-keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll)\n\t\t\t\t\t\tmask = (*f_op-&gt;poll)(file, retval ? <span class="hljs-literal">NULL</span> : wait);\n\t\t\t\t\tfput_light(file, fput_needed);\n\t\t\t\t\t<span class="hljs-keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) {\n\t\t\t\t\t\tres_in |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t}\n\t\t\t\t\t<span class="hljs-keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) {\n\t\t\t\t\t\tres_out |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t}\n\t\t\t\t\t<span class="hljs-keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) {\n\t\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t}\n\t\t\t\t}\n                <span class="hljs-comment">/* 主动让出CPU片，等待重新调度（提前设置了最高优先级PREEMPT_ACTIVE）*/</span>\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\t<span class="hljs-keyword">if</span> (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\t<span class="hljs-keyword">if</span> (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\t<span class="hljs-keyword">if</span> (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t}\n\t\twait = <span class="hljs-literal">NULL</span>;\n\t\t<span class="hljs-keyword">if</span> (retval || !*timeout || signal_pending(current))\n\t\t\t<span class="hljs-keyword">break</span>;\n\t\t<span class="hljs-keyword">if</span>(table.error) {\n\t\t\tretval = table.error;\n\t\t\t<span class="hljs-keyword">break</span>;\n\t\t}\n\n\t\t<span class="hljs-keyword">if</span> (*timeout &lt; <span class="hljs-number">0</span>) {\n\t\t\t<span class="hljs-comment">/* Wait indefinitely */</span>\n\t\t\t__timeout = MAX_SCHEDULE_TIMEOUT;\n\t\t} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unlikely(*timeout &gt;= (s64)MAX_SCHEDULE_TIMEOUT - <span class="hljs-number">1</span>)) {\n\t\t\t<span class="hljs-comment">/* Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in a loop */</span>\n\t\t\t__timeout = MAX_SCHEDULE_TIMEOUT - <span class="hljs-number">1</span>;\n\t\t\t*timeout -= __timeout;\n\t\t} <span class="hljs-keyword">else</span> {\n\t\t\t__timeout = *timeout;\n\t\t\t*timeout = <span class="hljs-number">0</span>;\n\t\t}\n        <span class="hljs-comment">/* 进入延时唤醒状态，待定预定的超时时间 */</span>\n\t\t__timeout = schedule_timeout(__timeout);\n\t\t<span class="hljs-keyword">if</span> (*timeout &gt;= <span class="hljs-number">0</span>)\n\t\t\t*timeout += __timeout;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tpoll_freewait(&amp;table);\n\n\t<span class="hljs-keyword">return</span> retval;\n}</code></pre><p>总结来看，<code>select</code> 完全能够支持IO多路复用。至少比用户程序自行实现轮询优秀得多。但是，也存在着一些明显的缺陷：</p>\n<ol>\n<li>支持的文件描述符存在上限，默认是1024。</li>\n<li>每次陷入内核态 <code>select</code> 函数之后，都需要按位遍历所有的文件描述符（无论该fd是否存在），max(fd)越大，开销越大。</li>\n<li>每次调用 <code>select</code> 都需要将fd集合从用户态复制到内核态，max(fd)越大，开销越大。</li>\n</ol>\n<h2>EPOLL</h2>\n<p>简单地描述过 <code>select</code> 系统调用之后，我们着重来聊一聊 <code>epoll</code> 的实现。毕竟 <code>select</code> 和 <code>poll</code> 的复杂度是 $O(N)$，而 <code>epoll</code> 只是 $O(\\log{N})$ （当然，这里对时间复杂度的比较维度不同，稍候细讲）。<code>epoll</code> 区别于传统I/O复用模型的最大特色在于：它将创建并维护一个 <code>eventpoll</code> 实例，并通过注册请 <code>epoll</code> 对新的文件描述符进行监听，这意味着数据从用户数据区到内核数据区的拷贝只有一次；相对的，传统方式在每次轮询时，都需要全量地将数据从用户数据区拷贝到内核数据区。</p>\n<h3><code>epoll_create</code></h3>\n<p><code>epoll_create</code> 负责创建一个新的 <code>eventpoll</code> 实例。这里的size并没有实际意义（由于历史原因而存在），传入的参数将被忽略。看源码总是件有意思的事，这个size被描述成了检查精神健全的标志...</p>\n<pre><code class="hljs"><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">sys_epoll_create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span>\n</span>{\n\t<span class="hljs-keyword">int</span> error, fd = <span class="hljs-number">-1</span>;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span>\n\n\tDNPRINTK(<span class="hljs-number">3</span>, (KERN_INFO <span class="hljs-string">"[%p] eventpoll: sys_epoll_create(%d)\\n"</span>,\n\t\t     current, size));\n\n\t<span class="hljs-comment">/*\n     * 精神健全检测(size)；同时建立内部数据结构 struct eventpoll\n\t */</span>\n\terror = -EINVAL;\n\t<span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span> || (error = ep_alloc(&amp;ep)) != <span class="hljs-number">0</span>)\n\t\t<span class="hljs-keyword">goto</span> error_return;\n\n\t<span class="hljs-comment">/*\n     * 创建一个新的文件描述符，文件数据结构和i节点\n\t */</span>\n\terror = anon_inode_getfd(&amp;fd, &amp;inode, &amp;file, <span class="hljs-string">"[eventpoll]"</span>,\n\t\t\t\t &amp;eventpoll_fops, ep);\n\t<span class="hljs-keyword">if</span> (error)\n\t\t<span class="hljs-keyword">goto</span> error_free;\n\n\tDNPRINTK(<span class="hljs-number">3</span>, (KERN_INFO <span class="hljs-string">"[%p] eventpoll: sys_epoll_create(%d) = %d\\n"</span>,\n\t\t     current, size, fd));\n\n\t<span class="hljs-keyword">return</span> fd;\n\nerror_free:\n\tep_free(ep);\nerror_return:\n\tDNPRINTK(<span class="hljs-number">3</span>, (KERN_INFO <span class="hljs-string">"[%p] eventpoll: sys_epoll_create(%d) = %d\\n"</span>,\n\t\t     current, size, error));\n\t<span class="hljs-keyword">return</span> error;\n}</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0qi7lrtgzj31eu0u075i.jpg" alt="Epoll Create | Model"></p>\n<h3><code>epoll_ctl</code></h3>\n<p><code>epoll_ctl</code> 顾名思义——<code>epoll</code>控制器，用于增加、修改、删除监听的事件。这里 <code>epfd</code> 用于找到 <code>eventpoll</code> 实例，<code>fd</code> 表示需要监听的文件描述符，<code>op</code> 区分增删改，<code>event</code> 表示监听的具体事件描述。</p>\n<pre><code class="hljs"><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">sys_epoll_ctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">int</span> fd,\n\t\t\t      struct epoll_event __user *event)</span>\n</span>{\n\t<span class="hljs-keyword">int</span> error;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>, *<span class="hljs-title">tfile</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epds</span>;</span>\n\n\tDNPRINTK(<span class="hljs-number">3</span>, (KERN_INFO <span class="hljs-string">"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)\\n"</span>,\n\t\t     current, epfd, op, fd, event));\n\n\terror = -EFAULT;\n    <span class="hljs-comment">/* 如果是增改操作，需要把事件描述拷贝到内核数据区; 删除操作不需要 */</span>\n\t<span class="hljs-keyword">if</span> (ep_op_has_event(op) &amp;&amp;\n\t    copy_from_user(&amp;epds, event, <span class="hljs-keyword">sizeof</span>(struct epoll_event)))\n\t\t<span class="hljs-keyword">goto</span> error_return;\n\n\t<span class="hljs-comment">/* Get the "struct file *" for the eventpoll file */</span>\n\terror = -EBADF;\n\tfile = fget(epfd);\n\t<span class="hljs-keyword">if</span> (!file)\n\t\t<span class="hljs-keyword">goto</span> error_return;\n\n\t<span class="hljs-comment">/* Get the "struct file *" for the target file */</span>\n\ttfile = fget(fd);\n\t<span class="hljs-keyword">if</span> (!tfile)\n\t\t<span class="hljs-keyword">goto</span> error_fput;\n\n    <span class="hljs-comment">/* 需要监听的文件描述符必须支持文件操作 poll */</span>\n\terror = -EPERM;\n\t<span class="hljs-keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)\n\t\t<span class="hljs-keyword">goto</span> error_tgt_fput;\n\n    <span class="hljs-comment">/* 需要确保不能把epfd作为被监听的fd加入 */</span>\n\terror = -EINVAL;\n\t<span class="hljs-keyword">if</span> (file == tfile || !is_file_epoll(file))\n\t\t<span class="hljs-keyword">goto</span> error_tgt_fput;\n\n    <span class="hljs-comment">/* \n     * 这里的文件描述符一定是指eventpoll实例对应的文件描述符\n     * 因此直接从中拿私有数据--预定义的*eventpoll\n     */</span>\n\tep = file-&gt;private_data;\n\n\tmutex_lock(&amp;ep-&gt;mtx);\n\n\t<span class="hljs-comment">/*\n     * 从RB树中查找已经维护起来的监听事件\n     * 当然，必须先把这个RB树结构锁定，防止查找时结构改变\n\t */</span>\n\tepi = ep_find(ep, tfile, fd);\n\n\terror = -EINVAL;\n\t<span class="hljs-keyword">switch</span> (op) {\n\t<span class="hljs-keyword">case</span> EPOLL_CTL_ADD:     <span class="hljs-comment">// 新增监听</span>\n\t\t<span class="hljs-keyword">if</span> (!epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\n\t\t\terror = ep_insert(ep, &amp;epds, tfile, fd);\n\t\t} <span class="hljs-keyword">else</span>\n\t\t\terror = -EEXIST;\n\t\t<span class="hljs-keyword">break</span>;\n\t<span class="hljs-keyword">case</span> EPOLL_CTL_DEL:     <span class="hljs-comment">// 删除监听</span>\n\t\t<span class="hljs-keyword">if</span> (epi)\n\t\t\terror = ep_remove(ep, epi);\n\t\t<span class="hljs-keyword">else</span>\n\t\t\terror = -ENOENT;\n\t\t<span class="hljs-keyword">break</span>;\n\t<span class="hljs-keyword">case</span> EPOLL_CTL_MOD:     <span class="hljs-comment">// 修改监听</span>\n\t\t<span class="hljs-keyword">if</span> (epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_modify(ep, epi, &amp;epds);\n\t\t} <span class="hljs-keyword">else</span>\n\t\t\terror = -ENOENT;\n\t\t<span class="hljs-keyword">break</span>;\n\t}\n\tmutex_unlock(&amp;ep-&gt;mtx);\n\nerror_tgt_fput:\n\tfput(tfile);\nerror_fput:\n\tfput(file);\nerror_return:\n\tDNPRINTK(<span class="hljs-number">3</span>, (KERN_INFO <span class="hljs-string">"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d\\n"</span>,\n\t\t     current, epfd, op, fd, event, error));\n\n\t<span class="hljs-keyword">return</span> error;\n}</code></pre><p>这里的核心操作，就是往 <code>eventpoll</code> 实例中增删改监听的事件。以 <code>ep_insert</code> 为例，先看看怎么新增监听。</p>\n<pre><code class="hljs"><span class="hljs-comment">/* 实例化 epitem */</span>\n<span class="hljs-keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))\n    <span class="hljs-keyword">goto</span> error_return;\n<span class="hljs-comment">/* 对 epitem 实例进行初始化数据 */</span>\nep_rb_initnode(&amp;epi-&gt;rbn);\nINIT_LIST_HEAD(&amp;epi-&gt;rdllink);\nINIT_LIST_HEAD(&amp;epi-&gt;fllink);\nINIT_LIST_HEAD(&amp;epi-&gt;pwqlist);\nepi-&gt;ep = ep;\n<span class="hljs-comment">/* 构建struct epoll_filefd，作为rb_tree比较不同的key */</span>\nep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);\nepi-&gt;event = *event;\nepi-&gt;nwait = <span class="hljs-number">0</span>;\nepi-&gt;next = EP_UNACTIVE_PTR;</code></pre><p>接下来要接触的就是一段比较烧脑的逻辑。</p>\n<p><code>poll_table</code> 是在 VFS 实现中相当重要的一个数据结构，用来与<code>poll</code>配合（这里的<code>poll</code>是指文件操作中的，而不是<code>poll()</code>系统调用）</p>\n<pre><code class="hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_struct</span> {</span>\n\tpoll_queue_proc _qproc;\n} poll_table;</code></pre><p>其中<code>poll_queue_proc</code>是一个函数指针</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*poll_queue_proc)</span><span class="hljs-params">(struct file *, <span class="hljs-keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</code></pre><p>为了让 <code>epitem</code> 更方便地追踪 <code>poll_queue_proc</code>，<code>epoll_ctl</code> 中使用了一个 <code>ep_pqueue</code> 的数据结构来包装 <code>poll_table</code>。</p>\n<pre><code class="hljs"><span class="hljs-comment">/* 使用 queue 回调函数初始化 poll table */</span>\nepq.epi = epi;\ninit_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0qwphhnz0j30xa0o6aan.jpg" alt=""></p>\n<p>之后就是把这个 <code>poll_table</code> 作为钩子方法挂载到被监控的文件上</p>\n<pre><code class="hljs">revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</code></pre><p>这里以 <code>tcp_poll</code> 为例，先看看这段逻辑怎么实现的。</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sock_poll</span><span class="hljs-params">(struct file *file, poll_table *wait)</span>\n</span>{\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>;</span>\n    <span class="hljs-comment">/* 获取 struct sock 内核套接字数据结构 */</span>\n    sock = file-&gt;private_data;\n    <span class="hljs-keyword">return</span> sock-&gt;ops-&gt;poll(file, sock, wait);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tcp_poll</span><span class="hljs-params">(struct file *file, struct socket *sock, poll_table *wait)</span>\n</span>{\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask;\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span> = <span class="hljs-title">sock</span>-&gt;<span class="hljs-title">sk</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcp_sock</span> *<span class="hljs-title">tp</span> = <span class="hljs-title">tcp_sk</span>(<span class="hljs-title">sk</span>);</span>\n\n    <span class="hljs-comment">/*\n     * 这里将调用 poll_table *wait 维护的回调函数\n     * 将持有 eventpoll 实例的进程注册到 sk 的等待队列中\n     */</span>\n\tpoll_wait(file, sk-&gt;sk_sleep, wait);\n\t<span class="hljs-keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN)\n\t\t<span class="hljs-keyword">return</span> inet_csk_listen_poll(sk);\n\n    <span class="hljs-comment">/*\n     * 这里省略了部分逻辑，主要是负责处理 struct sock 接收到的事件\n     * 处理成 mask 并返回\n     */</span>\n    ...\n\n    <span class="hljs-keyword">return</span> mask;\n}\n\n<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">poll_wait</span><span class="hljs-params">(struct file * filp, <span class="hljs-keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span>\n</span>{\n    <span class="hljs-keyword">if</span> (p &amp;&amp; wait_address)\n        p-&gt;qproc(filp, wait_address, p);\n}</code></pre><p>再来看看epoll定义的回调函数的实现。</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ep_ptable_queue_proc</span><span class="hljs-params">(struct file *file, <span class="hljs-keyword">wait_queue_head_t</span> *whead,\n\t\t\t\t poll_table *pt)</span>\n</span>{\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> = <span class="hljs-title">ep_item_from_epqueue</span>(<span class="hljs-title">pt</span>);</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eppoll_entry</span> *<span class="hljs-title">pwq</span>;</span>\n\n\t<span class="hljs-keyword">if</span> (epi-&gt;nwait &gt;= <span class="hljs-number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n\t\tinit_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);\n\t\tpwq-&gt;whead = whead;\n\t\tpwq-&gt;base = epi;\n        <span class="hljs-comment">/* 添加到 struct sock 等待队列队首 */</span>\n\t\tadd_wait_queue(whead, &amp;pwq-&gt;wait);\n\t\tlist_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);\n\t\tepi-&gt;nwait++;\n\t} <span class="hljs-keyword">else</span> {\n\t\t<span class="hljs-comment">/* We have to signal that an error occurred */</span>\n\t\tepi-&gt;nwait = <span class="hljs-number">-1</span>;\n\t}\n}</code></pre><p>到此为止，<code>ep_insert</code> 核心的逻辑已经介绍完毕。主要就是将当前的 <code>eventpoll</code> 实例注册到监听目标（文件描述符）的等待队列上，并注册<code>ep_poll_callback</code>作为回调函数。回调函数实现是怎样呢？</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ep_poll_callback</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *wait, <span class="hljs-keyword">unsigned</span> mode, <span class="hljs-keyword">int</span> sync, <span class="hljs-keyword">void</span> *key)</span>\n</span>{\n\t<span class="hljs-keyword">int</span> pwake = <span class="hljs-number">0</span>;\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;\n    <span class="hljs-comment">/* 获取 wait 结构维护的 epitem 实例 */</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> = <span class="hljs-title">ep_item_from_wait</span>(<span class="hljs-title">wait</span>);</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span> = <span class="hljs-title">epi</span>-&gt;<span class="hljs-title">ep</span>;</span>\n\n    <span class="hljs-comment">// ... code omitted...</span>\n    <span class="hljs-comment">/* \n     * 把当前的 epitem 实例添加到 eventpoll 实例的就绪队列中 \n     * 这是显然的，毕竟此回调函数只有在fd准备就绪后被回调\n     */</span>\n\tlist_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);\n\nis_linked:\n    <span class="hljs-comment">/* 如果 wait 结构维护的进程处于Sleeping状态，则将其唤醒并加入任务就绪队列 */</span>\n\t<span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))\n\t\t__wake_up_locked(&amp;ep-&gt;wq, TASK_UNINTERRUPTIBLE |\n\t\t\t\t TASK_INTERRUPTIBLE);\n\t<span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))\n\t\tpwake++;\n\nout_unlock:\n\tspin_unlock_irqrestore(&amp;ep-&gt;lock, flags);\n\n\t<span class="hljs-comment">/* We have to call this outside the lock */</span>\n\t<span class="hljs-keyword">if</span> (pwake)\n\t\tep_poll_safewake(&amp;psw, &amp;ep-&gt;poll_wait);\n\n\t<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;\n}</code></pre><h3><code>epoll_wait</code></h3>\n<p>处理完所有的监听事件的维护，用户程序需要通过 <code>epoll_wait</code> 与 <code>eventpoll</code> 实例进行交互，并被告知所有正在监听中的事件是否发生。由于 <code>epoll_wait</code> 的整个逻辑基本上都是在进行错误检测，此处不表。我们只关注其中的核心逻辑，即调用的 <code>ep_poll</code> 函数。</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ep_poll</span><span class="hljs-params">(struct eventpoll *ep, struct epoll_event __user *events,\n\t\t   <span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">long</span> timeout)</span>\n</span>{\n\t<span class="hljs-keyword">int</span> res, eavail;\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;\n\t<span class="hljs-keyword">long</span> jtimeout;\n\t<span class="hljs-keyword">wait_queue_t</span> wait;\n\n\t<span class="hljs-comment">/*\n\t * Calculate the timeout by checking for the "infinite" value ( -1 )\n\t * and the overflow condition. The passed timeout is in milliseconds,\n\t * that why (t * HZ) / 1000.\n\t */</span>\n\tjtimeout = (timeout &lt; <span class="hljs-number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?\n\t\tMAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="hljs-number">999</span>) / <span class="hljs-number">1000</span>;\n\nretry:\n\tspin_lock_irqsave(&amp;ep-&gt;lock, flags);\n\n\tres = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">/* \n     * 如果 eventpoll 实例的就绪队列为空，表明有没任何监听的事件发生。\n     * 主动让进程陷入Sleeping状态，知道被 ep_poll_callback() 唤醒\n\t */</span>\n\t<span class="hljs-keyword">if</span> (list_empty(&amp;ep-&gt;rdllist)) {\n\t\tinit_waitqueue_entry(&amp;wait, current);\n\t\twait.flags |= WQ_FLAG_EXCLUSIVE;\n\t\t__add_wait_queue(&amp;ep-&gt;wq, &amp;wait);\n\n\t\t<span class="hljs-keyword">for</span> (;;) {\n\t\t\t<span class="hljs-comment">/*\n\t\t\t * We don\'t want to sleep if the ep_poll_callback() sends us\n\t\t\t * a wakeup in between. That\'s why we set the task state\n\t\t\t * to TASK_INTERRUPTIBLE before doing the checks.\n\t\t\t */</span>\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t<span class="hljs-keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)\n\t\t\t\t<span class="hljs-keyword">break</span>;\n\t\t\t<span class="hljs-keyword">if</span> (signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\t<span class="hljs-keyword">break</span>;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&amp;ep-&gt;lock, flags);\n            <span class="hljs-comment">/* 主动陷入Sleeping状态 */</span>\n\t\t\tjtimeout = schedule_timeout(jtimeout);\n\t\t\tspin_lock_irqsave(&amp;ep-&gt;lock, flags);\n\t\t}\n\t\t__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);\n\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\t<span class="hljs-comment">/* Is it worth to try to dig for events ? */</span>\n\teavail = !list_empty(&amp;ep-&gt;rdllist);\n\n\tspin_unlock_irqrestore(&amp;ep-&gt;lock, flags);\n\n\t<span class="hljs-comment">/*\n     * 将监听到的事件拷贝到用户空间。如果没有事件就绪且还没超时，就再抱着\n     * 希望试一次。\n\t */</span>\n\t<span class="hljs-keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;\n\t    !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)\n\t\t<span class="hljs-keyword">goto</span> retry;\n\n\t<span class="hljs-keyword">return</span> res;\n}</code></pre><h3>Extra</h3>\n<p>这部分的数据结构配合着一些胶水代码比较难以理解，最好配合着类图看看（个人使用，不一定适合各位）</p>\n<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0rmx65dzhj324y0t8di4.jpg" alt=""></p>\n<h2>参考</h2>\n<ol>\n<li>Linux Kernel 2.6.24</li>\n<li><a href="https://idndx.com/2014/09/01/the-implementation-of-epoll-1/">The Implementation of epoll(1)</a></li>\n<li><a href="https://idndx.com/2014/09/02/the-implementation-of-epoll-2/">The Implementation of epoll(2)</a></li>\n<li><a href="https://idndx.com/2014/09/22/the-implementation-of-epoll-3/">The Implementation of epoll(3)</a></li>\n<li><a href="https://idndx.com/2015/07/08/the-implementation-of-epoll-4/">The Implementation of epoll(4)</a></li>\n</ol>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2019-03-05-understand-Kernel-9.json",ext:".json",sourceBase:"2019-03-05-understand-Kernel-9.md",sourceExt:".md"}},fuPZ:function(n){n.exports={title:"理解 Linux Kernel (1) - BIOS",author:"fangfeng",date:"2018-08-19T00:00:00.000Z",tags:["Linux","Kernel","BIOS"],bodyContent:'## 前言\n\n在[概述](https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/)，我想我已经介绍过我开始这一些列博文的原因。\n我不能担保我所进行的所有试验性操作都是对的，但是，至少这些在我所描述的环境下成功的运行了起来，并帮助我触及我始终敬畏而又敬而远之的**硬件&OS**\n\n在《Linux内核完全注释》一书第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，并最终通过 Bochs 仿真器在模拟开机通电后，BIOS Load \nboot 程序，通过显示器输出 *Loading System...* 。\n\n这些，将是这里所要描述的主要内容。\n\n\x3c!-- more --\x3e\n\n## boot.s 汇编程序\n\n这里没法多说，都是书中的源码，只是供未读过书的读者参考，特意摘录了下来(不过，就不加注释了)\n\nboot.s 源代码\n\n```asm\n.global begtext, begdata, begbss, endtext, enddata, endbss\n.text\nbegtext:\n.data\nbegdata:\n.bss\nbegbss:\n.text\nBOOTSEG=0x07c0\n\nentry start\nstart:\n    jmpi    go,BOOTSEG\ngo: mov ax,cs\n    mov ds,ax\n    mov es,ax\n    mov [msg+17],ah\n    mov cx,#20\n    mov dx,#0x1004\n    mov bx,#0x000c\n    mov bp,#msg\n    mov ax,#0x1301\n    int 0x10\nloop1:  jmp loop1\nmsg:    .ascii  "Loading System..."\n        .byte   13,10\n.org    510\n.word   0xAA55\n.text\nendtext:\n.data\nenddata:\n.bss\nendbss:\n```\n\n这段程序的主要的执行流程将是:\n\n1. 通过 BIOS 加载这段 boot 引导程序\n2. 红色字体打印 *Loading System...* 并响铃\n3. 指令自循环 (`loop1 jmp loop1`) ，将始终展示上述字样，并不接收命令\n\n下面就该把这个汇编程序 *编译 + 链接* 成 boot 引导程序。\n\n虽然在 macOS 上确实找到了一个 as86 汇编器(来自 nasm 的一个编译选项，但我不知道为什么始终无法正常编译，也可能这个根本就不是我想要的)。\n\n通过 docker 容器部署的 Ubuntu，可以很容易地得到一个 as86 汇编程序。\n\n```sh\napt-get install bin86   # as86, ld86 都在这个包里提供了\n\n# 这句需要在宿主机上执行\ndocker cp boot.s linux:/root/boot.s     # 这里 linux 是我 docker 部署的 Ubuntu 的容器的名称。   如果之前 boot.s 在宿主机上，可以这样拷贝到容器中\n\nas86 -0 -a -o boot.o boot.s             # 编译\n\nld86 -0 -s -o execfile boot.o           # 链接\n\n# 当然，到这里为止，其实都可以理解成在将汇编代码编译链接成可执行程序 (和 boot 引导程序没有太大关系，唯一有关系的就是这段汇编语言是以引导为目的写的)\n\ndd bs=32 if=execfile of=boot skip=1     # 这里去掉可执行程序的前 32 字节，形成刚好 512 字节的 boot 引导程序\n```\n\n## 用仿真器启动引导程序\n\n事实上，这部分内容，我始终没有搞清楚 **磁盘映像文件** 和 **boot 引导程序** 间的关系(当然还有 floppy 和 ata0~3)\n\n在上一节成功拿到 *512B* 的 boot 引导程序之后，直接使用这个貌似我也运行成功了(根本就不需要创建磁盘映像文件并将引导程序写入映像文件中，不过，也许只是因为这个引导程序太简单了，根本就不需要其他程序的配合。它最后就是一个死循环 )\n\n总之，先按照最简单的来吧。\n\n把 boot 引导程序拷贝到宿主机上(貌似频繁地在两个OS上交互文件，这个很无奈，docker容器中的进程难以启动显示程序)\n\n1. 在宿主机新建一个目录 *linux-boot*\n2. 拷贝 boot 引导程序到宿主机上 `docker cp linux:/root/boot linux-boot/`\n3. 在 *linux-boot* 下建立 bochsrc 文件(这将是整个仿真器的配置，用于模拟组装机器涉及的 CPU, 内存, BIOS, 显示器等)\n4. 这里使用的配置文件如下:\n\n```rc\n# You may now use double quotes around pathnames, in case\n# your pathname includes spaces.\n\ncpu: model=pentium, count=1, ips=50000000, reset_on_triple_fault=1, ignore_bad_msrs=1, msrs="msrs.def"\ncpu: cpuid_limit_winnt=0\n\nmemory: guest=512, host=256\n\nromimage: file=$BXSHARE/BIOS-bochs-legacy, options=fastboot     # BIOS 配置\n\nvgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest\n\nmouse: enabled=0\n\npci: enabled=1, chipset=i440fx\n\nprivate_colormap: enabled=0\n\nfloppya: 1\\_44="./boot", status=inserted         # 装载一个软盘 A ，这里用当前目录下的 boot (boot 引导程序，事实上书中说要用 .img 磁盘映像文件，但这里不影响实际效果)\n\nata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14\nata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15\nata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11\nata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9\n\nboot: a                                         # 配置引导程序所在的磁盘\n\nfloppy_bootsig_check: disabled=0\n\nlog: bochsout.txt\n\npanic: action=ask\nerror: action=report\ninfo: action=report\ndebug: action=ignore, pci=report # report BX_DEBUG from module \'pci\'\n\ndebugger_log: -\n\nparport1: enabled=1, file="parport.out"\n\nspeaker: enabled=1, mode=sound\n```\n\n5. 当前目录 *linux-boot* 下，键入命令 `bochs`\n6. 由于读取到 *bochsrc* 配置文件的存在，menu 的默认选项为 6 (开始模拟机器)\n\n```plain\nYou can also start bochs with the -q option to skip these menus.\n\n1. Restore factory default configuration\n2. Read options from...\n3. Edit options\n4. Save options to...\n5. Restore the Bochs state from...\n6. Begin simulation\n7. Quit now\n\nPlease choose one: [6]\n```\n\n7. 直接开始运行机器，键入命令 `c` (这部分在 [概述](https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/) 有过了描述，以后将不再描述)\n\n```plain\nPlease choose one: [6]\n00000000000i[      ] lt_dlhandle is 0x7f85d0405ff0\n00000000000i[PLUGIN] loaded plugin libbx_sdl2.so\n00000000000i[      ] installing sdl2 module as the Bochs GUI\n00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800\n00000000000i[      ] using log file bochsout.txt\nNext at t=0\n(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0\n<bochs:1> c\n\n```\n\n8. 观察仿真器的表现\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuf2kicsqyj313y0q0gn4.jpg)\n\nOh, YES! 成功输出了 *Loading System...* (不过响铃没有听到，可能与我没有配置 sound 有关)\n\n9. 关机\n\n无需多言，右上角模拟的就是**关机实体按键**\n\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<h2>前言</h2>\n<p>在<a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">概述</a>，我想我已经介绍过我开始这一些列博文的原因。\n我不能担保我所进行的所有试验性操作都是对的，但是，至少这些在我所描述的环境下成功的运行了起来，并帮助我触及我始终敬畏而又敬而远之的<strong>硬件&amp;OS</strong></p>\n<p>在《Linux内核完全注释》一书第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，并最终通过 Bochs 仿真器在模拟开机通电后，BIOS Load\nboot 程序，通过显示器输出 <em>Loading System...</em> 。</p>\n<p>这些，将是这里所要描述的主要内容。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>boot.s 汇编程序</h2>\n<p>这里没法多说，都是书中的源码，只是供未读过书的读者参考，特意摘录了下来(不过，就不加注释了)</p>\n<p>boot.s 源代码</p>\n<pre><code class="hljs">.global begtext, begdata, begbss, endtext, enddata, endbss\n.text\nbegtext:\n.data\nbegdata:\n.bss\nbegbss:\n.text\nBOOTSEG=0x07c0\n\nentry start\nstart:\n    jmpi    go,BOOTSEG\ngo: mov ax,cs\n    mov ds,ax\n    mov es,ax\n    mov [msg+17],ah\n    mov cx,#20\n    mov dx,#0x1004\n    mov bx,#0x000c\n    mov bp,#msg\n    mov ax,#0x1301\n    int 0x10\nloop1:  jmp loop1\nmsg:    .ascii  "Loading System..."\n        .byte   13,10\n.org    510\n.word   0xAA55\n.text\nendtext:\n.data\nenddata:\n.bss\nendbss:</code></pre><p>这段程序的主要的执行流程将是:</p>\n<ol>\n<li>通过 BIOS 加载这段 boot 引导程序</li>\n<li>红色字体打印 <em>Loading System...</em> 并响铃</li>\n<li>指令自循环 (<code>loop1 jmp loop1</code>) ，将始终展示上述字样，并不接收命令</li>\n</ol>\n<p>下面就该把这个汇编程序 <em>编译 + 链接</em> 成 boot 引导程序。</p>\n<p>虽然在 macOS 上确实找到了一个 as86 汇编器(来自 nasm 的一个编译选项，但我不知道为什么始终无法正常编译，也可能这个根本就不是我想要的)。</p>\n<p>通过 docker 容器部署的 Ubuntu，可以很容易地得到一个 as86 汇编程序。</p>\n<pre><code class="hljs">apt-get install bin86   <span class="hljs-comment"># as86, ld86 都在这个包里提供了</span>\n\n<span class="hljs-comment"># 这句需要在宿主机上执行</span>\ndocker cp boot.s linux:/root/boot.s     <span class="hljs-comment"># 这里 linux 是我 docker 部署的 Ubuntu 的容器的名称。   如果之前 boot.s 在宿主机上，可以这样拷贝到容器中</span>\n\nas86 -0 -a -o boot.o boot.s             <span class="hljs-comment"># 编译</span>\n\nld86 -0 -s -o execfile boot.o           <span class="hljs-comment"># 链接</span>\n\n<span class="hljs-comment"># 当然，到这里为止，其实都可以理解成在将汇编代码编译链接成可执行程序 (和 boot 引导程序没有太大关系，唯一有关系的就是这段汇编语言是以引导为目的写的)</span>\n\ndd bs=32 <span class="hljs-keyword">if</span>=execfile of=boot skip=1     <span class="hljs-comment"># 这里去掉可执行程序的前 32 字节，形成刚好 512 字节的 boot 引导程序</span></code></pre><h2>用仿真器启动引导程序</h2>\n<p>事实上，这部分内容，我始终没有搞清楚 <strong>磁盘映像文件</strong> 和 <strong>boot 引导程序</strong> 间的关系(当然还有 floppy 和 ata0~3)</p>\n<p>在上一节成功拿到 <em>512B</em> 的 boot 引导程序之后，直接使用这个貌似我也运行成功了(根本就不需要创建磁盘映像文件并将引导程序写入映像文件中，不过，也许只是因为这个引导程序太简单了，根本就不需要其他程序的配合。它最后就是一个死循环 )</p>\n<p>总之，先按照最简单的来吧。</p>\n<p>把 boot 引导程序拷贝到宿主机上(貌似频繁地在两个OS上交互文件，这个很无奈，docker容器中的进程难以启动显示程序)</p>\n<ol>\n<li>在宿主机新建一个目录 <em>linux-boot</em></li>\n<li>拷贝 boot 引导程序到宿主机上 <code>docker cp linux:/root/boot linux-boot/</code></li>\n<li>在 <em>linux-boot</em> 下建立 bochsrc 文件(这将是整个仿真器的配置，用于模拟组装机器涉及的 CPU, 内存, BIOS, 显示器等)</li>\n<li>这里使用的配置文件如下:</li>\n</ol>\n<pre><code class="hljs"># You may now use double quotes around pathnames, in case\n# your pathname includes spaces.\n\ncpu: model=pentium, count=1, ips=50000000, reset_on_triple_fault=1, ignore_bad_msrs=1, msrs="msrs.def"\ncpu: cpuid_limit_winnt=0\n\nmemory: guest=512, host=256\n\nromimage: file=$BXSHARE/BIOS-bochs-legacy, options=fastboot     # BIOS 配置\n\nvgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest\n\nmouse: enabled=0\n\npci: enabled=1, chipset=i440fx\n\nprivate_colormap: enabled=0\n\nfloppya: 1\\_44="./boot", status=inserted         # 装载一个软盘 A ，这里用当前目录下的 boot (boot 引导程序，事实上书中说要用 .img 磁盘映像文件，但这里不影响实际效果)\n\nata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14\nata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15\nata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11\nata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9\n\nboot: a                                         # 配置引导程序所在的磁盘\n\nfloppy_bootsig_check: disabled=0\n\nlog: bochsout.txt\n\npanic: action=ask\nerror: action=report\ninfo: action=report\ndebug: action=ignore, pci=report # report BX_DEBUG from module \'pci\'\n\ndebugger_log: -\n\nparport1: enabled=1, file="parport.out"\n\nspeaker: enabled=1, mode=sound</code></pre><ol start="5">\n<li>当前目录 <em>linux-boot</em> 下，键入命令 <code>bochs</code></li>\n<li>由于读取到 <em>bochsrc</em> 配置文件的存在，menu 的默认选项为 6 (开始模拟机器)</li>\n</ol>\n<pre><code class="hljs">You can also start bochs with the -q option to skip these menus.\n\n1. Restore factory default configuration\n2. Read options from...\n3. Edit options\n4. Save options to...\n5. Restore the Bochs state from...\n6. Begin simulation\n7. Quit now\n\nPlease choose one: [6]</code></pre><ol start="7">\n<li>直接开始运行机器，键入命令 <code>c</code> (这部分在 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">概述</a> 有过了描述，以后将不再描述)</li>\n</ol>\n<pre><code class="hljs">Please choose one: [6]\n00000000000i[      ] lt_dlhandle is 0x7f85d0405ff0\n00000000000i[PLUGIN] loaded plugin libbx_sdl2.so\n00000000000i[      ] installing sdl2 module as the Bochs GUI\n00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800\n00000000000i[      ] using log file bochsout.txt\nNext at t=0\n(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0\n&lt;bochs:1&gt; c</code></pre><ol start="8">\n<li>观察仿真器的表现</li>\n</ol>\n<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuf2kicsqyj313y0q0gn4.jpg" alt=""></p>\n<p>Oh, YES! 成功输出了 <em>Loading System...</em> (不过响铃没有听到，可能与我没有配置 sound 有关)</p>\n<ol start="9">\n<li>关机</li>\n</ol>\n<p>无需多言，右上角模拟的就是<strong>关机实体按键</strong></p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-08-19-understand-Kernel-1.json",ext:".json",sourceBase:"2018-08-19-understand-Kernel-1.md",sourceExt:".md"}},hCSg:function(n){n.exports={title:"CGlib Enhancer 主流程源码解析",author:"fangfeng",date:"2018-07-10T00:00:00.000Z",tags:["CGlib","ASM"],bodyContent:'## 前言\n\n此博文写作的目的: \n  - (Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。\n  - 基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。\n\n\x3c!-- more --\x3e\n\n## Enhancer\n\n从这篇不是官方但更胜于官方文档的 [CGlib Guide](http://mydailyjava.blogspot.com/2013/11/cglib-missing-manual.html) 来看，它首先提到的第一个类就是 Enhancer。\n其被用于创建 Java 代理类，相较于 Java 标准库的 Proxy 类，它**特别地**，能够支持那些没有实现接口的类的代理工作。\n\n### Enhancer 简单示例展示\n\n针对现有的 SampleClass 类\n```java\npublic class SampleClass {\n    public String test(String input) {\n        return "Hello World!";\n    }\n}\n```\n\n使用 CGlib 的 Enhancer 对 SampleClass 进行增强，下列操作的目的在于将 test(String) 方法的返回值改写成 "Hello cglib!"\n\n```java\n@Test\npublic void testFixedValue() {\n    // new 一个 Enhancer 实例\n    Enhancer enhancer = new Enhancer();\n    // 声明使用的父类是 SampleClass\n    enhancer.setSuperclass(SampleClass.class);\n    // 设置回调方法 - 回调方法实现为 FixedValue (固定值) .\n    enhancer.setCallback(new FixedValue() {\n        public Object loadObject() throws Exception {\n            return "Hello cglib!";\n        }\n    });\n    // 创建 SampleClass 的代理子类实例\n    SampleClass proxy = (SampleClass) enhancer.create();\n    Assert.assertEquals("Hello cglib!", proxy.test(null));\n}\n```\n\n简单测试上述代码，可以了解到确实，代理类的 test(String) 方法的返回值被改写了。\n那么，究竟这种操作是如何实现的？下面👇将进行具体的探究。\n\n## 调用链跟踪\n\n### 高度抽象的时序图\n\n![Enhancer 调用链 时序图](https://ws4.sinaimg.cn/large/006tKfTcgy1ft4ifuo997j31jh0st42t.jpg)\n\n*下列内容将根据时序图进行组织，根据调用编号(1,2,3...)进行展开*\n\n### Seq 1.\n\n```java\npublic Object create() {\n    classOnly = false;\n    argumentTypes = null;\n    return createHelper();\n}\n\npublic Object create(Class[] argumentTypes, Object[] arguments) {\n    classOnly = false;\n    if (argumentTypes == null || arguments == null || argumentTypes.length != arguments.length) {\n        throw new IllegalArgumentException("Arguments must be non-null and of equal length");\n    }\n    this.argumentTypes = argumentTypes;\n    this.arguments = arguments;\n    return createHelper();\n}\n```\n\n上述两个 `create(...)` 方法。结合上一节的使用示例，可以看到 `create()` 对应的**无参构造**。\n存在无参构造，那么**有参的构造方法**显然也是应该被支持id。`create(Class[], Object[])` 正是为了这个目标而存在。通过提供参数类型数组和参数实例数组，可以唯一地定位及调用代理类的特定构造方法。\n\n这个方法比较简单，只是将 Enhancer 作为一个数据内容的持有者，重置了新代理类将使用的构造函数参数内容，之后就直接调用了 `createHelper()` 。\n\n### Seq 2.\n\n```java\nprivate Object createHelper() {\n    // 对预声明的回调方法进行验证，要求 [多个回调就必须存在 CallbackFilter 作为调度器]\n    preValidate();\n    // 构建一个对这类增强操作唯一定位的 key\n    Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,\n            ReflectUtils.getNames(interfaces),\n            filter == ALL_ZERO ? null : new WeakCacheKey<CallbackFilter>(filter),\n            callbackTypes,\n            useFactory,\n            interceptDuringConstruction,\n            serialVersionUID);\n    this.currentKey = key;\n    // 调用父类通过的 create(...) 方法\n    Object result = super.create(key);\n    return result;\n}\n```\n\n### Seq 3.\n\n```java\nprotected Object create(Object key) {\n    try {\n        // 获取用于 加载 生成类 的 ClassLoader\n        ClassLoader loader = getClassLoader();\n        // 从缓存中加载 这个 ClassLoader 过去加载的相关数据\n        Map<ClassLoader, ClassLoaderData> cache = CACHE;\n        ClassLoaderData data = cache.get(loader);\n        // 如果在 缓存 中找不到，则初始化构造关于这个 ClassLoader 的数据实例\n        if (data == null) {\n            // 同步\n            synchronized (AbstractClassGenerator.class) {\n                // 进入同步块后的 再次确认，避免重复初始化构建\n                cache = CACHE;\n                data = cache.get(loader);\n                if (data == null) {\n                    // 构建新的 缓存，拷贝原有的缓存集的内容\n                    Map<ClassLoader, ClassLoaderData> newCache = new WeakHashMap<ClassLoader, ClassLoaderData>(cache);\n                    // 初始化 ClassLoaderData ，真正的构造操作\n                    data = new ClassLoaderData(loader);\n                    // 添加到缓存中\n                    newCache.put(loader, data);\n                    CACHE = newCache;\n                }\n            }\n        }\n        this.key = key;\n        Object obj = data.get(this, getUseCache());\n        if (obj instanceof Class) {\n            // 初次实例化操作，就是 Class 利用反射来进行实例化\n            return firstInstance((Class) obj);\n        }\n        // 非初次实例化，则是从 ClassLoaderData 中得到的之前维护的内容\n        return nextInstance(obj);\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (Error e) {\n        throw e;\n    } catch (Exception e) {\n        throw new CodeGenerationException(e);\n    }\n}\n```\n\n这部分内容比较多，且是调用链比较重要的一环。**Seq 4.** 和 **Seq 5.** 将作为其子内容进行调用，但为了本博文的结构完整， *Seq 4. & Seq5.* 的标题与 *Seq 3.* 标题同级\n\n### Seq 4. \n\n首先应该认识到，每个被加载的 Class ，在 `equal` 的判断过程中，依据的是同一个 ClassLoader 加载的同一 Class 才被认为是相同的，否则即使 Class 是同一个，但仍会被认为是不同的(由不同的 ClassLoader 加载)。\n\n```java\npublic ClassLoader getClassLoader() {\n    ClassLoader t = classLoader;\n    if (t == null) {\n        t = getDefaultClassLoader();\n    }\n    if (t == null) {\n        t = getClass().getClassLoader();\n    }\n    if (t == null) {\n        t = Thread.currentThread().getContextClassLoader();\n    }\n    if (t == null) {\n        throw new IllegalStateException("Cannot determine classloader");\n    }\n    return t;\n}\n```\n\n因此，在这部分中，首先需要确定的是由哪个 ClassLoader 进行加载的工作。`getClassLoader()` 的确定顺序是:\n\n1. 具体实现类声明的 **默认 ClassLoader** 为第一优先级\n2. 加载当前类(这里是 Enhancer) 的 ClassLoader 为第二优先级\n3. **当前线程上下文 ClassLoader** 为第三优先级\n4. 抛出异常\n\n回到 **Seq 3.** 的内容，\n下一步是对当前这个**AbstractClassGenerator** 维护的 CACHE 进行处理，如果在 CACHE 中能够得到以确定的 ClassLoader 为 Key 的键值对，则直接获取 ClassLoader 对应的值，否则将进行初始化构建一个新的 ClassLoaderData 作为这个 ClassLoader 的值。\n\n### Seq 5.\n在构建 ClassLoaderData 的过程中，最重要的一步:\n\n```java\npublic ClassLoaderData(ClassLoader classLoader) {\n    // ClassLoader 不可为空\n    if (classLoader == null) {\n        throw new IllegalArgumentException("classLoader == null is not yet supported");\n    }\n    // 构建 ClassLoader 的弱引用\n    this.classLoader = new WeakReference<ClassLoader>(classLoader);\n    // 写了个后置调用的函数，用于懒加载，只有调用了 load.apply(...) 才会构建 生成类\n    Function<AbstractClassGenerator, Object> load =\n            new Function<AbstractClassGenerator, Object>() {\n                public Object apply(AbstractClassGenerator gen) {\n                    Class klass = gen.generate(ClassLoaderData.this);\n                    return gen.wrapCachedClass(klass);\n                }\n            };\n    generatedClasses = new LoadingCache<AbstractClassGenerator, Object, Object>(GET_KEY, load);\n}\n```\n\n构建了一个 Function 实例，这个 Function 作为函数式接口，预定义执行的具体流程，但由上下文确定具体的调用时刻。\n\n### Seq 6.\n\n在正确得到了 ClassLoader 对应的 ClassLoaderData 之后，ClassLoaderData 的 `get(...)` 方法将在特定的 ClassLoader 之下，进行更具体的加载新生成类的工作。\n当然，这里的前提是新的生成类的字节码已经被构建:)\n\n```java\npublic Object get(AbstractClassGenerator gen, boolean useCache) {\n    // 标记为不使用缓存，直接构建 新的生成类\n    if (!useCache) {\n      return gen.generate(ClassLoaderData.this);\n    }\n    // 使用缓冲的情况\n    else {\n      Object cachedValue = generatedClasses.get(gen);\n      return gen.unwrapCachedValue(cachedValue);\n    }\n}\n```\n\n可以看到 `gen.generate(ClassLoaderData.this)` 这段代码在 `get(...)` 方法和上一小节 `ClassLoaderData(...)` 构造方法的 Function 函数式实例都出现了。\n\n实际上，这也是触发 ClassLoader 来加载动态生成的新 Class 的唯一入口。\n\n*判断逻辑* 的 `else` 内容的唯一区别就在于其构建的是一个加载缓存，将真正触发 gen.generate(ClassLoaderData.this) 的逻辑延迟。(不过，最终也还是会进行调用的，:) 这是毋庸置疑的)。\n\n### Seq 7.\n\n```java\nprotected Class generate(ClassLoaderData data) {\n    Class gen;\n    Object save = CURRENT.get();\n    CURRENT.set(this);\n    try {\n        // 拿到用于加载生成类的 ClassLoader\n        ClassLoader classLoader = data.getClassLoader();\n        if (classLoader == null) {\n            throw new IllegalStateException("ClassLoader is null while trying to define class " +\n                    getClassName() + ". It seems that the loader has been expired from a weak reference somehow. " +\n                    "Please file an issue at cglib\'s issue tracker.");\n        }\n        // 构建一个合法的 生成类 的类名(非重复)\n        synchronized (classLoader) {\n          String name = generateClassName(data.getUniqueNamePredicate());\n          data.reserveName(name);\n          this.setClassName(name);\n        }\n        if (attemptLoad) {\n            try {\n                // 尝试直接通过 ClassLoader 进行加载\n                gen = classLoader.loadClass(getClassName());\n                return gen;\n            } catch (ClassNotFoundException e) {\n                // ignore\n            }\n        }\n        // 策略下的生成类构建方法\n        byte[] b = strategy.generate(this);\n        // 通过解析字节码的形式获取 生成类的 className\n        String className = ClassNameReader.getClassName(new ClassReader(b));\n        ProtectionDomain protectionDomain = getProtectionDomain();\n        synchronized (classLoader) { // just in case\n            // 反射的形式加载 Class 类\n            if (protectionDomain == null) {\n                gen = ReflectUtils.defineClass(className, b, classLoader);\n            } else {\n                gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);\n            }\n        }\n        return gen;\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (Error e) {\n        throw e;\n    } catch (Exception e) {\n        throw new CodeGenerationException(e);\n    } finally {\n        CURRENT.set(save);\n    }\n}\n```\n\n这个方法，就是操作字节码，加载 Class 的核心调度方法。\n\n可以看到 `generateClassName(...)` 方法将构建一个当前 ClassLoader 下唯一, 不重复的新的类名。\n\n`strategy.generate(this)` 将通过特定策略实现的形式生成新的字节码\n\n`ReflectUtils.defineClass(className, b, classLoader)` 将使用反射使得 ClassLoader 来加载这个新的生成类。\n\n### Seq 8.\n\n生成新的不重复类名这部分不做过多陈述，可以简单进行了解，并熟悉 CGlib 默认的新类名的命名规则\n\n```java\n// DefaultNamePolicy\npublic String getClassName(String prefix, String source, Object key, Predicate names) {\n    if (prefix == null) {\n        prefix = "net.sf.cglib.empty.Object";\n    } else if (prefix.startsWith("java")) {\n        prefix = "$" + prefix;\n    }\n    String base =\n        prefix + "$$" +\n        source.substring(source.lastIndexOf(\'.\') + 1) +\n        getTag() + "$$" +\n        Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\n    String attempt = base;\n    int index = 2;\n    while (names.evaluate(attempt))\n        attempt = base + "_" + index++;\n    return attempt;\n}\n```\n\n### Seq 9.\n\n```java\n// 下列是 DefaultGeneratorStrategy 的实现\npublic byte[] generate(ClassGenerator cg) throws Exception {\n    DebuggingClassWriter cw = getClassVisitor();\n    transform(cg).generateClass(cw);\n    return transform(cw.toByteArray());\n}\n```\n\n### Seq 10.\n\n调用 `generateClass(ClassVisitor)` 将获得到新类的字节码。\n\n```java\npublic void generateClass(ClassVisitor v) throws Exception {\n    // 确定生成类的 父类\n    Class sc = (superclass == null) ? Object.class : superclass;\n\n    // 父类标识符不可以为 final\n    if (TypeUtils.isFinal(sc.getModifiers()))\n        throw new IllegalArgumentException("Cannot subclass final class " + sc.getName());\n    // 获取父类直接声明的构造方法\n    List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));\n    filterConstructors(sc, constructors);\n\n    // Order is very important: must add superclass, then\n    // its superclass chain, then each interface and\n    // its superinterfaces.\n    List actualMethods = new ArrayList();\n    List interfaceMethods = new ArrayList();\n    final Set forcePublic = new HashSet();\n    // 从父类中提取各种信息\n    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);\n\n    List methods = CollectionUtils.transform(actualMethods, new Transformer() {\n        public Object transform(Object value) {\n            Method method = (Method)value;\n            int modifiers = Constants.ACC_FINAL\n                | (method.getModifiers()\n                   & ~Constants.ACC_ABSTRACT\n                   & ~Constants.ACC_NATIVE\n                   & ~Constants.ACC_SYNCHRONIZED);\n            if (forcePublic.contains(MethodWrapper.create(method))) {\n                modifiers = (modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;\n            }\n            return ReflectUtils.getMethodInfo(method, modifiers);\n        }\n    });\n\n    ClassEmitter e = new ClassEmitter(v);\n    if (currentData == null) {\n    e.begin_class(Constants.V1_2,\n                  Constants.ACC_PUBLIC,\n                  getClassName(),\n                  Type.getType(sc),\n                  (useFactory ?\n                   TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :\n                   TypeUtils.getTypes(interfaces)),\n                  Constants.SOURCE_FILE);\n    } else {\n        e.begin_class(Constants.V1_2,\n                Constants.ACC_PUBLIC,\n                getClassName(),\n                null,\n                new Type[]{FACTORY},\n                Constants.SOURCE_FILE);\n    }\n    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\n\n    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);\n    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, null);\n    if (!interceptDuringConstruction) {\n        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null);\n    }\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);\n    if (serialVersionUID != null) {\n        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);\n    }\n\n    for (int i = 0; i < callbackTypes.length; i++) {\n        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null);\n    }\n    // This is declared private to avoid "public field" pollution\n    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, null);\n\n    if (currentData == null) {\n        emitMethods(e, methods, actualMethods);\n        emitConstructors(e, constructorInfo);\n    } else {\n        emitDefaultConstructor(e);\n    }\n    emitSetThreadCallbacks(e);\n    emitSetStaticCallbacks(e);\n    emitBindCallbacks(e);\n\n    if (useFactory || currentData != null) {\n        int[] keys = getCallbackKeys();\n        emitNewInstanceCallbacks(e);\n        emitNewInstanceCallback(e);\n        emitNewInstanceMultiarg(e, constructorInfo);\n        emitGetCallback(e, keys);\n        emitSetCallback(e, keys);\n        emitGetCallbacks(e);\n        emitSetCallbacks(e);\n    }\n\n    e.end_class();\n}\n```\n\n`generateClass(...)` 执行的操作和 ASM 库的 ClassVisitor 访问 Class 文件结构的流程基本类似。\n\n从上述截取到的部分代码，例如:\n\n```java\ne.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), \n        (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)),\n        Constants.SOURCE_FILE);\n```\n\n```java\ne.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n```\n\n都与 `classVisitor.visit(...)` 以及 `classVisitor.visitField(...)` 相当类似。而事实上，这些方法的具体实现也确实调用了 cv.visitXxx(...) 。\n毕竟，作为 CGlib 唯一依赖的库，ASM 还是可以说是难以替代的(既然已经有了可用的轮子，又何必重复造呢?)\n\n## 构造的实例\n\n下面将展示通过 CGlib 生成的新的类(由于生成的是字节码，懒得再自行解析 ClassFile 的内容，所有直接用 `IDEA` 做了字节码的解析)\n\n**首先展示的需要进行增强的 SampleClass 的具体内容**\n```java\npublic class SampleClass {\n    public String test(String input) {\n        return "Hello World!";\n    }\n}\n```\n\n**用于增强的简单代码**\n\n```java\n// 省略部分代码\npublic static void main(String... args) {\n    Enhancer enhancer = new Enhancer();\n    enhancer.setSuperclass(SampleClass.class);\n    enhancer.setCallback(new FixedValue() {\n        public Object loadObject() throws Exception {\n            return "Hello cglib!";\n        }\n    });\n    SampleClass proxy = (SampleClass) enhancer.create();\n}\n```\n\n**动态生成的新的类**\n\n```java\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\n// 不用过多关注，只是 CGlib 保证生成类与原有的类一定属于同一包下，偷懒直接把 SampleClass 写在 CGlib 项目里了\npackage net.sf.cglib.samples;\n\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.FixedValue;\n\n/**\n * 新的类名，通过 $$EnhancerByCGLIB 以及 $$7cd64b81(这个是哈希值) 对类名进行唯一区分 \n * 如果还是重复了，在动态生成前会进行类名的检测，并通过增加序号 "_<index>" 的形式进行进一步区分\n *\n * 可以看到新生成的类继承了 SampleClass \n */\npublic class SampleClass$$EnhancerByCGLIB$$7cd64b81 extends SampleClass implements Factory {\n    private boolean CGLIB$BOUND;\n    public static Object CGLIB$FACTORY_DATA;\n    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;\n    private static final Callback[] CGLIB$STATIC_CALLBACKS;\n\n    // 绑定一个在增强中声明的 Callback 实例\n    private FixedValue CGLIB$CALLBACK_0;\n    // 绑定一个静态的回调调度实例\n    private static Object CGLIB$CALLBACK_FILTER;\n\n    static void CGLIB$STATICHOOK1() {\n        CGLIB$THREAD_CALLBACKS = new ThreadLocal();\n    }\n\n    /**\n      * 对 test(String) 的方法的增强\n      */ \n    public final String test(String var1) {\n        // 在方法块中拿到 Callback 实例\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        // 为空则尝试获取\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        // 触发回调实例的方法获得返回值\n        return (String)var10000.loadObject();\n    }\n\n    /**\n      * 由于此次增强只声明了一个 Callback\n      * 因此所有方法的增强都相同, 都是调用这个回调方法获取\n      */\n    public final boolean equals(Object var1) {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        Object var2 = var10000.loadObject();\n        /**\n         * 但是，此处会尝试强制转型\n         * 同时在最终执行失败的时候直接抛出运行时异常\n         * 毕竟上面增强的时候返回固定值 "Hello, cglib!"\n         */\n        return var2 == null ? false : (Boolean)var2;\n    }\n\n    public final String toString() {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return (String)var10000.loadObject();\n    }\n\n    public final int hashCode() {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        Object var1 = var10000.loadObject();\n        return var1 == null ? 0 : ((Number)var1).intValue();\n    }\n\n    protected final Object clone() throws CloneNotSupportedException {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return var10000.loadObject();\n    }\n\n    public SampleClass$$EnhancerByCGLIB$$7cd64b81() {\n        CGLIB$BIND_CALLBACKS(this);\n    }\n\n    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {\n        CGLIB$THREAD_CALLBACKS.set(var0);\n    }\n\n    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {\n        CGLIB$STATIC_CALLBACKS = var0;\n    }\n\n    private static final void CGLIB$BIND_CALLBACKS(Object var0) {\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var1 = (SampleClass$$EnhancerByCGLIB$$7cd64b81)var0;\n        if (!var1.CGLIB$BOUND) {\n            var1.CGLIB$BOUND = true;\n            Object var10000 = CGLIB$THREAD_CALLBACKS.get();\n            if (var10000 == null) {\n                var10000 = CGLIB$STATIC_CALLBACKS;\n                if (CGLIB$STATIC_CALLBACKS == null) {\n                    return;\n                }\n            }\n\n            var1.CGLIB$CALLBACK_0 = (FixedValue)((Callback[])var10000)[0];\n        }\n\n    }\n\n    public Object newInstance(Callback[] var1) {\n        CGLIB$SET_THREAD_CALLBACKS(var1);\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Callback var1) {\n        CGLIB$SET_THREAD_CALLBACKS(new Callback[]{var1});\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {\n        CGLIB$SET_THREAD_CALLBACKS(var3);\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81;\n        switch(var1.length) {\n        case 0:\n            var10000.<init>();\n            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n            return var10000;\n        default:\n            throw new IllegalArgumentException("Constructor not found");\n        }\n    }\n\n    public Callback getCallback(int var1) {\n        CGLIB$BIND_CALLBACKS(this);\n        FixedValue var10000;\n        switch(var1) {\n        case 0:\n            var10000 = this.CGLIB$CALLBACK_0;\n            break;\n        default:\n            var10000 = null;\n        }\n\n        return var10000;\n    }\n\n    public void setCallback(int var1, Callback var2) {\n        switch(var1) {\n        case 0:\n            this.CGLIB$CALLBACK_0 = (FixedValue)var2;\n        default:\n        }\n    }\n\n    public Callback[] getCallbacks() {\n        CGLIB$BIND_CALLBACKS(this);\n        return new Callback[]{this.CGLIB$CALLBACK_0};\n    }\n\n    public void setCallbacks(Callback[] var1) {\n        this.CGLIB$CALLBACK_0 = (FixedValue)var1[0];\n    }\n\n    static {\n        CGLIB$STATICHOOK1();\n    }\n}\n```\n\n从上面的生成类可以看出来，CGlib 所进行的增强，是在不直接对原有的方法体内容进行改造的基础上(例如上面的 test(String) 方法，没有直接改写成 `return "Hello, cglib!` 的形式)，对方法执行之前入参或者方法执行之后的返回值进行一定的处理。\n\n主要使用的形式就是将回调实例与原有方法进行绑定，并通过调用回调方法来实现方法的增强。\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<h2>前言</h2>\n<p>此博文写作的目的:</p>\n<ul>\n<li>(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。</li>\n<li>基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。</li>\n</ul>\n<p>&lt;!-- more --&gt;</p>\n<h2>Enhancer</h2>\n<p>从这篇不是官方但更胜于官方文档的 <a href="http://mydailyjava.blogspot.com/2013/11/cglib-missing-manual.html">CGlib Guide</a> 来看，它首先提到的第一个类就是 Enhancer。\n其被用于创建 Java 代理类，相较于 Java 标准库的 Proxy 类，它<strong>特别地</strong>，能够支持那些没有实现接口的类的代理工作。</p>\n<h3>Enhancer 简单示例展示</h3>\n<p>针对现有的 SampleClass 类</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleClass</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">(String input)</span> </span>{\n        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World!"</span>;\n    }\n}</code></pre><p>使用 CGlib 的 Enhancer 对 SampleClass 进行增强，下列操作的目的在于将 test(String) 方法的返回值改写成 &quot;Hello cglib!&quot;</p>\n<pre><code class="hljs"><span class="hljs-meta">@Test</span>\n<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFixedValue</span><span class="hljs-params">()</span> </span>{\n    <span class="hljs-comment">// new 一个 Enhancer 实例</span>\n    Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();\n    <span class="hljs-comment">// 声明使用的父类是 SampleClass</span>\n    enhancer.setSuperclass(SampleClass.class);\n    <span class="hljs-comment">// 设置回调方法 - 回调方法实现为 FixedValue (固定值) .</span>\n    enhancer.setCallback(<span class="hljs-keyword">new</span> FixedValue() {\n        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">loadObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{\n            <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello cglib!"</span>;\n        }\n    });\n    <span class="hljs-comment">// 创建 SampleClass 的代理子类实例</span>\n    SampleClass proxy = (SampleClass) enhancer.create();\n    Assert.assertEquals(<span class="hljs-string">"Hello cglib!"</span>, proxy.test(<span class="hljs-keyword">null</span>));\n}</code></pre><p>简单测试上述代码，可以了解到确实，代理类的 test(String) 方法的返回值被改写了。\n那么，究竟这种操作是如何实现的？下面👇将进行具体的探究。</p>\n<h2>调用链跟踪</h2>\n<h3>高度抽象的时序图</h3>\n<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ft4ifuo997j31jh0st42t.jpg" alt="Enhancer 调用链 时序图"></p>\n<p><em>下列内容将根据时序图进行组织，根据调用编号(1,2,3...)进行展开</em></p>\n<h3>Seq 1.</h3>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>{\n    classOnly = <span class="hljs-keyword">false</span>;\n    argumentTypes = <span class="hljs-keyword">null</span>;\n    <span class="hljs-keyword">return</span> createHelper();\n}\n\n<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Class[] argumentTypes, Object[] arguments)</span> </span>{\n    classOnly = <span class="hljs-keyword">false</span>;\n    <span class="hljs-keyword">if</span> (argumentTypes == <span class="hljs-keyword">null</span> || arguments == <span class="hljs-keyword">null</span> || argumentTypes.length != arguments.length) {\n        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Arguments must be non-null and of equal length"</span>);\n    }\n    <span class="hljs-keyword">this</span>.argumentTypes = argumentTypes;\n    <span class="hljs-keyword">this</span>.arguments = arguments;\n    <span class="hljs-keyword">return</span> createHelper();\n}</code></pre><p>上述两个 <code>create(...)</code> 方法。结合上一节的使用示例，可以看到 <code>create()</code> 对应的<strong>无参构造</strong>。\n存在无参构造，那么<strong>有参的构造方法</strong>显然也是应该被支持id。<code>create(Class[], Object[])</code> 正是为了这个目标而存在。通过提供参数类型数组和参数实例数组，可以唯一地定位及调用代理类的特定构造方法。</p>\n<p>这个方法比较简单，只是将 Enhancer 作为一个数据内容的持有者，重置了新代理类将使用的构造函数参数内容，之后就直接调用了 <code>createHelper()</code> 。</p>\n<h3>Seq 2.</h3>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">createHelper</span><span class="hljs-params">()</span> </span>{\n    <span class="hljs-comment">// 对预声明的回调方法进行验证，要求 [多个回调就必须存在 CallbackFilter 作为调度器]</span>\n    preValidate();\n    <span class="hljs-comment">// 构建一个对这类增强操作唯一定位的 key</span>\n    Object key = KEY_FACTORY.newInstance((superclass != <span class="hljs-keyword">null</span>) ? superclass.getName() : <span class="hljs-keyword">null</span>,\n            ReflectUtils.getNames(interfaces),\n            filter == ALL_ZERO ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">new</span> WeakCacheKey&lt;CallbackFilter&gt;(filter),\n            callbackTypes,\n            useFactory,\n            interceptDuringConstruction,\n            serialVersionUID);\n    <span class="hljs-keyword">this</span>.currentKey = key;\n    <span class="hljs-comment">// 调用父类通过的 create(...) 方法</span>\n    Object result = <span class="hljs-keyword">super</span>.create(key);\n    <span class="hljs-keyword">return</span> result;\n}</code></pre><h3>Seq 3.</h3>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Object key)</span> </span>{\n    <span class="hljs-keyword">try</span> {\n        <span class="hljs-comment">// 获取用于 加载 生成类 的 ClassLoader</span>\n        ClassLoader loader = getClassLoader();\n        <span class="hljs-comment">// 从缓存中加载 这个 ClassLoader 过去加载的相关数据</span>\n        Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;\n        ClassLoaderData data = cache.get(loader);\n        <span class="hljs-comment">// 如果在 缓存 中找不到，则初始化构造关于这个 ClassLoader 的数据实例</span>\n        <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span>) {\n            <span class="hljs-comment">// 同步</span>\n            <span class="hljs-keyword">synchronized</span> (AbstractClassGenerator.class) {\n                <span class="hljs-comment">// 进入同步块后的 再次确认，避免重复初始化构建</span>\n                cache = CACHE;\n                data = cache.get(loader);\n                <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span>) {\n                    <span class="hljs-comment">// 构建新的 缓存，拷贝原有的缓存集的内容</span>\n                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache = <span class="hljs-keyword">new</span> WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;(cache);\n                    <span class="hljs-comment">// 初始化 ClassLoaderData ，真正的构造操作</span>\n                    data = <span class="hljs-keyword">new</span> ClassLoaderData(loader);\n                    <span class="hljs-comment">// 添加到缓存中</span>\n                    newCache.put(loader, data);\n                    CACHE = newCache;\n                }\n            }\n        }\n        <span class="hljs-keyword">this</span>.key = key;\n        Object obj = data.get(<span class="hljs-keyword">this</span>, getUseCache());\n        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Class) {\n            <span class="hljs-comment">// 初次实例化操作，就是 Class 利用反射来进行实例化</span>\n            <span class="hljs-keyword">return</span> firstInstance((Class) obj);\n        }\n        <span class="hljs-comment">// 非初次实例化，则是从 ClassLoaderData 中得到的之前维护的内容</span>\n        <span class="hljs-keyword">return</span> nextInstance(obj);\n    } <span class="hljs-keyword">catch</span> (RuntimeException e) {\n        <span class="hljs-keyword">throw</span> e;\n    } <span class="hljs-keyword">catch</span> (Error e) {\n        <span class="hljs-keyword">throw</span> e;\n    } <span class="hljs-keyword">catch</span> (Exception e) {\n        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CodeGenerationException(e);\n    }\n}</code></pre><p>这部分内容比较多，且是调用链比较重要的一环。<strong>Seq 4.</strong> 和 <strong>Seq 5.</strong> 将作为其子内容进行调用，但为了本博文的结构完整， <em>Seq 4. &amp; Seq5.</em> 的标题与 <em>Seq 3.</em> 标题同级</p>\n<h3>Seq 4.</h3>\n<p>首先应该认识到，每个被加载的 Class ，在 <code>equal</code> 的判断过程中，依据的是同一个 ClassLoader 加载的同一 Class 才被认为是相同的，否则即使 Class 是同一个，但仍会被认为是不同的(由不同的 ClassLoader 加载)。</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title">getClassLoader</span><span class="hljs-params">()</span> </span>{\n    ClassLoader t = classLoader;\n    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) {\n        t = getDefaultClassLoader();\n    }\n    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) {\n        t = getClass().getClassLoader();\n    }\n    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) {\n        t = Thread.currentThread().getContextClassLoader();\n    }\n    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) {\n        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot determine classloader"</span>);\n    }\n    <span class="hljs-keyword">return</span> t;\n}</code></pre><p>因此，在这部分中，首先需要确定的是由哪个 ClassLoader 进行加载的工作。<code>getClassLoader()</code> 的确定顺序是:</p>\n<ol>\n<li>具体实现类声明的 <strong>默认 ClassLoader</strong> 为第一优先级</li>\n<li>加载当前类(这里是 Enhancer) 的 ClassLoader 为第二优先级</li>\n<li><strong>当前线程上下文 ClassLoader</strong> 为第三优先级</li>\n<li>抛出异常</li>\n</ol>\n<p>回到 <strong>Seq 3.</strong> 的内容，\n下一步是对当前这个<strong>AbstractClassGenerator</strong> 维护的 CACHE 进行处理，如果在 CACHE 中能够得到以确定的 ClassLoader 为 Key 的键值对，则直接获取 ClassLoader 对应的值，否则将进行初始化构建一个新的 ClassLoaderData 作为这个 ClassLoader 的值。</p>\n<h3>Seq 5.</h3>\n<p>在构建 ClassLoaderData 的过程中，最重要的一步:</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassLoaderData</span><span class="hljs-params">(ClassLoader classLoader)</span> </span>{\n    <span class="hljs-comment">// ClassLoader 不可为空</span>\n    <span class="hljs-keyword">if</span> (classLoader == <span class="hljs-keyword">null</span>) {\n        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"classLoader == null is not yet supported"</span>);\n    }\n    <span class="hljs-comment">// 构建 ClassLoader 的弱引用</span>\n    <span class="hljs-keyword">this</span>.classLoader = <span class="hljs-keyword">new</span> WeakReference&lt;ClassLoader&gt;(classLoader);\n    <span class="hljs-comment">// 写了个后置调用的函数，用于懒加载，只有调用了 load.apply(...) 才会构建 生成类</span>\n    Function&lt;AbstractClassGenerator, Object&gt; load =\n            <span class="hljs-keyword">new</span> Function&lt;AbstractClassGenerator, Object&gt;() {\n                <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(AbstractClassGenerator gen)</span> </span>{\n                    Class klass = gen.generate(ClassLoaderData.<span class="hljs-keyword">this</span>);\n                    <span class="hljs-keyword">return</span> gen.wrapCachedClass(klass);\n                }\n            };\n    generatedClasses = <span class="hljs-keyword">new</span> LoadingCache&lt;AbstractClassGenerator, Object, Object&gt;(GET_KEY, load);\n}</code></pre><p>构建了一个 Function 实例，这个 Function 作为函数式接口，预定义执行的具体流程，但由上下文确定具体的调用时刻。</p>\n<h3>Seq 6.</h3>\n<p>在正确得到了 ClassLoader 对应的 ClassLoaderData 之后，ClassLoaderData 的 <code>get(...)</code> 方法将在特定的 ClassLoader 之下，进行更具体的加载新生成类的工作。\n当然，这里的前提是新的生成类的字节码已经被构建:)</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(AbstractClassGenerator gen, <span class="hljs-keyword">boolean</span> useCache)</span> </span>{\n    <span class="hljs-comment">// 标记为不使用缓存，直接构建 新的生成类</span>\n    <span class="hljs-keyword">if</span> (!useCache) {\n      <span class="hljs-keyword">return</span> gen.generate(ClassLoaderData.<span class="hljs-keyword">this</span>);\n    }\n    <span class="hljs-comment">// 使用缓冲的情况</span>\n    <span class="hljs-keyword">else</span> {\n      Object cachedValue = generatedClasses.get(gen);\n      <span class="hljs-keyword">return</span> gen.unwrapCachedValue(cachedValue);\n    }\n}</code></pre><p>可以看到 <code>gen.generate(ClassLoaderData.this)</code> 这段代码在 <code>get(...)</code> 方法和上一小节 <code>ClassLoaderData(...)</code> 构造方法的 Function 函数式实例都出现了。</p>\n<p>实际上，这也是触发 ClassLoader 来加载动态生成的新 Class 的唯一入口。</p>\n<p><em>判断逻辑</em> 的 <code>else</code> 内容的唯一区别就在于其构建的是一个加载缓存，将真正触发 gen.generate(ClassLoaderData.this) 的逻辑延迟。(不过，最终也还是会进行调用的，:) 这是毋庸置疑的)。</p>\n<h3>Seq 7.</h3>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">protected</span> Class <span class="hljs-title">generate</span><span class="hljs-params">(ClassLoaderData data)</span> </span>{\n    Class gen;\n    Object save = CURRENT.get();\n    CURRENT.set(<span class="hljs-keyword">this</span>);\n    <span class="hljs-keyword">try</span> {\n        <span class="hljs-comment">// 拿到用于加载生成类的 ClassLoader</span>\n        ClassLoader classLoader = data.getClassLoader();\n        <span class="hljs-keyword">if</span> (classLoader == <span class="hljs-keyword">null</span>) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"ClassLoader is null while trying to define class "</span> +\n                    getClassName() + <span class="hljs-string">". It seems that the loader has been expired from a weak reference somehow. "</span> +\n                    <span class="hljs-string">"Please file an issue at cglib\'s issue tracker."</span>);\n        }\n        <span class="hljs-comment">// 构建一个合法的 生成类 的类名(非重复)</span>\n        <span class="hljs-keyword">synchronized</span> (classLoader) {\n          String name = generateClassName(data.getUniqueNamePredicate());\n          data.reserveName(name);\n          <span class="hljs-keyword">this</span>.setClassName(name);\n        }\n        <span class="hljs-keyword">if</span> (attemptLoad) {\n            <span class="hljs-keyword">try</span> {\n                <span class="hljs-comment">// 尝试直接通过 ClassLoader 进行加载</span>\n                gen = classLoader.loadClass(getClassName());\n                <span class="hljs-keyword">return</span> gen;\n            } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {\n                <span class="hljs-comment">// ignore</span>\n            }\n        }\n        <span class="hljs-comment">// 策略下的生成类构建方法</span>\n        <span class="hljs-keyword">byte</span>[] b = strategy.generate(<span class="hljs-keyword">this</span>);\n        <span class="hljs-comment">// 通过解析字节码的形式获取 生成类的 className</span>\n        String className = ClassNameReader.getClassName(<span class="hljs-keyword">new</span> ClassReader(b));\n        ProtectionDomain protectionDomain = getProtectionDomain();\n        <span class="hljs-keyword">synchronized</span> (classLoader) { <span class="hljs-comment">// just in case</span>\n            <span class="hljs-comment">// 反射的形式加载 Class 类</span>\n            <span class="hljs-keyword">if</span> (protectionDomain == <span class="hljs-keyword">null</span>) {\n                gen = ReflectUtils.defineClass(className, b, classLoader);\n            } <span class="hljs-keyword">else</span> {\n                gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);\n            }\n        }\n        <span class="hljs-keyword">return</span> gen;\n    } <span class="hljs-keyword">catch</span> (RuntimeException e) {\n        <span class="hljs-keyword">throw</span> e;\n    } <span class="hljs-keyword">catch</span> (Error e) {\n        <span class="hljs-keyword">throw</span> e;\n    } <span class="hljs-keyword">catch</span> (Exception e) {\n        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CodeGenerationException(e);\n    } <span class="hljs-keyword">finally</span> {\n        CURRENT.set(save);\n    }\n}</code></pre><p>这个方法，就是操作字节码，加载 Class 的核心调度方法。</p>\n<p>可以看到 <code>generateClassName(...)</code> 方法将构建一个当前 ClassLoader 下唯一, 不重复的新的类名。</p>\n<p><code>strategy.generate(this)</code> 将通过特定策略实现的形式生成新的字节码</p>\n<p><code>ReflectUtils.defineClass(className, b, classLoader)</code> 将使用反射使得 ClassLoader 来加载这个新的生成类。</p>\n<h3>Seq 8.</h3>\n<p>生成新的不重复类名这部分不做过多陈述，可以简单进行了解，并熟悉 CGlib 默认的新类名的命名规则</p>\n<pre><code class="hljs"><span class="hljs-comment">// DefaultNamePolicy</span>\n<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getClassName</span><span class="hljs-params">(String prefix, String source, Object key, Predicate names)</span> </span>{\n    <span class="hljs-keyword">if</span> (prefix == <span class="hljs-keyword">null</span>) {\n        prefix = <span class="hljs-string">"net.sf.cglib.empty.Object"</span>;\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prefix.startsWith(<span class="hljs-string">"java"</span>)) {\n        prefix = <span class="hljs-string">"$"</span> + prefix;\n    }\n    String base =\n        prefix + <span class="hljs-string">"$$"</span> +\n        source.substring(source.lastIndexOf(<span class="hljs-string">\'.\'</span>) + <span class="hljs-number">1</span>) +\n        getTag() + <span class="hljs-string">"$$"</span> +\n        Integer.toHexString(STRESS_HASH_CODE ? <span class="hljs-number">0</span> : key.hashCode());\n    String attempt = base;\n    <span class="hljs-keyword">int</span> index = <span class="hljs-number">2</span>;\n    <span class="hljs-keyword">while</span> (names.evaluate(attempt))\n        attempt = base + <span class="hljs-string">"_"</span> + index++;\n    <span class="hljs-keyword">return</span> attempt;\n}</code></pre><h3>Seq 9.</h3>\n<pre><code class="hljs"><span class="hljs-comment">// 下列是 DefaultGeneratorStrategy 的实现</span>\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] generate(ClassGenerator cg) <span class="hljs-keyword">throws</span> Exception {\n    DebuggingClassWriter cw = getClassVisitor();\n    transform(cg).generateClass(cw);\n    <span class="hljs-keyword">return</span> transform(cw.toByteArray());\n}</code></pre><h3>Seq 10.</h3>\n<p>调用 <code>generateClass(ClassVisitor)</code> 将获得到新类的字节码。</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateClass</span><span class="hljs-params">(ClassVisitor v)</span> <span class="hljs-keyword">throws</span> Exception </span>{\n    <span class="hljs-comment">// 确定生成类的 父类</span>\n    Class sc = (superclass == <span class="hljs-keyword">null</span>) ? Object.class : superclass;\n\n    <span class="hljs-comment">// 父类标识符不可以为 final</span>\n    <span class="hljs-keyword">if</span> (TypeUtils.isFinal(sc.getModifiers()))\n        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot subclass final class "</span> + sc.getName());\n    <span class="hljs-comment">// 获取父类直接声明的构造方法</span>\n    List constructors = <span class="hljs-keyword">new</span> ArrayList(Arrays.asList(sc.getDeclaredConstructors()));\n    filterConstructors(sc, constructors);\n\n    <span class="hljs-comment">// Order is very important: must add superclass, then</span>\n    <span class="hljs-comment">// its superclass chain, then each interface and</span>\n    <span class="hljs-comment">// its superinterfaces.</span>\n    List actualMethods = <span class="hljs-keyword">new</span> ArrayList();\n    List interfaceMethods = <span class="hljs-keyword">new</span> ArrayList();\n    <span class="hljs-keyword">final</span> Set forcePublic = <span class="hljs-keyword">new</span> HashSet();\n    <span class="hljs-comment">// 从父类中提取各种信息</span>\n    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);\n\n    List methods = CollectionUtils.transform(actualMethods, <span class="hljs-keyword">new</span> Transformer() {\n        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">transform</span><span class="hljs-params">(Object value)</span> </span>{\n            Method method = (Method)value;\n            <span class="hljs-keyword">int</span> modifiers = Constants.ACC_FINAL\n                | (method.getModifiers()\n                   &amp; ~Constants.ACC_ABSTRACT\n                   &amp; ~Constants.ACC_NATIVE\n                   &amp; ~Constants.ACC_SYNCHRONIZED);\n            <span class="hljs-keyword">if</span> (forcePublic.contains(MethodWrapper.create(method))) {\n                modifiers = (modifiers &amp; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;\n            }\n            <span class="hljs-keyword">return</span> ReflectUtils.getMethodInfo(method, modifiers);\n        }\n    });\n\n    ClassEmitter e = <span class="hljs-keyword">new</span> ClassEmitter(v);\n    <span class="hljs-keyword">if</span> (currentData == <span class="hljs-keyword">null</span>) {\n    e.begin_class(Constants.V1_2,\n                  Constants.ACC_PUBLIC,\n                  getClassName(),\n                  Type.getType(sc),\n                  (useFactory ?\n                   TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :\n                   TypeUtils.getTypes(interfaces)),\n                  Constants.SOURCE_FILE);\n    } <span class="hljs-keyword">else</span> {\n        e.begin_class(Constants.V1_2,\n                Constants.ACC_PUBLIC,\n                getClassName(),\n                <span class="hljs-keyword">null</span>,\n                <span class="hljs-keyword">new</span> Type[]{FACTORY},\n                Constants.SOURCE_FILE);\n    }\n    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\n\n    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, <span class="hljs-keyword">null</span>);\n    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, <span class="hljs-keyword">null</span>);\n    <span class="hljs-keyword">if</span> (!interceptDuringConstruction) {\n        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, <span class="hljs-keyword">null</span>);\n    }\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, <span class="hljs-keyword">null</span>);\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, <span class="hljs-keyword">null</span>);\n    <span class="hljs-keyword">if</span> (serialVersionUID != <span class="hljs-keyword">null</span>) {\n        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);\n    }\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; callbackTypes.length; i++) {\n        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], <span class="hljs-keyword">null</span>);\n    }\n    <span class="hljs-comment">// This is declared private to avoid "public field" pollution</span>\n    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, <span class="hljs-keyword">null</span>);\n\n    <span class="hljs-keyword">if</span> (currentData == <span class="hljs-keyword">null</span>) {\n        emitMethods(e, methods, actualMethods);\n        emitConstructors(e, constructorInfo);\n    } <span class="hljs-keyword">else</span> {\n        emitDefaultConstructor(e);\n    }\n    emitSetThreadCallbacks(e);\n    emitSetStaticCallbacks(e);\n    emitBindCallbacks(e);\n\n    <span class="hljs-keyword">if</span> (useFactory || currentData != <span class="hljs-keyword">null</span>) {\n        <span class="hljs-keyword">int</span>[] keys = getCallbackKeys();\n        emitNewInstanceCallbacks(e);\n        emitNewInstanceCallback(e);\n        emitNewInstanceMultiarg(e, constructorInfo);\n        emitGetCallback(e, keys);\n        emitSetCallback(e, keys);\n        emitGetCallbacks(e);\n        emitSetCallbacks(e);\n    }\n\n    e.end_class();\n}</code></pre><p><code>generateClass(...)</code> 执行的操作和 ASM 库的 ClassVisitor 访问 Class 文件结构的流程基本类似。</p>\n<p>从上述截取到的部分代码，例如:</p>\n<pre><code class="hljs">e.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), \n        (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)),\n        Constants.SOURCE_FILE);</code></pre><pre><code class="hljs">e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, <span class="hljs-keyword">null</span>);</code></pre><p>都与 <code>classVisitor.visit(...)</code> 以及 <code>classVisitor.visitField(...)</code> 相当类似。而事实上，这些方法的具体实现也确实调用了 cv.visitXxx(...) 。\n毕竟，作为 CGlib 唯一依赖的库，ASM 还是可以说是难以替代的(既然已经有了可用的轮子，又何必重复造呢?)</p>\n<h2>构造的实例</h2>\n<p>下面将展示通过 CGlib 生成的新的类(由于生成的是字节码，懒得再自行解析 ClassFile 的内容，所有直接用 <code>IDEA</code> 做了字节码的解析)</p>\n<p><strong>首先展示的需要进行增强的 SampleClass 的具体内容</strong></p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleClass</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">(String input)</span> </span>{\n        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World!"</span>;\n    }\n}</code></pre><p><strong>用于增强的简单代码</strong></p>\n<pre><code class="hljs"><span class="hljs-comment">// 省略部分代码</span>\n<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{\n    Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();\n    enhancer.setSuperclass(SampleClass.class);\n    enhancer.setCallback(<span class="hljs-keyword">new</span> FixedValue() {\n        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">loadObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{\n            <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello cglib!"</span>;\n        }\n    });\n    SampleClass proxy = (SampleClass) enhancer.create();\n}</code></pre><p><strong>动态生成的新的类</strong></p>\n<pre><code class="hljs"><span class="hljs-comment">//</span>\n<span class="hljs-comment">// Source code recreated from a .class file by IntelliJ IDEA</span>\n<span class="hljs-comment">// (powered by Fernflower decompiler)</span>\n<span class="hljs-comment">//</span>\n\n<span class="hljs-comment">// 不用过多关注，只是 CGlib 保证生成类与原有的类一定属于同一包下，偷懒直接把 SampleClass 写在 CGlib 项目里了</span>\n<span class="hljs-keyword">package</span> net.sf.cglib.samples;\n\n<span class="hljs-keyword">import</span> net.sf.cglib.proxy.Callback;\n<span class="hljs-keyword">import</span> net.sf.cglib.proxy.Factory;\n<span class="hljs-keyword">import</span> net.sf.cglib.proxy.FixedValue;\n\n<span class="hljs-comment">/**\n * 新的类名，通过 $$EnhancerByCGLIB 以及 $$7cd64b81(这个是哈希值) 对类名进行唯一区分 \n * 如果还是重复了，在动态生成前会进行类名的检测，并通过增加序号 "_&lt;index&gt;" 的形式进行进一步区分\n *\n * 可以看到新生成的类继承了 SampleClass \n */</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleClass</span>$$<span class="hljs-title">EnhancerByCGLIB</span>$$7<span class="hljs-title">cd64b81</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SampleClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span> </span>{\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> CGLIB$BOUND;\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object CGLIB$FACTORY_DATA;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;\n\n    <span class="hljs-comment">// 绑定一个在增强中声明的 Callback 实例</span>\n    <span class="hljs-keyword">private</span> FixedValue CGLIB$CALLBACK_0;\n    <span class="hljs-comment">// 绑定一个静态的回调调度实例</span>\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object CGLIB$CALLBACK_FILTER;\n\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> CGLIB$STATICHOOK1() {\n        CGLIB$THREAD_CALLBACKS = <span class="hljs-keyword">new</span> ThreadLocal();\n    }\n\n    <span class="hljs-comment">/**\n      * 对 test(String) 的方法的增强\n      */</span> \n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">test</span><span class="hljs-params">(String var1)</span> </span>{\n        <span class="hljs-comment">// 在方法块中拿到 Callback 实例</span>\n        FixedValue var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;\n        <span class="hljs-comment">// 为空则尝试获取</span>\n        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 == <span class="hljs-keyword">null</span>) {\n            CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);\n            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;\n        }\n\n        <span class="hljs-comment">// 触发回调实例的方法获得返回值</span>\n        <span class="hljs-keyword">return</span> (String)var10000.loadObject();\n    }\n\n    <span class="hljs-comment">/**\n      * 由于此次增强只声明了一个 Callback\n      * 因此所有方法的增强都相同, 都是调用这个回调方法获取\n      */</span>\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> </span>{\n        FixedValue var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;\n        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 == <span class="hljs-keyword">null</span>) {\n            CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);\n            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;\n        }\n\n        Object var2 = var10000.loadObject();\n        <span class="hljs-comment">/**\n         * 但是，此处会尝试强制转型\n         * 同时在最终执行失败的时候直接抛出运行时异常\n         * 毕竟上面增强的时候返回固定值 "Hello, cglib!"\n         */</span>\n        <span class="hljs-keyword">return</span> var2 == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">false</span> : (Boolean)var2;\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{\n        FixedValue var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;\n        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 == <span class="hljs-keyword">null</span>) {\n            CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);\n            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;\n        }\n\n        <span class="hljs-keyword">return</span> (String)var10000.loadObject();\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{\n        FixedValue var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;\n        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 == <span class="hljs-keyword">null</span>) {\n            CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);\n            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;\n        }\n\n        Object var1 = var10000.loadObject();\n        <span class="hljs-keyword">return</span> var1 == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : ((Number)var1).intValue();\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>{\n        FixedValue var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;\n        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 == <span class="hljs-keyword">null</span>) {\n            CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);\n            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;\n        }\n\n        <span class="hljs-keyword">return</span> var10000.loadObject();\n    }\n\n    <span class="hljs-keyword">public</span> SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81() {\n        CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {\n        CGLIB$THREAD_CALLBACKS.set(var0);\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {\n        CGLIB$STATIC_CALLBACKS = var0;\n    }\n\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> CGLIB$BIND_CALLBACKS(Object var0) {\n        SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81 var1 = (SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81)var0;\n        <span class="hljs-keyword">if</span> (!var1.CGLIB$BOUND) {\n            var1.CGLIB$BOUND = <span class="hljs-keyword">true</span>;\n            Object var10000 = CGLIB$THREAD_CALLBACKS.get();\n            <span class="hljs-keyword">if</span> (var10000 == <span class="hljs-keyword">null</span>) {\n                var10000 = CGLIB$STATIC_CALLBACKS;\n                <span class="hljs-keyword">if</span> (CGLIB$STATIC_CALLBACKS == <span class="hljs-keyword">null</span>) {\n                    <span class="hljs-keyword">return</span>;\n                }\n            }\n\n            var1.CGLIB$CALLBACK_0 = (FixedValue)((Callback[])var10000)[<span class="hljs-number">0</span>];\n        }\n\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(Callback[] var1)</span> </span>{\n        CGLIB$SET_THREAD_CALLBACKS(var1);\n        SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81 var10000 = <span class="hljs-keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="hljs-keyword">null</span>);\n        <span class="hljs-keyword">return</span> var10000;\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(Callback var1)</span> </span>{\n        CGLIB$SET_THREAD_CALLBACKS(<span class="hljs-keyword">new</span> Callback[]{var1});\n        SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81 var10000 = <span class="hljs-keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="hljs-keyword">null</span>);\n        <span class="hljs-keyword">return</span> var10000;\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(Class[] var1, Object[] var2, Callback[] var3)</span> </span>{\n        CGLIB$SET_THREAD_CALLBACKS(var3);\n        SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81 var10000 = <span class="hljs-keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81;\n        <span class="hljs-keyword">switch</span>(var1.length) {\n        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:\n            var10000.&lt;init&gt;();\n            CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="hljs-keyword">null</span>);\n            <span class="hljs-keyword">return</span> var10000;\n        <span class="hljs-keyword">default</span>:\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Constructor not found"</span>);\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> Callback <span class="hljs-title">getCallback</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span> </span>{\n        CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);\n        FixedValue var10000;\n        <span class="hljs-keyword">switch</span>(var1) {\n        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:\n            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">default</span>:\n            var10000 = <span class="hljs-keyword">null</span>;\n        }\n\n        <span class="hljs-keyword">return</span> var10000;\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCallback</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1, Callback var2)</span> </span>{\n        <span class="hljs-keyword">switch</span>(var1) {\n        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:\n            <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 = (FixedValue)var2;\n        <span class="hljs-keyword">default</span>:\n        }\n    }\n\n    <span class="hljs-keyword">public</span> Callback[] getCallbacks() {\n        CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Callback[]{<span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0};\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCallbacks</span><span class="hljs-params">(Callback[] var1)</span> </span>{\n        <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 = (FixedValue)var1[<span class="hljs-number">0</span>];\n    }\n\n    <span class="hljs-keyword">static</span> {\n        CGLIB$STATICHOOK1();\n    }\n}</code></pre><p>从上面的生成类可以看出来，CGlib 所进行的增强，是在不直接对原有的方法体内容进行改造的基础上(例如上面的 test(String) 方法，没有直接改写成 <code>return &quot;Hello, cglib!</code> 的形式)，对方法执行之前入参或者方法执行之后的返回值进行一定的处理。</p>\n<p>主要使用的形式就是将回调实例与原有方法进行绑定，并通过调用回调方法来实现方法的增强。</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-07-10-CGlib-Enhancer.json",ext:".json",sourceBase:"2018-07-10-CGlib-Enhancer.md",sourceExt:".md"}},hW3s:function(n){n.exports={title:"Java Instrumentation",author:"fangfeng",date:"2018-08-15T00:00:00.000Z",tags:["Java","ASM","BTrace"],bodyContent:'## Start\n\n从现有的前置知识来说，我们能够认识到两个事实:\n\n1. Java Class 通过 ClassLoader 进行加载。\n   通过`全限定名`进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。\n   换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)\n2. 有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。\n   当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧\n   (虽然可能不了解细节。在此，欢迎学习前置技能 [CGlib Enhancer 主流程源码解析](https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/) 和 [Java Proxy 源码解析](https://dormouse-none.github.io/2018-07-20-Java-Proxy/)。不过不影响本文后续内容)\n\n另一个方面，也许绝大多数人都听说过所谓的`热部署`。但是究竟怎么才能做到 `热部署`(话题开得有点大哈。Y\\_Y 本文不讲这个)\n\n操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。\n\n如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚...\n\nJava 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的\n\n## Instrumentation\n\n`java.lang.instrument.Instrumentation` 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)\n\n相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。\n\n下列有两种方法可以达到目的\n\n1. 当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。\n2. 当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。\n\n话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了*检测*的目的)的使用\n\n\x3c!-- more --\x3e\n\n## 对各方法进行执行时间统计\n\n### 随 JVM 一起启动\n基本实例: 将对特定包 `me.fangfeng.client` 下的每个方法执行计时\n\n首先了解一下 client 包的内容:\n\n```java\npackage me.fangfeng.client;\n\n/**\n * Main.java\n * 执行两个方法，rand() & sleep() \n *\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class Main {\n\n    static void sleep() {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Rand rand = new Rand();\n\n        for (int i=0;i<10;i++) {\n            System.out.println(">>> start Rand.run() <<<");\n            rand.run();\n            System.out.println(">>> end Rand.run() <<<");\n\n            System.out.println();\n\n            System.out.println(">>> start Main.sleep() <<<");\n            Main.sleep();\n            System.out.println(">>> end MAin.sleep() <<<");\n\n            System.out.println();\n        }\n    }\n}\n```\n\n```java\npackage me.fangfeng.client;\n\n/**\n * Rand.java\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class Rand {\n\n    public void run() {\n        while (true) {\n            double rand = Math.random();\n            if (rand > 0.995) {\n                System.out.println(String.format("get random, values %f", rand));\n                return;\n            }\n        }\n    }\n}\n```\n\n接着，来构造一个代理类，以及最重要的 `premain` 方法\n\n```java\npackage me.fangfeng.javaagent;\n\nimport java.lang.instrument.Instrumentation;\n\n/**\n * Agent - 代理\n * 基于 JVM TI (JVM Tool Interface) 实现的 Java ClassFile 的增强\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class Agent {\n\n    // premain 将 JVM 初始化后，main(String... ) 执行前调用\n    public static void premain(String args, Instrumentation instrumentation) {\n        // new 一个转换器实例\n        ClassTimer transformer = new ClassTimer();\n        instrumentation.addTransformer(transformer);\n    }\n\n    // 之后的 agentmain(...) 将在这里提供，暂时隐去，避免对对读者产生干扰\n}\n```\n\n```java\npackage me.fangfeng.javaagent;\n\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.Opcodes;\n\nimport java.lang.instrument.ClassFileTransformer;\nimport java.security.ProtectionDomain;\n\n/**\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class ClassTimer implements ClassFileTransformer {\n\n    @Override\n    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {\n        // 这里涉及到了 ASM 的内容，主要目的是向每个方法块的开始及方法块的结束部分插入与计时器有关的代码\n        // 如果想了解 ASM 的内容，请参阅 https://dormouse-none.github.io/2018-06-25-ASM-Core/  提供了一些基础性的内容，更多的请自行学习\n        // 不了解具体内容将不影响对主体内容的理解\n        ClassReader cr = new ClassReader(classfileBuffer);\n        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n        MyClassWriter mcw = new MyClassWriter(Opcodes.ASM6, cw);\n        cr.accept(mcw, ClassReader.EXPAND_FRAMES);\n        return cw.toByteArray();\n    }\n}\n```\n\n其它代码略，详见附件。\n\nJava 这种对操作字节码的支持有个坑爹的地方，就是不得不打包成 Jar 来使用。\n\n具体来看一下\n\n`me.fangfeng.javaagent` 包中包括 \n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fublsbbdw0j309o07g74u.jpg)\n\n将被打包成 `agent.jar` 来使用\n\n首先，来看一下需要打包在 `agent.jar` 的 **MANIFEST.MF** 的内容\n\n```\nManifest-Version: 1.0\nClass-Path: /Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar\nPremain-Class: me.fangfeng.javaagent.Agent\nCan-Retransform-Classes: true\n```\n\n再来个 SHELL 脚本，用来给打包这个 Jar\n\n```sh\n#!/bin/bash\n\n# 编译 me.fangfeng.javaagent 包下的类\njavac -cp .:/Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar me/fangfeng/javaagent/Agent.java me/fangfeng/javaagent/ClassTimer.java me/fangfeng/javaagent/MyClassWriter.java me/fangfeng/javaagent/MyMethodWriter.java me/fangfeng/javaagent/StaticTimer.java\n\n# 打包 me.fangfeng.javaagent 的 .class -> agent.jar\njar cvfm agent.jar MANIFEST-agent.MF me/fangfeng/javaagent/Agent.class me/fangfeng/javaagent/ClassTimer.class me/fangfeng/javaagent/MyClassWriter.class me/fangfeng/javaagent/MyMethodWriter.class me/fangfeng/javaagent/StaticTimer.class\n\n# 编译 me.fangfeng.client 包下的类\njavac me/fangfeng/client/Main.java me/fangfeng/client/Rand.java\n\n# 以 me.fangfeng.client.Main 作为主类启动\njava -javaagent:agent.jar me.fangfeng.client.Main\n```\n\n执行后，可以看到类似如下内容:\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fubmp354ejj30tq0rmtdp.jpg)\n\n而直接用 `java me.fangfeng.client.Main` 的执行结果是:\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fubmqmj4uhj30j00f0dho.jpg)\n\n从理论上来讲，`-javaagent:agent.jar` 配合 `agent.jar` 中的 MANIFEST.MF 文件，\n使得 JVM 在初始化之后触发了被声明为 `Pre-Main` 的 me.fangfeng.javaagent.Agent 类的 premain(...) 方法。\n\n并为 ClassLoader 在加载类的流程上增加了一层**拦截器** (这里是 ClassTimer.java 类，它实现了 `ClassFileTransformer` 接口\n\n另外，`Can-Retransform-Classes: true` 的配置使得 ClassTimer 被允许对字节码进行重新转换。(而操作字节码是通过 ASM 来实现的)\n \n### 在运行中进行增强\n\n随着程序启动时直接使用了 `-javaagent` 选项。\n\n那么是否存在在程序运行中进行额外代理操作的支持呢？当然是可以的。这里要借助 Java 提供的另一个类 com.sun.tools.attach.VirtualMachine 。\n\n启动一个新的进程来连接到 正在运行中的进程，并令其加载 java agent。\n\n基本的类与上一节的描述相同，主要是包 `me.fangfeng.javaagent.*` 和 `me.fangfeng.client.*`\n\n新增一个类 `me.fangfeng.javaagent.Main` 用来启动另一个进程，并要求运行中的 java 进程加载 agent.jar 来进行增强。\n\n```java\npackage me.fangfeng.javaagent;\n\nimport com.sun.tools.attach.AgentInitializationException;\nimport com.sun.tools.attach.AgentLoadException;\nimport com.sun.tools.attach.AttachNotSupportedException;\nimport com.sun.tools.attach.VirtualMachine;\n\nimport java.io.IOException;\n\n/**\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class Main {\n\n    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException {\n        VirtualMachine vm = null;\n        try {\n            // 通过 VirtualMachine 连接到 运行中的进程 (可以通过 jps 找到进程号)\n            vm = VirtualMachine.attach(<PID>);\n            vm.loadAgent(<agent.jar 的路径>);\n        } finally {\n            if (vm != null) {\n                vm.detach();\n            }\n        }\n    }\n}\n```\n\n```java\npublic class Agent {\n\n    public static void premain(String args, Instrumentation instrumentation) {\n        ClassTimer transformer = new ClassTimer();\n        instrumentation.addTransformer(transformer);\n    }\n\n    // 现在在 Agent.java 上补上 agentmain(...) 的具体实现\n    public static void agentmain(String args, Instrumentation instrumentation) throws UnmodifiableClassException {\n        System.out.println("SUCCESS AGENTMAIN");\n        ClassTimer transformer = new ClassTimer();\n        // add Transformer\n        instrumentation.addTransformer(transformer, true);\n        // 对 Rand.class 进行重新转换\n        instrumentation.retransformClasses(Rand.class);\n    }\n}\n```\n\n其它内容基本相同\n\n首先需要先打包 agent.jar 。当然，如果是顺着本文的顺序进行本机实验，则 agent.jar 已经存在\n\n先启动进程 `java me.fangfeng.client.Main`\n\n通过 `jps` 获取 Main 进程的 **PID**\n\n在 `java me.fangfeng.javaagent.Main` 中替换上进程号，并执行\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuboclcelsj30tu152dlw.jpg)\n\n从执行结果可以看到，原进程首先正常执行代码，等到被 load Agent 之后，字节码已经有了新的变化，从而导致输出结果动态的产生了变化。\n\n*当然，需要注意的是，执行中的进程被要求 load Agent 之后，运行中的 Class 将被改写，并始终如此，知道进程终止。再下一次重新启动*\n\n## BTrace\n\n以上描述的内容也可以理解为是 BTrace 实现的基础。毕竟，JVMTI (JVM Tool Interface) 原本的目的就是赋予使用者一个在运行中\n查询系统各项数据的权利\n\n当然，实现上，上述代码直接将各种增强(计时)硬编码到该进程中，同时统一使用了该进程的输入输出。\n\n但是，BTrace 通过 Socket 将这些分离，检测代码通过 Socket 发回新的进程来维持输入输出。\n\n在此，不再细说。\n\n## 附录\n\n\\[1\\]. 示例代码: [instru.zip](https://github.com/DorMOUSE-None/Repo/raw/master/instru.zip) \n\\[2\\]. [java.lang.instrument.Instrumentation](https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html)\n\\[3\\]. [Package java.lang.instrument](https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html)\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<h2>Start</h2>\n<p>从现有的前置知识来说，我们能够认识到两个事实:</p>\n<ol>\n<li>Java Class 通过 ClassLoader 进行加载。\n通过<code>全限定名</code>进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。\n换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)</li>\n<li>有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。\n当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧\n(虽然可能不了解细节。在此，欢迎学习前置技能 <a href="https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/">CGlib Enhancer 主流程源码解析</a> 和 <a href="https://dormouse-none.github.io/2018-07-20-Java-Proxy/">Java Proxy 源码解析</a>。不过不影响本文后续内容)</li>\n</ol>\n<p>另一个方面，也许绝大多数人都听说过所谓的<code>热部署</code>。但是究竟怎么才能做到 <code>热部署</code>(话题开得有点大哈。Y_Y 本文不讲这个)</p>\n<p>操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。</p>\n<p>如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚...</p>\n<p>Java 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的</p>\n<h2>Instrumentation</h2>\n<p><code>java.lang.instrument.Instrumentation</code> 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)</p>\n<p>相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。</p>\n<p>下列有两种方法可以达到目的</p>\n<ol>\n<li>当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。</li>\n<li>当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。</li>\n</ol>\n<p>话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了<em>检测</em>的目的)的使用</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>对各方法进行执行时间统计</h2>\n<h3>随 JVM 一起启动</h3>\n<p>基本实例: 将对特定包 <code>me.fangfeng.client</code> 下的每个方法执行计时</p>\n<p>首先了解一下 client 包的内容:</p>\n<pre><code class="hljs"><span class="hljs-keyword">package</span> me.fangfeng.client;\n\n<span class="hljs-comment">/**\n * Main.java\n * 执行两个方法，rand() &amp; sleep() \n *\n * <span class="hljs-doctag">@author</span> fangfeng\n * <span class="hljs-doctag">@since</span> 2018/8/7\n */</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{\n\n    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>{\n        <span class="hljs-keyword">try</span> {\n            Thread.sleep(<span class="hljs-number">5000</span>);\n        } <span class="hljs-keyword">catch</span> (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\n        Rand rand = <span class="hljs-keyword">new</span> Rand();\n\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) {\n            System.out.println(<span class="hljs-string">"&gt;&gt;&gt; start Rand.run() &lt;&lt;&lt;"</span>);\n            rand.run();\n            System.out.println(<span class="hljs-string">"&gt;&gt;&gt; end Rand.run() &lt;&lt;&lt;"</span>);\n\n            System.out.println();\n\n            System.out.println(<span class="hljs-string">"&gt;&gt;&gt; start Main.sleep() &lt;&lt;&lt;"</span>);\n            Main.sleep();\n            System.out.println(<span class="hljs-string">"&gt;&gt;&gt; end MAin.sleep() &lt;&lt;&lt;"</span>);\n\n            System.out.println();\n        }\n    }\n}</code></pre><pre><code class="hljs"><span class="hljs-keyword">package</span> me.fangfeng.client;\n\n<span class="hljs-comment">/**\n * Rand.java\n * <span class="hljs-doctag">@author</span> fangfeng\n * <span class="hljs-doctag">@since</span> 2018/8/7\n */</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rand</span> </span>{\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{\n        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {\n            <span class="hljs-keyword">double</span> rand = Math.random();\n            <span class="hljs-keyword">if</span> (rand &gt; <span class="hljs-number">0.995</span>) {\n                System.out.println(String.format(<span class="hljs-string">"get random, values %f"</span>, rand));\n                <span class="hljs-keyword">return</span>;\n            }\n        }\n    }\n}</code></pre><p>接着，来构造一个代理类，以及最重要的 <code>premain</code> 方法</p>\n<pre><code class="hljs"><span class="hljs-keyword">package</span> me.fangfeng.javaagent;\n\n<span class="hljs-keyword">import</span> java.lang.instrument.Instrumentation;\n\n<span class="hljs-comment">/**\n * Agent - 代理\n * 基于 JVM TI (JVM Tool Interface) 实现的 Java ClassFile 的增强\n * <span class="hljs-doctag">@author</span> fangfeng\n * <span class="hljs-doctag">@since</span> 2018/8/7\n */</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Agent</span> </span>{\n\n    <span class="hljs-comment">// premain 将 JVM 初始化后，main(String... ) 执行前调用</span>\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">premain</span><span class="hljs-params">(String args, Instrumentation instrumentation)</span> </span>{\n        <span class="hljs-comment">// new 一个转换器实例</span>\n        ClassTimer transformer = <span class="hljs-keyword">new</span> ClassTimer();\n        instrumentation.addTransformer(transformer);\n    }\n\n    <span class="hljs-comment">// 之后的 agentmain(...) 将在这里提供，暂时隐去，避免对对读者产生干扰</span>\n}</code></pre><pre><code class="hljs"><span class="hljs-keyword">package</span> me.fangfeng.javaagent;\n\n<span class="hljs-keyword">import</span> org.objectweb.asm.ClassReader;\n<span class="hljs-keyword">import</span> org.objectweb.asm.ClassWriter;\n<span class="hljs-keyword">import</span> org.objectweb.asm.Opcodes;\n\n<span class="hljs-keyword">import</span> java.lang.instrument.ClassFileTransformer;\n<span class="hljs-keyword">import</span> java.security.ProtectionDomain;\n\n<span class="hljs-comment">/**\n * <span class="hljs-doctag">@author</span> fangfeng\n * <span class="hljs-doctag">@since</span> 2018/8/7\n */</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassTimer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClassFileTransformer</span> </span>{\n\n    <span class="hljs-meta">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="hljs-keyword">byte</span>[] classfileBuffer) {\n        <span class="hljs-comment">// 这里涉及到了 ASM 的内容，主要目的是向每个方法块的开始及方法块的结束部分插入与计时器有关的代码</span>\n        <span class="hljs-comment">// 如果想了解 ASM 的内容，请参阅 https://dormouse-none.github.io/2018-06-25-ASM-Core/  提供了一些基础性的内容，更多的请自行学习</span>\n        <span class="hljs-comment">// 不了解具体内容将不影响对主体内容的理解</span>\n        ClassReader cr = <span class="hljs-keyword">new</span> ClassReader(classfileBuffer);\n        ClassWriter cw = <span class="hljs-keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES);\n        MyClassWriter mcw = <span class="hljs-keyword">new</span> MyClassWriter(Opcodes.ASM6, cw);\n        cr.accept(mcw, ClassReader.EXPAND_FRAMES);\n        <span class="hljs-keyword">return</span> cw.toByteArray();\n    }\n}</code></pre><p>其它代码略，详见附件。</p>\n<p>Java 这种对操作字节码的支持有个坑爹的地方，就是不得不打包成 Jar 来使用。</p>\n<p>具体来看一下</p>\n<p><code>me.fangfeng.javaagent</code> 包中包括</p>\n<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fublsbbdw0j309o07g74u.jpg" alt=""></p>\n<p>将被打包成 <code>agent.jar</code> 来使用</p>\n<p>首先，来看一下需要打包在 <code>agent.jar</code> 的 <strong>MANIFEST.MF</strong> 的内容</p>\n<pre><code>Manifest-Version: 1.0\nClass-Path: /Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar\nPremain-Class: me.fangfeng.javaagent.Agent\nCan-Retransform-Classes: true\n</code></pre>\n<p>再来个 SHELL 脚本，用来给打包这个 Jar</p>\n<pre><code class="hljs"><span class="hljs-meta">#!/bin/bash\n</span>\n<span class="hljs-comment"># 编译 me.fangfeng.javaagent 包下的类</span>\njavac -cp .:/Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar me/fangfeng/javaagent/Agent.java me/fangfeng/javaagent/ClassTimer.java me/fangfeng/javaagent/MyClassWriter.java me/fangfeng/javaagent/MyMethodWriter.java me/fangfeng/javaagent/StaticTimer.java\n\n<span class="hljs-comment"># 打包 me.fangfeng.javaagent 的 .class -&gt; agent.jar</span>\njar cvfm agent.jar MANIFEST-agent.MF me/fangfeng/javaagent/Agent.class me/fangfeng/javaagent/ClassTimer.class me/fangfeng/javaagent/MyClassWriter.class me/fangfeng/javaagent/MyMethodWriter.class me/fangfeng/javaagent/StaticTimer.class\n\n<span class="hljs-comment"># 编译 me.fangfeng.client 包下的类</span>\njavac me/fangfeng/client/Main.java me/fangfeng/client/Rand.java\n\n<span class="hljs-comment"># 以 me.fangfeng.client.Main 作为主类启动</span>\njava -javaagent:agent.jar me.fangfeng.client.Main</code></pre><p>执行后，可以看到类似如下内容:</p>\n<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fubmp354ejj30tq0rmtdp.jpg" alt=""></p>\n<p>而直接用 <code>java me.fangfeng.client.Main</code> 的执行结果是:</p>\n<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fubmqmj4uhj30j00f0dho.jpg" alt=""></p>\n<p>从理论上来讲，<code>-javaagent:agent.jar</code> 配合 <code>agent.jar</code> 中的 MANIFEST.MF 文件，\n使得 JVM 在初始化之后触发了被声明为 <code>Pre-Main</code> 的 me.fangfeng.javaagent.Agent 类的 premain(...) 方法。</p>\n<p>并为 ClassLoader 在加载类的流程上增加了一层<strong>拦截器</strong> (这里是 ClassTimer.java 类，它实现了 <code>ClassFileTransformer</code> 接口</p>\n<p>另外，<code>Can-Retransform-Classes: true</code> 的配置使得 ClassTimer 被允许对字节码进行重新转换。(而操作字节码是通过 ASM 来实现的)</p>\n<h3>在运行中进行增强</h3>\n<p>随着程序启动时直接使用了 <code>-javaagent</code> 选项。</p>\n<p>那么是否存在在程序运行中进行额外代理操作的支持呢？当然是可以的。这里要借助 Java 提供的另一个类 com.sun.tools.attach.VirtualMachine 。</p>\n<p>启动一个新的进程来连接到 正在运行中的进程，并令其加载 java agent。</p>\n<p>基本的类与上一节的描述相同，主要是包 <code>me.fangfeng.javaagent.*</code> 和 <code>me.fangfeng.client.*</code></p>\n<p>新增一个类 <code>me.fangfeng.javaagent.Main</code> 用来启动另一个进程，并要求运行中的 java 进程加载 agent.jar 来进行增强。</p>\n<pre><code class="hljs"><span class="hljs-keyword">package</span> me.fangfeng.javaagent;\n\n<span class="hljs-keyword">import</span> com.sun.tools.attach.AgentInitializationException;\n<span class="hljs-keyword">import</span> com.sun.tools.attach.AgentLoadException;\n<span class="hljs-keyword">import</span> com.sun.tools.attach.AttachNotSupportedException;\n<span class="hljs-keyword">import</span> com.sun.tools.attach.VirtualMachine;\n\n<span class="hljs-keyword">import</span> java.io.IOException;\n\n<span class="hljs-comment">/**\n * <span class="hljs-doctag">@author</span> fangfeng\n * <span class="hljs-doctag">@since</span> 2018/8/7\n */</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException </span>{\n        VirtualMachine vm = <span class="hljs-keyword">null</span>;\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-comment">// 通过 VirtualMachine 连接到 运行中的进程 (可以通过 jps 找到进程号)</span>\n            vm = VirtualMachine.attach(&lt;PID&gt;);\n            vm.loadAgent(&lt;agent.jar 的路径&gt;);\n        } <span class="hljs-keyword">finally</span> {\n            <span class="hljs-keyword">if</span> (vm != <span class="hljs-keyword">null</span>) {\n                vm.detach();\n            }\n        }\n    }\n}</code></pre><pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Agent</span> </span>{\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">premain</span><span class="hljs-params">(String args, Instrumentation instrumentation)</span> </span>{\n        ClassTimer transformer = <span class="hljs-keyword">new</span> ClassTimer();\n        instrumentation.addTransformer(transformer);\n    }\n\n    <span class="hljs-comment">// 现在在 Agent.java 上补上 agentmain(...) 的具体实现</span>\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">agentmain</span><span class="hljs-params">(String args, Instrumentation instrumentation)</span> <span class="hljs-keyword">throws</span> UnmodifiableClassException </span>{\n        System.out.println(<span class="hljs-string">"SUCCESS AGENTMAIN"</span>);\n        ClassTimer transformer = <span class="hljs-keyword">new</span> ClassTimer();\n        <span class="hljs-comment">// add Transformer</span>\n        instrumentation.addTransformer(transformer, <span class="hljs-keyword">true</span>);\n        <span class="hljs-comment">// 对 Rand.class 进行重新转换</span>\n        instrumentation.retransformClasses(Rand.class);\n    }\n}</code></pre><p>其它内容基本相同</p>\n<p>首先需要先打包 agent.jar 。当然，如果是顺着本文的顺序进行本机实验，则 agent.jar 已经存在</p>\n<p>先启动进程 <code>java me.fangfeng.client.Main</code></p>\n<p>通过 <code>jps</code> 获取 Main 进程的 <strong>PID</strong></p>\n<p>在 <code>java me.fangfeng.javaagent.Main</code> 中替换上进程号，并执行</p>\n<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuboclcelsj30tu152dlw.jpg" alt=""></p>\n<p>从执行结果可以看到，原进程首先正常执行代码，等到被 load Agent 之后，字节码已经有了新的变化，从而导致输出结果动态的产生了变化。</p>\n<p><em>当然，需要注意的是，执行中的进程被要求 load Agent 之后，运行中的 Class 将被改写，并始终如此，知道进程终止。再下一次重新启动</em></p>\n<h2>BTrace</h2>\n<p>以上描述的内容也可以理解为是 BTrace 实现的基础。毕竟，JVMTI (JVM Tool Interface) 原本的目的就是赋予使用者一个在运行中\n查询系统各项数据的权利</p>\n<p>当然，实现上，上述代码直接将各种增强(计时)硬编码到该进程中，同时统一使用了该进程的输入输出。</p>\n<p>但是，BTrace 通过 Socket 将这些分离，检测代码通过 Socket 发回新的进程来维持输入输出。</p>\n<p>在此，不再细说。</p>\n<h2>附录</h2>\n<p>[1]. 示例代码: <a href="https://github.com/DorMOUSE-None/Repo/raw/master/instru.zip">instru.zip</a>\n[2]. <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html">java.lang.instrument.Instrumentation</a>\n[3]. <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html">Package java.lang.instrument</a></p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-08-15-Java-Instrumentation.json",ext:".json",sourceBase:"2018-08-15-Java-Instrumentation.md",sourceExt:".md"}},mF68:function(n){n.exports={title:"如何获取运行时进程堆栈",author:"fangfeng",date:"2019-03-25T00:00:00.000Z",tags:["Kernel","Linux","dump"],bodyContent:'前些天看了关于在密码学应用中使用`java.lang.String`与`byte[]`的相关讨论，不推荐使用`java.lang.String`的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。\n\n## /proc/${pid}/maps\n\n首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从`/proc`虚拟文件系统中，提供了进程虚拟地址映射。\n\n```\naddress                   perm offset   dev   inode                      pathname\n556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run\n556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run\n556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run\n55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]\n7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0\n7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0\n7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0\n7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]\n7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]\n7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]\nffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\n```\n\x3c!-- more --\x3e\n\n`/proc/${pid}/maps` 记录了当前进程虚拟内存区域的分配以及其访问控制。\n- 前三行表述的是当前进程ELF文件在虚拟内存中的地址（这里使用的ELF文件名为 `run` ）\n    - 第一行 `r-xp` 表示其将配合`Code Segment Register (CS)` 作为CPU执行指令的直接依据。\n    - 第二三行分别用作可读、可写数据区，将配合 `Data Segment Register (DS), ES, FS, GS` 等使用\n- 第四行直截了当，就是分配给堆的地址空间。当然，如果不够，可以不断地向上扩张。\n- `xxx.so` 文件描述的是C共享库在虚拟内存中的地址。\n- 最后才是栈内存，将以倒序的方式下内存低地址扩张。\n- 至于之后的内容，不了解，不表。\n\n## ptrace\n\n拿到了进程虚拟内存分布，又如何获取其中的内容。`ptrace` 总算是派上用场了。之前在阅读内核源码的时候，任务数据结构 `struct task` 专门为此预留了一些字段来加以描述，但始终找不到其用途。现在总算对其有了初步的了解。\n\n一般来说，进程彼此之间应该相互独立，虽然运行在同一台机器上，但应该是相互间不知道其他进程的存在。那又如何能够通过一个进程的代码来获取另一个进程的堆栈数据呢？`ptrace` 提供的就是这么一种可能性。通过 `PTRACE_ATTACH` 和 `PTRACE_DETACH`，A进程会使得目标进程B陷入Sleeping状态，而等待A继续通过其他命令来获取其数据。至于为什么会是陷入Sleeping呢？一旦B进程的在运行，数据等随时可能改变，显然不适合读取数据啊。\n\n如何读取？`PTRACE_PEEKTEXT` 就是这样一个实现进程间交互的好工具。\n\n```c\nvoid attach()\n{\n    if (ptrace(PTRACE_ATTACH, options.pid, NULL, NULL) == -1)\n    {\n        fprintf(stderr, "ptract attach failed. %s(errno: %d)\\n", strerror(errno), errno);\n        exit(0);\n    }\n    fprintf(stderr, "attach to %d success!\\n", options.pid);\n    wait(NULL);\n}\n\nvoid peek()\n{\n    char maps[17];\n    sprintf(maps, "/proc/%d/maps", options.pid);\n    FILE *fd = fopen(maps, "r");\n    if (fd == NULL)\n    {\n        fprintf(stderr, "open /proc/%d/maps failed. %s(errno: %d)\\n", strerror(errno), errno);\n        exit(0);\n    }\n\n    struct map *map = (struct map *) malloc(sizeof(struct map *));\n\n    long word;\n    while (fscanf(fd, "%llx-%llx %s %lx %*s %*s%*[^\\n]", &map->start_addr, &map->end_addr, map->op_flag, &map->offset) != EOF)\n    {\n        if (map->op_flag[0] == \'-\')\n            continue;\n        fprintf(stderr, "peek from [%llx-%llx]\\n", map->start_addr, map->end_addr);\n        long mem_len = map->end_addr - map->start_addr;\n        char *data = malloc(mem_len + 1);\n        for (long cursor = map->start_addr;cursor < map->end_addr;cursor += sizeof(long))\n        {\n            if ((word = ptrace(PTRACE_PEEKTEXT, options.pid, cursor, NULL)) == -1 && errno)\n            {\n                fprintf(stderr, "peek failed. %s(errno: %d)\\n", strerror(errno), errno);\n                free(data);\n                exit(0);\n            }\n            memcpy(data+cursor-map->start_addr, &word, sizeof(word));\n        }\n        dump(data, mem_len);\n\n        free(data);\n    }\n\n    free(map);\n}\n\nvoid detach()\n{\n    if (ptrace(PTRACE_DETACH, options.pid, NULL, NULL) == -1)\n    {\n        fprintf("ptract detach failed. %s(errno: %d)\\n", strerror(errno), errno);\n        exit(0);\n    }\n    fprintf(stderr, "detach from %d success!", options.pid);\n}\n\nint main(int argc, char **argv)\n{\n    // ...\n\n    attach();\n    peek();\n    detach();\n}\n```\n\n此处的代码片段就能完成dump堆栈的工作了（当然，由于没有对其它内容进行处理，同时会dump下ELF数据等）。[完整代码](https://github.com/DorMOUSE-None/ffDump)\n\n## 小结\n\n当然，之后才发现 GDB 的实现借用的也正是这样一套机制。同时也意味着上面这段代码的实现在 GDB 中有现成的工具了:<\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<p>前些天看了关于在密码学应用中使用<code>java.lang.String</code>与<code>byte[]</code>的相关讨论，不推荐使用<code>java.lang.String</code>的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。</p>\n<h2>/proc/${pid}/maps</h2>\n<p>首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从<code>/proc</code>虚拟文件系统中，提供了进程虚拟地址映射。</p>\n<pre><code>address                   perm offset   dev   inode                      pathname\n556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run\n556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run\n556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run\n55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]\n7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0\n7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0\n7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0\n7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]\n7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]\n7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]\nffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\n</code></pre>\n<p>&lt;!-- more --&gt;</p>\n<p><code>/proc/${pid}/maps</code> 记录了当前进程虚拟内存区域的分配以及其访问控制。</p>\n<ul>\n<li>前三行表述的是当前进程ELF文件在虚拟内存中的地址（这里使用的ELF文件名为 <code>run</code> ）\n<ul>\n<li>第一行 <code>r-xp</code> 表示其将配合<code>Code Segment Register (CS)</code> 作为CPU执行指令的直接依据。</li>\n<li>第二三行分别用作可读、可写数据区，将配合 <code>Data Segment Register (DS), ES, FS, GS</code> 等使用</li>\n</ul>\n</li>\n<li>第四行直截了当，就是分配给堆的地址空间。当然，如果不够，可以不断地向上扩张。</li>\n<li><code>xxx.so</code> 文件描述的是C共享库在虚拟内存中的地址。</li>\n<li>最后才是栈内存，将以倒序的方式下内存低地址扩张。</li>\n<li>至于之后的内容，不了解，不表。</li>\n</ul>\n<h2>ptrace</h2>\n<p>拿到了进程虚拟内存分布，又如何获取其中的内容。<code>ptrace</code> 总算是派上用场了。之前在阅读内核源码的时候，任务数据结构 <code>struct task</code> 专门为此预留了一些字段来加以描述，但始终找不到其用途。现在总算对其有了初步的了解。</p>\n<p>一般来说，进程彼此之间应该相互独立，虽然运行在同一台机器上，但应该是相互间不知道其他进程的存在。那又如何能够通过一个进程的代码来获取另一个进程的堆栈数据呢？<code>ptrace</code> 提供的就是这么一种可能性。通过 <code>PTRACE_ATTACH</code> 和 <code>PTRACE_DETACH</code>，A进程会使得目标进程B陷入Sleeping状态，而等待A继续通过其他命令来获取其数据。至于为什么会是陷入Sleeping呢？一旦B进程的在运行，数据等随时可能改变，显然不适合读取数据啊。</p>\n<p>如何读取？<code>PTRACE_PEEKTEXT</code> 就是这样一个实现进程间交互的好工具。</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">()</span>\n</span>{\n    <span class="hljs-keyword">if</span> (ptrace(PTRACE_ATTACH, options.pid, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>)\n    {\n        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"ptract attach failed. %s(errno: %d)\\n"</span>, strerror(errno), errno);\n        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);\n    }\n    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"attach to %d success!\\n"</span>, options.pid);\n    wait(<span class="hljs-literal">NULL</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span>\n</span>{\n    <span class="hljs-keyword">char</span> maps[<span class="hljs-number">17</span>];\n    <span class="hljs-built_in">sprintf</span>(maps, <span class="hljs-string">"/proc/%d/maps"</span>, options.pid);\n    FILE *fd = fopen(maps, <span class="hljs-string">"r"</span>);\n    <span class="hljs-keyword">if</span> (fd == <span class="hljs-literal">NULL</span>)\n    {\n        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"open /proc/%d/maps failed. %s(errno: %d)\\n"</span>, strerror(errno), errno);\n        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);\n    }\n\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">map</span> *<span class="hljs-title">map</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">map</span> *) <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">map</span> *));</span>\n\n    <span class="hljs-keyword">long</span> word;\n    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(fd, <span class="hljs-string">"%llx-%llx %s %lx %*s %*s%*[^\\n]"</span>, &amp;<span class="hljs-built_in">map</span>-&gt;start_addr, &amp;<span class="hljs-built_in">map</span>-&gt;end_addr, <span class="hljs-built_in">map</span>-&gt;op_flag, &amp;<span class="hljs-built_in">map</span>-&gt;offset) != EOF)\n    {\n        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;op_flag[<span class="hljs-number">0</span>] == <span class="hljs-string">\'-\'</span>)\n            <span class="hljs-keyword">continue</span>;\n        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"peek from [%llx-%llx]\\n"</span>, <span class="hljs-built_in">map</span>-&gt;start_addr, <span class="hljs-built_in">map</span>-&gt;end_addr);\n        <span class="hljs-keyword">long</span> mem_len = <span class="hljs-built_in">map</span>-&gt;end_addr - <span class="hljs-built_in">map</span>-&gt;start_addr;\n        <span class="hljs-keyword">char</span> *data = <span class="hljs-built_in">malloc</span>(mem_len + <span class="hljs-number">1</span>);\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> cursor = <span class="hljs-built_in">map</span>-&gt;start_addr;cursor &lt; <span class="hljs-built_in">map</span>-&gt;end_addr;cursor += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>))\n        {\n            <span class="hljs-keyword">if</span> ((word = ptrace(PTRACE_PEEKTEXT, options.pid, cursor, <span class="hljs-literal">NULL</span>)) == <span class="hljs-number">-1</span> &amp;&amp; errno)\n            {\n                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"peek failed. %s(errno: %d)\\n"</span>, strerror(errno), errno);\n                <span class="hljs-built_in">free</span>(data);\n                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);\n            }\n            <span class="hljs-built_in">memcpy</span>(data+cursor-<span class="hljs-built_in">map</span>-&gt;start_addr, &amp;word, <span class="hljs-keyword">sizeof</span>(word));\n        }\n        dump(data, mem_len);\n\n        <span class="hljs-built_in">free</span>(data);\n    }\n\n    <span class="hljs-built_in">free</span>(<span class="hljs-built_in">map</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">()</span>\n</span>{\n    <span class="hljs-keyword">if</span> (ptrace(PTRACE_DETACH, options.pid, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>)\n    {\n        <span class="hljs-built_in">fprintf</span>(<span class="hljs-string">"ptract detach failed. %s(errno: %d)\\n"</span>, strerror(errno), errno);\n        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);\n    }\n    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"detach from %d success!"</span>, options.pid);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span>\n</span>{\n    <span class="hljs-comment">// ...</span>\n\n    attach();\n    peek();\n    detach();\n}</code></pre><p>此处的代码片段就能完成dump堆栈的工作了（当然，由于没有对其它内容进行处理，同时会dump下ELF数据等）。<a href="https://github.com/DorMOUSE-None/ffDump">完整代码</a></p>\n<h2>小结</h2>\n<p>当然，之后才发现 GDB 的实现借用的也正是这样一套机制。同时也意味着上面这段代码的实现在 GDB 中有现成的工具了:&lt;</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2019-03-25-mem-dump.json",ext:".json",sourceBase:"2019-03-25-mem-dump.md",sourceExt:".md"}},nYHc:function(n){n.exports={title:"java-memory-model",date:"2018-06-21T00:00:00.000Z",author:"fangfeng",tags:["Java","JVM","Memory Model"],bodyContent:"## JVM 运行时数据区\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg)\n\x3c!-- more --\x3e\n\n### PC寄存器\n\n与操作系统中的PC寄存器功能基本一致。毕竟 JVM 建立的初衷就是模拟一台机器。\n指向存储在**方法区**的字节码methods\\_info部分的内存地址。\n\n### 虚拟机栈\n\n**虚拟机栈**用于存储**栈帧**\n\n### 本地方法栈\n\n用于支持 native 方法的执行\n\n### 栈帧\n\n存储在**虚拟机栈**中，主要包括**局部变量表**和**操作数栈**(又称**当前栈帧的操作数栈**)以及**运行时常量池的引用**。\n\n*仍然有必要区别两个概念: 操作数 & 指令*\n*指令指使操作数进行相关操作的基本命令*\n*操作数通常指整数、浮点数以及类型引用等*\n\n### 方法区\n\n**方法区**是多个线程共享的一块区域，主要用于存储I/O操作中读入的类/接口的字节码(ClassFile 文件)\n包括有 constant\\_pool, field\\_info, method\\_info, attribute\\_info 等\n\n### Java堆\n\n用于存储各种类的实例对象\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```",bodyHtml:'<h2>JVM 运行时数据区</h2>\n<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg" alt="">\n&lt;!-- more --&gt;</p>\n<h3>PC寄存器</h3>\n<p>与操作系统中的PC寄存器功能基本一致。毕竟 JVM 建立的初衷就是模拟一台机器。\n指向存储在<strong>方法区</strong>的字节码methods_info部分的内存地址。</p>\n<h3>虚拟机栈</h3>\n<p><strong>虚拟机栈</strong>用于存储<strong>栈帧</strong></p>\n<h3>本地方法栈</h3>\n<p>用于支持 native 方法的执行</p>\n<h3>栈帧</h3>\n<p>存储在<strong>虚拟机栈</strong>中，主要包括<strong>局部变量表</strong>和<strong>操作数栈</strong>(又称<strong>当前栈帧的操作数栈</strong>)以及<strong>运行时常量池的引用</strong>。</p>\n<p><em>仍然有必要区别两个概念: 操作数 &amp; 指令</em>\n<em>指令指使操作数进行相关操作的基本命令</em>\n<em>操作数通常指整数、浮点数以及类型引用等</em></p>\n<h3>方法区</h3>\n<p><strong>方法区</strong>是多个线程共享的一块区域，主要用于存储I/O操作中读入的类/接口的字节码(ClassFile 文件)\n包括有 constant_pool, field_info, method_info, attribute_info 等</p>\n<h3>Java堆</h3>\n<p>用于存储各种类的实例对象</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-06-21-java-memory-model.json",ext:".json",sourceBase:"2018-06-21-java-memory-model.md",sourceExt:".md"}},tpF5:function(n){n.exports={title:"如何方便地获取 CGlib 生成类",author:"fangfeng",date:"2018-07-13T00:00:00.000Z",tags:["CGlib","tools"],bodyContent:'## 配置参数\n\n**命令行使用**\n\n在 java 启动命令中添加参数配置项 `-Dcglib.debugLocation=<Custom Path>`\n\n**编码实现**\n\n在执行 CGlib 获取新生成类之前，调用 `System.setProperty("cglib.debugLocation", <Custom Path>)`\n\n\x3c!-- more --\x3e\n\n## 如何游刃有余地 Debug 掺杂 CGlib 生成类的调用链\n\n经常会遇到，项目中不经意间就遇到了 CGlib 代理，然后对调用链的 Debug 就开始出现断层。继而，对对象或实例变量的跟踪就显得一头雾水。\n\n特别是在不了解生成类到底是增强了那些内容的时候，甚至可能连调用链都跟踪不下去了 T\\_T 。\n\n通过 **配置参数** 一节的内容，你就可以在你理想的目录 `<Custom Path>` 下看到**所谓黑盒**中生成类的完成内容了。\n\n下面的内容，将简单地介绍如何配合 CGlib 生成类的内容实现: 保证 Debug 的每一步骤可见; 保证 Debug 的过程不会出现*黑盒*。\n\n### 确定 `<Custom Path>` 下哪个文件是原有 Java 类的生成类\n\n```java\npublic String getClassName(String prefix, String source, Object key, Predicate names) {\n    if (prefix == null) {\n        prefix = "net.sf.cglib.empty.Object";\n    } else if (prefix.startsWith("java")) {\n        prefix = "$" + prefix;\n    }\n    String base =\n        prefix + "$$" +\n        source.substring(source.lastIndexOf(\'.\') + 1) +\n        getTag() + "$$" +\n        Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\n    String attempt = base;\n    int index = 2;\n    while (names.evaluate(attempt))\n        attempt = base + "_" + index++;\n    return attempt;\n}\n```\n\nCGlib 默认的类名生成策略下，生成类的全限定名将结合原文件的全限定名决定。\n\n通常命名如下: `<原 Java 类全限定名>$$<类似 EnhancerByCGlib>$$<生成类核心内容的 hash 值>_<index[可能存在]>`\n\n例如: 原有 Java 类全限定名为 me.fangfeng.Test ，则生成类名可能为 `me.fangfeng.Test$$EnhancerByCGlib$$ab1203aa`\n\n当然，通常情况下会存在一个类名形如 `me.fangfeng.Test$$FastClassBySpring$$...` 的类，这是作为生成类 `me.fangfeng.Test$$EnhancerByCGlib$$ab1203aa` 的辅助类来使用。\n\n### 简单了解生成类下的调用关系\n\nJava 代码触发被增强的类，将首先调用生成类。但是，这是没办法进行 Debug 的，因为这个生成类的字节码缺少 SourceFile 属性，同时缺少 LineNumberTable 属性。\n\n但是，这并不影响对调用链的跟踪。\n\nCGlib 的增强，所有的增强逻辑都是以 Callback 实现类的形式来提供的。同时在 CGlib 生成类中也有 Callback 的实例变量来持有这些注入的 Callback 。\n\n**原有 Java 类**\n\n![LogonService.java](https://ws3.sinaimg.cn/large/006tKfTcgy1ft8e7kr7qvj30sc0j0wh4.jpg)\n\n**对应的生成类**\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1ft8e9ww4hqj31hg0oojzv.jpg)\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eanb6c9j31j00lgn1e.jpg)\n\n**跟踪 LogonService.addLogon(String var1) 演示**\n\n当前 LogonService 的生成类全限定名为me.fangfeng.transactionBugs.LogonService$$EnhancerBySpringCGLIB$$bfc1dc3.class; 以下简称为 LogonSerivce$$bfc1dc3 \n\n1. 首先，配置 `cglib.debugLocation` 参数，值 = 项目生成的 .class 路径\n\n2. 无断点直接运行一次需要处理的逻辑\n\n3. 找到 LogonSerive$$bfc1dc3.class, 随意打上一个看似有效的断点\n\n4. 在各处打上必要的断点，开始进行真正的调试工作\n\n5. 代码执行到 LogonService$$bfc1dc3.class, 虽然没有真正进入断点位置, 但是可以看到这个 LogonService$$bfc1dc3 实例的实例变量信息\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1ft8eq1be61j319w0bwtde.jpg)\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1ft8egtg1naj31ji0fmgp2.jpg)\n\n比照生成类代码中 addLogon(String var1) 方法体的内容以及展示的实例变量信息。可以看到生成类调用的 Callback 实例是 `CGLIB$CALLBACK_0` \n类型是 CglibAopProxy 的静态内部私有类 DynamicAdvisedInterceptor 。\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eu91oscj31gq0ayju5.jpg)\n\n在 intercept(...) 上打个断点，跳过生成类 addLogon(String var1) 方法的下一个调用方法就是 intercept(...) \n\n**而且事实上，CGlib 生成类的内容基本也就是对调用方法进行的一种转发**\n\n6. 继续 Debug ，对于生成类的内容，人肉了解并定位到触发的 Callback 实例或者 super.Xxx() 方法。\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<h2>配置参数</h2>\n<p><strong>命令行使用</strong></p>\n<p>在 java 启动命令中添加参数配置项 <code>-Dcglib.debugLocation=&lt;Custom Path&gt;</code></p>\n<p><strong>编码实现</strong></p>\n<p>在执行 CGlib 获取新生成类之前，调用 <code>System.setProperty(&quot;cglib.debugLocation&quot;, &lt;Custom Path&gt;)</code></p>\n<p>&lt;!-- more --&gt;</p>\n<h2>如何游刃有余地 Debug 掺杂 CGlib 生成类的调用链</h2>\n<p>经常会遇到，项目中不经意间就遇到了 CGlib 代理，然后对调用链的 Debug 就开始出现断层。继而，对对象或实例变量的跟踪就显得一头雾水。</p>\n<p>特别是在不了解生成类到底是增强了那些内容的时候，甚至可能连调用链都跟踪不下去了 T_T 。</p>\n<p>通过 <strong>配置参数</strong> 一节的内容，你就可以在你理想的目录 <code>&lt;Custom Path&gt;</code> 下看到<strong>所谓黑盒</strong>中生成类的完成内容了。</p>\n<p>下面的内容，将简单地介绍如何配合 CGlib 生成类的内容实现: 保证 Debug 的每一步骤可见; 保证 Debug 的过程不会出现<em>黑盒</em>。</p>\n<h3>确定 <code>&lt;Custom Path&gt;</code> 下哪个文件是原有 Java 类的生成类</h3>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getClassName</span><span class="hljs-params">(String prefix, String source, Object key, Predicate names)</span> </span>{\n    <span class="hljs-keyword">if</span> (prefix == <span class="hljs-keyword">null</span>) {\n        prefix = <span class="hljs-string">"net.sf.cglib.empty.Object"</span>;\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prefix.startsWith(<span class="hljs-string">"java"</span>)) {\n        prefix = <span class="hljs-string">"$"</span> + prefix;\n    }\n    String base =\n        prefix + <span class="hljs-string">"$$"</span> +\n        source.substring(source.lastIndexOf(<span class="hljs-string">\'.\'</span>) + <span class="hljs-number">1</span>) +\n        getTag() + <span class="hljs-string">"$$"</span> +\n        Integer.toHexString(STRESS_HASH_CODE ? <span class="hljs-number">0</span> : key.hashCode());\n    String attempt = base;\n    <span class="hljs-keyword">int</span> index = <span class="hljs-number">2</span>;\n    <span class="hljs-keyword">while</span> (names.evaluate(attempt))\n        attempt = base + <span class="hljs-string">"_"</span> + index++;\n    <span class="hljs-keyword">return</span> attempt;\n}</code></pre><p>CGlib 默认的类名生成策略下，生成类的全限定名将结合原文件的全限定名决定。</p>\n<p>通常命名如下: <code>&lt;原 Java 类全限定名&gt;$$&lt;类似 EnhancerByCGlib&gt;$$&lt;生成类核心内容的 hash 值&gt;_&lt;index[可能存在]&gt;</code></p>\n<p>例如: 原有 Java 类全限定名为 me.fangfeng.Test ，则生成类名可能为 <code>me.fangfeng.Test$$EnhancerByCGlib$$ab1203aa</code></p>\n<p>当然，通常情况下会存在一个类名形如 <code>me.fangfeng.Test$$FastClassBySpring$$...</code> 的类，这是作为生成类 <code>me.fangfeng.Test$$EnhancerByCGlib$$ab1203aa</code> 的辅助类来使用。</p>\n<h3>简单了解生成类下的调用关系</h3>\n<p>Java 代码触发被增强的类，将首先调用生成类。但是，这是没办法进行 Debug 的，因为这个生成类的字节码缺少 SourceFile 属性，同时缺少 LineNumberTable 属性。</p>\n<p>但是，这并不影响对调用链的跟踪。</p>\n<p>CGlib 的增强，所有的增强逻辑都是以 Callback 实现类的形式来提供的。同时在 CGlib 生成类中也有 Callback 的实例变量来持有这些注入的 Callback 。</p>\n<p><strong>原有 Java 类</strong></p>\n<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft8e7kr7qvj30sc0j0wh4.jpg" alt="LogonService.java"></p>\n<p><strong>对应的生成类</strong></p>\n<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8e9ww4hqj31hg0oojzv.jpg" alt=""></p>\n<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eanb6c9j31j00lgn1e.jpg" alt=""></p>\n<p><strong>跟踪 LogonService.addLogon(String var1) 演示</strong></p>\n<p>当前 LogonService 的生成类全限定名为me.fangfeng.transactionBugs.LogonService$$EnhancerBySpringCGLIB$$bfc1dc3.class; 以下简称为 LogonSerivce$$bfc1dc3</p>\n<ol>\n<li>\n<p>首先，配置 <code>cglib.debugLocation</code> 参数，值 = 项目生成的 .class 路径</p>\n</li>\n<li>\n<p>无断点直接运行一次需要处理的逻辑</p>\n</li>\n<li>\n<p>找到 LogonSerive$$bfc1dc3.class, 随意打上一个看似有效的断点</p>\n</li>\n<li>\n<p>在各处打上必要的断点，开始进行真正的调试工作</p>\n</li>\n<li>\n<p>代码执行到 LogonService$$bfc1dc3.class, 虽然没有真正进入断点位置, 但是可以看到这个 LogonService$$bfc1dc3 实例的实例变量信息</p>\n</li>\n</ol>\n<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft8eq1be61j319w0bwtde.jpg" alt=""></p>\n<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8egtg1naj31ji0fmgp2.jpg" alt=""></p>\n<p>比照生成类代码中 addLogon(String var1) 方法体的内容以及展示的实例变量信息。可以看到生成类调用的 Callback 实例是 <code>CGLIB$CALLBACK_0</code>\n类型是 CglibAopProxy 的静态内部私有类 DynamicAdvisedInterceptor 。</p>\n<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eu91oscj31gq0ayju5.jpg" alt=""></p>\n<p>在 intercept(...) 上打个断点，跳过生成类 addLogon(String var1) 方法的下一个调用方法就是 intercept(...)</p>\n<p><strong>而且事实上，CGlib 生成类的内容基本也就是对调用方法进行的一种转发</strong></p>\n<ol start="6">\n<li>继续 Debug ，对于生成类的内容，人肉了解并定位到触发的 Callback 实例或者 super.Xxx() 方法。</li>\n</ol>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-07-13-How-to-easily-get-CGlib-generated-code.json",ext:".json",sourceBase:"2018-07-13-How-to-easily-get-CGlib-generated-code.md",sourceExt:".md"}},wCSB:function(n){n.exports={title:"SQL 注入",author:"fangfeng",date:"2018-12-15T00:00:00.000Z",tags:["Security","SQL"],bodyContent:"说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。\n\n最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。\n\n更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: \"我用不用现成的工具只是取决于我想不想自己再写一套\"\n\n当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。\n\n\x3c!-- more --\x3e\n\n## 概要\n\nSQL 注入漏洞究竟会产生怎么样的危害性，仅仅只是绕过某些登录账号密码的验证? 只是绕过某些访问限制实现特权内容的访问?\n\n此前我的认识也仅仅只是停留在这里。可谁曾想，SQL SELECT 语句真的是功能强大啊。通过各种各样的字符串拼接，最终能达到的目的，可以说把整个数据库的内容拖下来也不为过。当然，这也是限定在没有实现分库分表，数据库查询账号的权限过大的前提下。\n\n不过，这也就够了。只有真正认识到问题的严重性，最终才会想着去做出一些改善。\n\n## SQL 注入技术\n\n### 基于布尔的注入\n\n最早接触到 SQL 注入问题，还是两个月前。操作的内容也相当简单，猜解某账号的密码。\n\n某接口提供了查询账号的功能，后台的拼接 SQL 可以简单理解成 `SELECT * FROM users WHERE username = '${}'` 。其中 `${}` 就是直接使用的接口请求参数。\n\n而接口的请求结果会根据 SQL 查询的结果，有或没有记录呈现两个不同的页面。\n\n这算是最简单容易的 SQL 注入了，也是凭借个人能力直接能够想到注入点的问题了。\n\n最先做的就是猜解存储密码字段的字段名究竟是什么? 很好，符合常理的设计，直接就是 `passwd` 。\n\n下面就是苦力工作，利用 SQL LIKE 操作符，逐一去猜每一位。`${}` 的注入内容就类似 `admin' AND passwd LIKE '?%` 这里的问号就是逐一猜解的内容(1-9a-zA-Z + 特殊符号)\n\n至于为什么利用 LIKE 操作符，很明确，减少猜解的次数。否则，在密码未知的情况下，即使六位密码也有猜解百万次。而 LIKE 操作符能将猜解次数降为线性，`密码长度 * 字符集数` 次\n\n这里仅仅用了 `AND`，但熟悉了一个，其它就基本类似了。\n\n如果登录也能够注入，认证 SQL 类似 `SELECT * FROM users WHERE username = '${}' AND passwd = '${}'`，那么直接在第一个 `${}` 处注入 `admin' OR 1=1; -- `\n\n### 基于时间的注入\n\n绝大多数时候，注入绝对没有这么简单。也许注入点背后的拼接 SQL 并不对返回值产生影响。例如仅仅只是为了从 DB 查询用户信息，并打一条日志，返回的永远是静态日志（当然，我知道这个例子不恰当，无奈目前只能想到这个）。\n\n既然拼接 SQL 总是存在，但没法给我们一个直观的注入成功 OR 失败的提示。那么，时间就成了一个最好的判断。毕竟是阻塞式的执行。\n\n还是以 `SELECT * FROM users WHERE username = '${}'` 为例，使用类似 `admin' AND IF(passwd LIKE '5%', SLEEP(5), 1);-- ` 的 PAYLOAD ，当满足 `passwd` 以 5 开始时，则 IF 判断进入 `SLEEP(5)` ，根据网页的响应时长就可以进行相应的判断。\n\n### 基于报错的注入\n\n这应该也算一种比较容易自动化的注入方式了。其实在猜解存储密码字段的字段名时，前面也是这样用的。\n\n```sql\n> SELECT * FROM users WHERE password ='1';\nERROR 1054 (42S22): Unknown column 'password' in 'where clause'\n```\n\n如果程序不做任何处理，对 SQL 错误直接抛出，那么，通过这个就能获得相当多的信息。\n\n由于这部分接触不深，仅仅给出 sqlmap 提的 PAYLOAD\n\n```\nAND (SELECT [RANDNUM] FROM(SELECT COUNT(*),CONCAT('[DELIMITER_START]',([QUERY]),'[DELIMITER_STOP]',FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)\n```\n\n很标准的 PAYLOAD，而且完全可以。`INFORMATION_SCHEMA` 库的表对所有用户都可查，因此不存在授权的问题。而且表中数据至少大于等于 3 条。\n\n这个 PAYLOAD 一定导致报错的主因，就是对 `RAND()` 与 `GROUP BY` 的配合应用。\n\n> Use of a column with RAND() values in an ORDER BY or GROUP BY clause may yield unexpected results because for either clause a RAND() expression can be evaluated multiple times for the same row, each time returning a different result. If the goal is to retrieve rows in random order, you can use a statement like this:\n\n而真正想要得到的内容，通过 `CONCAT('[DELIMITER_START]',([QUERY]),'[DELIMITER_STOP]',FLOOR(RAND(0)*2))x` 得到，`[QUERY]` 就是真正想要注入的完整SQL串。\n\n而这里的 `DELIMITER_START` `DELIMITER_STOP` 作为界定符，帮助程序提取 `[QUERY]` 得到的结果。否则，直接对请求返回的结果进行过滤可真是太困难了。\n\n### 联合查询注入\n\n联合查询，应该算是最顾名思义的注入方式。使用 `UNION` 在原 SQL 已经限定了查询表的前提下，获得数据库其它库表的信息。\n\nLIKE: `1' UNION SELECT * FROM users;-- ` 这样的 PAYLOAD。\n\n### 堆查询注入\n\n我想这应该是最让人摸不着头脑的命名方式了。\n\n形象化的，我们利用 PAYLOAD 来进行说明。`1'; INSERT INTO users (user, passwd) VALUES ('aaa', 'aaa');-- `\n\n看起来和 UNION 挺像的哈，都是补充上一个 OR 多个 SQL 。当然，也是有区别的，否则为什么会出现这样一种技术呢。\n\n最大的区别，就是堆查询注入能够完成 `UPDATE`, `INSERT`, `DELETE` 等操作，毕竟，UNION 联合的只能是作为查询了（可能说法不太恰当，但姑且这样吧）\n\n### 另类注入\n\n之前的几种，我们都是利用了 `SELECT` 完成的注入，那么对于 `INSERT`, `UPDATE` 之类的语句是否有注入的可能呢。当然也是存在可能的。\n\n不过，精力有限，而且目前看来也不需要做到这一步。暂时挖个坑吧。不填\n\n## SQLMAP \n\n简单的了解了几种注入原理之后，还是要看看 SQL 注入神器的——`SQLMAP`\n\n也算是尝试了好久才真正了解它的强大之处。此处强烈推荐 DVWA，`Damn Vulnerable Web Application`，一个用来合法攻击的工具。\n\n部署方式也是开箱可用，只要有 docker，直接 `docker run --rm -it -p 80:80 vulnerables/web-dvwa` 即可完成部署。\n\n对于将 DVWA 安全级别设置为 low 时，仅仅只需要执行下列命令就可以获取到 DB 里几乎完整的信息。\n\n```sh\n$ sqlmap -u http://127.0.0.1/vulnerabilities/sqli/\\?id\\=1\\&Submit\\=Submit\\# --cookie=\"PHPSESSID=jhton35qahj78l3unjea9k2lf7;security=low\" -v 3 --banner\n```\n\n当然，换一下相关获取的内容，例如把 `--banner` 换成 `--dump` ，我们借此来简单看看 SQL 注入漏洞的可怕之处\n\n```sh\n[10:41:39] [INFO] using default dictionary\ndo you want to use common password suffixes? (slow!) [y/N]\n[10:41:40] [INFO] starting dictionary-based cracking (md5_generic_passwd)\n[10:41:40] [INFO] starting 8 processes\n[10:41:42] [INFO] cracked password 'abc123' for hash 'e99a18c428cb38d5f260853678922e03'\n[10:41:44] [INFO] cracked password 'charley' for hash '8d3533d75ae2c3966d7e0d4fcc69216b'\n[10:41:47] [INFO] cracked password 'letmein' for hash '0d107d09f5bbe40cade3de5c71e9e9b7'\n[10:41:49] [INFO] cracked password 'password' for hash '5f4dcc3b5aa765d61d8327deb882cf99'\n[10:41:53] [DEBUG] post-processing table dump\nDatabase: dvwa\nTable: users\n[5 entries]\n+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+\n| user_id | avatar                      | user    | password                                    | last_name | first_name | last_login          | failed_login |\n+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+\n| 1       | /hackable/users/admin.jpg   | admin   | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin     | admin      | 2018-12-15 00:42:31 | 0            |\n| 2       | /hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123)   | Brown     | Gordon     | 2018-12-15 00:42:31 | 0            |\n| 3       | /hackable/users/1337.jpg    | 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b (charley)  | Me        | Hack       | 2018-12-15 00:42:31 | 0            |\n| 4       | /hackable/users/pablo.jpg   | pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein)  | Picasso   | Pablo      | 2018-12-15 00:42:31 | 0            |\n| 5       | /hackable/users/smithy.jpg  | smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith     | Bob        | 2018-12-15 00:42:31 | 0            |\n+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+\n```\n\n这里就可以看到 `dvwa.users` 表的全部内容，甚至连简单密码都帮你完成了爆破。\n\n更多内容可以自行尝试，说真的，这个工具相当强大。如果仅仅说我针对某型数据库(例如 MySQL)完成诸如基于报错的注入，在不考虑鲁棒性的情况下，完全可以做到。但是支持超10余种数据库，且自动完成注入的全过程...\n\n## 预编译 SQL\n\n提了这么多，究竟 SQL 注入就不能够预防吗? 当然可以，不然整个网络环境下的WEB应用不得都完蛋了。有釜底抽薪的处理方式吗，也有。\n\n预编译 SQL 就是一个超级 OK 的解决方案。同时在使用上也能够明显提升 DB 查询效率\n\n我相信预编译 SQL 很多人写过，毕竟借助例如 MyBatis 框架，能够快速实现 SQL 预编译语句的编写。同时在求学过程中估计也都用过 Java 原生 JDBC 的 `PreparedStatement` 。\n\n那么，与 MySQL 交互时的预编译 SQL 是怎么样地填上了占位符呢? 先来看看再说\n\n```sql\nmysql> prepare {name} from 'SELECT * FROM users WHERE user=? AND passwd=?'; # 这里的 {name} 可以自定义命名，无需 {}\n\nmysql> set @a='admin', @b='password';     # 声明变量，并赋值\n\nmysql> execute {name} using @a, @b;     # 提供变量并执行预编译 SQL\n```\n\n我想看到这里应该就应该能够明白了吧，MySQL 对于预编译 SQL 的每一个占位符，都已经认定了是单一的元素，也就不可能存在允许打破已有预编译结果的内容了。\n\n即使真的注入了 `admin OR 1=1` 之类的内容，也是会被认为这是一个完整的字符串，用来替代 `user` 字段或 `passwd` 字段，根本不可能重新拆解。\n\n ```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```",bodyHtml:"<p>说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。</p>\n<p>最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。</p>\n<p>更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: &quot;我用不用现成的工具只是取决于我想不想自己再写一套&quot;</p>\n<p>当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>概要</h2>\n<p>SQL 注入漏洞究竟会产生怎么样的危害性，仅仅只是绕过某些登录账号密码的验证? 只是绕过某些访问限制实现特权内容的访问?</p>\n<p>此前我的认识也仅仅只是停留在这里。可谁曾想，SQL SELECT 语句真的是功能强大啊。通过各种各样的字符串拼接，最终能达到的目的，可以说把整个数据库的内容拖下来也不为过。当然，这也是限定在没有实现分库分表，数据库查询账号的权限过大的前提下。</p>\n<p>不过，这也就够了。只有真正认识到问题的严重性，最终才会想着去做出一些改善。</p>\n<h2>SQL 注入技术</h2>\n<h3>基于布尔的注入</h3>\n<p>最早接触到 SQL 注入问题，还是两个月前。操作的内容也相当简单，猜解某账号的密码。</p>\n<p>某接口提供了查询账号的功能，后台的拼接 SQL 可以简单理解成 <code>SELECT * FROM users WHERE username = '${}'</code> 。其中 <code>${}</code> 就是直接使用的接口请求参数。</p>\n<p>而接口的请求结果会根据 SQL 查询的结果，有或没有记录呈现两个不同的页面。</p>\n<p>这算是最简单容易的 SQL 注入了，也是凭借个人能力直接能够想到注入点的问题了。</p>\n<p>最先做的就是猜解存储密码字段的字段名究竟是什么? 很好，符合常理的设计，直接就是 <code>passwd</code> 。</p>\n<p>下面就是苦力工作，利用 SQL LIKE 操作符，逐一去猜每一位。<code>${}</code> 的注入内容就类似 <code>admin' AND passwd LIKE '?%</code> 这里的问号就是逐一猜解的内容(1-9a-zA-Z + 特殊符号)</p>\n<p>至于为什么利用 LIKE 操作符，很明确，减少猜解的次数。否则，在密码未知的情况下，即使六位密码也有猜解百万次。而 LIKE 操作符能将猜解次数降为线性，<code>密码长度 * 字符集数</code> 次</p>\n<p>这里仅仅用了 <code>AND</code>，但熟悉了一个，其它就基本类似了。</p>\n<p>如果登录也能够注入，认证 SQL 类似 <code>SELECT * FROM users WHERE username = '${}' AND passwd = '${}'</code>，那么直接在第一个 <code>${}</code> 处注入 <code>admin' OR 1=1; --</code></p>\n<h3>基于时间的注入</h3>\n<p>绝大多数时候，注入绝对没有这么简单。也许注入点背后的拼接 SQL 并不对返回值产生影响。例如仅仅只是为了从 DB 查询用户信息，并打一条日志，返回的永远是静态日志（当然，我知道这个例子不恰当，无奈目前只能想到这个）。</p>\n<p>既然拼接 SQL 总是存在，但没法给我们一个直观的注入成功 OR 失败的提示。那么，时间就成了一个最好的判断。毕竟是阻塞式的执行。</p>\n<p>还是以 <code>SELECT * FROM users WHERE username = '${}'</code> 为例，使用类似 <code>admin' AND IF(passwd LIKE '5%', SLEEP(5), 1);--</code> 的 PAYLOAD ，当满足 <code>passwd</code> 以 5 开始时，则 IF 判断进入 <code>SLEEP(5)</code> ，根据网页的响应时长就可以进行相应的判断。</p>\n<h3>基于报错的注入</h3>\n<p>这应该也算一种比较容易自动化的注入方式了。其实在猜解存储密码字段的字段名时，前面也是这样用的。</p>\n<pre><code class=\"hljs\">&gt; SELECT * FROM users WHERE password ='1';\nERROR 1054 (42S22): Unknown column 'password' in 'where clause'</code></pre><p>如果程序不做任何处理，对 SQL 错误直接抛出，那么，通过这个就能获得相当多的信息。</p>\n<p>由于这部分接触不深，仅仅给出 sqlmap 提的 PAYLOAD</p>\n<pre><code>AND (SELECT [RANDNUM] FROM(SELECT COUNT(*),CONCAT('[DELIMITER_START]',([QUERY]),'[DELIMITER_STOP]',FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)\n</code></pre>\n<p>很标准的 PAYLOAD，而且完全可以。<code>INFORMATION_SCHEMA</code> 库的表对所有用户都可查，因此不存在授权的问题。而且表中数据至少大于等于 3 条。</p>\n<p>这个 PAYLOAD 一定导致报错的主因，就是对 <code>RAND()</code> 与 <code>GROUP BY</code> 的配合应用。</p>\n<blockquote>\n<p>Use of a column with RAND() values in an ORDER BY or GROUP BY clause may yield unexpected results because for either clause a RAND() expression can be evaluated multiple times for the same row, each time returning a different result. If the goal is to retrieve rows in random order, you can use a statement like this:</p>\n</blockquote>\n<p>而真正想要得到的内容，通过 <code>CONCAT('[DELIMITER_START]',([QUERY]),'[DELIMITER_STOP]',FLOOR(RAND(0)*2))x</code> 得到，<code>[QUERY]</code> 就是真正想要注入的完整SQL串。</p>\n<p>而这里的 <code>DELIMITER_START</code> <code>DELIMITER_STOP</code> 作为界定符，帮助程序提取 <code>[QUERY]</code> 得到的结果。否则，直接对请求返回的结果进行过滤可真是太困难了。</p>\n<h3>联合查询注入</h3>\n<p>联合查询，应该算是最顾名思义的注入方式。使用 <code>UNION</code> 在原 SQL 已经限定了查询表的前提下，获得数据库其它库表的信息。</p>\n<p>LIKE: <code>1' UNION SELECT * FROM users;--</code> 这样的 PAYLOAD。</p>\n<h3>堆查询注入</h3>\n<p>我想这应该是最让人摸不着头脑的命名方式了。</p>\n<p>形象化的，我们利用 PAYLOAD 来进行说明。<code>1'; INSERT INTO users (user, passwd) VALUES ('aaa', 'aaa');--</code></p>\n<p>看起来和 UNION 挺像的哈，都是补充上一个 OR 多个 SQL 。当然，也是有区别的，否则为什么会出现这样一种技术呢。</p>\n<p>最大的区别，就是堆查询注入能够完成 <code>UPDATE</code>, <code>INSERT</code>, <code>DELETE</code> 等操作，毕竟，UNION 联合的只能是作为查询了（可能说法不太恰当，但姑且这样吧）</p>\n<h3>另类注入</h3>\n<p>之前的几种，我们都是利用了 <code>SELECT</code> 完成的注入，那么对于 <code>INSERT</code>, <code>UPDATE</code> 之类的语句是否有注入的可能呢。当然也是存在可能的。</p>\n<p>不过，精力有限，而且目前看来也不需要做到这一步。暂时挖个坑吧。不填</p>\n<h2>SQLMAP</h2>\n<p>简单的了解了几种注入原理之后，还是要看看 SQL 注入神器的——<code>SQLMAP</code></p>\n<p>也算是尝试了好久才真正了解它的强大之处。此处强烈推荐 DVWA，<code>Damn Vulnerable Web Application</code>，一个用来合法攻击的工具。</p>\n<p>部署方式也是开箱可用，只要有 docker，直接 <code>docker run --rm -it -p 80:80 vulnerables/web-dvwa</code> 即可完成部署。</p>\n<p>对于将 DVWA 安全级别设置为 low 时，仅仅只需要执行下列命令就可以获取到 DB 里几乎完整的信息。</p>\n<pre><code class=\"hljs\">$ sqlmap -u http://127.0.0.1/vulnerabilities/sqli/\\?id\\=1\\&amp;Submit\\=Submit\\<span class=\"hljs-comment\"># --cookie=\"PHPSESSID=jhton35qahj78l3unjea9k2lf7;security=low\" -v 3 --banner</span></code></pre><p>当然，换一下相关获取的内容，例如把 <code>--banner</code> 换成 <code>--dump</code> ，我们借此来简单看看 SQL 注入漏洞的可怕之处</p>\n<pre><code class=\"hljs\">[10:41:39] [INFO] using default dictionary\n<span class=\"hljs-keyword\">do</span> you want to use common password suffixes? (slow!) [y/N]\n[10:41:40] [INFO] starting dictionary-based cracking (md5_generic_passwd)\n[10:41:40] [INFO] starting 8 processes\n[10:41:42] [INFO] cracked password <span class=\"hljs-string\">'abc123'</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">hash</span> <span class=\"hljs-string\">'e99a18c428cb38d5f260853678922e03'</span>\n[10:41:44] [INFO] cracked password <span class=\"hljs-string\">'charley'</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">hash</span> <span class=\"hljs-string\">'8d3533d75ae2c3966d7e0d4fcc69216b'</span>\n[10:41:47] [INFO] cracked password <span class=\"hljs-string\">'letmein'</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">hash</span> <span class=\"hljs-string\">'0d107d09f5bbe40cade3de5c71e9e9b7'</span>\n[10:41:49] [INFO] cracked password <span class=\"hljs-string\">'password'</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">hash</span> <span class=\"hljs-string\">'5f4dcc3b5aa765d61d8327deb882cf99'</span>\n[10:41:53] [DEBUG] post-processing table dump\nDatabase: dvwa\nTable: users\n[5 entries]\n+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+\n| user_id | avatar                      | user    | password                                    | last_name | first_name | last_login          | failed_login |\n+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+\n| 1       | /hackable/users/admin.jpg   | admin   | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin     | admin      | 2018-12-15 00:42:31 | 0            |\n| 2       | /hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123)   | Brown     | Gordon     | 2018-12-15 00:42:31 | 0            |\n| 3       | /hackable/users/1337.jpg    | 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b (charley)  | Me        | Hack       | 2018-12-15 00:42:31 | 0            |\n| 4       | /hackable/users/pablo.jpg   | pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein)  | Picasso   | Pablo      | 2018-12-15 00:42:31 | 0            |\n| 5       | /hackable/users/smithy.jpg  | smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith     | Bob        | 2018-12-15 00:42:31 | 0            |\n+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+</code></pre><p>这里就可以看到 <code>dvwa.users</code> 表的全部内容，甚至连简单密码都帮你完成了爆破。</p>\n<p>更多内容可以自行尝试，说真的，这个工具相当强大。如果仅仅说我针对某型数据库(例如 MySQL)完成诸如基于报错的注入，在不考虑鲁棒性的情况下，完全可以做到。但是支持超10余种数据库，且自动完成注入的全过程...</p>\n<h2>预编译 SQL</h2>\n<p>提了这么多，究竟 SQL 注入就不能够预防吗? 当然可以，不然整个网络环境下的WEB应用不得都完蛋了。有釜底抽薪的处理方式吗，也有。</p>\n<p>预编译 SQL 就是一个超级 OK 的解决方案。同时在使用上也能够明显提升 DB 查询效率</p>\n<p>我相信预编译 SQL 很多人写过，毕竟借助例如 MyBatis 框架，能够快速实现 SQL 预编译语句的编写。同时在求学过程中估计也都用过 Java 原生 JDBC 的 <code>PreparedStatement</code> 。</p>\n<p>那么，与 MySQL 交互时的预编译 SQL 是怎么样地填上了占位符呢? 先来看看再说</p>\n<pre><code class=\"hljs\">mysql&gt; prepare {name} from 'SELECT * FROM users WHERE user=? AND passwd=?'; # 这里的 {name} 可以自定义命名，无需 {}\n\nmysql&gt; set @a='admin', @b='password';     # 声明变量，并赋值\n\nmysql&gt; execute {name} using @a, @b;     # 提供变量并执行预编译 SQL</code></pre><p>我想看到这里应该就应该能够明白了吧，MySQL 对于预编译 SQL 的每一个占位符，都已经认定了是单一的元素，也就不可能存在允许打破已有预编译结果的内容了。</p>\n<p>即使真的注入了 <code>admin OR 1=1</code> 之类的内容，也是会被认为这是一个完整的字符串，用来替代 <code>user</code> 字段或 <code>passwd</code> 字段，根本不可能重新拆解。</p>\n<pre><code class=\"hljs\">__                    __                  \n/ _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                |___/                |___/</code></pre>",preview:"",dir:"content",base:"2018-12-15-sql-injection.json",ext:".json",sourceBase:"2018-12-15-sql-injection.md",sourceExt:".md"}},xo5S:function(n){n.exports={title:"JVM 指令简析",author:"fangfeng",date:"2018-07-24T00:00:00.000Z",tags:["JVM","Instruction"],bodyContent:'在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。\n\n当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。\n那么，直接阅读 [官方文档](https://docs.oracle.com/javase/specs/jvms/se8/html/index.html) 绝对是比本文的内容更为详实且准确。\n\n这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。\n\n\x3c!-- more --\x3e\n\n## 术语约定\n\n首先，需要就 `术语` 进行一些基础性的约定:\n\n### 变量\n\n![变量](https://ws3.sinaimg.cn/large/006tNc79gy1ftidi0xpmij30oa07kaaq.jpg)\n\n- `变量`: 在类中，区分于 `方法` 的声明\n  - `成员变量`: 作用域为整个类，在方法体与语句块之外声明的内容。在 `字节码` 中通常被称为 `字段(Field)`\n    - `类成员变量 / 静态成员变量`: 被 `static` 修饰的 `成员变量`。一个类只有一份，在类被加载的时候即初始化。\n    - `实例成员变量`: 非 `static` 修饰的 `成员变量`。随着类被实例化而进行初始化，每个实例对象都有一份特有的 `实例变量`。\n  - `局部变量`: 作用域为方法体或者语句块。\n\n### JVM 指令\n\n通常，我们借助于 `javap` 命令来对 .class 文件的字节码内容进行查阅。\n\n类似于汇编代码，`javap` 打印的JVM 指令将以下列格式进行展示:\n\n```plain\n<index> <opcode> [<operand1> [<operand2> ...]] [<comment>]\n```\n\n其中 \n- `<index>` 指在 `code[]` 属性中这条指令的偏移量(从 0 开始计数)。\n- `<opcode>` 指 `操作码`\n- `<operandX>` 指 `操作数`，每个 `<opcode>` 都需要确定数量的操作数(规范中已经确定)。\n- `<comment>` 指注释\n\n## 指令集概览\n\n首先，Java 代码经编译后的所有指令都基于 `方法(Method)` 被定义在 `Code` 属性中。\n\n在 [ClassFile](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3) 的 `Code` 属性，结构定义如下:\n\n```java\nCode_attribute {\n    // 其中 u1, u2, u4 分别表示这个变量所占的字节长度\n    u2 attribute_name_index;                    // 属性名在常量池中的 index (执行常量池中 Code 的位置)\n    u4 attribute_length;                        // 属性长度，不包括开始的六个字节\n    u2 max_stack;                               // 运行时操作数栈的最大深度\n    u2 max_locals;                              // 运行时所需的局部变量表的大小\n    u4 code_length;                             // code 数组的长度\n    u1 code[code_length];                       // code 数组，编译后方法体的内容都通过字节码指令存储在这里\n    u2 exception_table_length;                  // 异常表的长度\n    {   u2 start_pc;\n        u2 end_pc;\n        u2 handler_pc;\n        u2 catch_type;\n    } exception_table[exception_table_length]; // 异常表，Java 代码中所有的 catch, finally 的捕获都将由此表进行实现\n    u2 attributes_count;                       // 属性计数\n    attribute_info attributes[attributes_count];\n}\n```\n\nJava 虚拟机的指令是由一个字节长度的 `操作码` 配合上其后的 0 个或多个 `操作数` 所构成的。\n\n其中，`操作数` 的数量取决于 `操作码`，不同的 `操作码` 需要不同数量的 `操作数`。\n\n按照类型划分，`操作数` 主要包括下列几类:\n\n- 加载与存储指令，例如 iload, istore 等\n- 运算指令，例如 iadd, isub, imul 等\n- 类型转换指令，例如 i2b, i2s 等\n- 对象创建与操作指令，例如 new, newarray 等\n- 操作数栈管理指令，例如 dup, pop 等\n- 控制转移指令，例如 if\\_icmpeq 等\n- 方法调用与返回指令，例如 invokevirtual, invokestatic 等\n- 抛出异常指令，例如 athrow 等\n- 同步指令，例如 monitorenter 等\n\n**举几个简单的例子:**\n\n`iadd` 指令，表示对两个 int 数的相加指令。将从操作数栈顶依次取出两个数，并相加，再重新压入操作数栈中。\n\n`bipush 100` ，其中 `bipush` 是指令，后随一个操作数，表示把 `操作数 100 这个 byte 类型的数` 压入操作数栈顶\n\n## 运行时数据区\n\nJVM 定义了若干种运行期间会使用到的运行时数据区，见下图:\n\n![JVM 运行时数据区](https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg)\n\n至于每一个的具体意义，在此不做详细展开，可用参考:\n\n- 由周志明等翻译的 《Java 虚拟机规范(Java SE 7版) 》 2.5节内容 [链接](http://icyfenix.iteye.com/blog/1256329)\n- [JVMS 2.5. Run-Time Data Areas](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5)\n\n## Getter, Setter 的指令代码\n\n首先，有必要提及，想要得到 .class 可视且友好的展示结果，可以使用 JDK 自带的 `javap` 命令。\n\n本节要展示的内容是常见的 POJO 的 get, set 方法的指令代码。使用的示例代码如下:\n\n```java\npublic class Test {\n    \n    private int number;\n\n    public int getNumber() {\n        return number;\n    }\n\n    public void setNumber(int number) {\n        this.number = number;\n    }\n}\n```\n\n在经过 `javac` 编译，`javap` 解析之后，我们将看到下列内容\n\n```plain\nClassfile /Users/fangfeng/WorkPkg/lab/src/main/java/me/fangfeng/asm/Test.class\n  Last modified Jul 23, 2018; size 357 bytes\n  MD5 checksum bb1940cc6534d789359295b8dc80233b\n  Compiled from "Test.java"\npublic class me.fangfeng.asm.Test\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #4.#17         // java/lang/Object."<init>":()V\n   #2 = Fieldref           #3.#18         // me/fangfeng/asm/Test.number:I\n   #3 = Class              #19            // me/fangfeng/asm/Test\n   #4 = Class              #20            // java/lang/Object\n   #5 = Utf8               number\n   #6 = Utf8               I\n   #7 = Utf8               <init>\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               getNumber\n  #12 = Utf8               ()I\n  #13 = Utf8               setNumber\n  #14 = Utf8               (I)V\n  #15 = Utf8               SourceFile\n  #16 = Utf8               Test.java\n  #17 = NameAndType        #7:#8          // "<init>":()V\n  #18 = NameAndType        #5:#6          // number:I\n  #19 = Utf8               me/fangfeng/asm/Test\n  #20 = Utf8               java/lang/Object\n{\n  public me.fangfeng.asm.Test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object."<init>":()V\n         4: return\n      LineNumberTable:\n        line 3: 0\n\n  public int getNumber();\n    descriptor: ()I\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field number:I\n         4: ireturn\n      LineNumberTable:\n        line 8: 0\n\n  public void setNumber(int);\n    descriptor: (I)V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=2\n         0: aload_0\n         1: iload_1\n         2: putfield      #2                  // Field number:I\n         5: return\n      LineNumberTable:\n        line 12: 0\n        line 13: 5\n}\nSourceFile: "Test.java"\n```\n\n打印出来的内容包括有 类的全限定名，访问控制权限，父类，接口，常量池以及各个方法。\n\n以 `getNumber` 为例:\n\n```plain\npublic int getNumber();\n  descriptor: ()I\n  flags: ACC_PUBLIC\n  Code:\n    stack=1, locals=1, args_size=1\n       0: aload_0\n       1: getfield      #2                  // Field number:I\n       4: ireturn\n    LineNumberTable:\n      line 8: 0\n```\n\n- descriptor: 表示方法描述符，其中 `()` 内容表示入参，`I` 表示返回值的类型\n- flags     : 表示方法的访问权限，当前限定为 `public`\n- Code      : 存储有当前方法体指令码的一种方法内部属性。\n    - stack : 表示当前方法(意即在运行时所处的栈帧，每个方法的调用都将在 `虚拟机栈` 中构建一个新的 `栈帧`) 使用的 `操作数栈的最大深度`\n    - locals: 表示当前方法使用的 `局部变量表` 的大小\n    - args\\_size : 表示变量个数\n    - LineNumberTable : 与 Debug 有关，指当前的的指令集在源文件中的第几行开始\n\n```plain\n0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中\n1: getfield #2          // 获取常量池中 2 号元素(即 Field number:I) 的值，并加载到操作数栈中\n4: ireturn              // 抛出当前操作数栈顶元素作为返回值\n```\n\n其中，每条指令前的 0, 1, 4 指当前指令作为 `Code` 属性的内容的偏移量。\n\n换一句话说，`aload_0` 是 Code 属性 code[] 的第 0 个字节的内容\n`getfield #2` 的是从 code[] 的第 1 个字节开始的。\n`ireturn` 是从 code[] 的第 4 个字节开始。\n\n至于为什么每条指令的开始位置不同，这取决于每条指令的长度。`aload_0` 指令本身为 1 字节的长度，且不要求附带操作数。\n`getfield` 指令自长 1 个字节，但需要一个长度为 2 字节的常量池索引。因此 `ireturn` 将从第 4 字节开始\n\n--- \n\n同时，可能有人会有所疑问，`aload_0` 加载的 0 号元素是什么？它貌似没有被用到？\n\n首先，在每个方法被触发，在构建新的栈帧时，`this` 将自动作为 0 号元素被存入新栈帧的局部变量表作为 0 号元素。\n同时，如果方法有入参，则入参按入参声明顺序依次作为 1, 2, 3, ... 元素存入。\n(当然，这里存在特殊情况，诸如 long, double 这样长为 8 字节的元素，将占用 2 个局部变量表的数组下标，而其他元素顺延)。\n\n至于看似 0 号元素 `this` 并没有被用到。事实上，它是作为 `getfield` 的一个限定被使用的。\n试想，`getfield` 虽然通过 `#2` 能够知道需要获取到的变量名为 `number` 类型为 `I(即 int)` 的元素。但是，这个元素究竟属于哪个实例？\n而操作数栈顶的 `this` 恰恰是指明，需要使用当前方法所在的类的 number 变量。\n\n---\n\n类似的，我们看一下 `setNumber` 方法\n\n```plain\n0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中 (用于确定字段所属的类)\n1: iload_1              // 从局部变量表中加载 1 号元素到操作数栈中 (用于确定将要给字段赋的值)\n2: putfield      #2     // 获取常量池中 2 号元素(即 Field number:I) 的地址，并赋值\n5: return               // 无返回值的 return 指令来结束当前栈帧的执行\n```\n\n## 给变量赋初始值\n\n经常会见到在方法体内部有类似这样的声明 `int score = 100` ，那么这样的内容翻译成指令会是如何？\n\n对于较小的值，例如 100，将通过 `bipush 100`, `istore_1(假设用局部变量表 1 号元素存储 score 变量` 类似的形式进行赋值。\n类似的，还是 `sipush` ，两者的区别是 bipush 可以支持 1 字节大小的整数，sipush 支持 2 字节大小的整数。\n\n但是，int 最大可是可以到达 4 字节，更甚者，long 将达到 8 字节。\n\n这时候，将要借助的就是 `ldc #<index>` 用来读取常量池编号小于 128 的常量(例如整数常量，浮点常量等等)\n那么，超出 128 编号的？使用 `ldc_w #<index>` 读取 2 字节内容作为编号，最大 65535。当然，更大的内容，常量池都不能支持了哈。\n\n同时，区别于将 byte, short, int, float 统一作为 4 字节结果读取，对于 long, double 这样的八字节元素，使用 `ldc2_w`\n\n## 控制结构\n\n作为一门图灵完备的语言，至少，控制结构是必不可少的元素。\n\n那么，类似 `for(int i=0;i<10;i++)` 的 Java 代码编译成指令到底是什么样的呢？\n\n```plain\n0: iconst_0                     // 赋值指令，往操作数栈顶添加整数值 0\n1: istore_1                     // 将操作数栈顶的元素存入局部变量表 1 号位置\n2: iload_1                      // 从局部变量表 1 号位置加载元素到操作数栈\n3: bipush        10             // 往操作数栈顶压入 byte 型值 10\n5: if_icmpge     21             // 将操作数栈顶的两个元素进行比较, 如果 次顶部元素 >= 顶部元素，则重定向到偏移量为 21 的指令\n//  for (...) {} 语句块的内容\n15: iinc          1, 1          // 将局部变量表的 1 号位置元素 +1\n18: goto          2             // 跳转到偏移量为 2 的指令\n21: return                      // 调用无返回值的 return\n```\n\n类似的，`if(...)` 语句的比较较之 `for(;;)` 就更为简单。类比偏移量为 5 的指令即可。\n\n## 调用方法\n\nJVM 指令集中总计有 4 种调用方法的指令，包括有: \n\n- `invokevirtual`, 对普通实例方法的调用，将根据对象类型进行分发调用\n- `invokestatic`, 对静态方法的调用\n- `invokespecial`, 用于调用类的初始化方法，也用于调用父类方法和私有方法\n- `invokeinterface`, 用于调用接口方法\n\n以执行 `System.out.println()` 为例\n假设常量池内容存在目标元素(具体以相应注释为准)\n\n```plain\ngetstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\ninvokevirtual #4                  // Method java/io/PrintStream.println:()V\n```\n\n## More \n\n更多内容，包括: 如何实例化一个对象，如何抛出及处理异常，代码同步声明等，暂且不表。\n\n有时间再做补充\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<p>在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。</p>\n<p>当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。\n那么，直接阅读 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">官方文档</a> 绝对是比本文的内容更为详实且准确。</p>\n<p>这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>术语约定</h2>\n<p>首先，需要就 <code>术语</code> 进行一些基础性的约定:</p>\n<h3>变量</h3>\n<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftidi0xpmij30oa07kaaq.jpg" alt="变量"></p>\n<ul>\n<li><code>变量</code>: 在类中，区分于 <code>方法</code> 的声明\n<ul>\n<li><code>成员变量</code>: 作用域为整个类，在方法体与语句块之外声明的内容。在 <code>字节码</code> 中通常被称为 <code>字段(Field)</code>\n<ul>\n<li><code>类成员变量 / 静态成员变量</code>: 被 <code>static</code> 修饰的 <code>成员变量</code>。一个类只有一份，在类被加载的时候即初始化。</li>\n<li><code>实例成员变量</code>: 非 <code>static</code> 修饰的 <code>成员变量</code>。随着类被实例化而进行初始化，每个实例对象都有一份特有的 <code>实例变量</code>。</li>\n</ul>\n</li>\n<li><code>局部变量</code>: 作用域为方法体或者语句块。</li>\n</ul>\n</li>\n</ul>\n<h3>JVM 指令</h3>\n<p>通常，我们借助于 <code>javap</code> 命令来对 .class 文件的字节码内容进行查阅。</p>\n<p>类似于汇编代码，<code>javap</code> 打印的JVM 指令将以下列格式进行展示:</p>\n<pre><code class="hljs">&lt;index&gt; &lt;opcode&gt; [&lt;operand1&gt; [&lt;operand2&gt; ...]] [&lt;comment&gt;]</code></pre><p>其中</p>\n<ul>\n<li><code>&lt;index&gt;</code> 指在 <code>code[]</code> 属性中这条指令的偏移量(从 0 开始计数)。</li>\n<li><code>&lt;opcode&gt;</code> 指 <code>操作码</code></li>\n<li><code>&lt;operandX&gt;</code> 指 <code>操作数</code>，每个 <code>&lt;opcode&gt;</code> 都需要确定数量的操作数(规范中已经确定)。</li>\n<li><code>&lt;comment&gt;</code> 指注释</li>\n</ul>\n<h2>指令集概览</h2>\n<p>首先，Java 代码经编译后的所有指令都基于 <code>方法(Method)</code> 被定义在 <code>Code</code> 属性中。</p>\n<p>在 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3">ClassFile</a> 的 <code>Code</code> 属性，结构定义如下:</p>\n<pre><code class="hljs">Code_attribute {\n    <span class="hljs-comment">// 其中 u1, u2, u4 分别表示这个变量所占的字节长度</span>\n    u2 attribute_name_index;                    <span class="hljs-comment">// 属性名在常量池中的 index (执行常量池中 Code 的位置)</span>\n    u4 attribute_length;                        <span class="hljs-comment">// 属性长度，不包括开始的六个字节</span>\n    u2 max_stack;                               <span class="hljs-comment">// 运行时操作数栈的最大深度</span>\n    u2 max_locals;                              <span class="hljs-comment">// 运行时所需的局部变量表的大小</span>\n    u4 code_length;                             <span class="hljs-comment">// code 数组的长度</span>\n    u1 code[code_length];                       <span class="hljs-comment">// code 数组，编译后方法体的内容都通过字节码指令存储在这里</span>\n    u2 exception_table_length;                  <span class="hljs-comment">// 异常表的长度</span>\n    {   u2 start_pc;\n        u2 end_pc;\n        u2 handler_pc;\n        u2 catch_type;\n    } exception_table[exception_table_length]; <span class="hljs-comment">// 异常表，Java 代码中所有的 catch, finally 的捕获都将由此表进行实现</span>\n    u2 attributes_count;                       <span class="hljs-comment">// 属性计数</span>\n    attribute_info attributes[attributes_count];\n}</code></pre><p>Java 虚拟机的指令是由一个字节长度的 <code>操作码</code> 配合上其后的 0 个或多个 <code>操作数</code> 所构成的。</p>\n<p>其中，<code>操作数</code> 的数量取决于 <code>操作码</code>，不同的 <code>操作码</code> 需要不同数量的 <code>操作数</code>。</p>\n<p>按照类型划分，<code>操作数</code> 主要包括下列几类:</p>\n<ul>\n<li>加载与存储指令，例如 iload, istore 等</li>\n<li>运算指令，例如 iadd, isub, imul 等</li>\n<li>类型转换指令，例如 i2b, i2s 等</li>\n<li>对象创建与操作指令，例如 new, newarray 等</li>\n<li>操作数栈管理指令，例如 dup, pop 等</li>\n<li>控制转移指令，例如 if_icmpeq 等</li>\n<li>方法调用与返回指令，例如 invokevirtual, invokestatic 等</li>\n<li>抛出异常指令，例如 athrow 等</li>\n<li>同步指令，例如 monitorenter 等</li>\n</ul>\n<p><strong>举几个简单的例子:</strong></p>\n<p><code>iadd</code> 指令，表示对两个 int 数的相加指令。将从操作数栈顶依次取出两个数，并相加，再重新压入操作数栈中。</p>\n<p><code>bipush 100</code> ，其中 <code>bipush</code> 是指令，后随一个操作数，表示把 <code>操作数 100 这个 byte 类型的数</code> 压入操作数栈顶</p>\n<h2>运行时数据区</h2>\n<p>JVM 定义了若干种运行期间会使用到的运行时数据区，见下图:</p>\n<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg" alt="JVM 运行时数据区"></p>\n<p>至于每一个的具体意义，在此不做详细展开，可用参考:</p>\n<ul>\n<li>由周志明等翻译的 《Java 虚拟机规范(Java SE 7版) 》 2.5节内容 <a href="http://icyfenix.iteye.com/blog/1256329">链接</a></li>\n<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5">JVMS 2.5. Run-Time Data Areas</a></li>\n</ul>\n<h2>Getter, Setter 的指令代码</h2>\n<p>首先，有必要提及，想要得到 .class 可视且友好的展示结果，可以使用 JDK 自带的 <code>javap</code> 命令。</p>\n<p>本节要展示的内容是常见的 POJO 的 get, set 方法的指令代码。使用的示例代码如下:</p>\n<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{\n    \n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumber</span><span class="hljs-params">()</span> </span>{\n        <span class="hljs-keyword">return</span> number;\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>{\n        <span class="hljs-keyword">this</span>.number = number;\n    }\n}</code></pre><p>在经过 <code>javac</code> 编译，<code>javap</code> 解析之后，我们将看到下列内容</p>\n<pre><code class="hljs">Classfile /Users/fangfeng/WorkPkg/lab/src/main/java/me/fangfeng/asm/Test.class\n  Last modified Jul 23, 2018; size 357 bytes\n  MD5 checksum bb1940cc6534d789359295b8dc80233b\n  Compiled from "Test.java"\npublic class me.fangfeng.asm.Test\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #4.#17         // java/lang/Object."&lt;init&gt;":()V\n   #2 = Fieldref           #3.#18         // me/fangfeng/asm/Test.number:I\n   #3 = Class              #19            // me/fangfeng/asm/Test\n   #4 = Class              #20            // java/lang/Object\n   #5 = Utf8               number\n   #6 = Utf8               I\n   #7 = Utf8               &lt;init&gt;\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               getNumber\n  #12 = Utf8               ()I\n  #13 = Utf8               setNumber\n  #14 = Utf8               (I)V\n  #15 = Utf8               SourceFile\n  #16 = Utf8               Test.java\n  #17 = NameAndType        #7:#8          // "&lt;init&gt;":()V\n  #18 = NameAndType        #5:#6          // number:I\n  #19 = Utf8               me/fangfeng/asm/Test\n  #20 = Utf8               java/lang/Object\n{\n  public me.fangfeng.asm.Test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V\n         4: return\n      LineNumberTable:\n        line 3: 0\n\n  public int getNumber();\n    descriptor: ()I\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field number:I\n         4: ireturn\n      LineNumberTable:\n        line 8: 0\n\n  public void setNumber(int);\n    descriptor: (I)V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=2\n         0: aload_0\n         1: iload_1\n         2: putfield      #2                  // Field number:I\n         5: return\n      LineNumberTable:\n        line 12: 0\n        line 13: 5\n}\nSourceFile: "Test.java"</code></pre><p>打印出来的内容包括有 类的全限定名，访问控制权限，父类，接口，常量池以及各个方法。</p>\n<p>以 <code>getNumber</code> 为例:</p>\n<pre><code class="hljs">public int getNumber();\n  descriptor: ()I\n  flags: ACC_PUBLIC\n  Code:\n    stack=1, locals=1, args_size=1\n       0: aload_0\n       1: getfield      #2                  // Field number:I\n       4: ireturn\n    LineNumberTable:\n      line 8: 0</code></pre><ul>\n<li>descriptor: 表示方法描述符，其中 <code>()</code> 内容表示入参，<code>I</code> 表示返回值的类型</li>\n<li>flags     : 表示方法的访问权限，当前限定为 <code>public</code></li>\n<li>Code      : 存储有当前方法体指令码的一种方法内部属性。\n<ul>\n<li>stack : 表示当前方法(意即在运行时所处的栈帧，每个方法的调用都将在 <code>虚拟机栈</code> 中构建一个新的 <code>栈帧</code>) 使用的 <code>操作数栈的最大深度</code></li>\n<li>locals: 表示当前方法使用的 <code>局部变量表</code> 的大小</li>\n<li>args_size : 表示变量个数</li>\n<li>LineNumberTable : 与 Debug 有关，指当前的的指令集在源文件中的第几行开始</li>\n</ul>\n</li>\n</ul>\n<pre><code class="hljs">0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中\n1: getfield #2          // 获取常量池中 2 号元素(即 Field number:I) 的值，并加载到操作数栈中\n4: ireturn              // 抛出当前操作数栈顶元素作为返回值</code></pre><p>其中，每条指令前的 0, 1, 4 指当前指令作为 <code>Code</code> 属性的内容的偏移量。</p>\n<p>换一句话说，<code>aload_0</code> 是 Code 属性 code[] 的第 0 个字节的内容\n<code>getfield #2</code> 的是从 code[] 的第 1 个字节开始的。\n<code>ireturn</code> 是从 code[] 的第 4 个字节开始。</p>\n<p>至于为什么每条指令的开始位置不同，这取决于每条指令的长度。<code>aload_0</code> 指令本身为 1 字节的长度，且不要求附带操作数。\n<code>getfield</code> 指令自长 1 个字节，但需要一个长度为 2 字节的常量池索引。因此 <code>ireturn</code> 将从第 4 字节开始</p>\n<hr>\n<p>同时，可能有人会有所疑问，<code>aload_0</code> 加载的 0 号元素是什么？它貌似没有被用到？</p>\n<p>首先，在每个方法被触发，在构建新的栈帧时，<code>this</code> 将自动作为 0 号元素被存入新栈帧的局部变量表作为 0 号元素。\n同时，如果方法有入参，则入参按入参声明顺序依次作为 1, 2, 3, ... 元素存入。\n(当然，这里存在特殊情况，诸如 long, double 这样长为 8 字节的元素，将占用 2 个局部变量表的数组下标，而其他元素顺延)。</p>\n<p>至于看似 0 号元素 <code>this</code> 并没有被用到。事实上，它是作为 <code>getfield</code> 的一个限定被使用的。\n试想，<code>getfield</code> 虽然通过 <code>#2</code> 能够知道需要获取到的变量名为 <code>number</code> 类型为 <code>I(即 int)</code> 的元素。但是，这个元素究竟属于哪个实例？\n而操作数栈顶的 <code>this</code> 恰恰是指明，需要使用当前方法所在的类的 number 变量。</p>\n<hr>\n<p>类似的，我们看一下 <code>setNumber</code> 方法</p>\n<pre><code class="hljs">0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中 (用于确定字段所属的类)\n1: iload_1              // 从局部变量表中加载 1 号元素到操作数栈中 (用于确定将要给字段赋的值)\n2: putfield      #2     // 获取常量池中 2 号元素(即 Field number:I) 的地址，并赋值\n5: return               // 无返回值的 return 指令来结束当前栈帧的执行</code></pre><h2>给变量赋初始值</h2>\n<p>经常会见到在方法体内部有类似这样的声明 <code>int score = 100</code> ，那么这样的内容翻译成指令会是如何？</p>\n<p>对于较小的值，例如 100，将通过 <code>bipush 100</code>, <code>istore_1(假设用局部变量表 1 号元素存储 score 变量</code> 类似的形式进行赋值。\n类似的，还是 <code>sipush</code> ，两者的区别是 bipush 可以支持 1 字节大小的整数，sipush 支持 2 字节大小的整数。</p>\n<p>但是，int 最大可是可以到达 4 字节，更甚者，long 将达到 8 字节。</p>\n<p>这时候，将要借助的就是 <code>ldc #&lt;index&gt;</code> 用来读取常量池编号小于 128 的常量(例如整数常量，浮点常量等等)\n那么，超出 128 编号的？使用 <code>ldc_w #&lt;index&gt;</code> 读取 2 字节内容作为编号，最大 65535。当然，更大的内容，常量池都不能支持了哈。</p>\n<p>同时，区别于将 byte, short, int, float 统一作为 4 字节结果读取，对于 long, double 这样的八字节元素，使用 <code>ldc2_w</code></p>\n<h2>控制结构</h2>\n<p>作为一门图灵完备的语言，至少，控制结构是必不可少的元素。</p>\n<p>那么，类似 <code>for(int i=0;i&lt;10;i++)</code> 的 Java 代码编译成指令到底是什么样的呢？</p>\n<pre><code class="hljs">0: iconst_0                     // 赋值指令，往操作数栈顶添加整数值 0\n1: istore_1                     // 将操作数栈顶的元素存入局部变量表 1 号位置\n2: iload_1                      // 从局部变量表 1 号位置加载元素到操作数栈\n3: bipush        10             // 往操作数栈顶压入 byte 型值 10\n5: if_icmpge     21             // 将操作数栈顶的两个元素进行比较, 如果 次顶部元素 &gt;= 顶部元素，则重定向到偏移量为 21 的指令\n//  for (...) {} 语句块的内容\n15: iinc          1, 1          // 将局部变量表的 1 号位置元素 +1\n18: goto          2             // 跳转到偏移量为 2 的指令\n21: return                      // 调用无返回值的 return</code></pre><p>类似的，<code>if(...)</code> 语句的比较较之 <code>for(;;)</code> 就更为简单。类比偏移量为 5 的指令即可。</p>\n<h2>调用方法</h2>\n<p>JVM 指令集中总计有 4 种调用方法的指令，包括有:</p>\n<ul>\n<li><code>invokevirtual</code>, 对普通实例方法的调用，将根据对象类型进行分发调用</li>\n<li><code>invokestatic</code>, 对静态方法的调用</li>\n<li><code>invokespecial</code>, 用于调用类的初始化方法，也用于调用父类方法和私有方法</li>\n<li><code>invokeinterface</code>, 用于调用接口方法</li>\n</ul>\n<p>以执行 <code>System.out.println()</code> 为例\n假设常量池内容存在目标元素(具体以相应注释为准)</p>\n<pre><code class="hljs">getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\ninvokevirtual #4                  // Method java/io/PrintStream.println:()V</code></pre><h2>More</h2>\n<p>更多内容，包括: 如何实例化一个对象，如何抛出及处理异常，代码同步声明等，暂且不表。</p>\n<p>有时间再做补充</p>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-07-24-JVM-Instruction.json",ext:".json",sourceBase:"2018-07-24-JVM-Instruction.md",sourceExt:".md"}},yEfC:function(n){n.exports={title:"理解 Linux Kernel (3) - 操作系统启动",author:"fangfeng",date:"2018-10-06T00:00:00.000Z",tags:["Kernel","Linux","OS"],bodyContent:'这次拖得有够久的，毕竟需要将知识串联起来并不是一件容易的事情。更何况很多内容可以说和常理(个人理解的常理)有了比较大的偏差。\n\n不过确实比较有意思。从引导程序到操作系统启动，这中间究竟经历了多少流程呢？\n\n由于有了前几节的内容，这里不会再对引导程序及汇编语法做过多的介绍。而着重在于整个流程的描述。\n\n\x3c!-- more --\x3e\n\n## 引导程序\n\n从 BIOS 将512字节长的引导程序加载到物理内存`0x7c00`开始的连续递增空间后，即将程序的执行权交给了引导程序(这里指的执行权可以简单理解成CS:IP)\n\n> *CS:IP*\n>\n> **CS**. 代码段基址。一般用于划定一段连续代码开始的地址。是一个16位段寄存器，类似的还有 DS, ES, FS, GS, SS 等16位段寄存器，分别提供不同的段基址存储功能)\n> **IP**. 代码段偏移值。配合 CS 共同为 CPU 确定下一个将要被执行的机器指令的线性地址。\n\nLinux 0.11 版本的引导程序实现的支持比较简单。\n\n1. 将引导程序代码(自身) 512 字节的内容移动到 `0x90000` 开始的 512B 内存空间上\n2. 跳到 `0x90000` 开始的段的相应位置继续执行\n3. 从磁盘中读取 4\\*512 字节的 setup 程序的二进制内容\n4. 读取操作系统的二进制内容到内存 `0x10000` 开始的连续地址空间中 (此处最大可以有 0x90000 - 0x10000 = 0x80000 = 512 KB，即当时的操作系统二进制程序+数据最大只能是 512KB, 不过也很多了)\n5. 确认将要作为文件系统的磁盘是否存在\n6. 将控制权交给 setup 程序\n\n## SETUP 程序\n\n**读取硬件配置**\n\nsetup 程序，顾名思义，就是在搞一些配置。那么究竟在配置什么？\n\n就是通过 BIOS 中断读取各种硬件信息(诸如内存大小，显示器长宽比，磁盘等)，并将它们存储在内存的指定位置。\n\n哈哈，由于引导程序已经执行完了，再也不会使用了。因此，setup 程序就是将这些信息存储到了原引导程序所在的位置，即 0x90000 ~ 0x901FF 共 512 B 的内存中。\n\n当然，每个字节存的是什么内容都是一种约定(比如 setup 程序把内存大小的信息存到了哪，后面其它程序就到相应的位置去取)。\n\n**移动操作系统程序**\n\nOK，setup 程序也不是仅仅只干这么点事情的，不然要 4\\*512 字节岂不是太浪费了，哪用得了这么多。\n\nsetup 还要负责将操作系统程序移动到*方便*的位置。前面将操作系统程序加载到了内存 0x10000 处，主要是为了暂时保持 BIOS 中断向量表 (位于 0x0000 开始的连续 1024 B 内存中，由 BIOS 程序创建，用于各种中断调用) 。在 setup 决定不再使用 BIOS 中断之后，就已经可以完全废弃了。\n\n因此，操作系统程序将从 0x10000 顺次移动到 0x00000 的位置。\n\n**重置中断**\n\n软中断与硬中断，应该是在软硬件划分下唯二的两种中断形式。软中断一般通过汇编指令 `INT {中断号}` 的形式通过软件执行的形式产生，而硬中断是硬件由于某些错误指令而自动产生的中断。\n\n当然，这些中断都需要 CPU 进行相应的处理。那么，在 BIOS  中断向量表被覆盖了之后，如何来处理这些中断呢？\n\n首先，在上一步 **移动操作系统程序** 开始时，就直接通过汇编指令 `cli` 强制禁止除 *非可屏蔽中断* 外的所有中断，因此也就基本不考虑中断的问题。\n\n但是，总还得解除禁止吧。因此，setup 程序尽快地重新编制了硬件中断，进入保护模式。使用保护模式下的中断描述符表来替代 BIOS 中断向量表。\n\n至于如何创建中断描述符表，哈哈，这都是直接在汇编编程的时候写好的。直接划出了一块区域写上了中断描述符表的表项，然后与 setup 代码一起被读取到了内存的指定位置。至于唯一要做的，就是将 IDTR (中断描述符表寄存器) 修改为中断描述符表在内存的开始地址。\n\n**进入保护模式**\n\n首先，简单介绍一下实模式 & 保护模式。\n\n保护模式与实模式的主要区别，就在于两者的内存寻址方式，归根结底也就是段寄存器如何辅助完成内存地址定位的问题。\n\n先简单的回顾下实模式下的寻址方式\n\n段寄存器的出现，很大程度上是为了对 16 bit CPU 下可寻址地址不足所作出的补充。\n诸如 CS:IP = 0x07C0:0x0001 -> 0x07C01 。通过CS:IP 的配合，物理地址 = CS << 4 + IP ，将原本 128 KB 的可寻址空间扩展到 0xFFFF:0xFFFF -> 0x10FFFE 的寻址空间\n\n而保护模式的出现，也是由于实模式下的地址寻址仍然不能满足对内存寻址的需求。\n\n那么保护模式究竟将如何进行寻址呢？简单来说就是通过新增了一个寄存器 GDTR (全局描述符表寄存器。当然，暂时不考虑 LDTR) 用来存储全局描述符表(全局描述符表是一些在内存中的有结构的数据) ，那么类似的，本来是段寄存器中是表示一个内存段基址，现在通过借助中间项 (GDTR) ，由全局描述符表的每一个表项来表示每一个内存段基址，从而达到在最大 4GB 的内存中进行内存地址的寻址。\n\n而与上面的中断描述符表类似的，全局描述符表也是以同样的方式，预先写好，然后设置一下 GDTR 就 OK 了。\n\n**转入操作系统程序**\n\n最后的最后，当然是把控制权交给操作系统程序。即跳转到内存 0x00000 处。当然，由于现在已经处于保护模式下，因此 jmp 指令略有不同。 为 `jmpi 0, 8`。\n\n简单解释一下这一条指令 \n\n`jmpi` 指令表示进行段间跳转。(段间跳转与段内跳转的区别在于: 程序代码的寻址一般通过 CS:IP 配合完成，如果是段内跳转，则段基址不变，即 CS 不变，只需要给出 IP 即可；而段间跳转需要同时给出新的段基址(CS)和新的段偏移(IP)。\n\n`0` 这里 0 就表示的是段偏移。\n\n`8` 保护模式下的段寄存器以一种特殊的方式来配合 GDTR/LDTR 来完成对全局/局部描述符表项的定位。如下图所示。最后两位表示特权级，用于区分用户态(11) or 内核态(00) (Linux 只使用了两个，还有 01 和 10 不使用)\n\n第三位表示使用 GDTR 还是 LDTR\n\n高 13 位共同组成了对 GDTR/LDTR 表项的描述，究竟使用哪一个表项。当然，这里其实也侧面反映了，其实每个全局描述符表/局部描述符表最多只能有 $2^{13} = 8192$ 个表项。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fulm7vumywj31220aw74f.jpg)\n\n## 操作系统程序\n\n终于要到操作系统程序了。这个就比较复杂了。这里只简单描述将操作系统启动起来的最基本使用到的代码。其它以后继续。\n\n其实整一个操作系统程序是一个比较大的量，毕竟最大能够达到 512 KB 呢。\n\n简单的看一下文档树，见附录一，编译前的源代码文件总计 100 多个。\n\n首先被执行的是 head.s 中的代码，这里完成的工作主要包括:\n\n1. 重新编制每个中断的具体处理代码(这个应该比较好理解，说到底中断出现了，也还是要通过实现代码来完成中断逻辑。不论是 BIOS 中断向量还是保护模式下使用的中断描述符表，都不过是记录了一下中断处理代码的位置，进行了定位而已)。\n\n2. 初始化分页模式(不详述，以后有机会在说)\n\n3. 验证 80387 数学协处理器。\n\n4. 进入 main.c 程序 (既然 Linus 都将其命名为 main 了，那么显然这是整个操作系统最核心的部分了)。\n\n### main.c\n\n下面将简单给出 main.c 程序的两段代码 `main(...)` 和 `init(...)`，并直接针对代码进行直接解释。\n\n#### main(void)\n\n```c\nvoid main(void)\t\t\n{\n \tROOT_DEV = ORIG_ROOT_DEV;   // 读取在引导程序执行时获取到的文件系统所在的磁盘\n \tdrive_info = DRIVE_INFO;\n\tmemory_end = (1<<20) + (EXT_MEM_K<<10); // 首先先确认整个内存的大小\n\tmemory_end &= 0xfffff000;               // 当然，这里为了分页方便 (每页 4096 B)，直接将不满一页的内存忽略掉了\n\tif (memory_end > 16*1024*1024)          // 最大支持 16 MB 的内存，这里是 Linus 当时的机器只有 16 MB，因此没有做更大内存的支持，但可以自己去改源码\n\t\tmemory_end = 16*1024*1024;\n\tif (memory_end > 12*1024*1024)          // 确认缓存区的末地址 (根据实际内存大小调整, >12MB 留 4MB 缓存，>6MB 留 2 MB 缓存，否则 1MB )\n\t\tbuffer_memory_end = 4*1024*1024;\n\telse if (memory_end > 6*1024*1024)\n\t\tbuffer_memory_end = 2*1024*1024;\n\telse\n\t\tbuffer_memory_end = 1*1024*1024;\n\tmain_memory_start = buffer_memory_end;\n#ifdef RAMDISK\n\tmain_memory_start += rd_init(main_memory_start, RAMDISK*1024);      // 如果需要虚拟盘，则再留一部分作为交换区\n#endif\n\tmem_init(main_memory_start,memory_end); // 内存初始化，毕竟 Linux 操作系统下的所有内存都将被统一分配，用户程序没有权限随便使用内存，只能用被分配的\n\ttrap_init();            // 初始化中断\n\tblk_dev_init();         // 初始化块设备\n\tchr_dev_init();         // 初始化字符设备\n\ttty_init();             // 初始化 tty\n\ttime_init();            // 设置开机启动时间\n\tsched_init();           // 初始化任务调度程序，由此就将可以进行多任务切换了\n\tbuffer_init(buffer_memory_end); // 缓存区初始化\n\thd_init();              // 硬盘初始化\n\tfloppy_init();          // 软盘初始化\n\tsti();                  // 不再禁止中断，现在开始又允许中断了\n\tmove_to_user_mode();    // 进入用户态\n\tif (!fork()) {          // 关于 fork 函数，下面将简单介绍。\n\t\tinit();\n\t}\n\n\tfor(;;) pause();\n}\n```\n\n**fork()**\n\n如果熟悉 C 语言，应该对 fork() 也比较熟悉吧。这将执行一次系统调用，最终的结果是，创建一个新的任务 (这里将原来的操作系统程序认为是 0 号进程/任务，将产生 1 号进程/任务)。新的任务与原有任务几乎一模一样，除了 fork() 调用的返回值不同。子任务将返回 0 ，原有任务将返回子任务的任务号。\n\n因此，对于上面的代码，`if(!fork())` ，0号任务将不执行 `if(){}` 语句块内的 init ，而 1 号任务将执行 `init()` 函数\n\n而 0 号进程在做什么呢? \n\n很简单，下面 `for(;;) pause();`。 `pause()` 是指让 CPU 完全停止，只有发生硬件中断， CPU 才会从停止状态中恢复 (前面已经设置了定时的/ 10ms/次的时钟中断，因此 CPU 总是能够恢复)， \n\n具体的描述就是，如果任务调度程序把时间片分配给了 0 号进程，那么 0 号进程唯一做的，就是让 CPU 停止。而且 0 号进程的 `for` 是死循环，每次把时间分配给 0 号进程，它就 CPU 停止。我们在 Linux 操作系统上，通过 top 可以看到对 cpu 有如下描述\n\n```\n%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n```\n\n其中对 idle(id) 的统计，其实就在 0 号任务让 cpu 停止工作了而已。\n\n#### init(void)\n\n```c\nvoid init(void)\n{\n\tint pid,i;\n\n\tsetup((void *) &drive_info);\n\t(void) open("/dev/tty0",O_RDWR,0);\n\t(void) dup(0);\n\t(void) dup(0);\n\tprintf("%d buffers = %d bytes buffer space\\n\\r",NR_BUFFERS,\n\t\tNR_BUFFERS*BLOCK_SIZE);\n\tprintf("Free mem: %d bytes\\n\\r",memory_end-main_memory_start);\n\tif (!(pid=fork())) {\n\t\tclose(0);\n\t\tif (open("/etc/rc",O_RDONLY,0))\n\t\t\t_exit(1);\n\t\texecve("/bin/sh",argv_rc,envp_rc);\n\t\t_exit(2);\n\t}\n\tif (pid>0)\n\t\twhile (pid != wait(&i))\n\t\t\t/* nothing */;\n\twhile (1) {\n\t\tif ((pid=fork())<0) {\n\t\t\tprintf("Fork failed in init\\r\\n");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!pid) {\n\t\t\tclose(0);close(1);close(2);\n\t\t\tsetsid();\n\t\t\t(void) open("/dev/tty0",O_RDWR,0);\n\t\t\t(void) dup(0);\n\t\t\t(void) dup(0);\n\t\t\t_exit(execve("/bin/sh",argv,envp));\n\t\t}\n\t\twhile (1)\n\t\t\tif (pid == wait(&i))\n\t\t\t\tbreak;\n\t\tprintf("\\n\\rchild %d died with code %04x\\n\\r",pid,i);\n\t\tsync();\n\t}\n\t_exit(0);\t/* NOTE! _exit, not exit() */\n}\n```\n\n那么 1 号任务在做什么呢？看 init 的代码，可以看到大量诸如 `/dev/tty0`, `/bin/sh` 的代码。哈哈，下面通过 1,2,3... 对步骤进行标号简单描述一下。\n\n1. 1 号进程在做的是 fork 出新的进程(暂时叫它进程 X )\n\n2. 1 号进程不断询问 X 是否被销毁 \n    - 如果 X 进程被销毁了：那么继续执行步骤 1\n    - 否则：继续执行步骤 2 （为什么会出现不断循环呢？其实由于任务调度程序的存在，在单个 CPU 看来，这个轮询并不一直发生，有一些时间片已经给了其他进程继续执行任务了\n\n3. X 任务通过调用 `execve()` 把当前程序的代码+数据全部替换成是 shell 的 (其实大量的用户程序都是通过这种 fork + execve 的形式出现的)\n4. X 任务(也就是 Shell 程序) 开始通过 tty 与用户开始交互。直到用户选择 `exit` 退出 shell \n\n**execve(...)**\n\n前面介绍过 fork 是复制一份程序的各个寄存器的状态 + 程序的数据。现在 execve 做出的操作是直接将当前程序的代码和数据替换成目标程序的代码和数据，并通过对寄存器一定的重置，完成一个用户程序的启动流程(程序启动说到底不就是在内存中存在这个程序的代码，然后通过 CS:IP 定位到即将执行的程序指令，最后让 CPU 开始执行就 OK 了)\n\n## 小结\n\n整个操作系统的启动流程就简单地介绍到这里。\n\n0 号任务作为操作系统的常驻程序，在 OS 启动完成，每次时间片被分配给它，它就让 CPU 停止工作(通过 pause() 系统调用)\n\n1 号任务作为操作系统的常驻程序，唯一的任务就是判断进程X是否被退出，如果退出了，就重新创建一个(当然，也可能有人有疑问，为什么现在的 Linux 开多个 bash 都没有问题呢? 这里有个猜测是有一个隐藏的 shell 是被 1 号任务启动的，其它的 bash 是多余的。不过这只是猜测，待考察)\n\n## 附录\n\n### 附录一\n\n```\n.\n|-- Makefile\n|-- boot\n|   |-- head.s\n|-- fs\n|   |-- Makefile\n|   |-- bitmap.c\n|   |-- block_dev.c\n|   |-- buffer.c\n|   |-- char_dev.c\n|   |-- exec.c\n|   |-- fcntl.c\n|   |-- file_dev.c\n|   |-- file_table.c\n|   |-- inode.c\n|   |-- ioctl.c\n|   |-- namei.c\n|   |-- open.c\n|   |-- pipe.c\n|   |-- read_write.c\n|   |-- stat.c\n|   |-- super.c\n|   `-- truncate.c\n|-- include\n|   |-- a.out.h\n|   |-- asm\n|   |   |-- io.h\n|   |   |-- memory.h\n|   |   |-- segment.h\n|   |   `-- system.h\n|   |-- const.h\n|   |-- ctype.h\n|   |-- errno.h\n|   |-- fcntl.h\n|   |-- linux\n|   |   |-- config.h\n|   |   |-- fdreg.h\n|   |   |-- fs.h\n|   |   |-- hdreg.h\n|   |   |-- head.h\n|   |   |-- kernel.h\n|   |   |-- mm.h\n|   |   |-- sched.h\n|   |   |-- sys.h\n|   |   `-- tty.h\n|   |-- signal.h\n|   |-- stdarg.h\n|   |-- stddef.h\n|   |-- string.h\n|   |-- sys\n|   |   |-- stat.h\n|   |   |-- times.h\n|   |   |-- types.h\n|   |   |-- utsname.h\n|   |   `-- wait.h\n|   |-- termios.h\n|   |-- time.h\n|   |-- unistd.h\n|   `-- utime.h\n|-- init\n|   |-- main.c\n|-- kernel\n|   |-- Makefile\n|   |-- asm.o\n|   |-- asm.s\n|   |-- blk_drv\n|   |   |-- Makefile\n|   |   |-- blk.h\n|   |   |-- floppy.c\n|   |   |-- hd.c\n|   |   |-- ll_rw_blk.c\n|   |   `-- ramdisk.c\n|   |-- chr_drv\n|   |   |-- Makefile\n|   |   |-- console.c\n|   |   |-- keyboard.S\n|   |   |-- rs_io.s\n|   |   |-- serial.c\n|   |   |-- tty_io.c\n|   |   `-- tty_ioctl.c\n|   |-- exit.c\n|   |-- fork.c\n|   |-- fork.i\n|   |-- math\n|   |   |-- Makefile\n|   |   `-- math_emulate.c\n|   |-- mktime.c\n|   |-- panic.c\n|   |-- printk.c\n|   |-- sched.c\n|   |-- sched.o\n|   |-- signal.c\n|   |-- sys.c\n|   |-- system_call.o\n|   |-- system_call.s\n|   |-- traps.c\n|   |-- traps.o\n|   `-- vsprintf.c\n|-- lib\n|   |-- Makefile\n|   |-- _exit.c\n|   |-- close.c\n|   |-- ctype.c\n|   |-- dup.c\n|   |-- errno.c\n|   |-- execve.c\n|   |-- malloc.c\n|   |-- open.c\n|   |-- setsid.c\n|   |-- string.c\n|   |-- wait.c\n|   `-- write.c\n|-- mm\n|   |-- Makefile\n|   |-- memory.c\n|   `-- page.s\n`-- tools\n    `-- build.c\n```\n\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<p>这次拖得有够久的，毕竟需要将知识串联起来并不是一件容易的事情。更何况很多内容可以说和常理(个人理解的常理)有了比较大的偏差。</p>\n<p>不过确实比较有意思。从引导程序到操作系统启动，这中间究竟经历了多少流程呢？</p>\n<p>由于有了前几节的内容，这里不会再对引导程序及汇编语法做过多的介绍。而着重在于整个流程的描述。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>引导程序</h2>\n<p>从 BIOS 将512字节长的引导程序加载到物理内存<code>0x7c00</code>开始的连续递增空间后，即将程序的执行权交给了引导程序(这里指的执行权可以简单理解成CS:IP)</p>\n<blockquote>\n<p><em>CS:IP</em></p>\n<p><strong>CS</strong>. 代码段基址。一般用于划定一段连续代码开始的地址。是一个16位段寄存器，类似的还有 DS, ES, FS, GS, SS 等16位段寄存器，分别提供不同的段基址存储功能)\n<strong>IP</strong>. 代码段偏移值。配合 CS 共同为 CPU 确定下一个将要被执行的机器指令的线性地址。</p>\n</blockquote>\n<p>Linux 0.11 版本的引导程序实现的支持比较简单。</p>\n<ol>\n<li>将引导程序代码(自身) 512 字节的内容移动到 <code>0x90000</code> 开始的 512B 内存空间上</li>\n<li>跳到 <code>0x90000</code> 开始的段的相应位置继续执行</li>\n<li>从磁盘中读取 4*512 字节的 setup 程序的二进制内容</li>\n<li>读取操作系统的二进制内容到内存 <code>0x10000</code> 开始的连续地址空间中 (此处最大可以有 0x90000 - 0x10000 = 0x80000 = 512 KB，即当时的操作系统二进制程序+数据最大只能是 512KB, 不过也很多了)</li>\n<li>确认将要作为文件系统的磁盘是否存在</li>\n<li>将控制权交给 setup 程序</li>\n</ol>\n<h2>SETUP 程序</h2>\n<p><strong>读取硬件配置</strong></p>\n<p>setup 程序，顾名思义，就是在搞一些配置。那么究竟在配置什么？</p>\n<p>就是通过 BIOS 中断读取各种硬件信息(诸如内存大小，显示器长宽比，磁盘等)，并将它们存储在内存的指定位置。</p>\n<p>哈哈，由于引导程序已经执行完了，再也不会使用了。因此，setup 程序就是将这些信息存储到了原引导程序所在的位置，即 0x90000 ~ 0x901FF 共 512 B 的内存中。</p>\n<p>当然，每个字节存的是什么内容都是一种约定(比如 setup 程序把内存大小的信息存到了哪，后面其它程序就到相应的位置去取)。</p>\n<p><strong>移动操作系统程序</strong></p>\n<p>OK，setup 程序也不是仅仅只干这么点事情的，不然要 4*512 字节岂不是太浪费了，哪用得了这么多。</p>\n<p>setup 还要负责将操作系统程序移动到<em>方便</em>的位置。前面将操作系统程序加载到了内存 0x10000 处，主要是为了暂时保持 BIOS 中断向量表 (位于 0x0000 开始的连续 1024 B 内存中，由 BIOS 程序创建，用于各种中断调用) 。在 setup 决定不再使用 BIOS 中断之后，就已经可以完全废弃了。</p>\n<p>因此，操作系统程序将从 0x10000 顺次移动到 0x00000 的位置。</p>\n<p><strong>重置中断</strong></p>\n<p>软中断与硬中断，应该是在软硬件划分下唯二的两种中断形式。软中断一般通过汇编指令 <code>INT {中断号}</code> 的形式通过软件执行的形式产生，而硬中断是硬件由于某些错误指令而自动产生的中断。</p>\n<p>当然，这些中断都需要 CPU 进行相应的处理。那么，在 BIOS  中断向量表被覆盖了之后，如何来处理这些中断呢？</p>\n<p>首先，在上一步 <strong>移动操作系统程序</strong> 开始时，就直接通过汇编指令 <code>cli</code> 强制禁止除 <em>非可屏蔽中断</em> 外的所有中断，因此也就基本不考虑中断的问题。</p>\n<p>但是，总还得解除禁止吧。因此，setup 程序尽快地重新编制了硬件中断，进入保护模式。使用保护模式下的中断描述符表来替代 BIOS 中断向量表。</p>\n<p>至于如何创建中断描述符表，哈哈，这都是直接在汇编编程的时候写好的。直接划出了一块区域写上了中断描述符表的表项，然后与 setup 代码一起被读取到了内存的指定位置。至于唯一要做的，就是将 IDTR (中断描述符表寄存器) 修改为中断描述符表在内存的开始地址。</p>\n<p><strong>进入保护模式</strong></p>\n<p>首先，简单介绍一下实模式 &amp; 保护模式。</p>\n<p>保护模式与实模式的主要区别，就在于两者的内存寻址方式，归根结底也就是段寄存器如何辅助完成内存地址定位的问题。</p>\n<p>先简单的回顾下实模式下的寻址方式</p>\n<p>段寄存器的出现，很大程度上是为了对 16 bit CPU 下可寻址地址不足所作出的补充。\n诸如 CS:IP = 0x07C0:0x0001 -&gt; 0x07C01 。通过CS:IP 的配合，物理地址 = CS &lt;&lt; 4 + IP ，将原本 128 KB 的可寻址空间扩展到 0xFFFF:0xFFFF -&gt; 0x10FFFE 的寻址空间</p>\n<p>而保护模式的出现，也是由于实模式下的地址寻址仍然不能满足对内存寻址的需求。</p>\n<p>那么保护模式究竟将如何进行寻址呢？简单来说就是通过新增了一个寄存器 GDTR (全局描述符表寄存器。当然，暂时不考虑 LDTR) 用来存储全局描述符表(全局描述符表是一些在内存中的有结构的数据) ，那么类似的，本来是段寄存器中是表示一个内存段基址，现在通过借助中间项 (GDTR) ，由全局描述符表的每一个表项来表示每一个内存段基址，从而达到在最大 4GB 的内存中进行内存地址的寻址。</p>\n<p>而与上面的中断描述符表类似的，全局描述符表也是以同样的方式，预先写好，然后设置一下 GDTR 就 OK 了。</p>\n<p><strong>转入操作系统程序</strong></p>\n<p>最后的最后，当然是把控制权交给操作系统程序。即跳转到内存 0x00000 处。当然，由于现在已经处于保护模式下，因此 jmp 指令略有不同。 为 <code>jmpi 0, 8</code>。</p>\n<p>简单解释一下这一条指令</p>\n<p><code>jmpi</code> 指令表示进行段间跳转。(段间跳转与段内跳转的区别在于: 程序代码的寻址一般通过 CS:IP 配合完成，如果是段内跳转，则段基址不变，即 CS 不变，只需要给出 IP 即可；而段间跳转需要同时给出新的段基址(CS)和新的段偏移(IP)。</p>\n<p><code>0</code> 这里 0 就表示的是段偏移。</p>\n<p><code>8</code> 保护模式下的段寄存器以一种特殊的方式来配合 GDTR/LDTR 来完成对全局/局部描述符表项的定位。如下图所示。最后两位表示特权级，用于区分用户态(11) or 内核态(00) (Linux 只使用了两个，还有 01 和 10 不使用)</p>\n<p>第三位表示使用 GDTR 还是 LDTR</p>\n<p>高 13 位共同组成了对 GDTR/LDTR 表项的描述，究竟使用哪一个表项。当然，这里其实也侧面反映了，其实每个全局描述符表/局部描述符表最多只能有 $2^{13} = 8192$ 个表项。</p>\n<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fulm7vumywj31220aw74f.jpg" alt=""></p>\n<h2>操作系统程序</h2>\n<p>终于要到操作系统程序了。这个就比较复杂了。这里只简单描述将操作系统启动起来的最基本使用到的代码。其它以后继续。</p>\n<p>其实整一个操作系统程序是一个比较大的量，毕竟最大能够达到 512 KB 呢。</p>\n<p>简单的看一下文档树，见附录一，编译前的源代码文件总计 100 多个。</p>\n<p>首先被执行的是 head.s 中的代码，这里完成的工作主要包括:</p>\n<ol>\n<li>\n<p>重新编制每个中断的具体处理代码(这个应该比较好理解，说到底中断出现了，也还是要通过实现代码来完成中断逻辑。不论是 BIOS 中断向量还是保护模式下使用的中断描述符表，都不过是记录了一下中断处理代码的位置，进行了定位而已)。</p>\n</li>\n<li>\n<p>初始化分页模式(不详述，以后有机会在说)</p>\n</li>\n<li>\n<p>验证 80387 数学协处理器。</p>\n</li>\n<li>\n<p>进入 main.c 程序 (既然 Linus 都将其命名为 main 了，那么显然这是整个操作系统最核心的部分了)。</p>\n</li>\n</ol>\n<h3>main.c</h3>\n<p>下面将简单给出 main.c 程序的两段代码 <code>main(...)</code> 和 <code>init(...)</code>，并直接针对代码进行直接解释。</p>\n<h4>main(void)</h4>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\t\t\n</span>{\n \tROOT_DEV = ORIG_ROOT_DEV;   <span class="hljs-comment">// 读取在引导程序执行时获取到的文件系统所在的磁盘</span>\n \tdrive_info = DRIVE_INFO;\n\tmemory_end = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="hljs-number">10</span>); <span class="hljs-comment">// 首先先确认整个内存的大小</span>\n\tmemory_end &amp;= <span class="hljs-number">0xfffff000</span>;               <span class="hljs-comment">// 当然，这里为了分页方便 (每页 4096 B)，直接将不满一页的内存忽略掉了</span>\n\t<span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">16</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)          <span class="hljs-comment">// 最大支持 16 MB 的内存，这里是 Linus 当时的机器只有 16 MB，因此没有做更大内存的支持，但可以自己去改源码</span>\n\t\tmemory_end = <span class="hljs-number">16</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;\n\t<span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">12</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)          <span class="hljs-comment">// 确认缓存区的末地址 (根据实际内存大小调整, &gt;12MB 留 4MB 缓存，&gt;6MB 留 2 MB 缓存，否则 1MB )</span>\n\t\tbuffer_memory_end = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;\n\t<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">6</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)\n\t\tbuffer_memory_end = <span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;\n\t<span class="hljs-keyword">else</span>\n\t\tbuffer_memory_end = <span class="hljs-number">1</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;\n\tmain_memory_start = buffer_memory_end;\n<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> RAMDISK</span>\n\tmain_memory_start += rd_init(main_memory_start, RAMDISK*<span class="hljs-number">1024</span>);      <span class="hljs-comment">// 如果需要虚拟盘，则再留一部分作为交换区</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>\n\tmem_init(main_memory_start,memory_end); <span class="hljs-comment">// 内存初始化，毕竟 Linux 操作系统下的所有内存都将被统一分配，用户程序没有权限随便使用内存，只能用被分配的</span>\n\ttrap_init();            <span class="hljs-comment">// 初始化中断</span>\n\tblk_dev_init();         <span class="hljs-comment">// 初始化块设备</span>\n\tchr_dev_init();         <span class="hljs-comment">// 初始化字符设备</span>\n\ttty_init();             <span class="hljs-comment">// 初始化 tty</span>\n\ttime_init();            <span class="hljs-comment">// 设置开机启动时间</span>\n\tsched_init();           <span class="hljs-comment">// 初始化任务调度程序，由此就将可以进行多任务切换了</span>\n\tbuffer_init(buffer_memory_end); <span class="hljs-comment">// 缓存区初始化</span>\n\thd_init();              <span class="hljs-comment">// 硬盘初始化</span>\n\tfloppy_init();          <span class="hljs-comment">// 软盘初始化</span>\n\tsti();                  <span class="hljs-comment">// 不再禁止中断，现在开始又允许中断了</span>\n\tmove_to_user_mode();    <span class="hljs-comment">// 进入用户态</span>\n\t<span class="hljs-keyword">if</span> (!fork()) {          <span class="hljs-comment">// 关于 fork 函数，下面将简单介绍。</span>\n\t\tinit();\n\t}\n\n\t<span class="hljs-keyword">for</span>(;;) pause();\n}</code></pre><p><strong>fork()</strong></p>\n<p>如果熟悉 C 语言，应该对 fork() 也比较熟悉吧。这将执行一次系统调用，最终的结果是，创建一个新的任务 (这里将原来的操作系统程序认为是 0 号进程/任务，将产生 1 号进程/任务)。新的任务与原有任务几乎一模一样，除了 fork() 调用的返回值不同。子任务将返回 0 ，原有任务将返回子任务的任务号。</p>\n<p>因此，对于上面的代码，<code>if(!fork())</code> ，0号任务将不执行 <code>if(){}</code> 语句块内的 init ，而 1 号任务将执行 <code>init()</code> 函数</p>\n<p>而 0 号进程在做什么呢?</p>\n<p>很简单，下面 <code>for(;;) pause();</code>。 <code>pause()</code> 是指让 CPU 完全停止，只有发生硬件中断， CPU 才会从停止状态中恢复 (前面已经设置了定时的/ 10ms/次的时钟中断，因此 CPU 总是能够恢复)，</p>\n<p>具体的描述就是，如果任务调度程序把时间片分配给了 0 号进程，那么 0 号进程唯一做的，就是让 CPU 停止。而且 0 号进程的 <code>for</code> 是死循环，每次把时间分配给 0 号进程，它就 CPU 停止。我们在 Linux 操作系统上，通过 top 可以看到对 cpu 有如下描述</p>\n<pre><code>%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n</code></pre>\n<p>其中对 idle(id) 的统计，其实就在 0 号任务让 cpu 停止工作了而已。</p>\n<h4>init(void)</h4>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n\t<span class="hljs-keyword">int</span> pid,i;\n\n\tsetup((<span class="hljs-keyword">void</span> *) &amp;drive_info);\n\t(<span class="hljs-keyword">void</span>) open(<span class="hljs-string">"/dev/tty0"</span>,O_RDWR,<span class="hljs-number">0</span>);\n\t(<span class="hljs-keyword">void</span>) dup(<span class="hljs-number">0</span>);\n\t(<span class="hljs-keyword">void</span>) dup(<span class="hljs-number">0</span>);\n\t<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d buffers = %d bytes buffer space\\n\\r"</span>,NR_BUFFERS,\n\t\tNR_BUFFERS*BLOCK_SIZE);\n\t<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Free mem: %d bytes\\n\\r"</span>,memory_end-main_memory_start);\n\t<span class="hljs-keyword">if</span> (!(pid=fork())) {\n\t\tclose(<span class="hljs-number">0</span>);\n\t\t<span class="hljs-keyword">if</span> (open(<span class="hljs-string">"/etc/rc"</span>,O_RDONLY,<span class="hljs-number">0</span>))\n\t\t\t_exit(<span class="hljs-number">1</span>);\n\t\texecve(<span class="hljs-string">"/bin/sh"</span>,argv_rc,envp_rc);\n\t\t_exit(<span class="hljs-number">2</span>);\n\t}\n\t<span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>)\n\t\t<span class="hljs-keyword">while</span> (pid != wait(&amp;i))\n\t\t\t<span class="hljs-comment">/* nothing */</span>;\n\t<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {\n\t\t<span class="hljs-keyword">if</span> ((pid=fork())&lt;<span class="hljs-number">0</span>) {\n\t\t\t<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Fork failed in init\\r\\n"</span>);\n\t\t\t<span class="hljs-keyword">continue</span>;\n\t\t}\n\t\t<span class="hljs-keyword">if</span> (!pid) {\n\t\t\tclose(<span class="hljs-number">0</span>);close(<span class="hljs-number">1</span>);close(<span class="hljs-number">2</span>);\n\t\t\tsetsid();\n\t\t\t(<span class="hljs-keyword">void</span>) open(<span class="hljs-string">"/dev/tty0"</span>,O_RDWR,<span class="hljs-number">0</span>);\n\t\t\t(<span class="hljs-keyword">void</span>) dup(<span class="hljs-number">0</span>);\n\t\t\t(<span class="hljs-keyword">void</span>) dup(<span class="hljs-number">0</span>);\n\t\t\t_exit(execve(<span class="hljs-string">"/bin/sh"</span>,argv,envp));\n\t\t}\n\t\t<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)\n\t\t\t<span class="hljs-keyword">if</span> (pid == wait(&amp;i))\n\t\t\t\t<span class="hljs-keyword">break</span>;\n\t\t<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\\n\\rchild %d died with code %04x\\n\\r"</span>,pid,i);\n\t\tsync();\n\t}\n\t_exit(<span class="hljs-number">0</span>);\t<span class="hljs-comment">/* NOTE! _exit, not exit() */</span>\n}</code></pre><p>那么 1 号任务在做什么呢？看 init 的代码，可以看到大量诸如 <code>/dev/tty0</code>, <code>/bin/sh</code> 的代码。哈哈，下面通过 1,2,3... 对步骤进行标号简单描述一下。</p>\n<ol>\n<li>\n<p>1 号进程在做的是 fork 出新的进程(暂时叫它进程 X )</p>\n</li>\n<li>\n<p>1 号进程不断询问 X 是否被销毁</p>\n<ul>\n<li>如果 X 进程被销毁了：那么继续执行步骤 1</li>\n<li>否则：继续执行步骤 2 （为什么会出现不断循环呢？其实由于任务调度程序的存在，在单个 CPU 看来，这个轮询并不一直发生，有一些时间片已经给了其他进程继续执行任务了</li>\n</ul>\n</li>\n<li>\n<p>X 任务通过调用 <code>execve()</code> 把当前程序的代码+数据全部替换成是 shell 的 (其实大量的用户程序都是通过这种 fork + execve 的形式出现的)</p>\n</li>\n<li>\n<p>X 任务(也就是 Shell 程序) 开始通过 tty 与用户开始交互。直到用户选择 <code>exit</code> 退出 shell</p>\n</li>\n</ol>\n<p><strong>execve(...)</strong></p>\n<p>前面介绍过 fork 是复制一份程序的各个寄存器的状态 + 程序的数据。现在 execve 做出的操作是直接将当前程序的代码和数据替换成目标程序的代码和数据，并通过对寄存器一定的重置，完成一个用户程序的启动流程(程序启动说到底不就是在内存中存在这个程序的代码，然后通过 CS:IP 定位到即将执行的程序指令，最后让 CPU 开始执行就 OK 了)</p>\n<h2>小结</h2>\n<p>整个操作系统的启动流程就简单地介绍到这里。</p>\n<p>0 号任务作为操作系统的常驻程序，在 OS 启动完成，每次时间片被分配给它，它就让 CPU 停止工作(通过 pause() 系统调用)</p>\n<p>1 号任务作为操作系统的常驻程序，唯一的任务就是判断进程X是否被退出，如果退出了，就重新创建一个(当然，也可能有人有疑问，为什么现在的 Linux 开多个 bash 都没有问题呢? 这里有个猜测是有一个隐藏的 shell 是被 1 号任务启动的，其它的 bash 是多余的。不过这只是猜测，待考察)</p>\n<h2>附录</h2>\n<h3>附录一</h3>\n<pre><code>.\n|-- Makefile\n|-- boot\n|   |-- head.s\n|-- fs\n|   |-- Makefile\n|   |-- bitmap.c\n|   |-- block_dev.c\n|   |-- buffer.c\n|   |-- char_dev.c\n|   |-- exec.c\n|   |-- fcntl.c\n|   |-- file_dev.c\n|   |-- file_table.c\n|   |-- inode.c\n|   |-- ioctl.c\n|   |-- namei.c\n|   |-- open.c\n|   |-- pipe.c\n|   |-- read_write.c\n|   |-- stat.c\n|   |-- super.c\n|   `-- truncate.c\n|-- include\n|   |-- a.out.h\n|   |-- asm\n|   |   |-- io.h\n|   |   |-- memory.h\n|   |   |-- segment.h\n|   |   `-- system.h\n|   |-- const.h\n|   |-- ctype.h\n|   |-- errno.h\n|   |-- fcntl.h\n|   |-- linux\n|   |   |-- config.h\n|   |   |-- fdreg.h\n|   |   |-- fs.h\n|   |   |-- hdreg.h\n|   |   |-- head.h\n|   |   |-- kernel.h\n|   |   |-- mm.h\n|   |   |-- sched.h\n|   |   |-- sys.h\n|   |   `-- tty.h\n|   |-- signal.h\n|   |-- stdarg.h\n|   |-- stddef.h\n|   |-- string.h\n|   |-- sys\n|   |   |-- stat.h\n|   |   |-- times.h\n|   |   |-- types.h\n|   |   |-- utsname.h\n|   |   `-- wait.h\n|   |-- termios.h\n|   |-- time.h\n|   |-- unistd.h\n|   `-- utime.h\n|-- init\n|   |-- main.c\n|-- kernel\n|   |-- Makefile\n|   |-- asm.o\n|   |-- asm.s\n|   |-- blk_drv\n|   |   |-- Makefile\n|   |   |-- blk.h\n|   |   |-- floppy.c\n|   |   |-- hd.c\n|   |   |-- ll_rw_blk.c\n|   |   `-- ramdisk.c\n|   |-- chr_drv\n|   |   |-- Makefile\n|   |   |-- console.c\n|   |   |-- keyboard.S\n|   |   |-- rs_io.s\n|   |   |-- serial.c\n|   |   |-- tty_io.c\n|   |   `-- tty_ioctl.c\n|   |-- exit.c\n|   |-- fork.c\n|   |-- fork.i\n|   |-- math\n|   |   |-- Makefile\n|   |   `-- math_emulate.c\n|   |-- mktime.c\n|   |-- panic.c\n|   |-- printk.c\n|   |-- sched.c\n|   |-- sched.o\n|   |-- signal.c\n|   |-- sys.c\n|   |-- system_call.o\n|   |-- system_call.s\n|   |-- traps.c\n|   |-- traps.o\n|   `-- vsprintf.c\n|-- lib\n|   |-- Makefile\n|   |-- _exit.c\n|   |-- close.c\n|   |-- ctype.c\n|   |-- dup.c\n|   |-- errno.c\n|   |-- execve.c\n|   |-- malloc.c\n|   |-- open.c\n|   |-- setsid.c\n|   |-- string.c\n|   |-- wait.c\n|   `-- write.c\n|-- mm\n|   |-- Makefile\n|   |-- memory.c\n|   `-- page.s\n`-- tools\n    `-- build.c\n</code></pre>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-10-06-understand-Kernel-3.json",ext:".json",sourceBase:"2018-10-06-understand-Kernel-3.md",sourceExt:".md"}},zZw6:function(n){n.exports={title:"理解 Linux Kernel (7) - 字符设备",author:"fangfeng",date:"2018-12-28T00:00:00.000Z",tags:["Linux","Kernel","Char Dev"],bodyContent:'相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。\n\n回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。\n\n那么，常见的字符设备有什么？显示器、键盘、鼠标。\n\n\x3c!-- more --\x3e\n\n## 宏观概览\n\n通常在我们的认识中，命令行终端就被认为是与一套字符设备相配合来使用的。很正常嘛。我们打开一个 Shell ，通过键盘输入一些字符，配合显示器把这些经过加工的字符展示出来。\n\n那么，是不是就意味着 Shell 作为一个任务(进程)，以键盘设备作为标准输入，以显示设备作为标准输出?\n\n看看一个 1 号任务 `/bin/bash` 的文件描述符说明吧。\n\n```sh\n$ ls -al\ntotal 0\ndr-x------ 2 root root  0 Dec 13 23:20 .\ndr-xr-xr-x 9 root root  0 Dec 13 23:20 ..\nlrwx------ 1 root root 64 Dec 13 23:20 0 -> /dev/pts/0\nlrwx------ 1 root root 64 Dec 13 23:20 1 -> /dev/pts/0\nlrwx------ 1 root root 64 Dec 13 23:20 2 -> /dev/pts/0\nlrwx------ 1 root root 64 Dec 25 01:09 255 -> /dev/pts/0\n```\n\n这里文件描述符 0, 1, 2 分别表示任务的标准输入、标准输出、标准错误。这些内容在表现形式上做了一个链接。\n\n那么，`/dev/pts/0` 是什么? \n\n```sh\ncrw--w---- 1 root tty 136, 0 Dec 13 23:20 /dev/pts/0\n```\n\n一个字符设备。到此为止，似乎和最初预想的有比较大的区别。至少在假象中，至少是一个输入(键盘)，一个输出(显示器)。怎么就混成了一个呢？\n\n本来是怎么都想不通的，但后来配合"Unix一切皆文件"的信条，总算是有点明白了。\n\n相信大家都有这这样的经历，某个程序是以键盘输入作为标准输入的。其实就和上面👆展示的一样 `0 -> /dev/pts/0` 。那么，有没有考虑过这整套流程是怎么协作的呢？\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fyjvtjiu0zj31980oqmxe.jpg)\n\n对于程序来说，我们还是普通的调用 `read`, `write` 等经过封装的函数，来读取一个所谓的文件。\n\n但对于文件是字符设备时，最终调用的就是 `tty_read`, `tty_write` 了。通俗的讲，大概率的就是键盘作为输入，显示器作为输出了。\n\n## 源码剖析\n\n### 文件读写\n\n这部分上一篇已经介绍过了，不做过多说明。\n\n简单回顾下 `sys_read` 函数\n\n```c\nint sys_read(unsigned int fd,char * buf,int count)\n{\n\tstruct file * file;\n\tstruct m_inode * inode;\n\n\tif (fd>=NR_OPEN || count<0 || !(file=current->filp[fd]))\n\t\treturn -EINVAL;\n\tif (!count)\n\t\treturn 0;\n\tverify_area(buf,count);\n\tinode = file->f_inode;\n\tif (inode->i_pipe)\n\t\treturn (file->f_mode&1)?read_pipe(inode,buf,count):-EIO;\n    /* 确认到i节点描述的是字符设备 */\n\tif (S_ISCHR(inode->i_mode)) \n\t\treturn rw_char(READ,inode->i_zone[0],buf,count,&file->f_pos);\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn block_read(inode->i_zone[0],&file->f_pos,buf,count);\n\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode)) {\n\t\tif (count+file->f_pos > inode->i_size)\n\t\t\tcount = inode->i_size - file->f_pos;\n\t\tif (count<=0)\n\t\t\treturn 0;\n\t\treturn file_read(inode,file,buf,count);\n\t}\n\tprintk("(Read)inode->i_mode=%06o\\n\\r",inode->i_mode);\n\treturn -EINVAL;\n}\n```\n\n可以看到 `S_ISCHR()` 就是在对i节点的类型进行判别，从而进行不同的分发。\n\n```c\nstatic crw_ptr crw_table[]={\n\tNULL,\t\t/* nodev */\n\trw_memory,\t/* /dev/mem etc */\n\tNULL,\t\t/* /dev/fd */\n\tNULL,\t\t/* /dev/hd */\n\trw_ttyx,\t/* /dev/ttyx */\n\trw_tty,\t\t/* /dev/tty */\n\tNULL,\t\t/* /dev/lp */\n\tNULL};\t\t/* unnamed pipes */\n/**\n * 这段还是涉及到分发，由不同的设备号(dev) 来确定执行函数 (ttyx, 串口终端; tty, 控制台终端; mem, /dev/mem 等)\n * crw_ptr 是 C 语言中常见的函数指针。由dev号来确定调用哪个函数\n */\nint rw_char(int rw,int dev, char * buf, int count, off_t * pos)\n{\n\tcrw_ptr call_addr;\n\n\tif (MAJOR(dev)>=NRDEVS)\n\t\treturn -ENODEV;\n\tif (!(call_addr=crw_table[MAJOR(dev)]))\n\t\treturn -ENODEV;\n\treturn call_addr(rw,MINOR(dev),buf,count,pos);\n}\n```\n\n执行到 `rw_tty`, `rw_ttyx` 两个函数，就将对读/写进行区分，并由特定的函数进行处理。\n\n```c\nstatic int rw_ttyx(int rw,unsigned minor,char * buf,int count,off_t * pos)\n{\n\treturn ((rw==READ)?tty_read(minor,buf,count):\n\t\ttty_write(minor,buf,count));\n}\n\nstatic int rw_tty(int rw,unsigned minor,char * buf,int count, off_t * pos)\n{\n\tif (current->tty<0)\n\t\treturn -EPERM;\n\treturn rw_ttyx(rw,current->tty,buf,count,pos);\n}\n```\n\n到此为止，应该能够基本了解了字符设备，作为 Linux 的文件，所应该有的读写的相关支持。\n\n但是，究竟读、写的内容在哪呢？比如正规文件，都很容易地可以理解到，就是从磁盘中取出某个/某几个盘块的内容即可。字符设备的IO要从哪里取(往哪里送)数据呢?\n\n### 字符设备驱动\n\n对于设备驱动这个概念，至今没有搞清楚。不过，这不妨碍对代码的理解。反正对于字符设备驱动来说，也就是 Linux 内核中的一些软件层面的代码，与普通代码的唯一区别，就是对外设硬件做了相应的交互支持。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fykyc6lo9pj31i40u0ac8.jpg)\n\n承接操作系统的字符设备接口，`tty_read`、`tty_write` 负责读入和写出。\n\n从哪里读？`secondary` 数据队列；往哪里写？`write_q` 数据队列。\n\n同时，也可以看到，与这些队列直接相关的，就是我们熟知的键盘和显示器了。是不是有了点豁然开朗的感觉。\n\n好，我们先来看看这里描述的三个队列究竟是怎么工作的。这里就不得不先看看内存中抽象出来的描述终端的数据结构 `tty_struct`。\n\n```c\n/**\n * copied from include/linux/tty.h\n */\nstruct tty_struct {\n\tstruct termios termios;     /* terminal IO conf */\n\tint pgrp;                   /* 所属进程组 */\n\tint stopped;                /* 停止标志 */\n\tvoid (*write)(struct tty_struct * tty); /* 终端写函数指针 */\n\tstruct tty_queue read_q;    /* 终端读队列 */\n\tstruct tty_queue write_q;   /* 终端写队列 */\n\tstruct tty_queue secondary; /* 终端辅助队列 */\n};\n\n/**\n * copied from include/termios.h\n */\nstruct termios {                /* terminal IO 属性 */\n\tunsigned long c_iflag;\t\t/* input mode flags */\n\tunsigned long c_oflag;\t\t/* output mode flags */\n\tunsigned long c_cflag;\t\t/* control mode flags */\n\tunsigned long c_lflag;\t\t/* local mode flags */\n\tunsigned char c_line;\t\t/* line discipline */\n\tunsigned char c_cc[NCCS];\t/* control characters */\n};\n\n/**\n * copied from include/linux/tty.h\n */\nstruct tty_queue {\n\tunsigned long data;         /* 字符行数量 | 串口终端则存储端口号 */\n\tunsigned long head;         /* 头指针 */\n\tunsigned long tail;         /* 尾指针 */\n\tstruct task_struct * proc_list; /* 等待该终端的任务队列 */\n\tchar buf[TTY_BUF_SIZE];     /* 队列的缓冲区 */\n};\n```\n\n对于任何任务需要读写字符设备(这里指终端设备)，最终直接读取/写入到的就是 `secondary` 和 `write_q`。\n\n---\n\n这里可能有个小小的疑问? 为什么读终端设备不是读 `read_q` 呢？\n\n其实也比较好解释，相信日常在操作命令行的时候，我们在键盘上敲击的键位与显示器上实际展示的内容是不相匹配的。最普通的，我们键入了 **delete(删除键)**，为什么不是一个 **delete** 对应的 ascii (当然，这里请先忽视非打印字符的问题)，而是删除了最后一个字符呢？完全可以想象，反正任何键位与驱动交互的时候都是传入一串二进制码嘛。\n\n这里的 `secondary` 完成的就是怎么一个工作，`read_q` 存储的是所有的外设(这里是键盘)的输入，并原样存储。而到了 `secondary` 就是经过相应的加工，诸如控制字符之类的都展现了各自的意义，并完成一些加工工作，而不再仅仅只是普通地展示了。\n\n---\n\n另外，可能还有一个问题。虽然我们已经习惯了在命令行交互时，所有的输入都将直接在显示器上进行展示，好像我们在直接往显示器上写内容。但是，前面我们描述的内容都是，键盘设备作为输入，是要写到 `read_q` 乃至 `secondary` 并最终作为进程的输入的。在显示器上显示并不是它本来应该干的事情 (比较显示器上展示的应该是 `write_q` 的内容，也就是进程的标准输出)\n\n事实上，这仅仅只是一个回显，将 `secondary` 队列的内容复制了一份到写队列，也就呈现出让显示器打印相应键盘输入的效果了。\n\n同时，这也就能够直接解释为什么我们在使用 `passwd`, `su`, `sudo` 等命令时，要求输入密码都是不在显示器上回显的。实现也相当简单了嘛。把 tty_struct.termios 的相应控制属性 (ECHO) 重置，就可以实现不回显的效果了。\n\n### 终端设备交互\n\n最后一部分，应该也是最关心的了。外设如何与操作系统完成交互。其实也能够想得到了——中断。\n\n在操作系统初始化时，就把中断描述符表的中断表项配置得当。之后的事情就是等待键盘等外设输入的中断信号了。\n\n又看回到了 `init/main.c` 程序\n\n```c\nvoid main(void)\n{\n    ...\n\ttrap_init();\n\tblk_dev_init();\n\tchr_dev_init(); /* 块设备相关初始化, 方法体是空的，没有实现 */\n\ttty_init();     /* tty 终端设备初始化 */\n\ttime_init();\n\tsched_init();\n\tbuffer_init(buffer_memory_end);\n    ...\n}\n```\n\n```\n/**\n * Copied from kernel/chr_drv/tty_io.c\n * 终端设备初识化\n */\nvoid tty_init(void)\n{\n    /** 串口设备初始化 */\n\trs_init();\n    /** 控制台设备初始化 */\n\tcon_init();\n}\n```\n\n至于为什么有两种初始化方式。这来源于终端又区分为控制台终端与串口终端，区别就是一个是直接建立在主机上，串口终端是通过串行接口连接到主机的。当然，这都是古老的方式了，细节就不太清楚了。\n\n下面来看看 `con_init()` 做了哪些工作(`rs_init()` 的内容请自行了解)\n\n```c\nvoid con_init(void)\n{\n\tregister unsigned char a;\n\tchar *display_desc = "????";\n\tchar *display_ptr;\n\n    /**\n     * 读取 setup.s 程序预处理的内容\n     * 包括显示器的各种配置参数\n     */\n\tvideo_num_columns = ORIG_VIDEO_COLS;\n\tvideo_size_row = video_num_columns * 2;\n\tvideo_num_lines = ORIG_VIDEO_LINES;\n\tvideo_page = ORIG_VIDEO_PAGE;\n\tvideo_erase_char = 0x0720;\n\n    /**\n     * 读取显示器的配置并进行相关设置 (省略代码)\n     */\n    ...\n\n\torigin\t= video_mem_start;\n\tscr_end\t= video_mem_start + video_num_lines * video_size_row;\n\ttop\t= 0;\n\tbottom\t= video_num_lines;\n\n\tgotoxy(ORIG_X,ORIG_Y);\n    /** 设置陷阱门 */\n\tset_trap_gate(0x21,&keyboard_interrupt);\n\toutb_p(inb_p(0x21)&0xfd,0x21);\n\ta=inb_p(0x61);\n\toutb_p(a|0x80,0x61);\n\toutb(a,0x61);\n}\n```\n\n应该能够看到最重要的内容就是**设置键盘中断陷阱门**了。\n\n之后只有静静地等待键位敲击，也就能够产生硬件中断，从而让 `read_q` 获得到相应的字符输入。\n\n至于键盘中断的相应处理流程，这里不再详述。简述一些步骤:\n\n1. 产生硬中断 `keyboard_interrupt`，由程序 `Keyboard.s` 的汇编代码进行处理\n\n2. 根据不同的键盘(US 键盘、德式键盘等等)将获得的键位信号进行相应的字符转换(查转换表)\n\n3. 调用 `do_tty_interrupt` 处理函数 (确认是给哪个终端的信号)\n\n4. 调用 `copy_to_cooked(tty)` ，即完成 `read_q` 到 `secondary` 的相关加工。\n\n\n\n```plain\n  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n```',bodyHtml:'<p>相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。</p>\n<p>回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。</p>\n<p>那么，常见的字符设备有什么？显示器、键盘、鼠标。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>宏观概览</h2>\n<p>通常在我们的认识中，命令行终端就被认为是与一套字符设备相配合来使用的。很正常嘛。我们打开一个 Shell ，通过键盘输入一些字符，配合显示器把这些经过加工的字符展示出来。</p>\n<p>那么，是不是就意味着 Shell 作为一个任务(进程)，以键盘设备作为标准输入，以显示设备作为标准输出?</p>\n<p>看看一个 1 号任务 <code>/bin/bash</code> 的文件描述符说明吧。</p>\n<pre><code class="hljs">$ ls -al\ntotal 0\ndr-x------ 2 root root  0 Dec 13 23:20 .\ndr-xr-xr-x 9 root root  0 Dec 13 23:20 ..\nlrwx------ 1 root root 64 Dec 13 23:20 0 -&gt; /dev/pts/0\nlrwx------ 1 root root 64 Dec 13 23:20 1 -&gt; /dev/pts/0\nlrwx------ 1 root root 64 Dec 13 23:20 2 -&gt; /dev/pts/0\nlrwx------ 1 root root 64 Dec 25 01:09 255 -&gt; /dev/pts/0</code></pre><p>这里文件描述符 0, 1, 2 分别表示任务的标准输入、标准输出、标准错误。这些内容在表现形式上做了一个链接。</p>\n<p>那么，<code>/dev/pts/0</code> 是什么?</p>\n<pre><code class="hljs">crw--w---- 1 root tty 136, 0 Dec 13 23:20 /dev/pts/0</code></pre><p>一个字符设备。到此为止，似乎和最初预想的有比较大的区别。至少在假象中，至少是一个输入(键盘)，一个输出(显示器)。怎么就混成了一个呢？</p>\n<p>本来是怎么都想不通的，但后来配合&quot;Unix一切皆文件&quot;的信条，总算是有点明白了。</p>\n<p>相信大家都有这这样的经历，某个程序是以键盘输入作为标准输入的。其实就和上面👆展示的一样 <code>0 -&gt; /dev/pts/0</code> 。那么，有没有考虑过这整套流程是怎么协作的呢？</p>\n<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyjvtjiu0zj31980oqmxe.jpg" alt=""></p>\n<p>对于程序来说，我们还是普通的调用 <code>read</code>, <code>write</code> 等经过封装的函数，来读取一个所谓的文件。</p>\n<p>但对于文件是字符设备时，最终调用的就是 <code>tty_read</code>, <code>tty_write</code> 了。通俗的讲，大概率的就是键盘作为输入，显示器作为输出了。</p>\n<h2>源码剖析</h2>\n<h3>文件读写</h3>\n<p>这部分上一篇已经介绍过了，不做过多说明。</p>\n<p>简单回顾下 <code>sys_read</code> 函数</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sys_read</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">char</span> * buf,<span class="hljs-keyword">int</span> count)</span>\n</span>{\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">file</span>;</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">inode</span>;</span>\n\n\t<span class="hljs-keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="hljs-number">0</span> || !(file=current-&gt;filp[fd]))\n\t\t<span class="hljs-keyword">return</span> -EINVAL;\n\t<span class="hljs-keyword">if</span> (!count)\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n\tverify_area(buf,count);\n\tinode = file-&gt;f_inode;\n\t<span class="hljs-keyword">if</span> (inode-&gt;i_pipe)\n\t\t<span class="hljs-keyword">return</span> (file-&gt;f_mode&amp;<span class="hljs-number">1</span>)?read_pipe(inode,buf,count):-EIO;\n    <span class="hljs-comment">/* 确认到i节点描述的是字符设备 */</span>\n\t<span class="hljs-keyword">if</span> (S_ISCHR(inode-&gt;i_mode)) \n\t\t<span class="hljs-keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="hljs-number">0</span>],buf,count,&amp;file-&gt;f_pos);\n\t<span class="hljs-keyword">if</span> (S_ISBLK(inode-&gt;i_mode))\n\t\t<span class="hljs-keyword">return</span> block_read(inode-&gt;i_zone[<span class="hljs-number">0</span>],&amp;file-&gt;f_pos,buf,count);\n\t<span class="hljs-keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) {\n\t\t<span class="hljs-keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)\n\t\t\tcount = inode-&gt;i_size - file-&gt;f_pos;\n\t\t<span class="hljs-keyword">if</span> (count&lt;=<span class="hljs-number">0</span>)\n\t\t\t<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n\t\t<span class="hljs-keyword">return</span> file_read(inode,file,buf,count);\n\t}\n\tprintk(<span class="hljs-string">"(Read)inode-&gt;i_mode=%06o\\n\\r"</span>,inode-&gt;i_mode);\n\t<span class="hljs-keyword">return</span> -EINVAL;\n}</code></pre><p>可以看到 <code>S_ISCHR()</code> 就是在对i节点的类型进行判别，从而进行不同的分发。</p>\n<pre><code class="hljs"><span class="hljs-keyword">static</span> crw_ptr crw_table[]={\n\t<span class="hljs-literal">NULL</span>,\t\t<span class="hljs-comment">/* nodev */</span>\n\trw_memory,\t<span class="hljs-comment">/* /dev/mem etc */</span>\n\t<span class="hljs-literal">NULL</span>,\t\t<span class="hljs-comment">/* /dev/fd */</span>\n\t<span class="hljs-literal">NULL</span>,\t\t<span class="hljs-comment">/* /dev/hd */</span>\n\trw_ttyx,\t<span class="hljs-comment">/* /dev/ttyx */</span>\n\trw_tty,\t\t<span class="hljs-comment">/* /dev/tty */</span>\n\t<span class="hljs-literal">NULL</span>,\t\t<span class="hljs-comment">/* /dev/lp */</span>\n\t<span class="hljs-literal">NULL</span>};\t\t<span class="hljs-comment">/* unnamed pipes */</span>\n<span class="hljs-comment">/**\n * 这段还是涉及到分发，由不同的设备号(dev) 来确定执行函数 (ttyx, 串口终端; tty, 控制台终端; mem, /dev/mem 等)\n * crw_ptr 是 C 语言中常见的函数指针。由dev号来确定调用哪个函数\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rw_char</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rw,<span class="hljs-keyword">int</span> dev, <span class="hljs-keyword">char</span> * buf, <span class="hljs-keyword">int</span> count, <span class="hljs-keyword">off_t</span> * pos)</span>\n</span>{\n\tcrw_ptr call_addr;\n\n\t<span class="hljs-keyword">if</span> (MAJOR(dev)&gt;=NRDEVS)\n\t\t<span class="hljs-keyword">return</span> -ENODEV;\n\t<span class="hljs-keyword">if</span> (!(call_addr=crw_table[MAJOR(dev)]))\n\t\t<span class="hljs-keyword">return</span> -ENODEV;\n\t<span class="hljs-keyword">return</span> call_addr(rw,MINOR(dev),buf,count,pos);\n}</code></pre><p>执行到 <code>rw_tty</code>, <code>rw_ttyx</code> 两个函数，就将对读/写进行区分，并由特定的函数进行处理。</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rw_ttyx</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rw,<span class="hljs-keyword">unsigned</span> minor,<span class="hljs-keyword">char</span> * buf,<span class="hljs-keyword">int</span> count,<span class="hljs-keyword">off_t</span> * pos)</span>\n</span>{\n\t<span class="hljs-keyword">return</span> ((rw==READ)?tty_read(minor,buf,count):\n\t\ttty_write(minor,buf,count));\n}\n\n<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rw_tty</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rw,<span class="hljs-keyword">unsigned</span> minor,<span class="hljs-keyword">char</span> * buf,<span class="hljs-keyword">int</span> count, <span class="hljs-keyword">off_t</span> * pos)</span>\n</span>{\n\t<span class="hljs-keyword">if</span> (current-&gt;tty&lt;<span class="hljs-number">0</span>)\n\t\t<span class="hljs-keyword">return</span> -EPERM;\n\t<span class="hljs-keyword">return</span> rw_ttyx(rw,current-&gt;tty,buf,count,pos);\n}</code></pre><p>到此为止，应该能够基本了解了字符设备，作为 Linux 的文件，所应该有的读写的相关支持。</p>\n<p>但是，究竟读、写的内容在哪呢？比如正规文件，都很容易地可以理解到，就是从磁盘中取出某个/某几个盘块的内容即可。字符设备的IO要从哪里取(往哪里送)数据呢?</p>\n<h3>字符设备驱动</h3>\n<p>对于设备驱动这个概念，至今没有搞清楚。不过，这不妨碍对代码的理解。反正对于字符设备驱动来说，也就是 Linux 内核中的一些软件层面的代码，与普通代码的唯一区别，就是对外设硬件做了相应的交互支持。</p>\n<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fykyc6lo9pj31i40u0ac8.jpg" alt=""></p>\n<p>承接操作系统的字符设备接口，<code>tty_read</code>、<code>tty_write</code> 负责读入和写出。</p>\n<p>从哪里读？<code>secondary</code> 数据队列；往哪里写？<code>write_q</code> 数据队列。</p>\n<p>同时，也可以看到，与这些队列直接相关的，就是我们熟知的键盘和显示器了。是不是有了点豁然开朗的感觉。</p>\n<p>好，我们先来看看这里描述的三个队列究竟是怎么工作的。这里就不得不先看看内存中抽象出来的描述终端的数据结构 <code>tty_struct</code>。</p>\n<pre><code class="hljs"><span class="hljs-comment">/**\n * copied from include/linux/tty.h\n */</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> {</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">termios</span> <span class="hljs-title">termios</span>;</span>     <span class="hljs-comment">/* terminal IO conf */</span>\n\t<span class="hljs-keyword">int</span> pgrp;                   <span class="hljs-comment">/* 所属进程组 */</span>\n\t<span class="hljs-keyword">int</span> stopped;                <span class="hljs-comment">/* 停止标志 */</span>\n\t<span class="hljs-keyword">void</span> (*write)(struct tty_struct * tty); <span class="hljs-comment">/* 终端写函数指针 */</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_queue</span> <span class="hljs-title">read_q</span>;</span>    <span class="hljs-comment">/* 终端读队列 */</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_queue</span> <span class="hljs-title">write_q</span>;</span>   <span class="hljs-comment">/* 终端写队列 */</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_queue</span> <span class="hljs-title">secondary</span>;</span> <span class="hljs-comment">/* 终端辅助队列 */</span>\n};\n\n<span class="hljs-comment">/**\n * copied from include/termios.h\n */</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">termios</span> {</span>                <span class="hljs-comment">/* terminal IO 属性 */</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> c_iflag;\t\t<span class="hljs-comment">/* input mode flags */</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> c_oflag;\t\t<span class="hljs-comment">/* output mode flags */</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> c_cflag;\t\t<span class="hljs-comment">/* control mode flags */</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> c_lflag;\t\t<span class="hljs-comment">/* local mode flags */</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> c_line;\t\t<span class="hljs-comment">/* line discipline */</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> c_cc[NCCS];\t<span class="hljs-comment">/* control characters */</span>\n};\n\n<span class="hljs-comment">/**\n * copied from include/linux/tty.h\n */</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_queue</span> {</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> data;         <span class="hljs-comment">/* 字符行数量 | 串口终端则存储端口号 */</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> head;         <span class="hljs-comment">/* 头指针 */</span>\n\t<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> tail;         <span class="hljs-comment">/* 尾指针 */</span>\n\t<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> * <span class="hljs-title">proc_list</span>;</span> <span class="hljs-comment">/* 等待该终端的任务队列 */</span>\n\t<span class="hljs-keyword">char</span> buf[TTY_BUF_SIZE];     <span class="hljs-comment">/* 队列的缓冲区 */</span>\n};</code></pre><p>对于任何任务需要读写字符设备(这里指终端设备)，最终直接读取/写入到的就是 <code>secondary</code> 和 <code>write_q</code>。</p>\n<hr>\n<p>这里可能有个小小的疑问? 为什么读终端设备不是读 <code>read_q</code> 呢？</p>\n<p>其实也比较好解释，相信日常在操作命令行的时候，我们在键盘上敲击的键位与显示器上实际展示的内容是不相匹配的。最普通的，我们键入了 <strong>delete(删除键)</strong>，为什么不是一个 <strong>delete</strong> 对应的 ascii (当然，这里请先忽视非打印字符的问题)，而是删除了最后一个字符呢？完全可以想象，反正任何键位与驱动交互的时候都是传入一串二进制码嘛。</p>\n<p>这里的 <code>secondary</code> 完成的就是怎么一个工作，<code>read_q</code> 存储的是所有的外设(这里是键盘)的输入，并原样存储。而到了 <code>secondary</code> 就是经过相应的加工，诸如控制字符之类的都展现了各自的意义，并完成一些加工工作，而不再仅仅只是普通地展示了。</p>\n<hr>\n<p>另外，可能还有一个问题。虽然我们已经习惯了在命令行交互时，所有的输入都将直接在显示器上进行展示，好像我们在直接往显示器上写内容。但是，前面我们描述的内容都是，键盘设备作为输入，是要写到 <code>read_q</code> 乃至 <code>secondary</code> 并最终作为进程的输入的。在显示器上显示并不是它本来应该干的事情 (比较显示器上展示的应该是 <code>write_q</code> 的内容，也就是进程的标准输出)</p>\n<p>事实上，这仅仅只是一个回显，将 <code>secondary</code> 队列的内容复制了一份到写队列，也就呈现出让显示器打印相应键盘输入的效果了。</p>\n<p>同时，这也就能够直接解释为什么我们在使用 <code>passwd</code>, <code>su</code>, <code>sudo</code> 等命令时，要求输入密码都是不在显示器上回显的。实现也相当简单了嘛。把 tty_struct.termios 的相应控制属性 (ECHO) 重置，就可以实现不回显的效果了。</p>\n<h3>终端设备交互</h3>\n<p>最后一部分，应该也是最关心的了。外设如何与操作系统完成交互。其实也能够想得到了——中断。</p>\n<p>在操作系统初始化时，就把中断描述符表的中断表项配置得当。之后的事情就是等待键盘等外设输入的中断信号了。</p>\n<p>又看回到了 <code>init/main.c</code> 程序</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n    ...\n\ttrap_init();\n\tblk_dev_init();\n\tchr_dev_init(); <span class="hljs-comment">/* 块设备相关初始化, 方法体是空的，没有实现 */</span>\n\ttty_init();     <span class="hljs-comment">/* tty 终端设备初始化 */</span>\n\ttime_init();\n\tsched_init();\n\tbuffer_init(buffer_memory_end);\n    ...\n}</code></pre><pre><code>/**\n * Copied from kernel/chr_drv/tty_io.c\n * 终端设备初识化\n */\nvoid tty_init(void)\n{\n    /** 串口设备初始化 */\n\trs_init();\n    /** 控制台设备初始化 */\n\tcon_init();\n}\n</code></pre>\n<p>至于为什么有两种初始化方式。这来源于终端又区分为控制台终端与串口终端，区别就是一个是直接建立在主机上，串口终端是通过串行接口连接到主机的。当然，这都是古老的方式了，细节就不太清楚了。</p>\n<p>下面来看看 <code>con_init()</code> 做了哪些工作(<code>rs_init()</code> 的内容请自行了解)</p>\n<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">con_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>\n</span>{\n\t<span class="hljs-keyword">register</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> a;\n\t<span class="hljs-keyword">char</span> *display_desc = <span class="hljs-string">"????"</span>;\n\t<span class="hljs-keyword">char</span> *display_ptr;\n\n    <span class="hljs-comment">/**\n     * 读取 setup.s 程序预处理的内容\n     * 包括显示器的各种配置参数\n     */</span>\n\tvideo_num_columns = ORIG_VIDEO_COLS;\n\tvideo_size_row = video_num_columns * <span class="hljs-number">2</span>;\n\tvideo_num_lines = ORIG_VIDEO_LINES;\n\tvideo_page = ORIG_VIDEO_PAGE;\n\tvideo_erase_char = <span class="hljs-number">0x0720</span>;\n\n    <span class="hljs-comment">/**\n     * 读取显示器的配置并进行相关设置 (省略代码)\n     */</span>\n    ...\n\n\torigin\t= video_mem_start;\n\tscr_end\t= video_mem_start + video_num_lines * video_size_row;\n\ttop\t= <span class="hljs-number">0</span>;\n\tbottom\t= video_num_lines;\n\n\tgotoxy(ORIG_X,ORIG_Y);\n    <span class="hljs-comment">/** 设置陷阱门 */</span>\n\tset_trap_gate(<span class="hljs-number">0x21</span>,&amp;keyboard_interrupt);\n\toutb_p(inb_p(<span class="hljs-number">0x21</span>)&amp;<span class="hljs-number">0xfd</span>,<span class="hljs-number">0x21</span>);\n\ta=inb_p(<span class="hljs-number">0x61</span>);\n\toutb_p(a|<span class="hljs-number">0x80</span>,<span class="hljs-number">0x61</span>);\n\toutb(a,<span class="hljs-number">0x61</span>);\n}</code></pre><p>应该能够看到最重要的内容就是<strong>设置键盘中断陷阱门</strong>了。</p>\n<p>之后只有静静地等待键位敲击，也就能够产生硬件中断，从而让 <code>read_q</code> 获得到相应的字符输入。</p>\n<p>至于键盘中断的相应处理流程，这里不再详述。简述一些步骤:</p>\n<ol>\n<li>\n<p>产生硬中断 <code>keyboard_interrupt</code>，由程序 <code>Keyboard.s</code> 的汇编代码进行处理</p>\n</li>\n<li>\n<p>根据不同的键盘(US 键盘、德式键盘等等)将获得的键位信号进行相应的字符转换(查转换表)</p>\n</li>\n<li>\n<p>调用 <code>do_tty_interrupt</code> 处理函数 (确认是给哪个终端的信号)</p>\n</li>\n<li>\n<p>调用 <code>copy_to_cooked(tty)</code> ，即完成 <code>read_q</code> 到 <code>secondary</code> 的相关加工。</p>\n</li>\n</ol>\n<pre><code class="hljs">__                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | \'_ \\ / _` | |_ / _ \\ \'_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/</code></pre>',preview:"",dir:"content",base:"2018-12-28-understand-Kernel-7.json",ext:".json",sourceBase:"2018-12-28-understand-Kernel-7.md",sourceExt:".md"}}},[["MDTK","5d41","9da1"]]]);