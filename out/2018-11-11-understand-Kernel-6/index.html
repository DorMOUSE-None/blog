<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/EIk1vmF3q1tluVqsNXnmg/pages/post.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/EIk1vmF3q1tluVqsNXnmg/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.4197c692ff76bb557049.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.923c53dcd3ae2618e978.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.c66cb323.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.fdd739f1.chunk.css"/></head><body><div id="__next"><header><h1 class="title">ffutop</h1><div><a href="/blog/index">博客</a><a href="/blog/archives">归档</a><a href="/blog/tags">标签</a><a href="/blog/about">关于</a></div></header><div><main class="main"><div class="page-post"><div id="#write"><hr>
<p>title: 理解 Linux Kernel (6) - read &#x26; write
author: fangfeng
date: 2018-11-11
tags:</p>
<ul>
<li>Linux</li>
<li>Kernel</li>
<li>File System</li>
<li>read &#x26; write</li>
</ul>
<hr>
<p><a href="https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/">前一篇</a>已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。</p>
<p>首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式</p>
<pre><code class="language-c">#include &#x3C;stdio.h>
#include &#x3C;stdlib.h>
#include &#x3C;string.h>
#include &#x3C;unistd.h>
#include &#x3C;fcntl.h>
#include &#x3C;errno.h>
#include &#x3C;sys/types.h>
#include &#x3C;sys/stat.h>

int panic()
{
    fprintf(stderr, "%s (errno=%d)\n", strerror(errno), errno);
    return -1;
}

int main(int argc, char *argv[])
{
    /* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */
    int fd = open("/root/frw.txt", O_RDWR | O_CREAT);
    if (fd == -1)
        return panic();

    /* 向文件写入 Hello World! 共计 12 个字符 */
    ssize_t wsize = write(fd, "Hello World!", 12);
    if (wsize == -1)
        return panic();

    /* 重定位文件读写指针 */
    off_t off = lseek(fd, 0, SEEK_SET);
    if (off == -1)
        return panic();

    char* buf = (char *) malloc(wsize);
    /* 读取文件内容 */
    ssize_t rsize = read(fd, buf, wsize);
    if (rsize == -1)
        return panic();

    printf("%s\n", buf);
    free(buf);
    /* 关闭文件 */
    int stat = close(fd);
    if (stat == -1)
        return panic();

    return 0;
}
</code></pre>
<h2>高速缓冲区初始化</h2>
<p>上一篇已经描述过了，文件系统的结构、包括数据，都是持久化地存储在存储设备中的。</p>
<p>但是，我们应该也隐约的了解另一个事实，文件读写操作并不会直接操作存储设备上的数据，而是先经过一个称之为高速缓冲的内存区域。</p>
<p>那么，高速缓冲是什么? 究竟承担什么工作? 先来看看它的初始化流程吧。</p>
<p>首先回到 <code>main.c</code> (内核代码的主函数)</p>
<pre><code class="language-c">void main(void) 
{
    ROOT_DEV = ORIG_ROOT_DEV;
    drive_info = DRIVE_INFO;
    memory_end = (1&#x3C;&#x3C;20) + (EXT_MEM_K&#x3C;&#x3C;10);
    memory_end &#x26;= 0xfffff000;
    if (memory_end > 16*1024*1024)
        memory_end = 16*1024*1024;
    if (memory_end > 12*1024*1024)
        buffer_memory_end = 4*1024*1024;
    else if (memory_end > 6*1024*1024)
        buffer_memory_end = 2*1024*1024;
    else
        buffer_memory_end = 1*1024*1024;
    main_memory_start = buffer_memory_end;
#ifdef RAMDISK
    main_memory_start += rd_init(main_memory_start, RAMDISK*1024);
#endif
    mem_init(main_memory_start,memory_end);
    trap_init();
    blk_dev_init();
    chr_dev_init();
    tty_init();
    time_init();
    sched_init();                       // 第四篇已经讲过，负责任务调度模块的初始化
    buffer_init(buffer_memory_end);     // 本篇的起始，负责缓冲区的初始化
    hd_init();
    floppy_init();
    sti();
    move_to_user_mode();
    if (!fork()) {      /* we count on this going ok */
        init();
    }
    for(;;) pause();
}
</code></pre>
<p><code>buffer_init(buffer_memory_end);</code> 用来初始化缓冲区。此处有几个原因:</p>
<ol>
<li>
<p>CPU 读写操作如果直接操作外存，速度上是一个极大的考验。毕竟内存已经较之 CPU 速度慢，外存的读写速度就更慢了。</p>
</li>
<li>
<p>解耦，其实读写操作并不仅仅发生在外存(块存储设备)，同样的，字符设备等等也都会需要读写操作，增加中间层可以封装变化。</p>
</li>
<li>
<p>更多，个人了解有限...</p>
</li>
</ol>
<pre><code class="language-c">struct buffer_head {
 char * b_data;
 unsigned long b_blocknr;
 unsigned short b_dev;
 unsigned char b_uptodate;
 unsigned char b_dirt;
 unsigned char b_count;
 unsigned char b_lock;
 struct task_struct * b_wait;
 struct buffer_head * b_prev;
 struct buffer_head * b_next;
 struct buffer_head * b_prev_free;
 struct buffer_head * b_next_free;
};

/* from fs/buffer.c */
void buffer_init(long buffer_end)
{
    struct buffer_head * h = start_buffer;
    void * b;
    int i;

    if (buffer_end == 1&#x3C;&#x3C;20)
        b = (void *) (640*1024);
    else
        b = (void *) buffer_end;
    while ( (b -= BLOCK_SIZE) >= ((void *) (h+1)) ) {
        h->b_dev = 0;
        h->b_dirt = 0;
        h->b_count = 0;
        h->b_lock = 0;
        h->b_uptodate = 0;
        h->b_wait = NULL;
        h->b_next = NULL;
        h->b_prev = NULL;
        h->b_data = (char *) b;
        h->b_prev_free = h-1;
        h->b_next_free = h+1;
        h++;
        NR_BUFFERS++;
        /* 跳过 640K ~ 1M 的显存和 BIOS RAM 部分 */
        if (b == (void *) 0x100000)
            b = (void *) 0xA0000;
    }
    h--;
    free_list = start_buffer;
    free_list->b_prev_free = h;
    h->b_next_free = free_list;
    for (i=0;i&#x3C;NR_HASH;i++)
        hash_table[i]=NULL;
}
</code></pre>
<p>缓冲块的所有关键信息都由 <code>buffer_head</code> 数据结构进行记录, 至于有多少个 <code>buffer_head</code>? 只能说能划分多少就划分多少。</p>
<p>比较直观的结构信息如下</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwy2iag1exj31kw0k1dgb.jpg"></p>
<p>在 <code>main.c</code> 中已经提前确认了内核程序占用内存的大小，缓冲区大小以及主内存大小。</p>
<p>在高速缓冲区的开始位置，都用来存储 <code>buffer_head</code> 的信息，与每个缓冲块(从缓冲区结束位置开始分配)一一对应，直到中间某个位置不足以分配缓冲块为止。</p>
<p>另外的信息，就是可以看到一个 <code>hash_table</code> 数据结构了。</p>
<p>应该都能够想象，每个缓存块与外存中的数据块相对应，通过设备号 + 数据块号进行唯一定位。但是，如何快速查找需要操作的数据块是否已经存在与高速缓存中了呢? 显然直接遍历查找是不太可靠的办法。采用开放地址法的哈希表能够协助快速定位缓冲块。</p>
<h2>挂载文件系统</h2>
<p>既然高速缓冲区都准备就绪了，那么文件系统是否已经挂载了呢? 很遗憾，知道 <code>main()</code> 调用 <code>init()</code> 函数之前，文件系统依然没有挂载，也就是说，CPU 仍然只能通过基本输入输出对存储设备进行相当初级的 IO 操作。</p>
<p>那么，什么时候才能去挂载根目录呢?</p>
<pre><code class="language-c">/* from init/main.c */
/* 由 main() 触发 */
void init(void)
{
    int pid,i;
    /* 这是比较重要的一环了，开始挂载的起始动作 */
    setup((void *) &#x26;drive_info);
    ...
}
</code></pre>
<p><code>setup</code> 函数做了什么呢？这是一个内嵌汇编，主要做的就是触发系统调用 <code>int 0x80</code></p>
<pre><code class="language-asm">__inline__ int setup(void * BIOS) { 
    long __res; 
    __asm__ volatile (
            "int $0x80" 
            : "=a" (__res) 
            : "0" (0),"b" ((long)(BIOS))
    ); 
    if (__res >= 0) 
        return (int) __res; 
    errno = -__res; 
    return -1; 
}
</code></pre>
<p>其中看到给出的 <code>EAX = 0</code>, 查表(表在 <code>include/linux/sys.h</code> 里) 可以知道触发的是 <code>sys_setup</code> 函数(函数位于 <code>kernel/blk_drv/hd.c</code>)</p>
<pre><code class="language-c">/* This may be used only once, enforced by 'static int callable' */
int sys_setup(void * BIOS)
{
    static int callable = 1;
    int i,drive;
    unsigned char cmos_disks;
    struct partition *p;
    struct buffer_head * bh;

    /* setup 只允许被调用一次 */
    if (!callable)
        return -1;
    callable = 0;
    /* 可以强制在源码中指定硬盘参数, 所以加了宏定义作判断*/
#ifndef HD_TYPE
    for (drive=0 ; drive&#x3C;2 ; drive++) {
        hd_info[drive].cyl = *(unsigned short *) BIOS;
        hd_info[drive].head = *(unsigned char *) (2+BIOS);
        hd_info[drive].wpcom = *(unsigned short *) (5+BIOS);
        hd_info[drive].ctl = *(unsigned char *) (8+BIOS);
        hd_info[drive].lzone = *(unsigned short *) (12+BIOS);
        hd_info[drive].sect = *(unsigned char *) (14+BIOS);
        BIOS += 16;
    }
    if (hd_info[1].cyl)
        NR_HD=2;
    else
        NR_HD=1;
#endif
    for (i=0 ; i&#x3C;NR_HD ; i++) {
        hd[i*5].start_sect = 0;
        hd[i*5].nr_sects = hd_info[i].head*
                hd_info[i].sect*hd_info[i].cyl;
    }

    /*
        We querry CMOS about hard disks : it could be that
        we have a SCSI/ESDI/etc controller that is BIOS
        compatable with ST-506, and thus showing up in our
        BIOS table, but not register compatable, and therefore
        not present in CMOS.

        Furthurmore, we will assume that our ST-506 drives
        &#x3C;if any> are the primary drives in the system, and
        the ones reflected as drive 1 or 2.

        The first drive is stored in the high nibble of CMOS
        byte 0x12, the second in the low nibble.  This will be
        either a 4 bit drive type or 0xf indicating use byte 0x19
        for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.

        Needless to say, a non-zero value means we have
        an AT controller hard disk for that drive.


    */

    if ((cmos_disks = CMOS_READ(0x12)) &#x26; 0xf0)
        if (cmos_disks &#x26; 0x0f)
            NR_HD = 2;
        else
            NR_HD = 1;
    else
        NR_HD = 0;
    for (i = NR_HD ; i &#x3C; 2 ; i++) {
        hd[i*5].start_sect = 0;
        hd[i*5].nr_sects = 0;
    }
    /* 更进一步设置每个盘的参数 */
    for (drive=0 ; drive&#x3C;NR_HD ; drive++) {
        /* 0x300 和 0x305 分别代表两个硬盘 */
        /* 读取每个硬盘的第一块数据 (1024B) */
        if (!(bh = bread(0x300 + drive*5,0))) {
            printk("Unable to read partition table of drive %d\n\r",
                drive);
            panic("");
        }
        /* 判断硬盘有效性 */
        if (bh->b_data[510] != 0x55 || (unsigned char)
            bh->b_data[511] != 0xAA) {
            printk("Bad partition table on drive %d\n\r",drive);
            panic("");
        }
        /* 读取分区表 (位于 引导扇区第 446 字节开始处 */
        p = 0x1BE + (void *)bh->b_data;
        for (i=1;i&#x3C;5;i++,p++) {
            hd[i+5*drive].start_sect = p->start_sect;
            hd[i+5*drive].nr_sects = p->nr_sects;
        }
        brelse(bh);
    }
    if (NR_HD)
        printk("Partition table%s ok.\n\r",(NR_HD>1)?"s":"");
    rd_load();              /* 尝试创建并加载虚拟盘 */
    mount_root();           /* mount 根文件系统 */
    return (0);
}
</code></pre>
<p>终于到了挂载文件系统的时候了</p>
<p><code>mount_root</code> 用来做初级的初始化工作。同时，上一节已经描述过了，存储设备的超级块是用了记录整个文件系统最重要的结构。</p>
<p>那么通过将超级块的信息读取到内存，也就可以将内存与外存的文件系统相互联系起来了。</p>
<p>下面这段代码最重要的内容就是 <code>read_super()</code> 函数了 .</p>
<pre><code class="language-c">void mount_root(void)
{
    int i,free;
    struct super_block * p;
    struct m_inode * mi;

    if (32 != sizeof (struct d_inode))
        panic("bad i-node size");
    /* 先初始化文件表，该版本操作系统限制最大同时打开 NR_FILE(64个) 文件 */
    for(i=0;i&#x3C;NR_FILE;i++)
        /* f_count = 0 表明没有被引用 */
        file_table[i].f_count=0;
    /* 如果引导盘是软盘的话，提示插入根文件系统盘 */
    if (MAJOR(ROOT_DEV) == 2) {
        printk("Insert root floppy and press ENTER");
        wait_for_keypress();
    }
    /* 初始化内存超级块数据结构 (总共 8 个) */
    for(p = &#x26;super_block[0] ; p &#x3C; &#x26;super_block[NR_SUPER] ; p++) {
        p->s_dev = 0;
        p->s_lock = 0;
        p->s_wait = NULL;
    }
    /* Hint: 读取超级块的信息，挂载根文件系统重要的部分(代码请往下翻) */
    if (!(p=read_super(ROOT_DEV)))
        panic("Unable to mount root");
    /* 读取文件系统的 1 号i节点 (即该设备上文件系统的根节点) */
    if (!(mi=iget(ROOT_DEV,ROOT_INO)))
        panic("Unable to read root i-node");
    mi->i_count += 3 ;  /* NOTE! it is logically used 4 times, not 1 */
    p->s_isup = p->s_imount = mi;
    /* 应该还记得吧，current 指的是当前的任务(任务1)，以后所有的任务都会由任务1或任务1的子任务进行派生，也就意味着 current->root 会一直复制过去
     * 到这里为止，应该认为根文件系统以及被挂载了。是不是跟被耍了一样?
     */
    current->pwd = mi;
    current->root = mi;
    free=0;
    i=p->s_nzones;
    /* 统计还有多少空闲数据块以及多少可用i节点 (附上一张启动过程中打印的信息) */
    while (-- i >= 0)
        if (!set_bit(i&#x26;8191,p->s_zmap[i>>13]->b_data))
            free++;
    printk("%d/%d free blocks\n\r",free,p->s_nzones);
    free=0;
    i=p->s_ninodes+1;
    while (-- i >= 0)
        if (!set_bit(i&#x26;8191,p->s_imap[i>>13]->b_data))
            free++;
    printk("%d/%d free inodes\n\r",free,p->s_ninodes);
}
</code></pre>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwz8kvvgbpj30l006i3yb.jpg"></p>
<p>重要要的部分，<code>read_super(int dev)</code>，用于读取超级块的数据</p>
<pre><code class="language-c">static struct super_block * read_super(int dev)
{
    struct super_block * s;
    struct buffer_head * bh;
    int i,block;

    if (!dev)
        return NULL;
    check_disk_change(dev);
    /* 如果该超级块已经在内存中了，那么就直接使用 (和这里挂载根文件系统的流程无关) */
    if (s = get_super(dev))
        return s;
    /* 设备超级块不在内存中，就先找一个空闲的内存超级块 (总共维护 8 个超级块数据结构) */
    for (s = 0+super_block ;; s++) {
        if (s >= NR_SUPER+super_block)
            return NULL;
        if (!s->s_dev)
            break;
    }
    s->s_dev = dev;
    s->s_isup = NULL;
    s->s_imount = NULL;
    s->s_time = 0;
    s->s_rd_only = 0;
    s->s_dirt = 0;
    lock_super(s);
    /* 通过 block read 读取设备第一个物理块 (每个物理块 1024 B) */
    if (!(bh = bread(dev,1))) {
        s->s_dev=0;
        free_super(s);
        return NULL;
    }
    /* 复制一份超级块的数据 */
    *((struct d_super_block *) s) =
        *((struct d_super_block *) bh->b_data);
    /* 释放缓冲区的数据 */
    brelse(bh);
    /* 验证魔数, 该版本操作系统只支持 1.0 版 Minix 文件系统，魔数 0x137F */
    if (s->s_magic != SUPER_MAGIC) {
        s->s_dev = 0;
        free_super(s);
        return NULL;
    }
    /* 先清空内存中的数据 */
    for (i=0;i&#x3C;I_MAP_SLOTS;i++)
        s->s_imap[i] = NULL;
    for (i=0;i&#x3C;Z_MAP_SLOTS;i++)
        s->s_zmap[i] = NULL;
    block=2;
    /* 读取 i 节点位图块 */
    for (i=0 ; i &#x3C; s->s_imap_blocks ; i++)
        if (s->s_imap[i]=bread(dev,block))
            block++;
        else
            break;
    /* 读取数据块位图 */
    for (i=0 ; i &#x3C; s->s_zmap_blocks ; i++)
        if (s->s_zmap[i]=bread(dev,block))
            block++;
        else
            break;
    if (block != 2+s->s_imap_blocks+s->s_zmap_blocks) {
        for(i=0;i&#x3C;I_MAP_SLOTS;i++)
            brelse(s->s_imap[i]);
        for(i=0;i&#x3C;Z_MAP_SLOTS;i++)
            brelse(s->s_zmap[i]);
        s->s_dev=0;
        free_super(s);
        return NULL;
    }
    s->s_imap[0]->b_data[0] |= 1;
    s->s_zmap[0]->b_data[0] |= 1;
    /* 与前面的 wait_on_super() 对应(解开lock标志) */
    free_super(s);
    return s;
}
</code></pre>
<p>是不是觉得也没什么，就这样根文件系统已经挂载了? 毫无实感是吧。</p>
<h2>Extra: 普通挂载</h2>
<p>既然讲过了根文件系统的挂载。那就顺带着讲讲普通文件系统的挂载吧。</p>
<p>相信从命令上来讲应该比较简单也比较熟悉吧。<code>mount disk.img /mnt</code> 也算是挂载到 /mnt 下了</p>
<p>但是，究竟是怎么实现的呢?</p>
<pre><code class="language-c">int sys_mount(char * dev_name, char * dir_name, int rw_flag)
{
    struct m_inode * dev_i, * dir_i;
    struct super_block * sb;
    int dev;

    /** 
     * 省略大部分判断逻辑, 主要就是:
     * 1. 判断 dev_name 所属的设备号，读取该设备上的超级块
     * 2. 读取 dir_name (需要挂载到的位置)，判定是否允许被挂载(比如根节点不允许挂其它设备)
     */
    ...

    /* 设置超级块的 mount 标志 */
    sb->s_imount=dir_i;
    /* 设置该 i 节点的 mount 标志 */
    dir_i->i_mount=1;
    dir_i->i_dirt=1;        /* NOTE! we don't iput(dir_i) */
    return 0;           /* we do that in umount */
}
</code></pre>
<h2>文件读写</h2>
<p>前面讲了这么多，终于到了最关心的部分了。当然，也并不是说前面的内容不重要，事实上，相当重要，只是都隐藏在了内核引导的过程中，且调用频度低，才导致了没有存在感。但是这恰恰才是支持文件读写的基石。</p>
<p>不多说废话，下面就要开始文件读写的内容。</p>
<h3>打开文件</h3>
<p>打开文件的函数原型是 <code>int open(const char * filename, int flag, ...);</code></p>
<p>当然，此类系统调用最终的实现都是 <code>int 0x80</code> , 明确一个调用号，然后就陷入内核态了。</p>
<p>内核态下调用的函数是: <code>int sys_open(const char * filename,int flag,int mode)</code> </p>
<p>来看看细节:</p>
<pre><code class="language-c">int sys_open(const char * filename,int flag,int mode)
{
    struct m_inode * inode;
    struct file * f;
    int i,fd;

    /*
     * current 是由内核数据段维护的当前任务的指针
     * umask 是指当前任务在新建文件时的默认掩码
     *   例如 Linux 默认是 022, 即新建文件被禁止了组用户与其它用户的写权限
     * 这里是先确定新建文件的权限
     */
    mode &#x26;= 0777 &#x26; ~current->umask;
    /*
     * 文件描述符，每个文件单独维护一套，以数字标记
     * 找一个空闲的文件描述符项
     */
    for(fd=0 ; fd&#x3C;NR_OPEN ; fd++)
        if (!current->filp[fd])
            break;
    if (fd>=NR_OPEN)
        return -EINVAL;
    /*
     * 顾名思义，设置在调用 exec() 函数时主动关闭的文件
     * exec() 通常与 fork() 联用，fork() 负责复制一个任务，而 exec 负责替换新任务的代码和数据段(从而产生一个新的任务)
     * 这里的声明即是复位 fd 位置的标志，允许子任务也持有相同的文件描述符项
     */
    current->close_on_exec &#x26;= ~(1&#x3C;&#x3C;fd);
    f=0+file_table;
    /* 在文件表中找一项空闲的 */
    for (i=0 ; i&#x3C;NR_FILE ; i++,f++)
        if (!f->f_count) break;
    if (i>=NR_FILE)
        return -EINVAL;
    /* 当前任务的文件描述符项指向文件表项, 同时文件表项的引用计数+1*/
    (current->filp[fd]=f)->f_count++;
    /* 调用 open_namei 打开文件，如果失败则释放刚才占用的文件结构，并返回错误码 */
    if ((i=open_namei(filename,flag,mode,&#x26;inode))&#x3C;0) {
        current->filp[fd]=NULL;
        f->f_count=0;
        return i;
    }
    /* 
     * 对不同的文件进行不同的特殊处理, 毕竟有 "一切皆文件" 的口号嘛
     * 诸如字符设备等也都是文件
     */
/* ttys are somewhat special (ttyxx major==4, tty major==5) */
    if (S_ISCHR(inode->i_mode))
        if (MAJOR(inode->i_zone[0])==4) {
            if (current->leader &#x26;&#x26; current->tty&#x3C;0) {
                current->tty = MINOR(inode->i_zone[0]);
                tty_table[current->tty].pgrp = current->pgrp;
            }
        } else if (MAJOR(inode->i_zone[0])==5)
            if (current->tty&#x3C;0) {
                iput(inode);
                current->filp[fd]=NULL;
                f->f_count=0;
                return -EPERM;
            }
/* Likewise with block-devices: check for floppy_change */
    if (S_ISBLK(inode->i_mode))
        check_disk_change(inode->i_zone[0]);
    /* 初始化内存文件结构的各个参数 */
    f->f_mode = inode->i_mode;
    f->f_flags = flag;
    f->f_count = 1;
    f->f_inode = inode;
    f->f_pos = 0;
    return (fd);
}
</code></pre>
<p>在整个打开文件的过程中，除了真正去文件系统查找文件的时候用到了文件名，其它时候，都将是以文件描述符进行交互的。</p>
<p>再看看更细节的方面，毕竟就目前来说，我们跳过了最重要的一环 <code>open_namei</code> ，从而看似整个流程都简单了很多很多。</p>
<p>通常我们在编码过程中都是通过绝对地址/相对地址来唯一定位一个文件。因此，就必然存在逐级寻找文件的过程</p>
<pre><code class="language-c">static struct m_inode * get_dir(const char * pathname)
{
    char c;
    const char * thisname;
    struct m_inode * inode;
    struct buffer_head * bh;
    int namelen,inr,idev;
    struct dir_entry * de;

    /* 判定当前任务设定的根节点是否有效 */
    if (!current->root || !current->root->i_count)
        panic("No root inode");
    /* 判定当前路径i节点是否有效 */
    if (!current->pwd || !current->pwd->i_count)
        panic("No cwd inode");
    /* 
     * 这里的 get_fs_byte(..) 是宏定义，fs 指的是 FS 段寄存器
     * Linux 内核将 DS, ES 用于内核数据段, 用 FS 指向局部描述符表的当前任务数据段
     * 这里可以简单理解成取字符数组的第一个字节
     */
    if ((c=get_fs_byte(pathname))=='/') {
        inode = current->root;
        pathname++;
    } else if (c)
        inode = current->pwd;
    else
        return NULL;    /* empty name is bad */
    inode->i_count++;
    while (1) {
        thisname = pathname;
        if (!S_ISDIR(inode->i_mode) || !permission(inode,MAY_EXEC)) {
            iput(inode);
            return NULL;
        }
        for(namelen=0;(c=get_fs_byte(pathname++))&#x26;&#x26;(c!='/');namelen++)
            /* nothing */ ;
        if (!c)
            return inode;
        if (!(bh = find_entry(&#x26;inode,thisname,namelen,&#x26;de))) {
            iput(inode);
            return NULL;
        }
        inr = de->inode;
        idev = inode->i_dev;
        brelse(bh);
        iput(inode);
        if (!(inode = iget(idev,inr)))
            return NULL;
    }
}

/*
 *  dir_namei()
 *
 * 处理路径 pathname, 处理成i节点表示的最终一级目录+目录下文件名(也可能pathname表示的就是目录)
 */
static struct m_inode * dir_namei(const char * pathname, int * namelen, const char ** name)
{
    char c;
    const char * basename;
    struct m_inode * dir;

    if (!(dir = get_dir(pathname)))
        return NULL;
    basename = pathname;
    while (c=get_fs_byte(pathname++))
        if (c=='/')
            basename=pathname;
    *namelen = pathname-basename-1;
    *name = basename;
    return dir;
}

/*
 *  open_namei()
 *
 * namei for open - this is in fact almost the whole open-routine.
 */
int open_namei(const char * pathname, int flag, int mode,
    struct m_inode ** res_inode)
{
    const char * basename;
    int inr,dev,namelen;
    struct m_inode * dir, *inode;
    struct buffer_head * bh;
    struct dir_entry * de;

    if ((flag &#x26; O_TRUNC) &#x26;&#x26; !(flag &#x26; O_ACCMODE))
        flag |= O_WRONLY;
    mode &#x26;= 0777 &#x26; ~current->umask;
    mode |= I_REGULAR;
    if (!(dir = dir_namei(pathname,&#x26;namelen,&#x26;basename)))
        return -ENOENT;
    /* 如果给的 pathname 是一个目录 */
    if (!namelen) {         /* special case: '/usr/' etc */
        if (!(flag &#x26; (O_ACCMODE|O_CREAT|O_TRUNC))) {
            *res_inode=dir;
            return 0;
        }
        iput(dir);
        return -EISDIR;
    }
    /* 找到目录对应的i节点的数据块 */
    bh = find_entry(&#x26;dir,basename,namelen,&#x26;de);
    if (!bh) {
        if (!(flag &#x26; O_CREAT)) {
            iput(dir);
            return -ENOENT;
        }
        if (!permission(dir,MAY_WRITE)) {
            iput(dir);
            return -EACCES;
        }
        inode = new_inode(dir->i_dev);
        if (!inode) {
            iput(dir);
            return -ENOSPC;
        }
        inode->i_uid = current->euid;
        inode->i_mode = mode;
        inode->i_dirt = 1;
        bh = add_entry(dir,basename,namelen,&#x26;de);
        if (!bh) {
            inode->i_nlinks--;
            iput(inode);
            iput(dir);
            return -ENOSPC;
        }
        de->inode = inode->i_num;
        bh->b_dirt = 1;
        brelse(bh);
        iput(dir);
        *res_inode = inode;
        return 0;
    }
    inr = de->inode;
    dev = dir->i_dev;
    brelse(bh);
    iput(dir);
    if (flag &#x26; O_EXCL)
        return -EEXIST;
    if (!(inode=iget(dev,inr)))
        return -EACCES;
    if ((S_ISDIR(inode->i_mode) &#x26;&#x26; (flag &#x26; O_ACCMODE)) ||
        !permission(inode,ACC_MODE(flag))) {
        iput(inode);
        return -EPERM;
    }
    inode->i_atime = CURRENT_TIME;
    if (flag &#x26; O_TRUNC)
        truncate(inode);
    *res_inode = inode;
    return 0;
}
</code></pre>
<h3>文件写入</h3>
<p>接下来就要进行文件写入的流程了</p>
<p>如何陷入内核态函数就不再细说了，相信看过这么多系统调用之后，也能知道基本上系统调用在内核态对应的函数都是以 sys_ 形式出现的</p>
<pre><code class="language-c">int sys_write(unsigned int fd,char * buf,int count)
{
    struct file * file;
    struct m_inode * inode;

    /* 非法 fd , 抛异常 */
    if (fd>=NR_OPEN || count &#x3C;0 || !(file=current->filp[fd]))
        return -EINVAL;
    /* count = 0，无需写入数据 */
    if (!count)
        return 0;
    inode=file->f_inode;
    /* 针对不同的i节点类型，有不同的写入函数 */
    if (inode->i_pipe)
        return (file->f_mode&#x26;2)?write_pipe(inode,buf,count):-EIO;
    if (S_ISCHR(inode->i_mode))
        return rw_char(WRITE,inode->i_zone[0],buf,count,&#x26;file->f_pos);
    if (S_ISBLK(inode->i_mode))
        return block_write(inode->i_zone[0],&#x26;file->f_pos,buf,count);
    if (S_ISREG(inode->i_mode))
        return file_write(inode,file,buf,count);
    printk("(Write)inode->i_mode=%06o\n\r",inode->i_mode);
    return -EINVAL;
}
</code></pre>
<p>看看对于常规文件是怎么操作的吧。</p>
<pre><code class="language-c">int file_write(struct m_inode * inode, struct file * filp, char * buf, int count)
{
    off_t pos;      /* 偏移量 */
    int block,c;
    struct buffer_head * bh;
    char * p;
    int i=0;

    /* 如果是 Append 模式，把偏移量重置到文件末尾 */
    if (filp->f_flags &#x26; O_APPEND) 
        pos = inode->i_size;
    /* 否则就使用当前文件数据结构持有的偏移量 */
    /*
        附上数据结构  file 的内容 
        struct file {
            unsigned short f_mode;
            unsigned short f_flags;
            unsigned short f_count;
            struct m_inode * f_inode;
            off_t f_pos;    每个打开的文件都将持有当前的偏移值
        };
     */
    else
        pos = filp->f_pos;
    /* 逐字符向缓冲区写入数据 */
    while (i&#x3C;count) {
        /* 最开始当然是创建在磁盘上占用一个数据块了 (如果文件对应的块不存在的话) */
        if (!(block = create_block(inode,pos/BLOCK_SIZE)))
            break;
        /* 根据数据块获得相应的缓冲块 */
        if (!(bh=bread(inode->i_dev,block)))
            break;
        /* 在缓冲块中的偏移量 */
        c = pos % BLOCK_SIZE;
        /* 定位到具体的缓冲区的内存地址 */
        p = c + bh->b_data;
        bh->b_dirt = 1;
        /* 当前这个缓冲块还有多少字节可写 */
        c = BLOCK_SIZE-c;
        /* 如果需要写入的数据量少于 c */
        if (c > count-i) c = count-i;
        /* 添加偏移量计数, 更新数据结构中维护的值 */
        pos += c;
        if (pos > inode->i_size) {
            inode->i_size = pos;
            inode->i_dirt = 1;
        }
        i += c;
        /* 向缓冲块逐字节写入数据 */
        while (c-->0)
            *(p++) = get_fs_byte(buf++);
        /* 释放对缓冲块的占用，当然，在释放前会完成缓冲块&#x3C;->外存数据块的同步 */
        brelse(bh);
    }
    inode->i_mtime = CURRENT_TIME;
    if (!(filp->f_flags &#x26; O_APPEND)) {
        /* 非 APPEND 模式，更新文件读写指针(偏移量); APPEND 模式是使用 inode->i_size ，所有就不需要在这里更新了 */
        filp->f_pos = pos;
        inode->i_ctime = CURRENT_TIME;
    }
    return (i?i:-1);
}
</code></pre>
<p>是不是觉得也没有什么太高大上的操作。确实如此，更多关于缓存块与文件系统数据块的同步都已经被包装到 bread(), brelse() 中了。</p>
<p>不过，暂时无需细究。总之到此为止，先要有一个基础的观念: 所有与外存储器(这里也包括控制台等)进行数据交互都必须经过缓冲区</p>
<p>缓冲区封装了对外存储器的全部操作，而提供给 CPU 更高效的 I/O 操作，当然，也更为简单快捷</p>
<h3>文件读取</h3>
<p>至于文件读取，也基本类似了，所以也就不再深入描述。</p>
<p>当然，要注意的就是，在本篇开始的部分提供的例程中，write &#x26; read 中插入了 <code>off_t off = lseek(fd, 0, SEEK_SET);</code>  这样的代码。</p>
<p>原因应该也能够想到，学习 <code>sys_write(..)</code> 的时候我们已经看到，任务对同一个文件在内存中维护了一个文件读写偏移量。因此，要读取刚才写入的内容，就不得不先改动这个读写偏移量了</p>
<pre><code class="language-c">int sys_read(unsigned int fd,char * buf,int count)
{
    struct file * file;
    struct m_inode * inode;

    if (fd>=NR_OPEN || count&#x3C;0 || !(file=current->filp[fd]))
        return -EINVAL;
    if (!count)
        return 0;
    verify_area(buf,count);
    inode = file->f_inode;
    if (inode->i_pipe)
        return (file->f_mode&#x26;1)?read_pipe(inode,buf,count):-EIO;
    if (S_ISCHR(inode->i_mode))
        return rw_char(READ,inode->i_zone[0],buf,count,&#x26;file->f_pos);
    if (S_ISBLK(inode->i_mode))
        return block_read(inode->i_zone[0],&#x26;file->f_pos,buf,count);
    if (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode)) {
        if (count+file->f_pos > inode->i_size)
            count = inode->i_size - file->f_pos;
        if (count&#x3C;=0)
            return 0;
        return file_read(inode,file,buf,count);
    }
    printk("(Read)inode->i_mode=%06o\n\r",inode->i_mode);
    return -EINVAL;
}
</code></pre>
<h2>小结</h2>
<p>这篇对文件系统的代码层面的描述，仅仅只是捡了一个相当有限的片面 (常规文件读写)。从文件系统的挂载开始提供了一个读写的完整流程介绍(当然，很多细节是缺失的，不过不要着急)。</p>
<p>虽然平常都能够了解到一个比较模糊的前提，文件读写需要利用缓冲区，但是究竟什么是缓存区，如何使用都不会有太多的概念。本篇最大的重点，就是首先请读者们建立起一个基础性的对缓冲区的了解。事实上，这个中介在 I/O 中扮演了相当重要的角色。而且内存也为其提供了相当大的一份空间，差不多有 1/4 了。</p>
<p>跨了差不多半个多月来写，上下文的承接可能有些生硬了，甚至不一致了... 尴尬...</p>
<pre><code class="language-plain">  __                    __                  
 / _| __ _ _ __   __ _ / _| ___ _ __   __ _ 
| |_ / _` | '_ \ / _` | |_ / _ \ '_ \ / _` |
|  _| (_| | | | | (_| |  _|  __/ | | | (_| |
|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |
                 |___/                |___/ 
</code></pre></div></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/post","query":{"content":"\u003chr\u003e\n\u003cp\u003etitle: 理解 Linux Kernel (6) - read \u0026#x26; write\nauthor: fangfeng\ndate: 2018-11-11\ntags:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinux\u003c/li\u003e\n\u003cli\u003eKernel\u003c/li\u003e\n\u003cli\u003eFile System\u003c/li\u003e\n\u003cli\u003eread \u0026#x26; write\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003ca href=\"https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/\"\u003e前一篇\u003c/a\u003e已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。\u003c/p\u003e\n\u003cp\u003e首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \u0026#x3C;stdio.h\u003e\n#include \u0026#x3C;stdlib.h\u003e\n#include \u0026#x3C;string.h\u003e\n#include \u0026#x3C;unistd.h\u003e\n#include \u0026#x3C;fcntl.h\u003e\n#include \u0026#x3C;errno.h\u003e\n#include \u0026#x3C;sys/types.h\u003e\n#include \u0026#x3C;sys/stat.h\u003e\n\nint panic()\n{\n    fprintf(stderr, \"%s (errno=%d)\\n\", strerror(errno), errno);\n    return -1;\n}\n\nint main(int argc, char *argv[])\n{\n    /* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */\n    int fd = open(\"/root/frw.txt\", O_RDWR | O_CREAT);\n    if (fd == -1)\n        return panic();\n\n    /* 向文件写入 Hello World! 共计 12 个字符 */\n    ssize_t wsize = write(fd, \"Hello World!\", 12);\n    if (wsize == -1)\n        return panic();\n\n    /* 重定位文件读写指针 */\n    off_t off = lseek(fd, 0, SEEK_SET);\n    if (off == -1)\n        return panic();\n\n    char* buf = (char *) malloc(wsize);\n    /* 读取文件内容 */\n    ssize_t rsize = read(fd, buf, wsize);\n    if (rsize == -1)\n        return panic();\n\n    printf(\"%s\\n\", buf);\n    free(buf);\n    /* 关闭文件 */\n    int stat = close(fd);\n    if (stat == -1)\n        return panic();\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e高速缓冲区初始化\u003c/h2\u003e\n\u003cp\u003e上一篇已经描述过了，文件系统的结构、包括数据，都是持久化地存储在存储设备中的。\u003c/p\u003e\n\u003cp\u003e但是，我们应该也隐约的了解另一个事实，文件读写操作并不会直接操作存储设备上的数据，而是先经过一个称之为高速缓冲的内存区域。\u003c/p\u003e\n\u003cp\u003e那么，高速缓冲是什么? 究竟承担什么工作? 先来看看它的初始化流程吧。\u003c/p\u003e\n\u003cp\u003e首先回到 \u003ccode\u003emain.c\u003c/code\u003e (内核代码的主函数)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid main(void) \n{\n    ROOT_DEV = ORIG_ROOT_DEV;\n    drive_info = DRIVE_INFO;\n    memory_end = (1\u0026#x3C;\u0026#x3C;20) + (EXT_MEM_K\u0026#x3C;\u0026#x3C;10);\n    memory_end \u0026#x26;= 0xfffff000;\n    if (memory_end \u003e 16*1024*1024)\n        memory_end = 16*1024*1024;\n    if (memory_end \u003e 12*1024*1024)\n        buffer_memory_end = 4*1024*1024;\n    else if (memory_end \u003e 6*1024*1024)\n        buffer_memory_end = 2*1024*1024;\n    else\n        buffer_memory_end = 1*1024*1024;\n    main_memory_start = buffer_memory_end;\n#ifdef RAMDISK\n    main_memory_start += rd_init(main_memory_start, RAMDISK*1024);\n#endif\n    mem_init(main_memory_start,memory_end);\n    trap_init();\n    blk_dev_init();\n    chr_dev_init();\n    tty_init();\n    time_init();\n    sched_init();                       // 第四篇已经讲过，负责任务调度模块的初始化\n    buffer_init(buffer_memory_end);     // 本篇的起始，负责缓冲区的初始化\n    hd_init();\n    floppy_init();\n    sti();\n    move_to_user_mode();\n    if (!fork()) {      /* we count on this going ok */\n        init();\n    }\n    for(;;) pause();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebuffer_init(buffer_memory_end);\u003c/code\u003e 用来初始化缓冲区。此处有几个原因:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eCPU 读写操作如果直接操作外存，速度上是一个极大的考验。毕竟内存已经较之 CPU 速度慢，外存的读写速度就更慢了。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e解耦，其实读写操作并不仅仅发生在外存(块存储设备)，同样的，字符设备等等也都会需要读写操作，增加中间层可以封装变化。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e更多，个人了解有限...\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct buffer_head {\n char * b_data;\n unsigned long b_blocknr;\n unsigned short b_dev;\n unsigned char b_uptodate;\n unsigned char b_dirt;\n unsigned char b_count;\n unsigned char b_lock;\n struct task_struct * b_wait;\n struct buffer_head * b_prev;\n struct buffer_head * b_next;\n struct buffer_head * b_prev_free;\n struct buffer_head * b_next_free;\n};\n\n/* from fs/buffer.c */\nvoid buffer_init(long buffer_end)\n{\n    struct buffer_head * h = start_buffer;\n    void * b;\n    int i;\n\n    if (buffer_end == 1\u0026#x3C;\u0026#x3C;20)\n        b = (void *) (640*1024);\n    else\n        b = (void *) buffer_end;\n    while ( (b -= BLOCK_SIZE) \u003e= ((void *) (h+1)) ) {\n        h-\u003eb_dev = 0;\n        h-\u003eb_dirt = 0;\n        h-\u003eb_count = 0;\n        h-\u003eb_lock = 0;\n        h-\u003eb_uptodate = 0;\n        h-\u003eb_wait = NULL;\n        h-\u003eb_next = NULL;\n        h-\u003eb_prev = NULL;\n        h-\u003eb_data = (char *) b;\n        h-\u003eb_prev_free = h-1;\n        h-\u003eb_next_free = h+1;\n        h++;\n        NR_BUFFERS++;\n        /* 跳过 640K ~ 1M 的显存和 BIOS RAM 部分 */\n        if (b == (void *) 0x100000)\n            b = (void *) 0xA0000;\n    }\n    h--;\n    free_list = start_buffer;\n    free_list-\u003eb_prev_free = h;\n    h-\u003eb_next_free = free_list;\n    for (i=0;i\u0026#x3C;NR_HASH;i++)\n        hash_table[i]=NULL;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e缓冲块的所有关键信息都由 \u003ccode\u003ebuffer_head\u003c/code\u003e 数据结构进行记录, 至于有多少个 \u003ccode\u003ebuffer_head\u003c/code\u003e? 只能说能划分多少就划分多少。\u003c/p\u003e\n\u003cp\u003e比较直观的结构信息如下\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fwy2iag1exj31kw0k1dgb.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e在 \u003ccode\u003emain.c\u003c/code\u003e 中已经提前确认了内核程序占用内存的大小，缓冲区大小以及主内存大小。\u003c/p\u003e\n\u003cp\u003e在高速缓冲区的开始位置，都用来存储 \u003ccode\u003ebuffer_head\u003c/code\u003e 的信息，与每个缓冲块(从缓冲区结束位置开始分配)一一对应，直到中间某个位置不足以分配缓冲块为止。\u003c/p\u003e\n\u003cp\u003e另外的信息，就是可以看到一个 \u003ccode\u003ehash_table\u003c/code\u003e 数据结构了。\u003c/p\u003e\n\u003cp\u003e应该都能够想象，每个缓存块与外存中的数据块相对应，通过设备号 + 数据块号进行唯一定位。但是，如何快速查找需要操作的数据块是否已经存在与高速缓存中了呢? 显然直接遍历查找是不太可靠的办法。采用开放地址法的哈希表能够协助快速定位缓冲块。\u003c/p\u003e\n\u003ch2\u003e挂载文件系统\u003c/h2\u003e\n\u003cp\u003e既然高速缓冲区都准备就绪了，那么文件系统是否已经挂载了呢? 很遗憾，知道 \u003ccode\u003emain()\u003c/code\u003e 调用 \u003ccode\u003einit()\u003c/code\u003e 函数之前，文件系统依然没有挂载，也就是说，CPU 仍然只能通过基本输入输出对存储设备进行相当初级的 IO 操作。\u003c/p\u003e\n\u003cp\u003e那么，什么时候才能去挂载根目录呢?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* from init/main.c */\n/* 由 main() 触发 */\nvoid init(void)\n{\n    int pid,i;\n    /* 这是比较重要的一环了，开始挂载的起始动作 */\n    setup((void *) \u0026#x26;drive_info);\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esetup\u003c/code\u003e 函数做了什么呢？这是一个内嵌汇编，主要做的就是触发系统调用 \u003ccode\u003eint 0x80\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e__inline__ int setup(void * BIOS) { \n    long __res; \n    __asm__ volatile (\n            \"int $0x80\" \n            : \"=a\" (__res) \n            : \"0\" (0),\"b\" ((long)(BIOS))\n    ); \n    if (__res \u003e= 0) \n        return (int) __res; \n    errno = -__res; \n    return -1; \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中看到给出的 \u003ccode\u003eEAX = 0\u003c/code\u003e, 查表(表在 \u003ccode\u003einclude/linux/sys.h\u003c/code\u003e 里) 可以知道触发的是 \u003ccode\u003esys_setup\u003c/code\u003e 函数(函数位于 \u003ccode\u003ekernel/blk_drv/hd.c\u003c/code\u003e)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* This may be used only once, enforced by 'static int callable' */\nint sys_setup(void * BIOS)\n{\n    static int callable = 1;\n    int i,drive;\n    unsigned char cmos_disks;\n    struct partition *p;\n    struct buffer_head * bh;\n\n    /* setup 只允许被调用一次 */\n    if (!callable)\n        return -1;\n    callable = 0;\n    /* 可以强制在源码中指定硬盘参数, 所以加了宏定义作判断*/\n#ifndef HD_TYPE\n    for (drive=0 ; drive\u0026#x3C;2 ; drive++) {\n        hd_info[drive].cyl = *(unsigned short *) BIOS;\n        hd_info[drive].head = *(unsigned char *) (2+BIOS);\n        hd_info[drive].wpcom = *(unsigned short *) (5+BIOS);\n        hd_info[drive].ctl = *(unsigned char *) (8+BIOS);\n        hd_info[drive].lzone = *(unsigned short *) (12+BIOS);\n        hd_info[drive].sect = *(unsigned char *) (14+BIOS);\n        BIOS += 16;\n    }\n    if (hd_info[1].cyl)\n        NR_HD=2;\n    else\n        NR_HD=1;\n#endif\n    for (i=0 ; i\u0026#x3C;NR_HD ; i++) {\n        hd[i*5].start_sect = 0;\n        hd[i*5].nr_sects = hd_info[i].head*\n                hd_info[i].sect*hd_info[i].cyl;\n    }\n\n    /*\n        We querry CMOS about hard disks : it could be that\n        we have a SCSI/ESDI/etc controller that is BIOS\n        compatable with ST-506, and thus showing up in our\n        BIOS table, but not register compatable, and therefore\n        not present in CMOS.\n\n        Furthurmore, we will assume that our ST-506 drives\n        \u0026#x3C;if any\u003e are the primary drives in the system, and\n        the ones reflected as drive 1 or 2.\n\n        The first drive is stored in the high nibble of CMOS\n        byte 0x12, the second in the low nibble.  This will be\n        either a 4 bit drive type or 0xf indicating use byte 0x19\n        for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.\n\n        Needless to say, a non-zero value means we have\n        an AT controller hard disk for that drive.\n\n\n    */\n\n    if ((cmos_disks = CMOS_READ(0x12)) \u0026#x26; 0xf0)\n        if (cmos_disks \u0026#x26; 0x0f)\n            NR_HD = 2;\n        else\n            NR_HD = 1;\n    else\n        NR_HD = 0;\n    for (i = NR_HD ; i \u0026#x3C; 2 ; i++) {\n        hd[i*5].start_sect = 0;\n        hd[i*5].nr_sects = 0;\n    }\n    /* 更进一步设置每个盘的参数 */\n    for (drive=0 ; drive\u0026#x3C;NR_HD ; drive++) {\n        /* 0x300 和 0x305 分别代表两个硬盘 */\n        /* 读取每个硬盘的第一块数据 (1024B) */\n        if (!(bh = bread(0x300 + drive*5,0))) {\n            printk(\"Unable to read partition table of drive %d\\n\\r\",\n                drive);\n            panic(\"\");\n        }\n        /* 判断硬盘有效性 */\n        if (bh-\u003eb_data[510] != 0x55 || (unsigned char)\n            bh-\u003eb_data[511] != 0xAA) {\n            printk(\"Bad partition table on drive %d\\n\\r\",drive);\n            panic(\"\");\n        }\n        /* 读取分区表 (位于 引导扇区第 446 字节开始处 */\n        p = 0x1BE + (void *)bh-\u003eb_data;\n        for (i=1;i\u0026#x3C;5;i++,p++) {\n            hd[i+5*drive].start_sect = p-\u003estart_sect;\n            hd[i+5*drive].nr_sects = p-\u003enr_sects;\n        }\n        brelse(bh);\n    }\n    if (NR_HD)\n        printk(\"Partition table%s ok.\\n\\r\",(NR_HD\u003e1)?\"s\":\"\");\n    rd_load();              /* 尝试创建并加载虚拟盘 */\n    mount_root();           /* mount 根文件系统 */\n    return (0);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e终于到了挂载文件系统的时候了\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emount_root\u003c/code\u003e 用来做初级的初始化工作。同时，上一节已经描述过了，存储设备的超级块是用了记录整个文件系统最重要的结构。\u003c/p\u003e\n\u003cp\u003e那么通过将超级块的信息读取到内存，也就可以将内存与外存的文件系统相互联系起来了。\u003c/p\u003e\n\u003cp\u003e下面这段代码最重要的内容就是 \u003ccode\u003eread_super()\u003c/code\u003e 函数了 .\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid mount_root(void)\n{\n    int i,free;\n    struct super_block * p;\n    struct m_inode * mi;\n\n    if (32 != sizeof (struct d_inode))\n        panic(\"bad i-node size\");\n    /* 先初始化文件表，该版本操作系统限制最大同时打开 NR_FILE(64个) 文件 */\n    for(i=0;i\u0026#x3C;NR_FILE;i++)\n        /* f_count = 0 表明没有被引用 */\n        file_table[i].f_count=0;\n    /* 如果引导盘是软盘的话，提示插入根文件系统盘 */\n    if (MAJOR(ROOT_DEV) == 2) {\n        printk(\"Insert root floppy and press ENTER\");\n        wait_for_keypress();\n    }\n    /* 初始化内存超级块数据结构 (总共 8 个) */\n    for(p = \u0026#x26;super_block[0] ; p \u0026#x3C; \u0026#x26;super_block[NR_SUPER] ; p++) {\n        p-\u003es_dev = 0;\n        p-\u003es_lock = 0;\n        p-\u003es_wait = NULL;\n    }\n    /* Hint: 读取超级块的信息，挂载根文件系统重要的部分(代码请往下翻) */\n    if (!(p=read_super(ROOT_DEV)))\n        panic(\"Unable to mount root\");\n    /* 读取文件系统的 1 号i节点 (即该设备上文件系统的根节点) */\n    if (!(mi=iget(ROOT_DEV,ROOT_INO)))\n        panic(\"Unable to read root i-node\");\n    mi-\u003ei_count += 3 ;  /* NOTE! it is logically used 4 times, not 1 */\n    p-\u003es_isup = p-\u003es_imount = mi;\n    /* 应该还记得吧，current 指的是当前的任务(任务1)，以后所有的任务都会由任务1或任务1的子任务进行派生，也就意味着 current-\u003eroot 会一直复制过去\n     * 到这里为止，应该认为根文件系统以及被挂载了。是不是跟被耍了一样?\n     */\n    current-\u003epwd = mi;\n    current-\u003eroot = mi;\n    free=0;\n    i=p-\u003es_nzones;\n    /* 统计还有多少空闲数据块以及多少可用i节点 (附上一张启动过程中打印的信息) */\n    while (-- i \u003e= 0)\n        if (!set_bit(i\u0026#x26;8191,p-\u003es_zmap[i\u003e\u003e13]-\u003eb_data))\n            free++;\n    printk(\"%d/%d free blocks\\n\\r\",free,p-\u003es_nzones);\n    free=0;\n    i=p-\u003es_ninodes+1;\n    while (-- i \u003e= 0)\n        if (!set_bit(i\u0026#x26;8191,p-\u003es_imap[i\u003e\u003e13]-\u003eb_data))\n            free++;\n    printk(\"%d/%d free inodes\\n\\r\",free,p-\u003es_ninodes);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fwz8kvvgbpj30l006i3yb.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e重要要的部分，\u003ccode\u003eread_super(int dev)\u003c/code\u003e，用于读取超级块的数据\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic struct super_block * read_super(int dev)\n{\n    struct super_block * s;\n    struct buffer_head * bh;\n    int i,block;\n\n    if (!dev)\n        return NULL;\n    check_disk_change(dev);\n    /* 如果该超级块已经在内存中了，那么就直接使用 (和这里挂载根文件系统的流程无关) */\n    if (s = get_super(dev))\n        return s;\n    /* 设备超级块不在内存中，就先找一个空闲的内存超级块 (总共维护 8 个超级块数据结构) */\n    for (s = 0+super_block ;; s++) {\n        if (s \u003e= NR_SUPER+super_block)\n            return NULL;\n        if (!s-\u003es_dev)\n            break;\n    }\n    s-\u003es_dev = dev;\n    s-\u003es_isup = NULL;\n    s-\u003es_imount = NULL;\n    s-\u003es_time = 0;\n    s-\u003es_rd_only = 0;\n    s-\u003es_dirt = 0;\n    lock_super(s);\n    /* 通过 block read 读取设备第一个物理块 (每个物理块 1024 B) */\n    if (!(bh = bread(dev,1))) {\n        s-\u003es_dev=0;\n        free_super(s);\n        return NULL;\n    }\n    /* 复制一份超级块的数据 */\n    *((struct d_super_block *) s) =\n        *((struct d_super_block *) bh-\u003eb_data);\n    /* 释放缓冲区的数据 */\n    brelse(bh);\n    /* 验证魔数, 该版本操作系统只支持 1.0 版 Minix 文件系统，魔数 0x137F */\n    if (s-\u003es_magic != SUPER_MAGIC) {\n        s-\u003es_dev = 0;\n        free_super(s);\n        return NULL;\n    }\n    /* 先清空内存中的数据 */\n    for (i=0;i\u0026#x3C;I_MAP_SLOTS;i++)\n        s-\u003es_imap[i] = NULL;\n    for (i=0;i\u0026#x3C;Z_MAP_SLOTS;i++)\n        s-\u003es_zmap[i] = NULL;\n    block=2;\n    /* 读取 i 节点位图块 */\n    for (i=0 ; i \u0026#x3C; s-\u003es_imap_blocks ; i++)\n        if (s-\u003es_imap[i]=bread(dev,block))\n            block++;\n        else\n            break;\n    /* 读取数据块位图 */\n    for (i=0 ; i \u0026#x3C; s-\u003es_zmap_blocks ; i++)\n        if (s-\u003es_zmap[i]=bread(dev,block))\n            block++;\n        else\n            break;\n    if (block != 2+s-\u003es_imap_blocks+s-\u003es_zmap_blocks) {\n        for(i=0;i\u0026#x3C;I_MAP_SLOTS;i++)\n            brelse(s-\u003es_imap[i]);\n        for(i=0;i\u0026#x3C;Z_MAP_SLOTS;i++)\n            brelse(s-\u003es_zmap[i]);\n        s-\u003es_dev=0;\n        free_super(s);\n        return NULL;\n    }\n    s-\u003es_imap[0]-\u003eb_data[0] |= 1;\n    s-\u003es_zmap[0]-\u003eb_data[0] |= 1;\n    /* 与前面的 wait_on_super() 对应(解开lock标志) */\n    free_super(s);\n    return s;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e是不是觉得也没什么，就这样根文件系统已经挂载了? 毫无实感是吧。\u003c/p\u003e\n\u003ch2\u003eExtra: 普通挂载\u003c/h2\u003e\n\u003cp\u003e既然讲过了根文件系统的挂载。那就顺带着讲讲普通文件系统的挂载吧。\u003c/p\u003e\n\u003cp\u003e相信从命令上来讲应该比较简单也比较熟悉吧。\u003ccode\u003emount disk.img /mnt\u003c/code\u003e 也算是挂载到 /mnt 下了\u003c/p\u003e\n\u003cp\u003e但是，究竟是怎么实现的呢?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_mount(char * dev_name, char * dir_name, int rw_flag)\n{\n    struct m_inode * dev_i, * dir_i;\n    struct super_block * sb;\n    int dev;\n\n    /** \n     * 省略大部分判断逻辑, 主要就是:\n     * 1. 判断 dev_name 所属的设备号，读取该设备上的超级块\n     * 2. 读取 dir_name (需要挂载到的位置)，判定是否允许被挂载(比如根节点不允许挂其它设备)\n     */\n    ...\n\n    /* 设置超级块的 mount 标志 */\n    sb-\u003es_imount=dir_i;\n    /* 设置该 i 节点的 mount 标志 */\n    dir_i-\u003ei_mount=1;\n    dir_i-\u003ei_dirt=1;        /* NOTE! we don't iput(dir_i) */\n    return 0;           /* we do that in umount */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e文件读写\u003c/h2\u003e\n\u003cp\u003e前面讲了这么多，终于到了最关心的部分了。当然，也并不是说前面的内容不重要，事实上，相当重要，只是都隐藏在了内核引导的过程中，且调用频度低，才导致了没有存在感。但是这恰恰才是支持文件读写的基石。\u003c/p\u003e\n\u003cp\u003e不多说废话，下面就要开始文件读写的内容。\u003c/p\u003e\n\u003ch3\u003e打开文件\u003c/h3\u003e\n\u003cp\u003e打开文件的函数原型是 \u003ccode\u003eint open(const char * filename, int flag, ...);\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e当然，此类系统调用最终的实现都是 \u003ccode\u003eint 0x80\u003c/code\u003e , 明确一个调用号，然后就陷入内核态了。\u003c/p\u003e\n\u003cp\u003e内核态下调用的函数是: \u003ccode\u003eint sys_open(const char * filename,int flag,int mode)\u003c/code\u003e \u003c/p\u003e\n\u003cp\u003e来看看细节:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_open(const char * filename,int flag,int mode)\n{\n    struct m_inode * inode;\n    struct file * f;\n    int i,fd;\n\n    /*\n     * current 是由内核数据段维护的当前任务的指针\n     * umask 是指当前任务在新建文件时的默认掩码\n     *   例如 Linux 默认是 022, 即新建文件被禁止了组用户与其它用户的写权限\n     * 这里是先确定新建文件的权限\n     */\n    mode \u0026#x26;= 0777 \u0026#x26; ~current-\u003eumask;\n    /*\n     * 文件描述符，每个文件单独维护一套，以数字标记\n     * 找一个空闲的文件描述符项\n     */\n    for(fd=0 ; fd\u0026#x3C;NR_OPEN ; fd++)\n        if (!current-\u003efilp[fd])\n            break;\n    if (fd\u003e=NR_OPEN)\n        return -EINVAL;\n    /*\n     * 顾名思义，设置在调用 exec() 函数时主动关闭的文件\n     * exec() 通常与 fork() 联用，fork() 负责复制一个任务，而 exec 负责替换新任务的代码和数据段(从而产生一个新的任务)\n     * 这里的声明即是复位 fd 位置的标志，允许子任务也持有相同的文件描述符项\n     */\n    current-\u003eclose_on_exec \u0026#x26;= ~(1\u0026#x3C;\u0026#x3C;fd);\n    f=0+file_table;\n    /* 在文件表中找一项空闲的 */\n    for (i=0 ; i\u0026#x3C;NR_FILE ; i++,f++)\n        if (!f-\u003ef_count) break;\n    if (i\u003e=NR_FILE)\n        return -EINVAL;\n    /* 当前任务的文件描述符项指向文件表项, 同时文件表项的引用计数+1*/\n    (current-\u003efilp[fd]=f)-\u003ef_count++;\n    /* 调用 open_namei 打开文件，如果失败则释放刚才占用的文件结构，并返回错误码 */\n    if ((i=open_namei(filename,flag,mode,\u0026#x26;inode))\u0026#x3C;0) {\n        current-\u003efilp[fd]=NULL;\n        f-\u003ef_count=0;\n        return i;\n    }\n    /* \n     * 对不同的文件进行不同的特殊处理, 毕竟有 \"一切皆文件\" 的口号嘛\n     * 诸如字符设备等也都是文件\n     */\n/* ttys are somewhat special (ttyxx major==4, tty major==5) */\n    if (S_ISCHR(inode-\u003ei_mode))\n        if (MAJOR(inode-\u003ei_zone[0])==4) {\n            if (current-\u003eleader \u0026#x26;\u0026#x26; current-\u003etty\u0026#x3C;0) {\n                current-\u003etty = MINOR(inode-\u003ei_zone[0]);\n                tty_table[current-\u003etty].pgrp = current-\u003epgrp;\n            }\n        } else if (MAJOR(inode-\u003ei_zone[0])==5)\n            if (current-\u003etty\u0026#x3C;0) {\n                iput(inode);\n                current-\u003efilp[fd]=NULL;\n                f-\u003ef_count=0;\n                return -EPERM;\n            }\n/* Likewise with block-devices: check for floppy_change */\n    if (S_ISBLK(inode-\u003ei_mode))\n        check_disk_change(inode-\u003ei_zone[0]);\n    /* 初始化内存文件结构的各个参数 */\n    f-\u003ef_mode = inode-\u003ei_mode;\n    f-\u003ef_flags = flag;\n    f-\u003ef_count = 1;\n    f-\u003ef_inode = inode;\n    f-\u003ef_pos = 0;\n    return (fd);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在整个打开文件的过程中，除了真正去文件系统查找文件的时候用到了文件名，其它时候，都将是以文件描述符进行交互的。\u003c/p\u003e\n\u003cp\u003e再看看更细节的方面，毕竟就目前来说，我们跳过了最重要的一环 \u003ccode\u003eopen_namei\u003c/code\u003e ，从而看似整个流程都简单了很多很多。\u003c/p\u003e\n\u003cp\u003e通常我们在编码过程中都是通过绝对地址/相对地址来唯一定位一个文件。因此，就必然存在逐级寻找文件的过程\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic struct m_inode * get_dir(const char * pathname)\n{\n    char c;\n    const char * thisname;\n    struct m_inode * inode;\n    struct buffer_head * bh;\n    int namelen,inr,idev;\n    struct dir_entry * de;\n\n    /* 判定当前任务设定的根节点是否有效 */\n    if (!current-\u003eroot || !current-\u003eroot-\u003ei_count)\n        panic(\"No root inode\");\n    /* 判定当前路径i节点是否有效 */\n    if (!current-\u003epwd || !current-\u003epwd-\u003ei_count)\n        panic(\"No cwd inode\");\n    /* \n     * 这里的 get_fs_byte(..) 是宏定义，fs 指的是 FS 段寄存器\n     * Linux 内核将 DS, ES 用于内核数据段, 用 FS 指向局部描述符表的当前任务数据段\n     * 这里可以简单理解成取字符数组的第一个字节\n     */\n    if ((c=get_fs_byte(pathname))=='/') {\n        inode = current-\u003eroot;\n        pathname++;\n    } else if (c)\n        inode = current-\u003epwd;\n    else\n        return NULL;    /* empty name is bad */\n    inode-\u003ei_count++;\n    while (1) {\n        thisname = pathname;\n        if (!S_ISDIR(inode-\u003ei_mode) || !permission(inode,MAY_EXEC)) {\n            iput(inode);\n            return NULL;\n        }\n        for(namelen=0;(c=get_fs_byte(pathname++))\u0026#x26;\u0026#x26;(c!='/');namelen++)\n            /* nothing */ ;\n        if (!c)\n            return inode;\n        if (!(bh = find_entry(\u0026#x26;inode,thisname,namelen,\u0026#x26;de))) {\n            iput(inode);\n            return NULL;\n        }\n        inr = de-\u003einode;\n        idev = inode-\u003ei_dev;\n        brelse(bh);\n        iput(inode);\n        if (!(inode = iget(idev,inr)))\n            return NULL;\n    }\n}\n\n/*\n *  dir_namei()\n *\n * 处理路径 pathname, 处理成i节点表示的最终一级目录+目录下文件名(也可能pathname表示的就是目录)\n */\nstatic struct m_inode * dir_namei(const char * pathname, int * namelen, const char ** name)\n{\n    char c;\n    const char * basename;\n    struct m_inode * dir;\n\n    if (!(dir = get_dir(pathname)))\n        return NULL;\n    basename = pathname;\n    while (c=get_fs_byte(pathname++))\n        if (c=='/')\n            basename=pathname;\n    *namelen = pathname-basename-1;\n    *name = basename;\n    return dir;\n}\n\n/*\n *  open_namei()\n *\n * namei for open - this is in fact almost the whole open-routine.\n */\nint open_namei(const char * pathname, int flag, int mode,\n    struct m_inode ** res_inode)\n{\n    const char * basename;\n    int inr,dev,namelen;\n    struct m_inode * dir, *inode;\n    struct buffer_head * bh;\n    struct dir_entry * de;\n\n    if ((flag \u0026#x26; O_TRUNC) \u0026#x26;\u0026#x26; !(flag \u0026#x26; O_ACCMODE))\n        flag |= O_WRONLY;\n    mode \u0026#x26;= 0777 \u0026#x26; ~current-\u003eumask;\n    mode |= I_REGULAR;\n    if (!(dir = dir_namei(pathname,\u0026#x26;namelen,\u0026#x26;basename)))\n        return -ENOENT;\n    /* 如果给的 pathname 是一个目录 */\n    if (!namelen) {         /* special case: '/usr/' etc */\n        if (!(flag \u0026#x26; (O_ACCMODE|O_CREAT|O_TRUNC))) {\n            *res_inode=dir;\n            return 0;\n        }\n        iput(dir);\n        return -EISDIR;\n    }\n    /* 找到目录对应的i节点的数据块 */\n    bh = find_entry(\u0026#x26;dir,basename,namelen,\u0026#x26;de);\n    if (!bh) {\n        if (!(flag \u0026#x26; O_CREAT)) {\n            iput(dir);\n            return -ENOENT;\n        }\n        if (!permission(dir,MAY_WRITE)) {\n            iput(dir);\n            return -EACCES;\n        }\n        inode = new_inode(dir-\u003ei_dev);\n        if (!inode) {\n            iput(dir);\n            return -ENOSPC;\n        }\n        inode-\u003ei_uid = current-\u003eeuid;\n        inode-\u003ei_mode = mode;\n        inode-\u003ei_dirt = 1;\n        bh = add_entry(dir,basename,namelen,\u0026#x26;de);\n        if (!bh) {\n            inode-\u003ei_nlinks--;\n            iput(inode);\n            iput(dir);\n            return -ENOSPC;\n        }\n        de-\u003einode = inode-\u003ei_num;\n        bh-\u003eb_dirt = 1;\n        brelse(bh);\n        iput(dir);\n        *res_inode = inode;\n        return 0;\n    }\n    inr = de-\u003einode;\n    dev = dir-\u003ei_dev;\n    brelse(bh);\n    iput(dir);\n    if (flag \u0026#x26; O_EXCL)\n        return -EEXIST;\n    if (!(inode=iget(dev,inr)))\n        return -EACCES;\n    if ((S_ISDIR(inode-\u003ei_mode) \u0026#x26;\u0026#x26; (flag \u0026#x26; O_ACCMODE)) ||\n        !permission(inode,ACC_MODE(flag))) {\n        iput(inode);\n        return -EPERM;\n    }\n    inode-\u003ei_atime = CURRENT_TIME;\n    if (flag \u0026#x26; O_TRUNC)\n        truncate(inode);\n    *res_inode = inode;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e文件写入\u003c/h3\u003e\n\u003cp\u003e接下来就要进行文件写入的流程了\u003c/p\u003e\n\u003cp\u003e如何陷入内核态函数就不再细说了，相信看过这么多系统调用之后，也能知道基本上系统调用在内核态对应的函数都是以 sys_ 形式出现的\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_write(unsigned int fd,char * buf,int count)\n{\n    struct file * file;\n    struct m_inode * inode;\n\n    /* 非法 fd , 抛异常 */\n    if (fd\u003e=NR_OPEN || count \u0026#x3C;0 || !(file=current-\u003efilp[fd]))\n        return -EINVAL;\n    /* count = 0，无需写入数据 */\n    if (!count)\n        return 0;\n    inode=file-\u003ef_inode;\n    /* 针对不同的i节点类型，有不同的写入函数 */\n    if (inode-\u003ei_pipe)\n        return (file-\u003ef_mode\u0026#x26;2)?write_pipe(inode,buf,count):-EIO;\n    if (S_ISCHR(inode-\u003ei_mode))\n        return rw_char(WRITE,inode-\u003ei_zone[0],buf,count,\u0026#x26;file-\u003ef_pos);\n    if (S_ISBLK(inode-\u003ei_mode))\n        return block_write(inode-\u003ei_zone[0],\u0026#x26;file-\u003ef_pos,buf,count);\n    if (S_ISREG(inode-\u003ei_mode))\n        return file_write(inode,file,buf,count);\n    printk(\"(Write)inode-\u003ei_mode=%06o\\n\\r\",inode-\u003ei_mode);\n    return -EINVAL;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e看看对于常规文件是怎么操作的吧。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint file_write(struct m_inode * inode, struct file * filp, char * buf, int count)\n{\n    off_t pos;      /* 偏移量 */\n    int block,c;\n    struct buffer_head * bh;\n    char * p;\n    int i=0;\n\n    /* 如果是 Append 模式，把偏移量重置到文件末尾 */\n    if (filp-\u003ef_flags \u0026#x26; O_APPEND) \n        pos = inode-\u003ei_size;\n    /* 否则就使用当前文件数据结构持有的偏移量 */\n    /*\n        附上数据结构  file 的内容 \n        struct file {\n            unsigned short f_mode;\n            unsigned short f_flags;\n            unsigned short f_count;\n            struct m_inode * f_inode;\n            off_t f_pos;    每个打开的文件都将持有当前的偏移值\n        };\n     */\n    else\n        pos = filp-\u003ef_pos;\n    /* 逐字符向缓冲区写入数据 */\n    while (i\u0026#x3C;count) {\n        /* 最开始当然是创建在磁盘上占用一个数据块了 (如果文件对应的块不存在的话) */\n        if (!(block = create_block(inode,pos/BLOCK_SIZE)))\n            break;\n        /* 根据数据块获得相应的缓冲块 */\n        if (!(bh=bread(inode-\u003ei_dev,block)))\n            break;\n        /* 在缓冲块中的偏移量 */\n        c = pos % BLOCK_SIZE;\n        /* 定位到具体的缓冲区的内存地址 */\n        p = c + bh-\u003eb_data;\n        bh-\u003eb_dirt = 1;\n        /* 当前这个缓冲块还有多少字节可写 */\n        c = BLOCK_SIZE-c;\n        /* 如果需要写入的数据量少于 c */\n        if (c \u003e count-i) c = count-i;\n        /* 添加偏移量计数, 更新数据结构中维护的值 */\n        pos += c;\n        if (pos \u003e inode-\u003ei_size) {\n            inode-\u003ei_size = pos;\n            inode-\u003ei_dirt = 1;\n        }\n        i += c;\n        /* 向缓冲块逐字节写入数据 */\n        while (c--\u003e0)\n            *(p++) = get_fs_byte(buf++);\n        /* 释放对缓冲块的占用，当然，在释放前会完成缓冲块\u0026#x3C;-\u003e外存数据块的同步 */\n        brelse(bh);\n    }\n    inode-\u003ei_mtime = CURRENT_TIME;\n    if (!(filp-\u003ef_flags \u0026#x26; O_APPEND)) {\n        /* 非 APPEND 模式，更新文件读写指针(偏移量); APPEND 模式是使用 inode-\u003ei_size ，所有就不需要在这里更新了 */\n        filp-\u003ef_pos = pos;\n        inode-\u003ei_ctime = CURRENT_TIME;\n    }\n    return (i?i:-1);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e是不是觉得也没有什么太高大上的操作。确实如此，更多关于缓存块与文件系统数据块的同步都已经被包装到 bread(), brelse() 中了。\u003c/p\u003e\n\u003cp\u003e不过，暂时无需细究。总之到此为止，先要有一个基础的观念: 所有与外存储器(这里也包括控制台等)进行数据交互都必须经过缓冲区\u003c/p\u003e\n\u003cp\u003e缓冲区封装了对外存储器的全部操作，而提供给 CPU 更高效的 I/O 操作，当然，也更为简单快捷\u003c/p\u003e\n\u003ch3\u003e文件读取\u003c/h3\u003e\n\u003cp\u003e至于文件读取，也基本类似了，所以也就不再深入描述。\u003c/p\u003e\n\u003cp\u003e当然，要注意的就是，在本篇开始的部分提供的例程中，write \u0026#x26; read 中插入了 \u003ccode\u003eoff_t off = lseek(fd, 0, SEEK_SET);\u003c/code\u003e  这样的代码。\u003c/p\u003e\n\u003cp\u003e原因应该也能够想到，学习 \u003ccode\u003esys_write(..)\u003c/code\u003e 的时候我们已经看到，任务对同一个文件在内存中维护了一个文件读写偏移量。因此，要读取刚才写入的内容，就不得不先改动这个读写偏移量了\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_read(unsigned int fd,char * buf,int count)\n{\n    struct file * file;\n    struct m_inode * inode;\n\n    if (fd\u003e=NR_OPEN || count\u0026#x3C;0 || !(file=current-\u003efilp[fd]))\n        return -EINVAL;\n    if (!count)\n        return 0;\n    verify_area(buf,count);\n    inode = file-\u003ef_inode;\n    if (inode-\u003ei_pipe)\n        return (file-\u003ef_mode\u0026#x26;1)?read_pipe(inode,buf,count):-EIO;\n    if (S_ISCHR(inode-\u003ei_mode))\n        return rw_char(READ,inode-\u003ei_zone[0],buf,count,\u0026#x26;file-\u003ef_pos);\n    if (S_ISBLK(inode-\u003ei_mode))\n        return block_read(inode-\u003ei_zone[0],\u0026#x26;file-\u003ef_pos,buf,count);\n    if (S_ISDIR(inode-\u003ei_mode) || S_ISREG(inode-\u003ei_mode)) {\n        if (count+file-\u003ef_pos \u003e inode-\u003ei_size)\n            count = inode-\u003ei_size - file-\u003ef_pos;\n        if (count\u0026#x3C;=0)\n            return 0;\n        return file_read(inode,file,buf,count);\n    }\n    printk(\"(Read)inode-\u003ei_mode=%06o\\n\\r\",inode-\u003ei_mode);\n    return -EINVAL;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e小结\u003c/h2\u003e\n\u003cp\u003e这篇对文件系统的代码层面的描述，仅仅只是捡了一个相当有限的片面 (常规文件读写)。从文件系统的挂载开始提供了一个读写的完整流程介绍(当然，很多细节是缺失的，不过不要着急)。\u003c/p\u003e\n\u003cp\u003e虽然平常都能够了解到一个比较模糊的前提，文件读写需要利用缓冲区，但是究竟什么是缓存区，如何使用都不会有太多的概念。本篇最大的重点，就是首先请读者们建立起一个基础性的对缓冲区的了解。事实上，这个中介在 I/O 中扮演了相当重要的角色。而且内存也为其提供了相当大的一份空间，差不多有 1/4 了。\u003c/p\u003e\n\u003cp\u003e跨了差不多半个多月来写，上下文的承接可能有些生硬了，甚至不一致了... 尴尬...\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e"},"buildId":"EIk1vmF3q1tluVqsNXnmg","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/post" src="https://www.ffutop.com/blog/_next/static/EIk1vmF3q1tluVqsNXnmg/pages/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/EIk1vmF3q1tluVqsNXnmg/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.4197c692ff76bb557049.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.923c53dcd3ae2618e978.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>