<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/UUFWw6WeKk9dr4EqrBuOf/pages/post.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/UUFWw6WeKk9dr4EqrBuOf/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.4197c692ff76bb557049.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.923c53dcd3ae2618e978.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.c66cb323.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.fdd739f1.chunk.css"/></head><body><div id="__next"><header><h1 class="title">ffutop</h1><div><a href="/blog/index">博客</a><a href="/blog/archives">归档</a><a href="/blog/tags">标签</a><a href="/blog/about">关于</a></div></header><div><main class="main"><div class="page-post"><div id="#write"><h2>Java ClassFile 文件格式</h2>
<p>读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。
<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The class File Format(Java SE 8)</a> </p>
<blockquote>
<p>u1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)</p>
</blockquote>
<pre><code class="language-c++">ClassFile {
    u4             magic;                                   // 魔数(magic) 固定为 0xCAFEBABE
    u2             minor_version;                           // 次版本号
    u2             major_version;                           // 主版本号
    u2             constant_pool_count;                     // 常量池 constant_pool 的数量 + 1, 最大为 (2&#x3C;&#x3C;16 - 1) = 65535
    cp_info        constant_pool[constant_pool_count-1];    // 常量池 取值下标为 [1, constant_pool_count)
    u2             access_flags;                            // 对类 or 接口的访问权限和属性的标志的掩码
    u2             this_class;                              // 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)
    u2             super_class;                             // 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标
    u2             interfaces_count;                        // 直接父接口的数量
    u2             interfaces[interfaces_count];            // 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i&#x3C;interfaces_count), 指向的类型为 CONSTANT_Class_info)
    u2             fields_count;                            // 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)
    field_info     fields[fields_count];                    // 字段的详细声明, 不包含继承来的字段
    u2             methods_count;                           // 方法数量
    method_info    methods[methods_count];                  // 方法的详细声明, 不包括继承来的方法
    u2             attributes_count;                        // 属性数量
    attribute_info attributes[attributes_count];            // 属性的详细声明
}
</code></pre>
<p>通过 <code>javac Xxx.java</code> 命令得到的 <code>Xxx.class</code> 文件严格按照定义的 ClassFile 文件格式以8比特的字节为单位进行存储。</p>
<p><strong>下面的例子都将通过 Trie.java (实际代码见本文最后) 以及其经编译后的文件 Trie.class 做基本的介绍。</strong></p>
<h3>magic, minor_verion &#x26; major_version</h3>
<p>通过命令 <code>xxd Trie.class</code> 查看 Trie.class 的十六进制编码，前16字节的内容如下:</p>
<pre><code class="language-text">00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.
</code></pre>
<p>可以看到前4字节的内容 <code>0xcafebabe</code>，没有实际意义，但是作为其是能否被JVM(Java Virtual Machine, Java虚拟机)接收的Class文件的一个校验。</p>
<p>紧接着的4个字节包括<code>次版本号</code> 和 <code>主版本号</code>，暂时不做深入。</p>
<h3>常量池 constant_pool</h3>
<p>从第10个字节开始(从第0字节开始计数)，连续的两个字节表示常量池中各种 CONSTANT 的总个数+1 (constant_pool_count)。constant_pool_count 只有2字节也就意味着: 常量池的最大常量数量为 (2&#x3C;&#x3C;16 - 1) = 65535 (当然，貌似在这个量级上，也从没见过有谁能够维护这样一个大JAVA类文件了)。</p>
<p>可以看到 constant_pool_count 的内容为 <code>0x008f = 143</code> ，即对于常量池的声明可以认为是 <code>cp_info constant_pool[142]</code></p>
<pre><code class="language-text">cp_info {
    u1 tag;
    u1 info[]; 
}
</code></pre>
<p>利用 JDK 自带的 <code>javap</code> 来查看 <code>Trie.class</code> 文件(<code>javap -v Trie.class</code>)，可以对 cp_info 的格式有一个粗浅但形象化的认识(结果见<strong>附录2</strong>)
其中第一列的内容 <code>#? = ?</code> <code>#?</code>表示id，<code>= ?</code>表示一个 cp_info 的实际类型，有 <code>cp_info.tag</code> 指定，具体映射表为</p>
<table>
<thead>
<tr>
<th>Constant Type</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CONSTANT_Class</code></td>
<td>7</td>
</tr>
<tr>
<td><code>CONSTANT_Fieldref</code></td>
<td>9</td>
</tr>
<tr>
<td><code>CONSTANT_Methodref</code></td>
<td>10</td>
</tr>
<tr>
<td><code>CONSTANT_InterfaceMethodref</code></td>
<td>11</td>
</tr>
<tr>
<td><code>CONSTANT_String</code></td>
<td>8</td>
</tr>
<tr>
<td><code>CONSTANT_Integer</code></td>
<td>3</td>
</tr>
<tr>
<td><code>CONSTANT_Float</code></td>
<td>4</td>
</tr>
<tr>
<td><code>CONSTANT_Long</code></td>
<td>5</td>
</tr>
<tr>
<td><code>CONSTANT_Double</code></td>
<td>6</td>
</tr>
<tr>
<td><code>CONSTANT_NameAndType</code></td>
<td>12</td>
</tr>
<tr>
<td><code>CONSTANT_Utf8</code></td>
<td>1</td>
</tr>
<tr>
<td><code>CONSTANT_MethodHandle</code></td>
<td>15</td>
</tr>
<tr>
<td><code>CONSTANT_MethodType</code></td>
<td>16</td>
</tr>
<tr>
<td><code>CONSTANT_InvokeDynamic</code></td>
<td>18</td>
</tr>
<tr>
<td><code>CONSTANT_Module</code></td>
<td>19</td>
</tr>
<tr>
<td><code>CONSTANT_Package</code></td>
<td>20</td>
</tr>
</tbody>
</table>
<p>在 Java ClassFile 的格式定义中，同时定义了每种 <code>CONSTANT</code> 的长度与格式。
例如:</p>
<pre><code class="language-c++">CONSTANT_Class_info {
    u1 tag;
    u2 name_index;
}
</code></pre>
<pre><code class="language-c++">CONSTANT_Fieldref_info {
     u1 tag;
     u2 class_index;
     u2 name_and_type_index;
}
CONSTANT_Methodref_info {
  u1 tag;
  u2 class_index;
  u2 name_and_type_index;
}
</code></pre>
<p>更多的 <code>CONSTANT_XXX</code> 的格式定义见 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">ClassFile CONSTANT_XXX 结构</a></p>
<p>简单解析一下 cp_info[1]。</p>
<pre><code class="language-text">00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.

#1 = Methodref          #36.#75       // java/lang/Object."&#x3C;init>":()V
</code></pre>
<p><code>cp_info[1].tag = 0x0a = 10</code>，即 cp_info[1] 的类型为 Methodref 。
之后就直接套用 <code>CONSTANT_Methodref_info</code> 的数据结构定义的格式
<code>cp_info[1].class_index = 0x0024 = 36</code>，即 cp_info[1].class_index 表示的类名指向常量池第 36 个元素表示的类
<code>cp_info[1].name_and_type_index = 0x004b = 75</code>。表示指向的是常量池第 75 个元素表示的 NameAndType 结构</p>
<p>对于这部分内容的理解，如果觉得有能够阅读英文文档，可以参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification Chap 4.</a>
否则，可以选择 <a href="http://icyfenix.iteye.com/blog/1256329">Java 虚拟机规范(Java SE 7 版) 第四章</a>
并尝试根据经编译后.class文件的二进制码进行人工解析，以加深对此的理解。</p>
<h3>more...</h3>
<p>更多内容于此基本类似，均属于已经被严格预定义的规范化格式，对此进行解析即可得到相应的内容。</p>
<h2>ASM 概览</h2>
<h3>包结构</h3>
<p>asm, asm-analysis, asm-commons, asm-tree, asm-util, asm-xml 模块基于 Maven 的组织形式，并包含有单元测试的内容。</p>
<p>asm-test 实现了对上述模块的单元测试的整合。</p>
<p>benchmarks 定义了一些基本的 JMH 基准测试来衡量ASM的表现</p>
<p>gradle 包含了一些 Gradle 包装器，来辅助 Linux or Windows 脚本的调用请求</p>
<p>tools 包含两个 Gradle 项目来帮助 ASM 生成 Artifacts 。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1frywra01upj308g0akmxr.jpg" alt="ASM Structure"></p>
<h3>代码组织形式</h3>
<p><img src="http://asm.ow2.io/asm-package-dependencies.svg" alt="Code Organization"></p>
<ul>
<li>org.objectweb.asm 作为核心包，定义了 ASM 访问者 API 以及两个核心类 ClassReader &#x26; ClassWriter 来读写编译后的 Java 类。该包不依赖于其他包，且可单独使用</li>
<li>org.objectweb.asm.signature 提供了读写泛型签名的 API</li>
<li>org.objectweb.asm.tree 提供了类 DOM API 与类 SAX API。</li>
<li>org.objectweb.asm.tree.analysis 基于 .tree 提供了静态字节码分析框架</li>
<li>org.objectweb.asm.commons 提供了一些基于 core 和 tree 包的类适配器。</li>
<li>org.objectweb.asm.util 提供了一些用于 DEBUG 的访问者类与适配器类</li>
<li>org.objectweb.asm.xml 目前已经被 @Deprecated 。提供了类文件与 XML 互相转换的能力</li>
</ul>
<p>综上，asm 核心包是最为复杂的一个模块，而其它诸如 tree, util, xml 等都只是提供了将 JAVA 类从一种高级表示形态转换为另一种的能力。signature 也相当简单，提供了解析和打印简单语法的能力。</p>
<h3>主要数据结构</h3>
<p>核心包由 28 个类(接口) 组成。如果不考虑 Opcodes 接口, 5 个抽象访问者类(AnnotationVistitor, ClassVisitor, FieldVisitor, MethodVisitor and ModuleVisitor), 6 个工具类(ConstantDynamic, Contants, Handle, Type, TypePath and TypeReference), 剩下 16 个类的由下图提供一个粗略的展示。</p>
<p><img src="http://asm.ow2.io/asm-package-overview.svg"></p>
<p>编译类到访问事件的转换只由一个类 ClassReader 以及辅助类 Context 完成。其逆过程由以 ClassWriter 为核心的其它 14 个类完成。</p>
<h3>ClassReader</h3>
<p>ClassReader 作为 ASM 核心包解析现有 .class 的唯一工具，组织形式相当简单。</p>
<ul>
<li>在构造函数中完成对常量池和引导方法的解析<ul>
<li>存储每个常量池项目的起始偏移量 cpInfoOffsets</li>
<li>存储每个引导方法的起始偏移量 bootstrapMethodOffsets</li>
<li>存储最长字符串常量的大小 maxStringLength</li>
</ul></li>
</ul>
<pre><code class="language-java">  ClassReader(final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {
    this.b = classFileBuffer;   // .class 文件缓存
    // 检查主版本号, 第6,7个字节(从0字节开始计数)
    if (checkClassVersion &#x26;&#x26; readShort(classFileOffset + 6) > Opcodes.V11) {
      throw new IllegalArgumentException(
          "Unsupported class file major version " + readShort(classFileOffset + 6));
    }
    // 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节
    int constantPoolCount = readUnsignedShort(classFileOffset + 8);     // 读取无符号short, 即读取连续两字节作为一个short值
    cpInfoOffsets = new int[constantPoolCount];                         // 每个常量的偏移位置
    cpInfoValues = new Object[constantPoolCount];                       // 每个常量的实例对象
    int currentCpInfoIndex = 1;
    int currentCpInfoOffset = classFileOffset + 10;
    int currentMaxStringLength = 0;                                     // 最长字符串常量
    while (currentCpInfoIndex &#x3C; constantPoolCount) {
      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;
      int cpInfoSize;
      switch (classFileBuffer[currentCpInfoOffset]) {
        case Symbol.CONSTANT_FIELDREF_TAG:
        case Symbol.CONSTANT_METHODREF_TAG:
        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:
        case Symbol.CONSTANT_INTEGER_TAG:
        case Symbol.CONSTANT_FLOAT_TAG:
        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
        case Symbol.CONSTANT_DYNAMIC_TAG:
          cpInfoSize = 5;
          break;
        case Symbol.CONSTANT_LONG_TAG:
        case Symbol.CONSTANT_DOUBLE_TAG:
          cpInfoSize = 9;
          currentCpInfoIndex++;
          break;
        case Symbol.CONSTANT_UTF8_TAG:
          cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);
          if (cpInfoSize > currentMaxStringLength) {
            // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate
            // of the length in characters of the corresponding string, and is much cheaper to
            // compute than this exact length.
            currentMaxStringLength = cpInfoSize;
          }
          break;
        case Symbol.CONSTANT_METHOD_HANDLE_TAG:
          cpInfoSize = 4;
          break;
        case Symbol.CONSTANT_CLASS_TAG:
        case Symbol.CONSTANT_STRING_TAG:
        case Symbol.CONSTANT_METHOD_TYPE_TAG:
        case Symbol.CONSTANT_PACKAGE_TAG:
        case Symbol.CONSTANT_MODULE_TAG:
          cpInfoSize = 3;
          break;
        default:
          throw new IllegalArgumentException();
      }
      currentCpInfoOffset += cpInfoSize;
    }
    this.maxStringLength = currentMaxStringLength;
    // The Classfile's access_flags field is just after the last constant pool entry.
    this.header = currentCpInfoOffset;

    // 读取 BootstrapMethods 属性(如果存在)
    int currentAttributeOffset = getFirstAttributeOffset();
    int[] currentBootstrapMethodOffsets = null;
    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {
      // 读取每个 attribute_info 的属性名和属性长度
      String attributeName = readUTF8(currentAttributeOffset, new char[maxStringLength]);
      int attributeLength = readInt(currentAttributeOffset + 2);
      currentAttributeOffset += 6;
      // 如果当前属性名为 BootstrapMethods ，则进入处理逻辑
      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {
        // Read the num_bootstrap_methods field and create an array of this size.
        currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];
        // Compute and store the offset of each 'bootstrap_methods' array field entry.
        int currentBootstrapMethodOffset = currentAttributeOffset + 2;
        for (int j = 0; j &#x3C; currentBootstrapMethodOffsets.length; ++j) {
          currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;
          // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),
          // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).
          currentBootstrapMethodOffset +=
              4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;
        }
      }
      currentAttributeOffset += attributeLength;
    }
    this.bootstrapMethodOffsets = currentBootstrapMethodOffsets;
  }
</code></pre>
<p>到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。
但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。</p>
<p>这部分的内容在 accept(...) 和 readXXX(...) 中将得到解析。</p>
<p>主要流程类似:</p>
<ol>
<li>读取当前内容的偏移量(相较于整个 byte[])</li>
<li>解析当前的内容</li>
<li>调用 visitXXX 方法</li>
<li>在 visitXXX 方法中进行相关的处理</li>
<li>visitEnd</li>
</ol>
<h2>附录1 Trie.java</h2>
<pre><code class="language-java">package me.fangfeng.filter;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.OutputStreamWriter;

/**
 * @author fangfeng
 * @since 2018/5/16
 */
public class Trie {
    
    private static int MAX_ITEM = 700000;
    private static int AVG_LENGTH = 11;
    private static int MAX_NODE = MAX_ITEM * AVG_LENGTH;
    private static int CHAR_NUM = 10;

    int[][] nxt = new int[MAX_NODE][CHAR_NUM];
    boolean[] flag = new boolean[MAX_NODE];
    int trieIndex = 0;

    void insert(long number) {
        int tmpIndex = 0;
        for (;number != 0;number /= 10) {
            if (nxt[tmpIndex][(int) (number % 10)] == 0) {
                nxt[tmpIndex][(int) (number % 10)] = ++trieIndex;
            }
            tmpIndex = nxt[tmpIndex][(int) (number % 10)];
        }
        flag[tmpIndex] = true;
    }

    boolean query(long number) {
        int tmpIndex = 0;
        for (;number != 0;number /= 10) {
            if (nxt[tmpIndex][(int) (number % 10)] == 0) {
                return false;
            }
            tmpIndex = nxt[tmpIndex][(int) (number % 10)];
        }
        return flag[tmpIndex];
    }

    public static void main(String... args) throws FileNotFoundException, IOException {

        long start = System.currentTimeMillis();

        String ruleFilePath = args[0];
        String sendFilePath = args[1];
        String outFilePath = args[2];

        BufferedReader ruleReader = new BufferedReader(new InputStreamReader(new FileInputStream(ruleFilePath)));
        BufferedReader sendReader = new BufferedReader(new InputStreamReader(new FileInputStream(sendFilePath)));

        BufferedWriter outWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outFilePath)));

        Trie trie = new Trie();
        String mobile;
        while((mobile = ruleReader.readLine()) != null) {
            trie.insert(Long.parseLong(mobile));
        }
        ruleReader.close();

        while((mobile = sendReader.readLine()) != null) {
            if(trie.query(Long.parseLong(mobile)) == false) {
                outWriter.write(mobile);
                outWriter.newLine();
            }
        }
        sendReader.close();

        outWriter.flush();
        outWriter.close();

        long end = System.currentTimeMillis();
        System.out.println(String.format("exec success! used %d ms", end - start));
    }
}
</code></pre>
<h2>附录2 Constant pool</h2>
<pre><code>Constant pool:
    #1 = Methodref          #36.#75       // java/lang/Object."&#x3C;init>":()V
    #2 = Fieldref           #23.#76       // me/fangfeng/filter/Trie.MAX_NODE:I
    #3 = Fieldref           #23.#77       // me/fangfeng/filter/Trie.CHAR_NUM:I
    #4 = Class              #49           // "[[I"
    #5 = Fieldref           #23.#78       // me/fangfeng/filter/Trie.nxt:[[I
    #6 = Fieldref           #23.#79       // me/fangfeng/filter/Trie.flag:[Z
    #7 = Fieldref           #23.#80       // me/fangfeng/filter/Trie.trieIndex:I
    #8 = Long               10l
   #10 = Methodref          #81.#82       // java/lang/System.currentTimeMillis:()J
   #11 = Class              #83           // java/io/BufferedReader
   #12 = Class              #84           // java/io/InputStreamReader
   #13 = Class              #85           // java/io/FileInputStream
   #14 = Methodref          #13.#86       // java/io/FileInputStream."&#x3C;init>":(Ljava/lang/String;)V
   #15 = Methodref          #12.#87       // java/io/InputStreamReader."&#x3C;init>":(Ljava/io/InputStream;)V
   #16 = Methodref          #11.#88       // java/io/BufferedReader."&#x3C;init>":(Ljava/io/Reader;)V
   #17 = Class              #89           // java/io/BufferedWriter
   #18 = Class              #90           // java/io/OutputStreamWriter
   #19 = Class              #91           // java/io/FileOutputStream
   #20 = Methodref          #19.#86       // java/io/FileOutputStream."&#x3C;init>":(Ljava/lang/String;)V
   #21 = Methodref          #18.#92       // java/io/OutputStreamWriter."&#x3C;init>":(Ljava/io/OutputStream;)V
   #22 = Methodref          #17.#93       // java/io/BufferedWriter."&#x3C;init>":(Ljava/io/Writer;)V
   #23 = Class              #94           // me/fangfeng/filter/Trie
   #24 = Methodref          #23.#75       // me/fangfeng/filter/Trie."&#x3C;init>":()V
   #25 = Methodref          #11.#95       // java/io/BufferedReader.readLine:()Ljava/lang/String;
   #26 = Methodref          #96.#97       // java/lang/Long.parseLong:(Ljava/lang/String;)J
   #27 = Methodref          #23.#98       // me/fangfeng/filter/Trie.insert:(J)V
   #28 = Methodref          #11.#99       // java/io/BufferedReader.close:()V
   #29 = Methodref          #23.#100      // me/fangfeng/filter/Trie.query:(J)Z
   #30 = Methodref          #17.#101      // java/io/BufferedWriter.write:(Ljava/lang/String;)V
   #31 = Methodref          #17.#102      // java/io/BufferedWriter.newLine:()V
   #32 = Methodref          #17.#103      // java/io/BufferedWriter.flush:()V
   #33 = Methodref          #17.#99       // java/io/BufferedWriter.close:()V
   #34 = Fieldref           #81.#104      // java/lang/System.out:Ljava/io/PrintStream;
   #35 = String             #105          // exec success! used %d ms
   #36 = Class              #106          // java/lang/Object
   #37 = Methodref          #96.#107      // java/lang/Long.valueOf:(J)Ljava/lang/Long;
   #38 = Methodref          #108.#109     // java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
   #39 = Methodref          #110.#111     // java/io/PrintStream.println:(Ljava/lang/String;)V
   #40 = Integer            700000
   #41 = Fieldref           #23.#112      // me/fangfeng/filter/Trie.MAX_ITEM:I
   #42 = Fieldref           #23.#113      // me/fangfeng/filter/Trie.AVG_LENGTH:I
   #43 = Utf8               MAX_ITEM
   #44 = Utf8               I
   #45 = Utf8               AVG_LENGTH
   #46 = Utf8               MAX_NODE
   #47 = Utf8               CHAR_NUM
   #48 = Utf8               nxt
   #49 = Utf8               [[I
   #50 = Utf8               flag
   #51 = Utf8               [Z
   #52 = Utf8               trieIndex
   #53 = Utf8               &#x3C;init>
   #54 = Utf8               ()V
   #55 = Utf8               Code
   #56 = Utf8               LineNumberTable
   #57 = Utf8               insert
   #58 = Utf8               (J)V
   #59 = Utf8               StackMapTable
   #60 = Utf8               query
   #61 = Utf8               (J)Z
   #62 = Utf8               main
   #63 = Utf8               ([Ljava/lang/String;)V
   #64 = Class              #114          // "[Ljava/lang/String;"
   #65 = Class              #115          // java/lang/String
   #66 = Class              #83           // java/io/BufferedReader
   #67 = Class              #89           // java/io/BufferedWriter
   #68 = Class              #94           // me/fangfeng/filter/Trie
   #69 = Utf8               Exceptions
   #70 = Class              #116          // java/io/FileNotFoundException
   #71 = Class              #117          // java/io/IOException
   #72 = Utf8               &#x3C;clinit>
   #73 = Utf8               SourceFile
   #74 = Utf8               Trie.java
   #75 = NameAndType        #53:#54       // "&#x3C;init>":()V
   #76 = NameAndType        #46:#44       // MAX_NODE:I
   #77 = NameAndType        #47:#44       // CHAR_NUM:I
   #78 = NameAndType        #48:#49       // nxt:[[I
   #79 = NameAndType        #50:#51       // flag:[Z
   #80 = NameAndType        #52:#44       // trieIndex:I
   #81 = Class              #118          // java/lang/System
   #82 = NameAndType        #119:#120     // currentTimeMillis:()J
   #83 = Utf8               java/io/BufferedReader
   #84 = Utf8               java/io/InputStreamReader
   #85 = Utf8               java/io/FileInputStream
   #86 = NameAndType        #53:#121      // "&#x3C;init>":(Ljava/lang/String;)V
   #87 = NameAndType        #53:#122      // "&#x3C;init>":(Ljava/io/InputStream;)V
   #88 = NameAndType        #53:#123      // "&#x3C;init>":(Ljava/io/Reader;)V
   #89 = Utf8               java/io/BufferedWriter
   #90 = Utf8               java/io/OutputStreamWriter
   #91 = Utf8               java/io/FileOutputStream
   #92 = NameAndType        #53:#124      // "&#x3C;init>":(Ljava/io/OutputStream;)V
   #93 = NameAndType        #53:#125      // "&#x3C;init>":(Ljava/io/Writer;)V
   #94 = Utf8               me/fangfeng/filter/Trie
   #95 = NameAndType        #126:#127     // readLine:()Ljava/lang/String;
   #96 = Class              #128          // java/lang/Long
   #97 = NameAndType        #129:#130     // parseLong:(Ljava/lang/String;)J
   #98 = NameAndType        #57:#58       // insert:(J)V
   #99 = NameAndType        #131:#54      // close:()V
  #100 = NameAndType        #60:#61       // query:(J)Z
  #101 = NameAndType        #132:#121     // write:(Ljava/lang/String;)V
  #102 = NameAndType        #133:#54      // newLine:()V
  #103 = NameAndType        #134:#54      // flush:()V
  #104 = NameAndType        #135:#136     // out:Ljava/io/PrintStream;
  #105 = Utf8               exec success! used %d ms
  #106 = Utf8               java/lang/Object
  #107 = NameAndType        #137:#138     // valueOf:(J)Ljava/lang/Long;
  #108 = Class              #115          // java/lang/String
  #109 = NameAndType        #139:#140     // format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
  #110 = Class              #141          // java/io/PrintStream
  #111 = NameAndType        #142:#121     // println:(Ljava/lang/String;)V
  #112 = NameAndType        #43:#44       // MAX_ITEM:I
  #113 = NameAndType        #45:#44       // AVG_LENGTH:I
  #114 = Utf8               [Ljava/lang/String;
  #115 = Utf8               java/lang/String
  #116 = Utf8               java/io/FileNotFoundException
  #117 = Utf8               java/io/IOException
  #118 = Utf8               java/lang/System
  #119 = Utf8               currentTimeMillis
  #120 = Utf8               ()J
  #121 = Utf8               (Ljava/lang/String;)V
  #122 = Utf8               (Ljava/io/InputStream;)V
  #123 = Utf8               (Ljava/io/Reader;)V
  #124 = Utf8               (Ljava/io/OutputStream;)V
  #125 = Utf8               (Ljava/io/Writer;)V
  #126 = Utf8               readLine
  #127 = Utf8               ()Ljava/lang/String;
  #128 = Utf8               java/lang/Long
  #129 = Utf8               parseLong
  #130 = Utf8               (Ljava/lang/String;)J
  #131 = Utf8               close
  #132 = Utf8               write
  #133 = Utf8               newLine
  #134 = Utf8               flush
  #135 = Utf8               out
  #136 = Utf8               Ljava/io/PrintStream;
  #137 = Utf8               valueOf
  #138 = Utf8               (J)Ljava/lang/Long;
  #139 = Utf8               format
  #140 = Utf8               (Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
  #141 = Utf8               java/io/PrintStream
  #142 = Utf8               println
</code></pre>
<h2>参考</h2>
<p>[1]: <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a> "Java Virtual Machine Specification"
[2]: <a href="http://icyfenix.iteye.com/blog/1256329">http://icyfenix.iteye.com/blog/1256329</a> "Java虚拟机规范（Java SE 7 中文版）"</p>
<pre><code class="language-plain">  __                    __                  
 / _| __ _ _ __   __ _ / _| ___ _ __   __ _ 
| |_ / _` | '_ \ / _` | |_ / _ \ '_ \ / _` |
|  _| (_| | | | | (_| |  _|  __/ | | | (_| |
|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |
                 |___/                |___/ 
</code></pre></div></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/post","query":{"content":"\u003ch2\u003eJava ClassFile 文件格式\u003c/h2\u003e\n\u003cp\u003e读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。\n\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\"\u003eThe class File Format(Java SE 8)\u003c/a\u003e \u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eu1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-c++\"\u003eClassFile {\n    u4             magic;                                   // 魔数(magic) 固定为 0xCAFEBABE\n    u2             minor_version;                           // 次版本号\n    u2             major_version;                           // 主版本号\n    u2             constant_pool_count;                     // 常量池 constant_pool 的数量 + 1, 最大为 (2\u0026#x3C;\u0026#x3C;16 - 1) = 65535\n    cp_info        constant_pool[constant_pool_count-1];    // 常量池 取值下标为 [1, constant_pool_count)\n    u2             access_flags;                            // 对类 or 接口的访问权限和属性的标志的掩码\n    u2             this_class;                              // 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)\n    u2             super_class;                             // 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标\n    u2             interfaces_count;                        // 直接父接口的数量\n    u2             interfaces[interfaces_count];            // 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i\u0026#x3C;interfaces_count), 指向的类型为 CONSTANT_Class_info)\n    u2             fields_count;                            // 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)\n    field_info     fields[fields_count];                    // 字段的详细声明, 不包含继承来的字段\n    u2             methods_count;                           // 方法数量\n    method_info    methods[methods_count];                  // 方法的详细声明, 不包括继承来的方法\n    u2             attributes_count;                        // 属性数量\n    attribute_info attributes[attributes_count];            // 属性的详细声明\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过 \u003ccode\u003ejavac Xxx.java\u003c/code\u003e 命令得到的 \u003ccode\u003eXxx.class\u003c/code\u003e 文件严格按照定义的 ClassFile 文件格式以8比特的字节为单位进行存储。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e下面的例子都将通过 Trie.java (实际代码见本文最后) 以及其经编译后的文件 Trie.class 做基本的介绍。\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003emagic, minor_verion \u0026#x26; major_version\u003c/h3\u003e\n\u003cp\u003e通过命令 \u003ccode\u003exxd Trie.class\u003c/code\u003e 查看 Trie.class 的十六进制编码，前16字节的内容如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到前4字节的内容 \u003ccode\u003e0xcafebabe\u003c/code\u003e，没有实际意义，但是作为其是能否被JVM(Java Virtual Machine, Java虚拟机)接收的Class文件的一个校验。\u003c/p\u003e\n\u003cp\u003e紧接着的4个字节包括\u003ccode\u003e次版本号\u003c/code\u003e 和 \u003ccode\u003e主版本号\u003c/code\u003e，暂时不做深入。\u003c/p\u003e\n\u003ch3\u003e常量池 constant_pool\u003c/h3\u003e\n\u003cp\u003e从第10个字节开始(从第0字节开始计数)，连续的两个字节表示常量池中各种 CONSTANT 的总个数+1 (constant_pool_count)。constant_pool_count 只有2字节也就意味着: 常量池的最大常量数量为 (2\u0026#x3C;\u0026#x3C;16 - 1) = 65535 (当然，貌似在这个量级上，也从没见过有谁能够维护这样一个大JAVA类文件了)。\u003c/p\u003e\n\u003cp\u003e可以看到 constant_pool_count 的内容为 \u003ccode\u003e0x008f = 143\u003c/code\u003e ，即对于常量池的声明可以认为是 \u003ccode\u003ecp_info constant_pool[142]\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003ecp_info {\n    u1 tag;\n    u1 info[]; \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e利用 JDK 自带的 \u003ccode\u003ejavap\u003c/code\u003e 来查看 \u003ccode\u003eTrie.class\u003c/code\u003e 文件(\u003ccode\u003ejavap -v Trie.class\u003c/code\u003e)，可以对 cp_info 的格式有一个粗浅但形象化的认识(结果见\u003cstrong\u003e附录2\u003c/strong\u003e)\n其中第一列的内容 \u003ccode\u003e#? = ?\u003c/code\u003e \u003ccode\u003e#?\u003c/code\u003e表示id，\u003ccode\u003e= ?\u003c/code\u003e表示一个 cp_info 的实际类型，有 \u003ccode\u003ecp_info.tag\u003c/code\u003e 指定，具体映射表为\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eConstant Type\u003c/th\u003e\n\u003cth\u003eValue\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Class\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e7\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Fieldref\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e9\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Methodref\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e10\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_InterfaceMethodref\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e11\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_String\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e8\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Integer\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Float\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e4\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Long\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Double\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e6\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_NameAndType\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e12\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Utf8\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_MethodHandle\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e15\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_MethodType\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e16\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_InvokeDynamic\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e18\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Module\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e19\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Package\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e20\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e在 Java ClassFile 的格式定义中，同时定义了每种 \u003ccode\u003eCONSTANT\u003c/code\u003e 的长度与格式。\n例如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c++\"\u003eCONSTANT_Class_info {\n    u1 tag;\n    u2 name_index;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-c++\"\u003eCONSTANT_Fieldref_info {\n     u1 tag;\n     u2 class_index;\n     u2 name_and_type_index;\n}\nCONSTANT_Methodref_info {\n  u1 tag;\n  u2 class_index;\n  u2 name_and_type_index;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e更多的 \u003ccode\u003eCONSTANT_XXX\u003c/code\u003e 的格式定义见 \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4\"\u003eClassFile CONSTANT_XXX 结构\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e简单解析一下 cp_info[1]。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.\n\n#1 = Methodref          #36.#75       // java/lang/Object.\"\u0026#x3C;init\u003e\":()V\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecp_info[1].tag = 0x0a = 10\u003c/code\u003e，即 cp_info[1] 的类型为 Methodref 。\n之后就直接套用 \u003ccode\u003eCONSTANT_Methodref_info\u003c/code\u003e 的数据结构定义的格式\n\u003ccode\u003ecp_info[1].class_index = 0x0024 = 36\u003c/code\u003e，即 cp_info[1].class_index 表示的类名指向常量池第 36 个元素表示的类\n\u003ccode\u003ecp_info[1].name_and_type_index = 0x004b = 75\u003c/code\u003e。表示指向的是常量池第 75 个元素表示的 NameAndType 结构\u003c/p\u003e\n\u003cp\u003e对于这部分内容的理解，如果觉得有能够阅读英文文档，可以参考 \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\"\u003eThe Java® Virtual Machine Specification Chap 4.\u003c/a\u003e\n否则，可以选择 \u003ca href=\"http://icyfenix.iteye.com/blog/1256329\"\u003eJava 虚拟机规范(Java SE 7 版) 第四章\u003c/a\u003e\n并尝试根据经编译后.class文件的二进制码进行人工解析，以加深对此的理解。\u003c/p\u003e\n\u003ch3\u003emore...\u003c/h3\u003e\n\u003cp\u003e更多内容于此基本类似，均属于已经被严格预定义的规范化格式，对此进行解析即可得到相应的内容。\u003c/p\u003e\n\u003ch2\u003eASM 概览\u003c/h2\u003e\n\u003ch3\u003e包结构\u003c/h3\u003e\n\u003cp\u003easm, asm-analysis, asm-commons, asm-tree, asm-util, asm-xml 模块基于 Maven 的组织形式，并包含有单元测试的内容。\u003c/p\u003e\n\u003cp\u003easm-test 实现了对上述模块的单元测试的整合。\u003c/p\u003e\n\u003cp\u003ebenchmarks 定义了一些基本的 JMH 基准测试来衡量ASM的表现\u003c/p\u003e\n\u003cp\u003egradle 包含了一些 Gradle 包装器，来辅助 Linux or Windows 脚本的调用请求\u003c/p\u003e\n\u003cp\u003etools 包含两个 Gradle 项目来帮助 ASM 生成 Artifacts 。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1frywra01upj308g0akmxr.jpg\" alt=\"ASM Structure\"\u003e\u003c/p\u003e\n\u003ch3\u003e代码组织形式\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"http://asm.ow2.io/asm-package-dependencies.svg\" alt=\"Code Organization\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eorg.objectweb.asm 作为核心包，定义了 ASM 访问者 API 以及两个核心类 ClassReader \u0026#x26; ClassWriter 来读写编译后的 Java 类。该包不依赖于其他包，且可单独使用\u003c/li\u003e\n\u003cli\u003eorg.objectweb.asm.signature 提供了读写泛型签名的 API\u003c/li\u003e\n\u003cli\u003eorg.objectweb.asm.tree 提供了类 DOM API 与类 SAX API。\u003c/li\u003e\n\u003cli\u003eorg.objectweb.asm.tree.analysis 基于 .tree 提供了静态字节码分析框架\u003c/li\u003e\n\u003cli\u003eorg.objectweb.asm.commons 提供了一些基于 core 和 tree 包的类适配器。\u003c/li\u003e\n\u003cli\u003eorg.objectweb.asm.util 提供了一些用于 DEBUG 的访问者类与适配器类\u003c/li\u003e\n\u003cli\u003eorg.objectweb.asm.xml 目前已经被 @Deprecated 。提供了类文件与 XML 互相转换的能力\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e综上，asm 核心包是最为复杂的一个模块，而其它诸如 tree, util, xml 等都只是提供了将 JAVA 类从一种高级表示形态转换为另一种的能力。signature 也相当简单，提供了解析和打印简单语法的能力。\u003c/p\u003e\n\u003ch3\u003e主要数据结构\u003c/h3\u003e\n\u003cp\u003e核心包由 28 个类(接口) 组成。如果不考虑 Opcodes 接口, 5 个抽象访问者类(AnnotationVistitor, ClassVisitor, FieldVisitor, MethodVisitor and ModuleVisitor), 6 个工具类(ConstantDynamic, Contants, Handle, Type, TypePath and TypeReference), 剩下 16 个类的由下图提供一个粗略的展示。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"http://asm.ow2.io/asm-package-overview.svg\"\u003e\u003c/p\u003e\n\u003cp\u003e编译类到访问事件的转换只由一个类 ClassReader 以及辅助类 Context 完成。其逆过程由以 ClassWriter 为核心的其它 14 个类完成。\u003c/p\u003e\n\u003ch3\u003eClassReader\u003c/h3\u003e\n\u003cp\u003eClassReader 作为 ASM 核心包解析现有 .class 的唯一工具，组织形式相当简单。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在构造函数中完成对常量池和引导方法的解析\u003cul\u003e\n\u003cli\u003e存储每个常量池项目的起始偏移量 cpInfoOffsets\u003c/li\u003e\n\u003cli\u003e存储每个引导方法的起始偏移量 bootstrapMethodOffsets\u003c/li\u003e\n\u003cli\u003e存储最长字符串常量的大小 maxStringLength\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e  ClassReader(final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {\n    this.b = classFileBuffer;   // .class 文件缓存\n    // 检查主版本号, 第6,7个字节(从0字节开始计数)\n    if (checkClassVersion \u0026#x26;\u0026#x26; readShort(classFileOffset + 6) \u003e Opcodes.V11) {\n      throw new IllegalArgumentException(\n          \"Unsupported class file major version \" + readShort(classFileOffset + 6));\n    }\n    // 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节\n    int constantPoolCount = readUnsignedShort(classFileOffset + 8);     // 读取无符号short, 即读取连续两字节作为一个short值\n    cpInfoOffsets = new int[constantPoolCount];                         // 每个常量的偏移位置\n    cpInfoValues = new Object[constantPoolCount];                       // 每个常量的实例对象\n    int currentCpInfoIndex = 1;\n    int currentCpInfoOffset = classFileOffset + 10;\n    int currentMaxStringLength = 0;                                     // 最长字符串常量\n    while (currentCpInfoIndex \u0026#x3C; constantPoolCount) {\n      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;\n      int cpInfoSize;\n      switch (classFileBuffer[currentCpInfoOffset]) {\n        case Symbol.CONSTANT_FIELDREF_TAG:\n        case Symbol.CONSTANT_METHODREF_TAG:\n        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n        case Symbol.CONSTANT_INTEGER_TAG:\n        case Symbol.CONSTANT_FLOAT_TAG:\n        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n        case Symbol.CONSTANT_DYNAMIC_TAG:\n          cpInfoSize = 5;\n          break;\n        case Symbol.CONSTANT_LONG_TAG:\n        case Symbol.CONSTANT_DOUBLE_TAG:\n          cpInfoSize = 9;\n          currentCpInfoIndex++;\n          break;\n        case Symbol.CONSTANT_UTF8_TAG:\n          cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);\n          if (cpInfoSize \u003e currentMaxStringLength) {\n            // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate\n            // of the length in characters of the corresponding string, and is much cheaper to\n            // compute than this exact length.\n            currentMaxStringLength = cpInfoSize;\n          }\n          break;\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n          cpInfoSize = 4;\n          break;\n        case Symbol.CONSTANT_CLASS_TAG:\n        case Symbol.CONSTANT_STRING_TAG:\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\n        case Symbol.CONSTANT_PACKAGE_TAG:\n        case Symbol.CONSTANT_MODULE_TAG:\n          cpInfoSize = 3;\n          break;\n        default:\n          throw new IllegalArgumentException();\n      }\n      currentCpInfoOffset += cpInfoSize;\n    }\n    this.maxStringLength = currentMaxStringLength;\n    // The Classfile's access_flags field is just after the last constant pool entry.\n    this.header = currentCpInfoOffset;\n\n    // 读取 BootstrapMethods 属性(如果存在)\n    int currentAttributeOffset = getFirstAttributeOffset();\n    int[] currentBootstrapMethodOffsets = null;\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i \u003e 0; --i) {\n      // 读取每个 attribute_info 的属性名和属性长度\n      String attributeName = readUTF8(currentAttributeOffset, new char[maxStringLength]);\n      int attributeLength = readInt(currentAttributeOffset + 2);\n      currentAttributeOffset += 6;\n      // 如果当前属性名为 BootstrapMethods ，则进入处理逻辑\n      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        // Read the num_bootstrap_methods field and create an array of this size.\n        currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];\n        // Compute and store the offset of each 'bootstrap_methods' array field entry.\n        int currentBootstrapMethodOffset = currentAttributeOffset + 2;\n        for (int j = 0; j \u0026#x3C; currentBootstrapMethodOffsets.length; ++j) {\n          currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;\n          // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\n          // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\n          currentBootstrapMethodOffset +=\n              4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\n        }\n      }\n      currentAttributeOffset += attributeLength;\n    }\n    this.bootstrapMethodOffsets = currentBootstrapMethodOffsets;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。\n但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。\u003c/p\u003e\n\u003cp\u003e这部分的内容在 accept(...) 和 readXXX(...) 中将得到解析。\u003c/p\u003e\n\u003cp\u003e主要流程类似:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e读取当前内容的偏移量(相较于整个 byte[])\u003c/li\u003e\n\u003cli\u003e解析当前的内容\u003c/li\u003e\n\u003cli\u003e调用 visitXXX 方法\u003c/li\u003e\n\u003cli\u003e在 visitXXX 方法中进行相关的处理\u003c/li\u003e\n\u003cli\u003evisitEnd\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e附录1 Trie.java\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage me.fangfeng.filter;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\n\n/**\n * @author fangfeng\n * @since 2018/5/16\n */\npublic class Trie {\n    \n    private static int MAX_ITEM = 700000;\n    private static int AVG_LENGTH = 11;\n    private static int MAX_NODE = MAX_ITEM * AVG_LENGTH;\n    private static int CHAR_NUM = 10;\n\n    int[][] nxt = new int[MAX_NODE][CHAR_NUM];\n    boolean[] flag = new boolean[MAX_NODE];\n    int trieIndex = 0;\n\n    void insert(long number) {\n        int tmpIndex = 0;\n        for (;number != 0;number /= 10) {\n            if (nxt[tmpIndex][(int) (number % 10)] == 0) {\n                nxt[tmpIndex][(int) (number % 10)] = ++trieIndex;\n            }\n            tmpIndex = nxt[tmpIndex][(int) (number % 10)];\n        }\n        flag[tmpIndex] = true;\n    }\n\n    boolean query(long number) {\n        int tmpIndex = 0;\n        for (;number != 0;number /= 10) {\n            if (nxt[tmpIndex][(int) (number % 10)] == 0) {\n                return false;\n            }\n            tmpIndex = nxt[tmpIndex][(int) (number % 10)];\n        }\n        return flag[tmpIndex];\n    }\n\n    public static void main(String... args) throws FileNotFoundException, IOException {\n\n        long start = System.currentTimeMillis();\n\n        String ruleFilePath = args[0];\n        String sendFilePath = args[1];\n        String outFilePath = args[2];\n\n        BufferedReader ruleReader = new BufferedReader(new InputStreamReader(new FileInputStream(ruleFilePath)));\n        BufferedReader sendReader = new BufferedReader(new InputStreamReader(new FileInputStream(sendFilePath)));\n\n        BufferedWriter outWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outFilePath)));\n\n        Trie trie = new Trie();\n        String mobile;\n        while((mobile = ruleReader.readLine()) != null) {\n            trie.insert(Long.parseLong(mobile));\n        }\n        ruleReader.close();\n\n        while((mobile = sendReader.readLine()) != null) {\n            if(trie.query(Long.parseLong(mobile)) == false) {\n                outWriter.write(mobile);\n                outWriter.newLine();\n            }\n        }\n        sendReader.close();\n\n        outWriter.flush();\n        outWriter.close();\n\n        long end = System.currentTimeMillis();\n        System.out.println(String.format(\"exec success! used %d ms\", end - start));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e附录2 Constant pool\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eConstant pool:\n    #1 = Methodref          #36.#75       // java/lang/Object.\"\u0026#x3C;init\u003e\":()V\n    #2 = Fieldref           #23.#76       // me/fangfeng/filter/Trie.MAX_NODE:I\n    #3 = Fieldref           #23.#77       // me/fangfeng/filter/Trie.CHAR_NUM:I\n    #4 = Class              #49           // \"[[I\"\n    #5 = Fieldref           #23.#78       // me/fangfeng/filter/Trie.nxt:[[I\n    #6 = Fieldref           #23.#79       // me/fangfeng/filter/Trie.flag:[Z\n    #7 = Fieldref           #23.#80       // me/fangfeng/filter/Trie.trieIndex:I\n    #8 = Long               10l\n   #10 = Methodref          #81.#82       // java/lang/System.currentTimeMillis:()J\n   #11 = Class              #83           // java/io/BufferedReader\n   #12 = Class              #84           // java/io/InputStreamReader\n   #13 = Class              #85           // java/io/FileInputStream\n   #14 = Methodref          #13.#86       // java/io/FileInputStream.\"\u0026#x3C;init\u003e\":(Ljava/lang/String;)V\n   #15 = Methodref          #12.#87       // java/io/InputStreamReader.\"\u0026#x3C;init\u003e\":(Ljava/io/InputStream;)V\n   #16 = Methodref          #11.#88       // java/io/BufferedReader.\"\u0026#x3C;init\u003e\":(Ljava/io/Reader;)V\n   #17 = Class              #89           // java/io/BufferedWriter\n   #18 = Class              #90           // java/io/OutputStreamWriter\n   #19 = Class              #91           // java/io/FileOutputStream\n   #20 = Methodref          #19.#86       // java/io/FileOutputStream.\"\u0026#x3C;init\u003e\":(Ljava/lang/String;)V\n   #21 = Methodref          #18.#92       // java/io/OutputStreamWriter.\"\u0026#x3C;init\u003e\":(Ljava/io/OutputStream;)V\n   #22 = Methodref          #17.#93       // java/io/BufferedWriter.\"\u0026#x3C;init\u003e\":(Ljava/io/Writer;)V\n   #23 = Class              #94           // me/fangfeng/filter/Trie\n   #24 = Methodref          #23.#75       // me/fangfeng/filter/Trie.\"\u0026#x3C;init\u003e\":()V\n   #25 = Methodref          #11.#95       // java/io/BufferedReader.readLine:()Ljava/lang/String;\n   #26 = Methodref          #96.#97       // java/lang/Long.parseLong:(Ljava/lang/String;)J\n   #27 = Methodref          #23.#98       // me/fangfeng/filter/Trie.insert:(J)V\n   #28 = Methodref          #11.#99       // java/io/BufferedReader.close:()V\n   #29 = Methodref          #23.#100      // me/fangfeng/filter/Trie.query:(J)Z\n   #30 = Methodref          #17.#101      // java/io/BufferedWriter.write:(Ljava/lang/String;)V\n   #31 = Methodref          #17.#102      // java/io/BufferedWriter.newLine:()V\n   #32 = Methodref          #17.#103      // java/io/BufferedWriter.flush:()V\n   #33 = Methodref          #17.#99       // java/io/BufferedWriter.close:()V\n   #34 = Fieldref           #81.#104      // java/lang/System.out:Ljava/io/PrintStream;\n   #35 = String             #105          // exec success! used %d ms\n   #36 = Class              #106          // java/lang/Object\n   #37 = Methodref          #96.#107      // java/lang/Long.valueOf:(J)Ljava/lang/Long;\n   #38 = Methodref          #108.#109     // java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n   #39 = Methodref          #110.#111     // java/io/PrintStream.println:(Ljava/lang/String;)V\n   #40 = Integer            700000\n   #41 = Fieldref           #23.#112      // me/fangfeng/filter/Trie.MAX_ITEM:I\n   #42 = Fieldref           #23.#113      // me/fangfeng/filter/Trie.AVG_LENGTH:I\n   #43 = Utf8               MAX_ITEM\n   #44 = Utf8               I\n   #45 = Utf8               AVG_LENGTH\n   #46 = Utf8               MAX_NODE\n   #47 = Utf8               CHAR_NUM\n   #48 = Utf8               nxt\n   #49 = Utf8               [[I\n   #50 = Utf8               flag\n   #51 = Utf8               [Z\n   #52 = Utf8               trieIndex\n   #53 = Utf8               \u0026#x3C;init\u003e\n   #54 = Utf8               ()V\n   #55 = Utf8               Code\n   #56 = Utf8               LineNumberTable\n   #57 = Utf8               insert\n   #58 = Utf8               (J)V\n   #59 = Utf8               StackMapTable\n   #60 = Utf8               query\n   #61 = Utf8               (J)Z\n   #62 = Utf8               main\n   #63 = Utf8               ([Ljava/lang/String;)V\n   #64 = Class              #114          // \"[Ljava/lang/String;\"\n   #65 = Class              #115          // java/lang/String\n   #66 = Class              #83           // java/io/BufferedReader\n   #67 = Class              #89           // java/io/BufferedWriter\n   #68 = Class              #94           // me/fangfeng/filter/Trie\n   #69 = Utf8               Exceptions\n   #70 = Class              #116          // java/io/FileNotFoundException\n   #71 = Class              #117          // java/io/IOException\n   #72 = Utf8               \u0026#x3C;clinit\u003e\n   #73 = Utf8               SourceFile\n   #74 = Utf8               Trie.java\n   #75 = NameAndType        #53:#54       // \"\u0026#x3C;init\u003e\":()V\n   #76 = NameAndType        #46:#44       // MAX_NODE:I\n   #77 = NameAndType        #47:#44       // CHAR_NUM:I\n   #78 = NameAndType        #48:#49       // nxt:[[I\n   #79 = NameAndType        #50:#51       // flag:[Z\n   #80 = NameAndType        #52:#44       // trieIndex:I\n   #81 = Class              #118          // java/lang/System\n   #82 = NameAndType        #119:#120     // currentTimeMillis:()J\n   #83 = Utf8               java/io/BufferedReader\n   #84 = Utf8               java/io/InputStreamReader\n   #85 = Utf8               java/io/FileInputStream\n   #86 = NameAndType        #53:#121      // \"\u0026#x3C;init\u003e\":(Ljava/lang/String;)V\n   #87 = NameAndType        #53:#122      // \"\u0026#x3C;init\u003e\":(Ljava/io/InputStream;)V\n   #88 = NameAndType        #53:#123      // \"\u0026#x3C;init\u003e\":(Ljava/io/Reader;)V\n   #89 = Utf8               java/io/BufferedWriter\n   #90 = Utf8               java/io/OutputStreamWriter\n   #91 = Utf8               java/io/FileOutputStream\n   #92 = NameAndType        #53:#124      // \"\u0026#x3C;init\u003e\":(Ljava/io/OutputStream;)V\n   #93 = NameAndType        #53:#125      // \"\u0026#x3C;init\u003e\":(Ljava/io/Writer;)V\n   #94 = Utf8               me/fangfeng/filter/Trie\n   #95 = NameAndType        #126:#127     // readLine:()Ljava/lang/String;\n   #96 = Class              #128          // java/lang/Long\n   #97 = NameAndType        #129:#130     // parseLong:(Ljava/lang/String;)J\n   #98 = NameAndType        #57:#58       // insert:(J)V\n   #99 = NameAndType        #131:#54      // close:()V\n  #100 = NameAndType        #60:#61       // query:(J)Z\n  #101 = NameAndType        #132:#121     // write:(Ljava/lang/String;)V\n  #102 = NameAndType        #133:#54      // newLine:()V\n  #103 = NameAndType        #134:#54      // flush:()V\n  #104 = NameAndType        #135:#136     // out:Ljava/io/PrintStream;\n  #105 = Utf8               exec success! used %d ms\n  #106 = Utf8               java/lang/Object\n  #107 = NameAndType        #137:#138     // valueOf:(J)Ljava/lang/Long;\n  #108 = Class              #115          // java/lang/String\n  #109 = NameAndType        #139:#140     // format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n  #110 = Class              #141          // java/io/PrintStream\n  #111 = NameAndType        #142:#121     // println:(Ljava/lang/String;)V\n  #112 = NameAndType        #43:#44       // MAX_ITEM:I\n  #113 = NameAndType        #45:#44       // AVG_LENGTH:I\n  #114 = Utf8               [Ljava/lang/String;\n  #115 = Utf8               java/lang/String\n  #116 = Utf8               java/io/FileNotFoundException\n  #117 = Utf8               java/io/IOException\n  #118 = Utf8               java/lang/System\n  #119 = Utf8               currentTimeMillis\n  #120 = Utf8               ()J\n  #121 = Utf8               (Ljava/lang/String;)V\n  #122 = Utf8               (Ljava/io/InputStream;)V\n  #123 = Utf8               (Ljava/io/Reader;)V\n  #124 = Utf8               (Ljava/io/OutputStream;)V\n  #125 = Utf8               (Ljava/io/Writer;)V\n  #126 = Utf8               readLine\n  #127 = Utf8               ()Ljava/lang/String;\n  #128 = Utf8               java/lang/Long\n  #129 = Utf8               parseLong\n  #130 = Utf8               (Ljava/lang/String;)J\n  #131 = Utf8               close\n  #132 = Utf8               write\n  #133 = Utf8               newLine\n  #134 = Utf8               flush\n  #135 = Utf8               out\n  #136 = Utf8               Ljava/io/PrintStream;\n  #137 = Utf8               valueOf\n  #138 = Utf8               (J)Ljava/lang/Long;\n  #139 = Utf8               format\n  #140 = Utf8               (Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n  #141 = Utf8               java/io/PrintStream\n  #142 = Utf8               println\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e[1]: \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\"\u003ehttps://docs.oracle.com/javase/specs/jvms/se8/html/index.html\u003c/a\u003e \"Java Virtual Machine Specification\"\n[2]: \u003ca href=\"http://icyfenix.iteye.com/blog/1256329\"\u003ehttp://icyfenix.iteye.com/blog/1256329\u003c/a\u003e \"Java虚拟机规范（Java SE 7 中文版）\"\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e"},"buildId":"UUFWw6WeKk9dr4EqrBuOf","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/post" src="https://www.ffutop.com/blog/_next/static/UUFWw6WeKk9dr4EqrBuOf/pages/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/UUFWw6WeKk9dr4EqrBuOf/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.4197c692ff76bb557049.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.923c53dcd3ae2618e978.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>