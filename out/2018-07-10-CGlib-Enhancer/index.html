<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/xx4WXnl7odya2QE7dUtyW/pages/post.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/xx4WXnl7odya2QE7dUtyW/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.966200943f7869d2249d.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.2d2aeb3a0a1eb931bc6e.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.a70990b9.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.196d8b6b.chunk.css"/></head><body><div id="__next"><header><h1 class="title">ffutop</h1><div><a href="/blog/blog/">博客</a><a href="/blog/archives/">归档</a><a href="/blog/tags/">标签</a><a href="/blog/about/">关于</a></div></header><div><main class="main"><div><h2>前言</h2>
<p>此博文写作的目的:</p>
<ul>
<li>(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。</li>
<li>基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。</li>
</ul>
<p>&lt;!-- more --&gt;</p>
<h2>Enhancer</h2>
<p>从这篇不是官方但更胜于官方文档的 <a href="http://mydailyjava.blogspot.com/2013/11/cglib-missing-manual.html">CGlib Guide</a> 来看，它首先提到的第一个类就是 Enhancer。
其被用于创建 Java 代理类，相较于 Java 标准库的 Proxy 类，它<strong>特别地</strong>，能够支持那些没有实现接口的类的代理工作。</p>
<h3>Enhancer 简单示例展示</h3>
<p>针对现有的 SampleClass 类</p>
<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleClass</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">(String input)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World!"</span>;
    }
}</code></pre><p>使用 CGlib 的 Enhancer 对 SampleClass 进行增强，下列操作的目的在于将 test(String) 方法的返回值改写成 &quot;Hello cglib!&quot;</p>
<pre><code class="hljs"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFixedValue</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// new 一个 Enhancer 实例</span>
    Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();
    <span class="hljs-comment">// 声明使用的父类是 SampleClass</span>
    enhancer.setSuperclass(SampleClass.class);
    <span class="hljs-comment">// 设置回调方法 - 回调方法实现为 FixedValue (固定值) .</span>
    enhancer.setCallback(<span class="hljs-keyword">new</span> FixedValue() {
        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">loadObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello cglib!"</span>;
        }
    });
    <span class="hljs-comment">// 创建 SampleClass 的代理子类实例</span>
    SampleClass proxy = (SampleClass) enhancer.create();
    Assert.assertEquals(<span class="hljs-string">"Hello cglib!"</span>, proxy.test(<span class="hljs-keyword">null</span>));
}</code></pre><p>简单测试上述代码，可以了解到确实，代理类的 test(String) 方法的返回值被改写了。
那么，究竟这种操作是如何实现的？下面👇将进行具体的探究。</p>
<h2>调用链跟踪</h2>
<h3>高度抽象的时序图</h3>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ft4ifuo997j31jh0st42t.jpg" alt="Enhancer 调用链 时序图"></p>
<p><em>下列内容将根据时序图进行组织，根据调用编号(1,2,3...)进行展开</em></p>
<h3>Seq 1.</h3>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>{
    classOnly = <span class="hljs-keyword">false</span>;
    argumentTypes = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">return</span> createHelper();
}

<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Class[] argumentTypes, Object[] arguments)</span> </span>{
    classOnly = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span> (argumentTypes == <span class="hljs-keyword">null</span> || arguments == <span class="hljs-keyword">null</span> || argumentTypes.length != arguments.length) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Arguments must be non-null and of equal length"</span>);
    }
    <span class="hljs-keyword">this</span>.argumentTypes = argumentTypes;
    <span class="hljs-keyword">this</span>.arguments = arguments;
    <span class="hljs-keyword">return</span> createHelper();
}</code></pre><p>上述两个 <code>create(...)</code> 方法。结合上一节的使用示例，可以看到 <code>create()</code> 对应的<strong>无参构造</strong>。
存在无参构造，那么<strong>有参的构造方法</strong>显然也是应该被支持id。<code>create(Class[], Object[])</code> 正是为了这个目标而存在。通过提供参数类型数组和参数实例数组，可以唯一地定位及调用代理类的特定构造方法。</p>
<p>这个方法比较简单，只是将 Enhancer 作为一个数据内容的持有者，重置了新代理类将使用的构造函数参数内容，之后就直接调用了 <code>createHelper()</code> 。</p>
<h3>Seq 2.</h3>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">createHelper</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 对预声明的回调方法进行验证，要求 [多个回调就必须存在 CallbackFilter 作为调度器]</span>
    preValidate();
    <span class="hljs-comment">// 构建一个对这类增强操作唯一定位的 key</span>
    Object key = KEY_FACTORY.newInstance((superclass != <span class="hljs-keyword">null</span>) ? superclass.getName() : <span class="hljs-keyword">null</span>,
            ReflectUtils.getNames(interfaces),
            filter == ALL_ZERO ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">new</span> WeakCacheKey&lt;CallbackFilter&gt;(filter),
            callbackTypes,
            useFactory,
            interceptDuringConstruction,
            serialVersionUID);
    <span class="hljs-keyword">this</span>.currentKey = key;
    <span class="hljs-comment">// 调用父类通过的 create(...) 方法</span>
    Object result = <span class="hljs-keyword">super</span>.create(key);
    <span class="hljs-keyword">return</span> result;
}</code></pre><h3>Seq 3.</h3>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Object key)</span> </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 获取用于 加载 生成类 的 ClassLoader</span>
        ClassLoader loader = getClassLoader();
        <span class="hljs-comment">// 从缓存中加载 这个 ClassLoader 过去加载的相关数据</span>
        Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;
        ClassLoaderData data = cache.get(loader);
        <span class="hljs-comment">// 如果在 缓存 中找不到，则初始化构造关于这个 ClassLoader 的数据实例</span>
        <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// 同步</span>
            <span class="hljs-keyword">synchronized</span> (AbstractClassGenerator.class) {
                <span class="hljs-comment">// 进入同步块后的 再次确认，避免重复初始化构建</span>
                cache = CACHE;
                data = cache.get(loader);
                <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span>) {
                    <span class="hljs-comment">// 构建新的 缓存，拷贝原有的缓存集的内容</span>
                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache = <span class="hljs-keyword">new</span> WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;(cache);
                    <span class="hljs-comment">// 初始化 ClassLoaderData ，真正的构造操作</span>
                    data = <span class="hljs-keyword">new</span> ClassLoaderData(loader);
                    <span class="hljs-comment">// 添加到缓存中</span>
                    newCache.put(loader, data);
                    CACHE = newCache;
                }
            }
        }
        <span class="hljs-keyword">this</span>.key = key;
        Object obj = data.get(<span class="hljs-keyword">this</span>, getUseCache());
        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Class) {
            <span class="hljs-comment">// 初次实例化操作，就是 Class 利用反射来进行实例化</span>
            <span class="hljs-keyword">return</span> firstInstance((Class) obj);
        }
        <span class="hljs-comment">// 非初次实例化，则是从 ClassLoaderData 中得到的之前维护的内容</span>
        <span class="hljs-keyword">return</span> nextInstance(obj);
    } <span class="hljs-keyword">catch</span> (RuntimeException e) {
        <span class="hljs-keyword">throw</span> e;
    } <span class="hljs-keyword">catch</span> (Error e) {
        <span class="hljs-keyword">throw</span> e;
    } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CodeGenerationException(e);
    }
}</code></pre><p>这部分内容比较多，且是调用链比较重要的一环。<strong>Seq 4.</strong> 和 <strong>Seq 5.</strong> 将作为其子内容进行调用，但为了本博文的结构完整， <em>Seq 4. &amp; Seq5.</em> 的标题与 <em>Seq 3.</em> 标题同级</p>
<h3>Seq 4.</h3>
<p>首先应该认识到，每个被加载的 Class ，在 <code>equal</code> 的判断过程中，依据的是同一个 ClassLoader 加载的同一 Class 才被认为是相同的，否则即使 Class 是同一个，但仍会被认为是不同的(由不同的 ClassLoader 加载)。</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title">getClassLoader</span><span class="hljs-params">()</span> </span>{
    ClassLoader t = classLoader;
    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) {
        t = getDefaultClassLoader();
    }
    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) {
        t = getClass().getClassLoader();
    }
    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) {
        t = Thread.currentThread().getContextClassLoader();
    }
    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot determine classloader"</span>);
    }
    <span class="hljs-keyword">return</span> t;
}</code></pre><p>因此，在这部分中，首先需要确定的是由哪个 ClassLoader 进行加载的工作。<code>getClassLoader()</code> 的确定顺序是:</p>
<ol>
<li>具体实现类声明的 <strong>默认 ClassLoader</strong> 为第一优先级</li>
<li>加载当前类(这里是 Enhancer) 的 ClassLoader 为第二优先级</li>
<li><strong>当前线程上下文 ClassLoader</strong> 为第三优先级</li>
<li>抛出异常</li>
</ol>
<p>回到 <strong>Seq 3.</strong> 的内容，
下一步是对当前这个<strong>AbstractClassGenerator</strong> 维护的 CACHE 进行处理，如果在 CACHE 中能够得到以确定的 ClassLoader 为 Key 的键值对，则直接获取 ClassLoader 对应的值，否则将进行初始化构建一个新的 ClassLoaderData 作为这个 ClassLoader 的值。</p>
<h3>Seq 5.</h3>
<p>在构建 ClassLoaderData 的过程中，最重要的一步:</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassLoaderData</span><span class="hljs-params">(ClassLoader classLoader)</span> </span>{
    <span class="hljs-comment">// ClassLoader 不可为空</span>
    <span class="hljs-keyword">if</span> (classLoader == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"classLoader == null is not yet supported"</span>);
    }
    <span class="hljs-comment">// 构建 ClassLoader 的弱引用</span>
    <span class="hljs-keyword">this</span>.classLoader = <span class="hljs-keyword">new</span> WeakReference&lt;ClassLoader&gt;(classLoader);
    <span class="hljs-comment">// 写了个后置调用的函数，用于懒加载，只有调用了 load.apply(...) 才会构建 生成类</span>
    Function&lt;AbstractClassGenerator, Object&gt; load =
            <span class="hljs-keyword">new</span> Function&lt;AbstractClassGenerator, Object&gt;() {
                <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(AbstractClassGenerator gen)</span> </span>{
                    Class klass = gen.generate(ClassLoaderData.<span class="hljs-keyword">this</span>);
                    <span class="hljs-keyword">return</span> gen.wrapCachedClass(klass);
                }
            };
    generatedClasses = <span class="hljs-keyword">new</span> LoadingCache&lt;AbstractClassGenerator, Object, Object&gt;(GET_KEY, load);
}</code></pre><p>构建了一个 Function 实例，这个 Function 作为函数式接口，预定义执行的具体流程，但由上下文确定具体的调用时刻。</p>
<h3>Seq 6.</h3>
<p>在正确得到了 ClassLoader 对应的 ClassLoaderData 之后，ClassLoaderData 的 <code>get(...)</code> 方法将在特定的 ClassLoader 之下，进行更具体的加载新生成类的工作。
当然，这里的前提是新的生成类的字节码已经被构建:)</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(AbstractClassGenerator gen, <span class="hljs-keyword">boolean</span> useCache)</span> </span>{
    <span class="hljs-comment">// 标记为不使用缓存，直接构建 新的生成类</span>
    <span class="hljs-keyword">if</span> (!useCache) {
      <span class="hljs-keyword">return</span> gen.generate(ClassLoaderData.<span class="hljs-keyword">this</span>);
    }
    <span class="hljs-comment">// 使用缓冲的情况</span>
    <span class="hljs-keyword">else</span> {
      Object cachedValue = generatedClasses.get(gen);
      <span class="hljs-keyword">return</span> gen.unwrapCachedValue(cachedValue);
    }
}</code></pre><p>可以看到 <code>gen.generate(ClassLoaderData.this)</code> 这段代码在 <code>get(...)</code> 方法和上一小节 <code>ClassLoaderData(...)</code> 构造方法的 Function 函数式实例都出现了。</p>
<p>实际上，这也是触发 ClassLoader 来加载动态生成的新 Class 的唯一入口。</p>
<p><em>判断逻辑</em> 的 <code>else</code> 内容的唯一区别就在于其构建的是一个加载缓存，将真正触发 gen.generate(ClassLoaderData.this) 的逻辑延迟。(不过，最终也还是会进行调用的，:) 这是毋庸置疑的)。</p>
<h3>Seq 7.</h3>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">protected</span> Class <span class="hljs-title">generate</span><span class="hljs-params">(ClassLoaderData data)</span> </span>{
    Class gen;
    Object save = CURRENT.get();
    CURRENT.set(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 拿到用于加载生成类的 ClassLoader</span>
        ClassLoader classLoader = data.getClassLoader();
        <span class="hljs-keyword">if</span> (classLoader == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"ClassLoader is null while trying to define class "</span> +
                    getClassName() + <span class="hljs-string">". It seems that the loader has been expired from a weak reference somehow. "</span> +
                    <span class="hljs-string">"Please file an issue at cglib's issue tracker."</span>);
        }
        <span class="hljs-comment">// 构建一个合法的 生成类 的类名(非重复)</span>
        <span class="hljs-keyword">synchronized</span> (classLoader) {
          String name = generateClassName(data.getUniqueNamePredicate());
          data.reserveName(name);
          <span class="hljs-keyword">this</span>.setClassName(name);
        }
        <span class="hljs-keyword">if</span> (attemptLoad) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 尝试直接通过 ClassLoader 进行加载</span>
                gen = classLoader.loadClass(getClassName());
                <span class="hljs-keyword">return</span> gen;
            } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
                <span class="hljs-comment">// ignore</span>
            }
        }
        <span class="hljs-comment">// 策略下的生成类构建方法</span>
        <span class="hljs-keyword">byte</span>[] b = strategy.generate(<span class="hljs-keyword">this</span>);
        <span class="hljs-comment">// 通过解析字节码的形式获取 生成类的 className</span>
        String className = ClassNameReader.getClassName(<span class="hljs-keyword">new</span> ClassReader(b));
        ProtectionDomain protectionDomain = getProtectionDomain();
        <span class="hljs-keyword">synchronized</span> (classLoader) { <span class="hljs-comment">// just in case</span>
            <span class="hljs-comment">// 反射的形式加载 Class 类</span>
            <span class="hljs-keyword">if</span> (protectionDomain == <span class="hljs-keyword">null</span>) {
                gen = ReflectUtils.defineClass(className, b, classLoader);
            } <span class="hljs-keyword">else</span> {
                gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);
            }
        }
        <span class="hljs-keyword">return</span> gen;
    } <span class="hljs-keyword">catch</span> (RuntimeException e) {
        <span class="hljs-keyword">throw</span> e;
    } <span class="hljs-keyword">catch</span> (Error e) {
        <span class="hljs-keyword">throw</span> e;
    } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CodeGenerationException(e);
    } <span class="hljs-keyword">finally</span> {
        CURRENT.set(save);
    }
}</code></pre><p>这个方法，就是操作字节码，加载 Class 的核心调度方法。</p>
<p>可以看到 <code>generateClassName(...)</code> 方法将构建一个当前 ClassLoader 下唯一, 不重复的新的类名。</p>
<p><code>strategy.generate(this)</code> 将通过特定策略实现的形式生成新的字节码</p>
<p><code>ReflectUtils.defineClass(className, b, classLoader)</code> 将使用反射使得 ClassLoader 来加载这个新的生成类。</p>
<h3>Seq 8.</h3>
<p>生成新的不重复类名这部分不做过多陈述，可以简单进行了解，并熟悉 CGlib 默认的新类名的命名规则</p>
<pre><code class="hljs"><span class="hljs-comment">// DefaultNamePolicy</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getClassName</span><span class="hljs-params">(String prefix, String source, Object key, Predicate names)</span> </span>{
    <span class="hljs-keyword">if</span> (prefix == <span class="hljs-keyword">null</span>) {
        prefix = <span class="hljs-string">"net.sf.cglib.empty.Object"</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prefix.startsWith(<span class="hljs-string">"java"</span>)) {
        prefix = <span class="hljs-string">"$"</span> + prefix;
    }
    String base =
        prefix + <span class="hljs-string">"$$"</span> +
        source.substring(source.lastIndexOf(<span class="hljs-string">'.'</span>) + <span class="hljs-number">1</span>) +
        getTag() + <span class="hljs-string">"$$"</span> +
        Integer.toHexString(STRESS_HASH_CODE ? <span class="hljs-number">0</span> : key.hashCode());
    String attempt = base;
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">while</span> (names.evaluate(attempt))
        attempt = base + <span class="hljs-string">"_"</span> + index++;
    <span class="hljs-keyword">return</span> attempt;
}</code></pre><h3>Seq 9.</h3>
<pre><code class="hljs"><span class="hljs-comment">// 下列是 DefaultGeneratorStrategy 的实现</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] generate(ClassGenerator cg) <span class="hljs-keyword">throws</span> Exception {
    DebuggingClassWriter cw = getClassVisitor();
    transform(cg).generateClass(cw);
    <span class="hljs-keyword">return</span> transform(cw.toByteArray());
}</code></pre><h3>Seq 10.</h3>
<p>调用 <code>generateClass(ClassVisitor)</code> 将获得到新类的字节码。</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateClass</span><span class="hljs-params">(ClassVisitor v)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// 确定生成类的 父类</span>
    Class sc = (superclass == <span class="hljs-keyword">null</span>) ? Object.class : superclass;

    <span class="hljs-comment">// 父类标识符不可以为 final</span>
    <span class="hljs-keyword">if</span> (TypeUtils.isFinal(sc.getModifiers()))
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot subclass final class "</span> + sc.getName());
    <span class="hljs-comment">// 获取父类直接声明的构造方法</span>
    List constructors = <span class="hljs-keyword">new</span> ArrayList(Arrays.asList(sc.getDeclaredConstructors()));
    filterConstructors(sc, constructors);

    <span class="hljs-comment">// Order is very important: must add superclass, then</span>
    <span class="hljs-comment">// its superclass chain, then each interface and</span>
    <span class="hljs-comment">// its superinterfaces.</span>
    List actualMethods = <span class="hljs-keyword">new</span> ArrayList();
    List interfaceMethods = <span class="hljs-keyword">new</span> ArrayList();
    <span class="hljs-keyword">final</span> Set forcePublic = <span class="hljs-keyword">new</span> HashSet();
    <span class="hljs-comment">// 从父类中提取各种信息</span>
    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);

    List methods = CollectionUtils.transform(actualMethods, <span class="hljs-keyword">new</span> Transformer() {
        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">transform</span><span class="hljs-params">(Object value)</span> </span>{
            Method method = (Method)value;
            <span class="hljs-keyword">int</span> modifiers = Constants.ACC_FINAL
                | (method.getModifiers()
                   &amp; ~Constants.ACC_ABSTRACT
                   &amp; ~Constants.ACC_NATIVE
                   &amp; ~Constants.ACC_SYNCHRONIZED);
            <span class="hljs-keyword">if</span> (forcePublic.contains(MethodWrapper.create(method))) {
                modifiers = (modifiers &amp; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;
            }
            <span class="hljs-keyword">return</span> ReflectUtils.getMethodInfo(method, modifiers);
        }
    });

    ClassEmitter e = <span class="hljs-keyword">new</span> ClassEmitter(v);
    <span class="hljs-keyword">if</span> (currentData == <span class="hljs-keyword">null</span>) {
    e.begin_class(Constants.V1_2,
                  Constants.ACC_PUBLIC,
                  getClassName(),
                  Type.getType(sc),
                  (useFactory ?
                   TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :
                   TypeUtils.getTypes(interfaces)),
                  Constants.SOURCE_FILE);
    } <span class="hljs-keyword">else</span> {
        e.begin_class(Constants.V1_2,
                Constants.ACC_PUBLIC,
                getClassName(),
                <span class="hljs-keyword">null</span>,
                <span class="hljs-keyword">new</span> Type[]{FACTORY},
                Constants.SOURCE_FILE);
    }
    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());

    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, <span class="hljs-keyword">null</span>);
    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, <span class="hljs-keyword">null</span>);
    <span class="hljs-keyword">if</span> (!interceptDuringConstruction) {
        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, <span class="hljs-keyword">null</span>);
    }
    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, <span class="hljs-keyword">null</span>);
    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, <span class="hljs-keyword">null</span>);
    <span class="hljs-keyword">if</span> (serialVersionUID != <span class="hljs-keyword">null</span>) {
        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; callbackTypes.length; i++) {
        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], <span class="hljs-keyword">null</span>);
    }
    <span class="hljs-comment">// This is declared private to avoid "public field" pollution</span>
    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, <span class="hljs-keyword">null</span>);

    <span class="hljs-keyword">if</span> (currentData == <span class="hljs-keyword">null</span>) {
        emitMethods(e, methods, actualMethods);
        emitConstructors(e, constructorInfo);
    } <span class="hljs-keyword">else</span> {
        emitDefaultConstructor(e);
    }
    emitSetThreadCallbacks(e);
    emitSetStaticCallbacks(e);
    emitBindCallbacks(e);

    <span class="hljs-keyword">if</span> (useFactory || currentData != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">int</span>[] keys = getCallbackKeys();
        emitNewInstanceCallbacks(e);
        emitNewInstanceCallback(e);
        emitNewInstanceMultiarg(e, constructorInfo);
        emitGetCallback(e, keys);
        emitSetCallback(e, keys);
        emitGetCallbacks(e);
        emitSetCallbacks(e);
    }

    e.end_class();
}</code></pre><p><code>generateClass(...)</code> 执行的操作和 ASM 库的 ClassVisitor 访问 Class 文件结构的流程基本类似。</p>
<p>从上述截取到的部分代码，例如:</p>
<pre><code class="hljs">e.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), 
        (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)),
        Constants.SOURCE_FILE);</code></pre><pre><code class="hljs">e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, <span class="hljs-keyword">null</span>);</code></pre><p>都与 <code>classVisitor.visit(...)</code> 以及 <code>classVisitor.visitField(...)</code> 相当类似。而事实上，这些方法的具体实现也确实调用了 cv.visitXxx(...) 。
毕竟，作为 CGlib 唯一依赖的库，ASM 还是可以说是难以替代的(既然已经有了可用的轮子，又何必重复造呢?)</p>
<h2>构造的实例</h2>
<p>下面将展示通过 CGlib 生成的新的类(由于生成的是字节码，懒得再自行解析 ClassFile 的内容，所有直接用 <code>IDEA</code> 做了字节码的解析)</p>
<p><strong>首先展示的需要进行增强的 SampleClass 的具体内容</strong></p>
<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleClass</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">(String input)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World!"</span>;
    }
}</code></pre><p><strong>用于增强的简单代码</strong></p>
<pre><code class="hljs"><span class="hljs-comment">// 省略部分代码</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{
    Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();
    enhancer.setSuperclass(SampleClass.class);
    enhancer.setCallback(<span class="hljs-keyword">new</span> FixedValue() {
        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">loadObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello cglib!"</span>;
        }
    });
    SampleClass proxy = (SampleClass) enhancer.create();
}</code></pre><p><strong>动态生成的新的类</strong></p>
<pre><code class="hljs"><span class="hljs-comment">//</span>
<span class="hljs-comment">// Source code recreated from a .class file by IntelliJ IDEA</span>
<span class="hljs-comment">// (powered by Fernflower decompiler)</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">// 不用过多关注，只是 CGlib 保证生成类与原有的类一定属于同一包下，偷懒直接把 SampleClass 写在 CGlib 项目里了</span>
<span class="hljs-keyword">package</span> net.sf.cglib.samples;

<span class="hljs-keyword">import</span> net.sf.cglib.proxy.Callback;
<span class="hljs-keyword">import</span> net.sf.cglib.proxy.Factory;
<span class="hljs-keyword">import</span> net.sf.cglib.proxy.FixedValue;

<span class="hljs-comment">/**
 * 新的类名，通过 $$EnhancerByCGLIB 以及 $$7cd64b81(这个是哈希值) 对类名进行唯一区分 
 * 如果还是重复了，在动态生成前会进行类名的检测，并通过增加序号 "_&lt;index&gt;" 的形式进行进一步区分
 *
 * 可以看到新生成的类继承了 SampleClass 
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleClass</span>$$<span class="hljs-title">EnhancerByCGLIB</span>$$7<span class="hljs-title">cd64b81</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SampleClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> CGLIB$BOUND;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object CGLIB$FACTORY_DATA;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;

    <span class="hljs-comment">// 绑定一个在增强中声明的 Callback 实例</span>
    <span class="hljs-keyword">private</span> FixedValue CGLIB$CALLBACK_0;
    <span class="hljs-comment">// 绑定一个静态的回调调度实例</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object CGLIB$CALLBACK_FILTER;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> CGLIB$STATICHOOK1() {
        CGLIB$THREAD_CALLBACKS = <span class="hljs-keyword">new</span> ThreadLocal();
    }

    <span class="hljs-comment">/**
      * 对 test(String) 的方法的增强
      */</span> 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">test</span><span class="hljs-params">(String var1)</span> </span>{
        <span class="hljs-comment">// 在方法块中拿到 Callback 实例</span>
        FixedValue var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;
        <span class="hljs-comment">// 为空则尝试获取</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 == <span class="hljs-keyword">null</span>) {
            CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);
            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;
        }

        <span class="hljs-comment">// 触发回调实例的方法获得返回值</span>
        <span class="hljs-keyword">return</span> (String)var10000.loadObject();
    }

    <span class="hljs-comment">/**
      * 由于此次增强只声明了一个 Callback
      * 因此所有方法的增强都相同, 都是调用这个回调方法获取
      */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> </span>{
        FixedValue var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 == <span class="hljs-keyword">null</span>) {
            CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);
            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;
        }

        Object var2 = var10000.loadObject();
        <span class="hljs-comment">/**
         * 但是，此处会尝试强制转型
         * 同时在最终执行失败的时候直接抛出运行时异常
         * 毕竟上面增强的时候返回固定值 "Hello, cglib!"
         */</span>
        <span class="hljs-keyword">return</span> var2 == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">false</span> : (Boolean)var2;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        FixedValue var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 == <span class="hljs-keyword">null</span>) {
            CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);
            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;
        }

        <span class="hljs-keyword">return</span> (String)var10000.loadObject();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{
        FixedValue var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 == <span class="hljs-keyword">null</span>) {
            CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);
            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;
        }

        Object var1 = var10000.loadObject();
        <span class="hljs-keyword">return</span> var1 == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : ((Number)var1).intValue();
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>{
        FixedValue var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 == <span class="hljs-keyword">null</span>) {
            CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);
            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;
        }

        <span class="hljs-keyword">return</span> var10000.loadObject();
    }

    <span class="hljs-keyword">public</span> SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81() {
        CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {
        CGLIB$THREAD_CALLBACKS.set(var0);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {
        CGLIB$STATIC_CALLBACKS = var0;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> CGLIB$BIND_CALLBACKS(Object var0) {
        SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81 var1 = (SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81)var0;
        <span class="hljs-keyword">if</span> (!var1.CGLIB$BOUND) {
            var1.CGLIB$BOUND = <span class="hljs-keyword">true</span>;
            Object var10000 = CGLIB$THREAD_CALLBACKS.get();
            <span class="hljs-keyword">if</span> (var10000 == <span class="hljs-keyword">null</span>) {
                var10000 = CGLIB$STATIC_CALLBACKS;
                <span class="hljs-keyword">if</span> (CGLIB$STATIC_CALLBACKS == <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">return</span>;
                }
            }

            var1.CGLIB$CALLBACK_0 = (FixedValue)((Callback[])var10000)[<span class="hljs-number">0</span>];
        }

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(Callback[] var1)</span> </span>{
        CGLIB$SET_THREAD_CALLBACKS(var1);
        SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81 var10000 = <span class="hljs-keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81();
        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="hljs-keyword">null</span>);
        <span class="hljs-keyword">return</span> var10000;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(Callback var1)</span> </span>{
        CGLIB$SET_THREAD_CALLBACKS(<span class="hljs-keyword">new</span> Callback[]{var1});
        SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81 var10000 = <span class="hljs-keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81();
        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="hljs-keyword">null</span>);
        <span class="hljs-keyword">return</span> var10000;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(Class[] var1, Object[] var2, Callback[] var3)</span> </span>{
        CGLIB$SET_THREAD_CALLBACKS(var3);
        SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81 var10000 = <span class="hljs-keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cd64b81;
        <span class="hljs-keyword">switch</span>(var1.length) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            var10000.&lt;init&gt;();
            CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="hljs-keyword">null</span>);
            <span class="hljs-keyword">return</span> var10000;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Constructor not found"</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Callback <span class="hljs-title">getCallback</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span> </span>{
        CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);
        FixedValue var10000;
        <span class="hljs-keyword">switch</span>(var1) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            var10000 = <span class="hljs-keyword">null</span>;
        }

        <span class="hljs-keyword">return</span> var10000;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCallback</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1, Callback var2)</span> </span>{
        <span class="hljs-keyword">switch</span>(var1) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 = (FixedValue)var2;
        <span class="hljs-keyword">default</span>:
        }
    }

    <span class="hljs-keyword">public</span> Callback[] getCallbacks() {
        CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Callback[]{<span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0};
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCallbacks</span><span class="hljs-params">(Callback[] var1)</span> </span>{
        <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0 = (FixedValue)var1[<span class="hljs-number">0</span>];
    }

    <span class="hljs-keyword">static</span> {
        CGLIB$STATICHOOK1();
    }
}</code></pre><p>从上面的生成类可以看出来，CGlib 所进行的增强，是在不直接对原有的方法体内容进行改造的基础上(例如上面的 test(String) 方法，没有直接改写成 <code>return &quot;Hello, cglib!</code> 的形式)，对方法执行之前入参或者方法执行之后的返回值进行一定的处理。</p>
<p>主要使用的形式就是将回调实例与原有方法进行绑定，并通过调用回调方法来实现方法的增强。</p>
<pre><code class="hljs">__                    __                  
 / _| __ _ _ __   __ _ / _| ___ _ __   __ _ 
| |_ / _` | '_ \ / _` | |_ / _ \ '_ \ / _` |
|  _| (_| | | | | (_| |  _|  __/ | | | (_| |
|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |
                 |___/                |___/</code></pre></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/post","query":{"fullUrl":"/2018-07-10-CGlib-Enhancer"},"buildId":"xx4WXnl7odya2QE7dUtyW","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/post" src="https://www.ffutop.com/blog/_next/static/xx4WXnl7odya2QE7dUtyW/pages/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/xx4WXnl7odya2QE7dUtyW/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.966200943f7869d2249d.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.2d2aeb3a0a1eb931bc6e.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>