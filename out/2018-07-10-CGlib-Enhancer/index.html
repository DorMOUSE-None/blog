<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/wCGTolfdNbbPfjrHBGsfY/pages/post.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/wCGTolfdNbbPfjrHBGsfY/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.b54d8442e6b63c30cad4.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.a1d4ae30.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.f85dcf60.chunk.css"/></head><body><div id="__next"><header class="component-header"><h1 class="title">ffutop</h1><ul class="nav-items"><li><a href="/blog/index">博客</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/about">关于</a></li></ul></header><div><main class="main"><div class="page-post"><div><h2>前言</h2>
<p>此博文写作的目的: </p>
<ul>
<li>(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。</li>
<li>基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。</li>
</ul>
<h2>Enhancer</h2>
<p>从这篇不是官方但更胜于官方文档的 <a href="http://mydailyjava.blogspot.com/2013/11/cglib-missing-manual.html">CGlib Guide</a> 来看，它首先提到的第一个类就是 Enhancer。
其被用于创建 Java 代理类，相较于 Java 标准库的 Proxy 类，它<strong>特别地</strong>，能够支持那些没有实现接口的类的代理工作。</p>
<h3>Enhancer 简单示例展示</h3>
<p>针对现有的 SampleClass 类</p>
<pre><code class="language-java">public class SampleClass {
    public String test(String input) {
        return "Hello World!";
    }
}
</code></pre>
<p>使用 CGlib 的 Enhancer 对 SampleClass 进行增强，下列操作的目的在于将 test(String) 方法的返回值改写成 "Hello cglib!"</p>
<pre><code class="language-java">@Test
public void testFixedValue() {
    // new 一个 Enhancer 实例
    Enhancer enhancer = new Enhancer();
    // 声明使用的父类是 SampleClass
    enhancer.setSuperclass(SampleClass.class);
    // 设置回调方法 - 回调方法实现为 FixedValue (固定值) .
    enhancer.setCallback(new FixedValue() {
        public Object loadObject() throws Exception {
            return "Hello cglib!";
        }
    });
    // 创建 SampleClass 的代理子类实例
    SampleClass proxy = (SampleClass) enhancer.create();
    Assert.assertEquals("Hello cglib!", proxy.test(null));
}
</code></pre>
<p>简单测试上述代码，可以了解到确实，代理类的 test(String) 方法的返回值被改写了。
那么，究竟这种操作是如何实现的？下面👇将进行具体的探究。</p>
<h2>调用链跟踪</h2>
<h3>高度抽象的时序图</h3>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ft4ifuo997j31jh0st42t.jpg" alt="Enhancer 调用链 时序图"></p>
<p><em>下列内容将根据时序图进行组织，根据调用编号(1,2,3...)进行展开</em></p>
<h3>Seq 1.</h3>
<pre><code class="language-java">public Object create() {
    classOnly = false;
    argumentTypes = null;
    return createHelper();
}

public Object create(Class[] argumentTypes, Object[] arguments) {
    classOnly = false;
    if (argumentTypes == null || arguments == null || argumentTypes.length != arguments.length) {
        throw new IllegalArgumentException("Arguments must be non-null and of equal length");
    }
    this.argumentTypes = argumentTypes;
    this.arguments = arguments;
    return createHelper();
}
</code></pre>
<p>上述两个 <code>create(...)</code> 方法。结合上一节的使用示例，可以看到 <code>create()</code> 对应的<strong>无参构造</strong>。
存在无参构造，那么<strong>有参的构造方法</strong>显然也是应该被支持id。<code>create(Class[], Object[])</code> 正是为了这个目标而存在。通过提供参数类型数组和参数实例数组，可以唯一地定位及调用代理类的特定构造方法。</p>
<p>这个方法比较简单，只是将 Enhancer 作为一个数据内容的持有者，重置了新代理类将使用的构造函数参数内容，之后就直接调用了 <code>createHelper()</code> 。</p>
<h3>Seq 2.</h3>
<pre><code class="language-java">private Object createHelper() {
    // 对预声明的回调方法进行验证，要求 [多个回调就必须存在 CallbackFilter 作为调度器]
    preValidate();
    // 构建一个对这类增强操作唯一定位的 key
    Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,
            ReflectUtils.getNames(interfaces),
            filter == ALL_ZERO ? null : new WeakCacheKey&#x3C;CallbackFilter>(filter),
            callbackTypes,
            useFactory,
            interceptDuringConstruction,
            serialVersionUID);
    this.currentKey = key;
    // 调用父类通过的 create(...) 方法
    Object result = super.create(key);
    return result;
}
</code></pre>
<h3>Seq 3.</h3>
<pre><code class="language-java">protected Object create(Object key) {
    try {
        // 获取用于 加载 生成类 的 ClassLoader
        ClassLoader loader = getClassLoader();
        // 从缓存中加载 这个 ClassLoader 过去加载的相关数据
        Map&#x3C;ClassLoader, ClassLoaderData> cache = CACHE;
        ClassLoaderData data = cache.get(loader);
        // 如果在 缓存 中找不到，则初始化构造关于这个 ClassLoader 的数据实例
        if (data == null) {
            // 同步
            synchronized (AbstractClassGenerator.class) {
                // 进入同步块后的 再次确认，避免重复初始化构建
                cache = CACHE;
                data = cache.get(loader);
                if (data == null) {
                    // 构建新的 缓存，拷贝原有的缓存集的内容
                    Map&#x3C;ClassLoader, ClassLoaderData> newCache = new WeakHashMap&#x3C;ClassLoader, ClassLoaderData>(cache);
                    // 初始化 ClassLoaderData ，真正的构造操作
                    data = new ClassLoaderData(loader);
                    // 添加到缓存中
                    newCache.put(loader, data);
                    CACHE = newCache;
                }
            }
        }
        this.key = key;
        Object obj = data.get(this, getUseCache());
        if (obj instanceof Class) {
            // 初次实例化操作，就是 Class 利用反射来进行实例化
            return firstInstance((Class) obj);
        }
        // 非初次实例化，则是从 ClassLoaderData 中得到的之前维护的内容
        return nextInstance(obj);
    } catch (RuntimeException e) {
        throw e;
    } catch (Error e) {
        throw e;
    } catch (Exception e) {
        throw new CodeGenerationException(e);
    }
}
</code></pre>
<p>这部分内容比较多，且是调用链比较重要的一环。<strong>Seq 4.</strong> 和 <strong>Seq 5.</strong> 将作为其子内容进行调用，但为了本博文的结构完整， <em>Seq 4. &#x26; Seq5.</em> 的标题与 <em>Seq 3.</em> 标题同级</p>
<h3>Seq 4.</h3>
<p>首先应该认识到，每个被加载的 Class ，在 <code>equal</code> 的判断过程中，依据的是同一个 ClassLoader 加载的同一 Class 才被认为是相同的，否则即使 Class 是同一个，但仍会被认为是不同的(由不同的 ClassLoader 加载)。</p>
<pre><code class="language-java">public ClassLoader getClassLoader() {
    ClassLoader t = classLoader;
    if (t == null) {
        t = getDefaultClassLoader();
    }
    if (t == null) {
        t = getClass().getClassLoader();
    }
    if (t == null) {
        t = Thread.currentThread().getContextClassLoader();
    }
    if (t == null) {
        throw new IllegalStateException("Cannot determine classloader");
    }
    return t;
}
</code></pre>
<p>因此，在这部分中，首先需要确定的是由哪个 ClassLoader 进行加载的工作。<code>getClassLoader()</code> 的确定顺序是:</p>
<ol>
<li>具体实现类声明的 <strong>默认 ClassLoader</strong> 为第一优先级</li>
<li>加载当前类(这里是 Enhancer) 的 ClassLoader 为第二优先级</li>
<li><strong>当前线程上下文 ClassLoader</strong> 为第三优先级</li>
<li>抛出异常</li>
</ol>
<p>回到 <strong>Seq 3.</strong> 的内容，
下一步是对当前这个<strong>AbstractClassGenerator</strong> 维护的 CACHE 进行处理，如果在 CACHE 中能够得到以确定的 ClassLoader 为 Key 的键值对，则直接获取 ClassLoader 对应的值，否则将进行初始化构建一个新的 ClassLoaderData 作为这个 ClassLoader 的值。</p>
<h3>Seq 5.</h3>
<p>在构建 ClassLoaderData 的过程中，最重要的一步:</p>
<pre><code class="language-java">public ClassLoaderData(ClassLoader classLoader) {
    // ClassLoader 不可为空
    if (classLoader == null) {
        throw new IllegalArgumentException("classLoader == null is not yet supported");
    }
    // 构建 ClassLoader 的弱引用
    this.classLoader = new WeakReference&#x3C;ClassLoader>(classLoader);
    // 写了个后置调用的函数，用于懒加载，只有调用了 load.apply(...) 才会构建 生成类
    Function&#x3C;AbstractClassGenerator, Object> load =
            new Function&#x3C;AbstractClassGenerator, Object>() {
                public Object apply(AbstractClassGenerator gen) {
                    Class klass = gen.generate(ClassLoaderData.this);
                    return gen.wrapCachedClass(klass);
                }
            };
    generatedClasses = new LoadingCache&#x3C;AbstractClassGenerator, Object, Object>(GET_KEY, load);
}
</code></pre>
<p>构建了一个 Function 实例，这个 Function 作为函数式接口，预定义执行的具体流程，但由上下文确定具体的调用时刻。</p>
<h3>Seq 6.</h3>
<p>在正确得到了 ClassLoader 对应的 ClassLoaderData 之后，ClassLoaderData 的 <code>get(...)</code> 方法将在特定的 ClassLoader 之下，进行更具体的加载新生成类的工作。
当然，这里的前提是新的生成类的字节码已经被构建:)</p>
<pre><code class="language-java">public Object get(AbstractClassGenerator gen, boolean useCache) {
    // 标记为不使用缓存，直接构建 新的生成类
    if (!useCache) {
      return gen.generate(ClassLoaderData.this);
    }
    // 使用缓冲的情况
    else {
      Object cachedValue = generatedClasses.get(gen);
      return gen.unwrapCachedValue(cachedValue);
    }
}
</code></pre>
<p>可以看到 <code>gen.generate(ClassLoaderData.this)</code> 这段代码在 <code>get(...)</code> 方法和上一小节 <code>ClassLoaderData(...)</code> 构造方法的 Function 函数式实例都出现了。</p>
<p>实际上，这也是触发 ClassLoader 来加载动态生成的新 Class 的唯一入口。</p>
<p><em>判断逻辑</em> 的 <code>else</code> 内容的唯一区别就在于其构建的是一个加载缓存，将真正触发 gen.generate(ClassLoaderData.this) 的逻辑延迟。(不过，最终也还是会进行调用的，:) 这是毋庸置疑的)。</p>
<h3>Seq 7.</h3>
<pre><code class="language-java">protected Class generate(ClassLoaderData data) {
    Class gen;
    Object save = CURRENT.get();
    CURRENT.set(this);
    try {
        // 拿到用于加载生成类的 ClassLoader
        ClassLoader classLoader = data.getClassLoader();
        if (classLoader == null) {
            throw new IllegalStateException("ClassLoader is null while trying to define class " +
                    getClassName() + ". It seems that the loader has been expired from a weak reference somehow. " +
                    "Please file an issue at cglib's issue tracker.");
        }
        // 构建一个合法的 生成类 的类名(非重复)
        synchronized (classLoader) {
          String name = generateClassName(data.getUniqueNamePredicate());
          data.reserveName(name);
          this.setClassName(name);
        }
        if (attemptLoad) {
            try {
                // 尝试直接通过 ClassLoader 进行加载
                gen = classLoader.loadClass(getClassName());
                return gen;
            } catch (ClassNotFoundException e) {
                // ignore
            }
        }
        // 策略下的生成类构建方法
        byte[] b = strategy.generate(this);
        // 通过解析字节码的形式获取 生成类的 className
        String className = ClassNameReader.getClassName(new ClassReader(b));
        ProtectionDomain protectionDomain = getProtectionDomain();
        synchronized (classLoader) { // just in case
            // 反射的形式加载 Class 类
            if (protectionDomain == null) {
                gen = ReflectUtils.defineClass(className, b, classLoader);
            } else {
                gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);
            }
        }
        return gen;
    } catch (RuntimeException e) {
        throw e;
    } catch (Error e) {
        throw e;
    } catch (Exception e) {
        throw new CodeGenerationException(e);
    } finally {
        CURRENT.set(save);
    }
}
</code></pre>
<p>这个方法，就是操作字节码，加载 Class 的核心调度方法。</p>
<p>可以看到 <code>generateClassName(...)</code> 方法将构建一个当前 ClassLoader 下唯一, 不重复的新的类名。</p>
<p><code>strategy.generate(this)</code> 将通过特定策略实现的形式生成新的字节码</p>
<p><code>ReflectUtils.defineClass(className, b, classLoader)</code> 将使用反射使得 ClassLoader 来加载这个新的生成类。</p>
<h3>Seq 8.</h3>
<p>生成新的不重复类名这部分不做过多陈述，可以简单进行了解，并熟悉 CGlib 默认的新类名的命名规则</p>
<pre><code class="language-java">// DefaultNamePolicy
public String getClassName(String prefix, String source, Object key, Predicate names) {
    if (prefix == null) {
        prefix = "net.sf.cglib.empty.Object";
    } else if (prefix.startsWith("java")) {
        prefix = "$" + prefix;
    }
    String base =
        prefix + "$$" +
        source.substring(source.lastIndexOf('.') + 1) +
        getTag() + "$$" +
        Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());
    String attempt = base;
    int index = 2;
    while (names.evaluate(attempt))
        attempt = base + "_" + index++;
    return attempt;
}
</code></pre>
<h3>Seq 9.</h3>
<pre><code class="language-java">// 下列是 DefaultGeneratorStrategy 的实现
public byte[] generate(ClassGenerator cg) throws Exception {
    DebuggingClassWriter cw = getClassVisitor();
    transform(cg).generateClass(cw);
    return transform(cw.toByteArray());
}
</code></pre>
<h3>Seq 10.</h3>
<p>调用 <code>generateClass(ClassVisitor)</code> 将获得到新类的字节码。</p>
<pre><code class="language-java">public void generateClass(ClassVisitor v) throws Exception {
    // 确定生成类的 父类
    Class sc = (superclass == null) ? Object.class : superclass;

    // 父类标识符不可以为 final
    if (TypeUtils.isFinal(sc.getModifiers()))
        throw new IllegalArgumentException("Cannot subclass final class " + sc.getName());
    // 获取父类直接声明的构造方法
    List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));
    filterConstructors(sc, constructors);

    // Order is very important: must add superclass, then
    // its superclass chain, then each interface and
    // its superinterfaces.
    List actualMethods = new ArrayList();
    List interfaceMethods = new ArrayList();
    final Set forcePublic = new HashSet();
    // 从父类中提取各种信息
    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);

    List methods = CollectionUtils.transform(actualMethods, new Transformer() {
        public Object transform(Object value) {
            Method method = (Method)value;
            int modifiers = Constants.ACC_FINAL
                | (method.getModifiers()
                   &#x26; ~Constants.ACC_ABSTRACT
                   &#x26; ~Constants.ACC_NATIVE
                   &#x26; ~Constants.ACC_SYNCHRONIZED);
            if (forcePublic.contains(MethodWrapper.create(method))) {
                modifiers = (modifiers &#x26; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;
            }
            return ReflectUtils.getMethodInfo(method, modifiers);
        }
    });

    ClassEmitter e = new ClassEmitter(v);
    if (currentData == null) {
    e.begin_class(Constants.V1_2,
                  Constants.ACC_PUBLIC,
                  getClassName(),
                  Type.getType(sc),
                  (useFactory ?
                   TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :
                   TypeUtils.getTypes(interfaces)),
                  Constants.SOURCE_FILE);
    } else {
        e.begin_class(Constants.V1_2,
                Constants.ACC_PUBLIC,
                getClassName(),
                null,
                new Type[]{FACTORY},
                Constants.SOURCE_FILE);
    }
    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());

    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);
    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, null);
    if (!interceptDuringConstruction) {
        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null);
    }
    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);
    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);
    if (serialVersionUID != null) {
        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);
    }

    for (int i = 0; i &#x3C; callbackTypes.length; i++) {
        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null);
    }
    // This is declared private to avoid "public field" pollution
    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, null);

    if (currentData == null) {
        emitMethods(e, methods, actualMethods);
        emitConstructors(e, constructorInfo);
    } else {
        emitDefaultConstructor(e);
    }
    emitSetThreadCallbacks(e);
    emitSetStaticCallbacks(e);
    emitBindCallbacks(e);

    if (useFactory || currentData != null) {
        int[] keys = getCallbackKeys();
        emitNewInstanceCallbacks(e);
        emitNewInstanceCallback(e);
        emitNewInstanceMultiarg(e, constructorInfo);
        emitGetCallback(e, keys);
        emitSetCallback(e, keys);
        emitGetCallbacks(e);
        emitSetCallbacks(e);
    }

    e.end_class();
}
</code></pre>
<p><code>generateClass(...)</code> 执行的操作和 ASM 库的 ClassVisitor 访问 Class 文件结构的流程基本类似。</p>
<p>从上述截取到的部分代码，例如:</p>
<pre><code class="language-java">e.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), 
        (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)),
        Constants.SOURCE_FILE);
</code></pre>
<pre><code class="language-java">e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);
</code></pre>
<p>都与 <code>classVisitor.visit(...)</code> 以及 <code>classVisitor.visitField(...)</code> 相当类似。而事实上，这些方法的具体实现也确实调用了 cv.visitXxx(...) 。
毕竟，作为 CGlib 唯一依赖的库，ASM 还是可以说是难以替代的(既然已经有了可用的轮子，又何必重复造呢?)</p>
<h2>构造的实例</h2>
<p>下面将展示通过 CGlib 生成的新的类(由于生成的是字节码，懒得再自行解析 ClassFile 的内容，所有直接用 <code>IDEA</code> 做了字节码的解析)</p>
<p><strong>首先展示的需要进行增强的 SampleClass 的具体内容</strong></p>
<pre><code class="language-java">public class SampleClass {
    public String test(String input) {
        return "Hello World!";
    }
}
</code></pre>
<p><strong>用于增强的简单代码</strong></p>
<pre><code class="language-java">// 省略部分代码
public static void main(String... args) {
    Enhancer enhancer = new Enhancer();
    enhancer.setSuperclass(SampleClass.class);
    enhancer.setCallback(new FixedValue() {
        public Object loadObject() throws Exception {
            return "Hello cglib!";
        }
    });
    SampleClass proxy = (SampleClass) enhancer.create();
}
</code></pre>
<p><strong>动态生成的新的类</strong></p>
<pre><code class="language-java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

// 不用过多关注，只是 CGlib 保证生成类与原有的类一定属于同一包下，偷懒直接把 SampleClass 写在 CGlib 项目里了
package net.sf.cglib.samples;

import net.sf.cglib.proxy.Callback;
import net.sf.cglib.proxy.Factory;
import net.sf.cglib.proxy.FixedValue;

/**
 * 新的类名，通过 $$EnhancerByCGLIB 以及 $$7cd64b81(这个是哈希值) 对类名进行唯一区分 
 * 如果还是重复了，在动态生成前会进行类名的检测，并通过增加序号 "_&#x3C;index>" 的形式进行进一步区分
 *
 * 可以看到新生成的类继承了 SampleClass 
 */
public class SampleClass$$EnhancerByCGLIB$$7cd64b81 extends SampleClass implements Factory {
    private boolean CGLIB$BOUND;
    public static Object CGLIB$FACTORY_DATA;
    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;
    private static final Callback[] CGLIB$STATIC_CALLBACKS;

    // 绑定一个在增强中声明的 Callback 实例
    private FixedValue CGLIB$CALLBACK_0;
    // 绑定一个静态的回调调度实例
    private static Object CGLIB$CALLBACK_FILTER;

    static void CGLIB$STATICHOOK1() {
        CGLIB$THREAD_CALLBACKS = new ThreadLocal();
    }

    /**
      * 对 test(String) 的方法的增强
      */ 
    public final String test(String var1) {
        // 在方法块中拿到 Callback 实例
        FixedValue var10000 = this.CGLIB$CALLBACK_0;
        // 为空则尝试获取
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        // 触发回调实例的方法获得返回值
        return (String)var10000.loadObject();
    }

    /**
      * 由于此次增强只声明了一个 Callback
      * 因此所有方法的增强都相同, 都是调用这个回调方法获取
      */
    public final boolean equals(Object var1) {
        FixedValue var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        Object var2 = var10000.loadObject();
        /**
         * 但是，此处会尝试强制转型
         * 同时在最终执行失败的时候直接抛出运行时异常
         * 毕竟上面增强的时候返回固定值 "Hello, cglib!"
         */
        return var2 == null ? false : (Boolean)var2;
    }

    public final String toString() {
        FixedValue var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        return (String)var10000.loadObject();
    }

    public final int hashCode() {
        FixedValue var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        Object var1 = var10000.loadObject();
        return var1 == null ? 0 : ((Number)var1).intValue();
    }

    protected final Object clone() throws CloneNotSupportedException {
        FixedValue var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        return var10000.loadObject();
    }

    public SampleClass$$EnhancerByCGLIB$$7cd64b81() {
        CGLIB$BIND_CALLBACKS(this);
    }

    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {
        CGLIB$THREAD_CALLBACKS.set(var0);
    }

    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {
        CGLIB$STATIC_CALLBACKS = var0;
    }

    private static final void CGLIB$BIND_CALLBACKS(Object var0) {
        SampleClass$$EnhancerByCGLIB$$7cd64b81 var1 = (SampleClass$$EnhancerByCGLIB$$7cd64b81)var0;
        if (!var1.CGLIB$BOUND) {
            var1.CGLIB$BOUND = true;
            Object var10000 = CGLIB$THREAD_CALLBACKS.get();
            if (var10000 == null) {
                var10000 = CGLIB$STATIC_CALLBACKS;
                if (CGLIB$STATIC_CALLBACKS == null) {
                    return;
                }
            }

            var1.CGLIB$CALLBACK_0 = (FixedValue)((Callback[])var10000)[0];
        }

    }

    public Object newInstance(Callback[] var1) {
        CGLIB$SET_THREAD_CALLBACKS(var1);
        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81();
        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
        return var10000;
    }

    public Object newInstance(Callback var1) {
        CGLIB$SET_THREAD_CALLBACKS(new Callback[]{var1});
        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81();
        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
        return var10000;
    }

    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {
        CGLIB$SET_THREAD_CALLBACKS(var3);
        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81;
        switch(var1.length) {
        case 0:
            var10000.&#x3C;init>();
            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
            return var10000;
        default:
            throw new IllegalArgumentException("Constructor not found");
        }
    }

    public Callback getCallback(int var1) {
        CGLIB$BIND_CALLBACKS(this);
        FixedValue var10000;
        switch(var1) {
        case 0:
            var10000 = this.CGLIB$CALLBACK_0;
            break;
        default:
            var10000 = null;
        }

        return var10000;
    }

    public void setCallback(int var1, Callback var2) {
        switch(var1) {
        case 0:
            this.CGLIB$CALLBACK_0 = (FixedValue)var2;
        default:
        }
    }

    public Callback[] getCallbacks() {
        CGLIB$BIND_CALLBACKS(this);
        return new Callback[]{this.CGLIB$CALLBACK_0};
    }

    public void setCallbacks(Callback[] var1) {
        this.CGLIB$CALLBACK_0 = (FixedValue)var1[0];
    }

    static {
        CGLIB$STATICHOOK1();
    }
}
</code></pre>
<p>从上面的生成类可以看出来，CGlib 所进行的增强，是在不直接对原有的方法体内容进行改造的基础上(例如上面的 test(String) 方法，没有直接改写成 <code>return "Hello, cglib!</code> 的形式)，对方法执行之前入参或者方法执行之后的返回值进行一定的处理。</p>
<p>主要使用的形式就是将回调实例与原有方法进行绑定，并通过调用回调方法来实现方法的增强。</p>
<pre><code class="language-plain">  __                    __                  
 / _| __ _ _ __   __ _ / _| ___ _ __   __ _ 
| |_ / _` | '_ \ / _` | |_ / _ \ '_ \ / _` |
|  _| (_| | | | | (_| |  _|  __/ | | | (_| |
|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |
                 |___/                |___/ 
</code></pre></div></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/post","query":{"content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e此博文写作的目的: \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。\u003c/li\u003e\n\u003cli\u003e基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eEnhancer\u003c/h2\u003e\n\u003cp\u003e从这篇不是官方但更胜于官方文档的 \u003ca href=\"http://mydailyjava.blogspot.com/2013/11/cglib-missing-manual.html\"\u003eCGlib Guide\u003c/a\u003e 来看，它首先提到的第一个类就是 Enhancer。\n其被用于创建 Java 代理类，相较于 Java 标准库的 Proxy 类，它\u003cstrong\u003e特别地\u003c/strong\u003e，能够支持那些没有实现接口的类的代理工作。\u003c/p\u003e\n\u003ch3\u003eEnhancer 简单示例展示\u003c/h3\u003e\n\u003cp\u003e针对现有的 SampleClass 类\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SampleClass {\n    public String test(String input) {\n        return \"Hello World!\";\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用 CGlib 的 Enhancer 对 SampleClass 进行增强，下列操作的目的在于将 test(String) 方法的返回值改写成 \"Hello cglib!\"\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Test\npublic void testFixedValue() {\n    // new 一个 Enhancer 实例\n    Enhancer enhancer = new Enhancer();\n    // 声明使用的父类是 SampleClass\n    enhancer.setSuperclass(SampleClass.class);\n    // 设置回调方法 - 回调方法实现为 FixedValue (固定值) .\n    enhancer.setCallback(new FixedValue() {\n        public Object loadObject() throws Exception {\n            return \"Hello cglib!\";\n        }\n    });\n    // 创建 SampleClass 的代理子类实例\n    SampleClass proxy = (SampleClass) enhancer.create();\n    Assert.assertEquals(\"Hello cglib!\", proxy.test(null));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e简单测试上述代码，可以了解到确实，代理类的 test(String) 方法的返回值被改写了。\n那么，究竟这种操作是如何实现的？下面👇将进行具体的探究。\u003c/p\u003e\n\u003ch2\u003e调用链跟踪\u003c/h2\u003e\n\u003ch3\u003e高度抽象的时序图\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1ft4ifuo997j31jh0st42t.jpg\" alt=\"Enhancer 调用链 时序图\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e下列内容将根据时序图进行组织，根据调用编号(1,2,3...)进行展开\u003c/em\u003e\u003c/p\u003e\n\u003ch3\u003eSeq 1.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Object create() {\n    classOnly = false;\n    argumentTypes = null;\n    return createHelper();\n}\n\npublic Object create(Class[] argumentTypes, Object[] arguments) {\n    classOnly = false;\n    if (argumentTypes == null || arguments == null || argumentTypes.length != arguments.length) {\n        throw new IllegalArgumentException(\"Arguments must be non-null and of equal length\");\n    }\n    this.argumentTypes = argumentTypes;\n    this.arguments = arguments;\n    return createHelper();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述两个 \u003ccode\u003ecreate(...)\u003c/code\u003e 方法。结合上一节的使用示例，可以看到 \u003ccode\u003ecreate()\u003c/code\u003e 对应的\u003cstrong\u003e无参构造\u003c/strong\u003e。\n存在无参构造，那么\u003cstrong\u003e有参的构造方法\u003c/strong\u003e显然也是应该被支持id。\u003ccode\u003ecreate(Class[], Object[])\u003c/code\u003e 正是为了这个目标而存在。通过提供参数类型数组和参数实例数组，可以唯一地定位及调用代理类的特定构造方法。\u003c/p\u003e\n\u003cp\u003e这个方法比较简单，只是将 Enhancer 作为一个数据内容的持有者，重置了新代理类将使用的构造函数参数内容，之后就直接调用了 \u003ccode\u003ecreateHelper()\u003c/code\u003e 。\u003c/p\u003e\n\u003ch3\u003eSeq 2.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Object createHelper() {\n    // 对预声明的回调方法进行验证，要求 [多个回调就必须存在 CallbackFilter 作为调度器]\n    preValidate();\n    // 构建一个对这类增强操作唯一定位的 key\n    Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,\n            ReflectUtils.getNames(interfaces),\n            filter == ALL_ZERO ? null : new WeakCacheKey\u0026#x3C;CallbackFilter\u003e(filter),\n            callbackTypes,\n            useFactory,\n            interceptDuringConstruction,\n            serialVersionUID);\n    this.currentKey = key;\n    // 调用父类通过的 create(...) 方法\n    Object result = super.create(key);\n    return result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSeq 3.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprotected Object create(Object key) {\n    try {\n        // 获取用于 加载 生成类 的 ClassLoader\n        ClassLoader loader = getClassLoader();\n        // 从缓存中加载 这个 ClassLoader 过去加载的相关数据\n        Map\u0026#x3C;ClassLoader, ClassLoaderData\u003e cache = CACHE;\n        ClassLoaderData data = cache.get(loader);\n        // 如果在 缓存 中找不到，则初始化构造关于这个 ClassLoader 的数据实例\n        if (data == null) {\n            // 同步\n            synchronized (AbstractClassGenerator.class) {\n                // 进入同步块后的 再次确认，避免重复初始化构建\n                cache = CACHE;\n                data = cache.get(loader);\n                if (data == null) {\n                    // 构建新的 缓存，拷贝原有的缓存集的内容\n                    Map\u0026#x3C;ClassLoader, ClassLoaderData\u003e newCache = new WeakHashMap\u0026#x3C;ClassLoader, ClassLoaderData\u003e(cache);\n                    // 初始化 ClassLoaderData ，真正的构造操作\n                    data = new ClassLoaderData(loader);\n                    // 添加到缓存中\n                    newCache.put(loader, data);\n                    CACHE = newCache;\n                }\n            }\n        }\n        this.key = key;\n        Object obj = data.get(this, getUseCache());\n        if (obj instanceof Class) {\n            // 初次实例化操作，就是 Class 利用反射来进行实例化\n            return firstInstance((Class) obj);\n        }\n        // 非初次实例化，则是从 ClassLoaderData 中得到的之前维护的内容\n        return nextInstance(obj);\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (Error e) {\n        throw e;\n    } catch (Exception e) {\n        throw new CodeGenerationException(e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这部分内容比较多，且是调用链比较重要的一环。\u003cstrong\u003eSeq 4.\u003c/strong\u003e 和 \u003cstrong\u003eSeq 5.\u003c/strong\u003e 将作为其子内容进行调用，但为了本博文的结构完整， \u003cem\u003eSeq 4. \u0026#x26; Seq5.\u003c/em\u003e 的标题与 \u003cem\u003eSeq 3.\u003c/em\u003e 标题同级\u003c/p\u003e\n\u003ch3\u003eSeq 4.\u003c/h3\u003e\n\u003cp\u003e首先应该认识到，每个被加载的 Class ，在 \u003ccode\u003eequal\u003c/code\u003e 的判断过程中，依据的是同一个 ClassLoader 加载的同一 Class 才被认为是相同的，否则即使 Class 是同一个，但仍会被认为是不同的(由不同的 ClassLoader 加载)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic ClassLoader getClassLoader() {\n    ClassLoader t = classLoader;\n    if (t == null) {\n        t = getDefaultClassLoader();\n    }\n    if (t == null) {\n        t = getClass().getClassLoader();\n    }\n    if (t == null) {\n        t = Thread.currentThread().getContextClassLoader();\n    }\n    if (t == null) {\n        throw new IllegalStateException(\"Cannot determine classloader\");\n    }\n    return t;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因此，在这部分中，首先需要确定的是由哪个 ClassLoader 进行加载的工作。\u003ccode\u003egetClassLoader()\u003c/code\u003e 的确定顺序是:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e具体实现类声明的 \u003cstrong\u003e默认 ClassLoader\u003c/strong\u003e 为第一优先级\u003c/li\u003e\n\u003cli\u003e加载当前类(这里是 Enhancer) 的 ClassLoader 为第二优先级\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e当前线程上下文 ClassLoader\u003c/strong\u003e 为第三优先级\u003c/li\u003e\n\u003cli\u003e抛出异常\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e回到 \u003cstrong\u003eSeq 3.\u003c/strong\u003e 的内容，\n下一步是对当前这个\u003cstrong\u003eAbstractClassGenerator\u003c/strong\u003e 维护的 CACHE 进行处理，如果在 CACHE 中能够得到以确定的 ClassLoader 为 Key 的键值对，则直接获取 ClassLoader 对应的值，否则将进行初始化构建一个新的 ClassLoaderData 作为这个 ClassLoader 的值。\u003c/p\u003e\n\u003ch3\u003eSeq 5.\u003c/h3\u003e\n\u003cp\u003e在构建 ClassLoaderData 的过程中，最重要的一步:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic ClassLoaderData(ClassLoader classLoader) {\n    // ClassLoader 不可为空\n    if (classLoader == null) {\n        throw new IllegalArgumentException(\"classLoader == null is not yet supported\");\n    }\n    // 构建 ClassLoader 的弱引用\n    this.classLoader = new WeakReference\u0026#x3C;ClassLoader\u003e(classLoader);\n    // 写了个后置调用的函数，用于懒加载，只有调用了 load.apply(...) 才会构建 生成类\n    Function\u0026#x3C;AbstractClassGenerator, Object\u003e load =\n            new Function\u0026#x3C;AbstractClassGenerator, Object\u003e() {\n                public Object apply(AbstractClassGenerator gen) {\n                    Class klass = gen.generate(ClassLoaderData.this);\n                    return gen.wrapCachedClass(klass);\n                }\n            };\n    generatedClasses = new LoadingCache\u0026#x3C;AbstractClassGenerator, Object, Object\u003e(GET_KEY, load);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e构建了一个 Function 实例，这个 Function 作为函数式接口，预定义执行的具体流程，但由上下文确定具体的调用时刻。\u003c/p\u003e\n\u003ch3\u003eSeq 6.\u003c/h3\u003e\n\u003cp\u003e在正确得到了 ClassLoader 对应的 ClassLoaderData 之后，ClassLoaderData 的 \u003ccode\u003eget(...)\u003c/code\u003e 方法将在特定的 ClassLoader 之下，进行更具体的加载新生成类的工作。\n当然，这里的前提是新的生成类的字节码已经被构建:)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Object get(AbstractClassGenerator gen, boolean useCache) {\n    // 标记为不使用缓存，直接构建 新的生成类\n    if (!useCache) {\n      return gen.generate(ClassLoaderData.this);\n    }\n    // 使用缓冲的情况\n    else {\n      Object cachedValue = generatedClasses.get(gen);\n      return gen.unwrapCachedValue(cachedValue);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003egen.generate(ClassLoaderData.this)\u003c/code\u003e 这段代码在 \u003ccode\u003eget(...)\u003c/code\u003e 方法和上一小节 \u003ccode\u003eClassLoaderData(...)\u003c/code\u003e 构造方法的 Function 函数式实例都出现了。\u003c/p\u003e\n\u003cp\u003e实际上，这也是触发 ClassLoader 来加载动态生成的新 Class 的唯一入口。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e判断逻辑\u003c/em\u003e 的 \u003ccode\u003eelse\u003c/code\u003e 内容的唯一区别就在于其构建的是一个加载缓存，将真正触发 gen.generate(ClassLoaderData.this) 的逻辑延迟。(不过，最终也还是会进行调用的，:) 这是毋庸置疑的)。\u003c/p\u003e\n\u003ch3\u003eSeq 7.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprotected Class generate(ClassLoaderData data) {\n    Class gen;\n    Object save = CURRENT.get();\n    CURRENT.set(this);\n    try {\n        // 拿到用于加载生成类的 ClassLoader\n        ClassLoader classLoader = data.getClassLoader();\n        if (classLoader == null) {\n            throw new IllegalStateException(\"ClassLoader is null while trying to define class \" +\n                    getClassName() + \". It seems that the loader has been expired from a weak reference somehow. \" +\n                    \"Please file an issue at cglib's issue tracker.\");\n        }\n        // 构建一个合法的 生成类 的类名(非重复)\n        synchronized (classLoader) {\n          String name = generateClassName(data.getUniqueNamePredicate());\n          data.reserveName(name);\n          this.setClassName(name);\n        }\n        if (attemptLoad) {\n            try {\n                // 尝试直接通过 ClassLoader 进行加载\n                gen = classLoader.loadClass(getClassName());\n                return gen;\n            } catch (ClassNotFoundException e) {\n                // ignore\n            }\n        }\n        // 策略下的生成类构建方法\n        byte[] b = strategy.generate(this);\n        // 通过解析字节码的形式获取 生成类的 className\n        String className = ClassNameReader.getClassName(new ClassReader(b));\n        ProtectionDomain protectionDomain = getProtectionDomain();\n        synchronized (classLoader) { // just in case\n            // 反射的形式加载 Class 类\n            if (protectionDomain == null) {\n                gen = ReflectUtils.defineClass(className, b, classLoader);\n            } else {\n                gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);\n            }\n        }\n        return gen;\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (Error e) {\n        throw e;\n    } catch (Exception e) {\n        throw new CodeGenerationException(e);\n    } finally {\n        CURRENT.set(save);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个方法，就是操作字节码，加载 Class 的核心调度方法。\u003c/p\u003e\n\u003cp\u003e可以看到 \u003ccode\u003egenerateClassName(...)\u003c/code\u003e 方法将构建一个当前 ClassLoader 下唯一, 不重复的新的类名。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estrategy.generate(this)\u003c/code\u003e 将通过特定策略实现的形式生成新的字节码\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eReflectUtils.defineClass(className, b, classLoader)\u003c/code\u003e 将使用反射使得 ClassLoader 来加载这个新的生成类。\u003c/p\u003e\n\u003ch3\u003eSeq 8.\u003c/h3\u003e\n\u003cp\u003e生成新的不重复类名这部分不做过多陈述，可以简单进行了解，并熟悉 CGlib 默认的新类名的命名规则\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// DefaultNamePolicy\npublic String getClassName(String prefix, String source, Object key, Predicate names) {\n    if (prefix == null) {\n        prefix = \"net.sf.cglib.empty.Object\";\n    } else if (prefix.startsWith(\"java\")) {\n        prefix = \"$\" + prefix;\n    }\n    String base =\n        prefix + \"$$\" +\n        source.substring(source.lastIndexOf('.') + 1) +\n        getTag() + \"$$\" +\n        Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\n    String attempt = base;\n    int index = 2;\n    while (names.evaluate(attempt))\n        attempt = base + \"_\" + index++;\n    return attempt;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSeq 9.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 下列是 DefaultGeneratorStrategy 的实现\npublic byte[] generate(ClassGenerator cg) throws Exception {\n    DebuggingClassWriter cw = getClassVisitor();\n    transform(cg).generateClass(cw);\n    return transform(cw.toByteArray());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSeq 10.\u003c/h3\u003e\n\u003cp\u003e调用 \u003ccode\u003egenerateClass(ClassVisitor)\u003c/code\u003e 将获得到新类的字节码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void generateClass(ClassVisitor v) throws Exception {\n    // 确定生成类的 父类\n    Class sc = (superclass == null) ? Object.class : superclass;\n\n    // 父类标识符不可以为 final\n    if (TypeUtils.isFinal(sc.getModifiers()))\n        throw new IllegalArgumentException(\"Cannot subclass final class \" + sc.getName());\n    // 获取父类直接声明的构造方法\n    List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));\n    filterConstructors(sc, constructors);\n\n    // Order is very important: must add superclass, then\n    // its superclass chain, then each interface and\n    // its superinterfaces.\n    List actualMethods = new ArrayList();\n    List interfaceMethods = new ArrayList();\n    final Set forcePublic = new HashSet();\n    // 从父类中提取各种信息\n    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);\n\n    List methods = CollectionUtils.transform(actualMethods, new Transformer() {\n        public Object transform(Object value) {\n            Method method = (Method)value;\n            int modifiers = Constants.ACC_FINAL\n                | (method.getModifiers()\n                   \u0026#x26; ~Constants.ACC_ABSTRACT\n                   \u0026#x26; ~Constants.ACC_NATIVE\n                   \u0026#x26; ~Constants.ACC_SYNCHRONIZED);\n            if (forcePublic.contains(MethodWrapper.create(method))) {\n                modifiers = (modifiers \u0026#x26; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;\n            }\n            return ReflectUtils.getMethodInfo(method, modifiers);\n        }\n    });\n\n    ClassEmitter e = new ClassEmitter(v);\n    if (currentData == null) {\n    e.begin_class(Constants.V1_2,\n                  Constants.ACC_PUBLIC,\n                  getClassName(),\n                  Type.getType(sc),\n                  (useFactory ?\n                   TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :\n                   TypeUtils.getTypes(interfaces)),\n                  Constants.SOURCE_FILE);\n    } else {\n        e.begin_class(Constants.V1_2,\n                Constants.ACC_PUBLIC,\n                getClassName(),\n                null,\n                new Type[]{FACTORY},\n                Constants.SOURCE_FILE);\n    }\n    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\n\n    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);\n    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, null);\n    if (!interceptDuringConstruction) {\n        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null);\n    }\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);\n    if (serialVersionUID != null) {\n        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);\n    }\n\n    for (int i = 0; i \u0026#x3C; callbackTypes.length; i++) {\n        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null);\n    }\n    // This is declared private to avoid \"public field\" pollution\n    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, null);\n\n    if (currentData == null) {\n        emitMethods(e, methods, actualMethods);\n        emitConstructors(e, constructorInfo);\n    } else {\n        emitDefaultConstructor(e);\n    }\n    emitSetThreadCallbacks(e);\n    emitSetStaticCallbacks(e);\n    emitBindCallbacks(e);\n\n    if (useFactory || currentData != null) {\n        int[] keys = getCallbackKeys();\n        emitNewInstanceCallbacks(e);\n        emitNewInstanceCallback(e);\n        emitNewInstanceMultiarg(e, constructorInfo);\n        emitGetCallback(e, keys);\n        emitSetCallback(e, keys);\n        emitGetCallbacks(e);\n        emitSetCallbacks(e);\n    }\n\n    e.end_class();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egenerateClass(...)\u003c/code\u003e 执行的操作和 ASM 库的 ClassVisitor 访问 Class 文件结构的流程基本类似。\u003c/p\u003e\n\u003cp\u003e从上述截取到的部分代码，例如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ee.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), \n        (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)),\n        Constants.SOURCE_FILE);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ee.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e都与 \u003ccode\u003eclassVisitor.visit(...)\u003c/code\u003e 以及 \u003ccode\u003eclassVisitor.visitField(...)\u003c/code\u003e 相当类似。而事实上，这些方法的具体实现也确实调用了 cv.visitXxx(...) 。\n毕竟，作为 CGlib 唯一依赖的库，ASM 还是可以说是难以替代的(既然已经有了可用的轮子，又何必重复造呢?)\u003c/p\u003e\n\u003ch2\u003e构造的实例\u003c/h2\u003e\n\u003cp\u003e下面将展示通过 CGlib 生成的新的类(由于生成的是字节码，懒得再自行解析 ClassFile 的内容，所有直接用 \u003ccode\u003eIDEA\u003c/code\u003e 做了字节码的解析)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e首先展示的需要进行增强的 SampleClass 的具体内容\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SampleClass {\n    public String test(String input) {\n        return \"Hello World!\";\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e用于增强的简单代码\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 省略部分代码\npublic static void main(String... args) {\n    Enhancer enhancer = new Enhancer();\n    enhancer.setSuperclass(SampleClass.class);\n    enhancer.setCallback(new FixedValue() {\n        public Object loadObject() throws Exception {\n            return \"Hello cglib!\";\n        }\n    });\n    SampleClass proxy = (SampleClass) enhancer.create();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e动态生成的新的类\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\n// 不用过多关注，只是 CGlib 保证生成类与原有的类一定属于同一包下，偷懒直接把 SampleClass 写在 CGlib 项目里了\npackage net.sf.cglib.samples;\n\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.FixedValue;\n\n/**\n * 新的类名，通过 $$EnhancerByCGLIB 以及 $$7cd64b81(这个是哈希值) 对类名进行唯一区分 \n * 如果还是重复了，在动态生成前会进行类名的检测，并通过增加序号 \"_\u0026#x3C;index\u003e\" 的形式进行进一步区分\n *\n * 可以看到新生成的类继承了 SampleClass \n */\npublic class SampleClass$$EnhancerByCGLIB$$7cd64b81 extends SampleClass implements Factory {\n    private boolean CGLIB$BOUND;\n    public static Object CGLIB$FACTORY_DATA;\n    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;\n    private static final Callback[] CGLIB$STATIC_CALLBACKS;\n\n    // 绑定一个在增强中声明的 Callback 实例\n    private FixedValue CGLIB$CALLBACK_0;\n    // 绑定一个静态的回调调度实例\n    private static Object CGLIB$CALLBACK_FILTER;\n\n    static void CGLIB$STATICHOOK1() {\n        CGLIB$THREAD_CALLBACKS = new ThreadLocal();\n    }\n\n    /**\n      * 对 test(String) 的方法的增强\n      */ \n    public final String test(String var1) {\n        // 在方法块中拿到 Callback 实例\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        // 为空则尝试获取\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        // 触发回调实例的方法获得返回值\n        return (String)var10000.loadObject();\n    }\n\n    /**\n      * 由于此次增强只声明了一个 Callback\n      * 因此所有方法的增强都相同, 都是调用这个回调方法获取\n      */\n    public final boolean equals(Object var1) {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        Object var2 = var10000.loadObject();\n        /**\n         * 但是，此处会尝试强制转型\n         * 同时在最终执行失败的时候直接抛出运行时异常\n         * 毕竟上面增强的时候返回固定值 \"Hello, cglib!\"\n         */\n        return var2 == null ? false : (Boolean)var2;\n    }\n\n    public final String toString() {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return (String)var10000.loadObject();\n    }\n\n    public final int hashCode() {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        Object var1 = var10000.loadObject();\n        return var1 == null ? 0 : ((Number)var1).intValue();\n    }\n\n    protected final Object clone() throws CloneNotSupportedException {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return var10000.loadObject();\n    }\n\n    public SampleClass$$EnhancerByCGLIB$$7cd64b81() {\n        CGLIB$BIND_CALLBACKS(this);\n    }\n\n    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {\n        CGLIB$THREAD_CALLBACKS.set(var0);\n    }\n\n    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {\n        CGLIB$STATIC_CALLBACKS = var0;\n    }\n\n    private static final void CGLIB$BIND_CALLBACKS(Object var0) {\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var1 = (SampleClass$$EnhancerByCGLIB$$7cd64b81)var0;\n        if (!var1.CGLIB$BOUND) {\n            var1.CGLIB$BOUND = true;\n            Object var10000 = CGLIB$THREAD_CALLBACKS.get();\n            if (var10000 == null) {\n                var10000 = CGLIB$STATIC_CALLBACKS;\n                if (CGLIB$STATIC_CALLBACKS == null) {\n                    return;\n                }\n            }\n\n            var1.CGLIB$CALLBACK_0 = (FixedValue)((Callback[])var10000)[0];\n        }\n\n    }\n\n    public Object newInstance(Callback[] var1) {\n        CGLIB$SET_THREAD_CALLBACKS(var1);\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Callback var1) {\n        CGLIB$SET_THREAD_CALLBACKS(new Callback[]{var1});\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {\n        CGLIB$SET_THREAD_CALLBACKS(var3);\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81;\n        switch(var1.length) {\n        case 0:\n            var10000.\u0026#x3C;init\u003e();\n            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n            return var10000;\n        default:\n            throw new IllegalArgumentException(\"Constructor not found\");\n        }\n    }\n\n    public Callback getCallback(int var1) {\n        CGLIB$BIND_CALLBACKS(this);\n        FixedValue var10000;\n        switch(var1) {\n        case 0:\n            var10000 = this.CGLIB$CALLBACK_0;\n            break;\n        default:\n            var10000 = null;\n        }\n\n        return var10000;\n    }\n\n    public void setCallback(int var1, Callback var2) {\n        switch(var1) {\n        case 0:\n            this.CGLIB$CALLBACK_0 = (FixedValue)var2;\n        default:\n        }\n    }\n\n    public Callback[] getCallbacks() {\n        CGLIB$BIND_CALLBACKS(this);\n        return new Callback[]{this.CGLIB$CALLBACK_0};\n    }\n\n    public void setCallbacks(Callback[] var1) {\n        this.CGLIB$CALLBACK_0 = (FixedValue)var1[0];\n    }\n\n    static {\n        CGLIB$STATICHOOK1();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从上面的生成类可以看出来，CGlib 所进行的增强，是在不直接对原有的方法体内容进行改造的基础上(例如上面的 test(String) 方法，没有直接改写成 \u003ccode\u003ereturn \"Hello, cglib!\u003c/code\u003e 的形式)，对方法执行之前入参或者方法执行之后的返回值进行一定的处理。\u003c/p\u003e\n\u003cp\u003e主要使用的形式就是将回调实例与原有方法进行绑定，并通过调用回调方法来实现方法的增强。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e"},"buildId":"wCGTolfdNbbPfjrHBGsfY","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/post" src="https://www.ffutop.com/blog/_next/static/wCGTolfdNbbPfjrHBGsfY/pages/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/wCGTolfdNbbPfjrHBGsfY/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.b54d8442e6b63c30cad4.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>