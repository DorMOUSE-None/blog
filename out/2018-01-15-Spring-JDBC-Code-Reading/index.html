<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/xx4WXnl7odya2QE7dUtyW/pages/post.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/xx4WXnl7odya2QE7dUtyW/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.966200943f7869d2249d.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.2d2aeb3a0a1eb931bc6e.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.a70990b9.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.196d8b6b.chunk.css"/></head><body><div id="__next"><header><h1 class="title">ffutop</h1><div><a href="/blog/blog/">博客</a><a href="/blog/archives/">归档</a><a href="/blog/tags/">标签</a><a href="/blog/about/">关于</a></div></header><div><main class="main"><div><h2>概览</h2>
<p>在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。</p>
<p>&lt;!-- more --&gt;</p>
<pre><code class="hljs"><span class="hljs-comment">/**
 * copied from https://www.tutorialspoint.com/jdbc/jdbc-sample-code.htm
 * updated by DorMOUSENone
 */</span>

<span class="hljs-comment">//STEP 1. 引入必须的包</span>
<span class="hljs-keyword">import</span> java.sql.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>{
	<span class="hljs-comment">// JDBC 驱动名 与 DB URL </span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JDBC_DRIVER = <span class="hljs-string">"com.mysql.jdbc.Driver"</span>;  
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DB_URL = <span class="hljs-string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>;

  	<span class="hljs-comment">// 数据库登录验证 (用户名、密码等)</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String USER = <span class="hljs-string">"username"</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PASS = <span class="hljs-string">"password"</span>;
   
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		Connection conn = <span class="hljs-keyword">null</span>;
		Statement stmt = <span class="hljs-keyword">null</span>;
		<span class="hljs-keyword">try</span>{
			<span class="hljs-comment">//STEP 2: 注册驱动(注册到驱动管理器 DriverManager 类中)</span>
			Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);

            <span class="hljs-comment">//STEP 3: 创建一个连接</span>
          	System.out.println(<span class="hljs-string">"Connecting to database..."</span>);
          	conn = DriverManager.getConnection(DB_URL,USER,PASS);

          	<span class="hljs-comment">//STEP 4: 执行一个查询</span>
          	System.out.println(<span class="hljs-string">"Creating statement..."</span>);
          	stmt = conn.createStatement();
          	String sql;
          	sql = <span class="hljs-string">"SELECT id, first, last, age FROM Employees"</span>;
          	ResultSet rs = stmt.executeQuery(sql);

          	<span class="hljs-comment">//STEP 5: 将结果从结果集(ResultSet)中取出</span>
          	<span class="hljs-keyword">while</span>(rs.next()){
             	<span class="hljs-comment">//根据列名逐一取出数据</span>
             	<span class="hljs-keyword">int</span> id  = rs.getInt(<span class="hljs-string">"id"</span>);
             	<span class="hljs-keyword">int</span> age = rs.getInt(<span class="hljs-string">"age"</span>);
             	String first = rs.getString(<span class="hljs-string">"first"</span>);
             	String last = rs.getString(<span class="hljs-string">"last"</span>);

             	<span class="hljs-comment">//展示结果</span>
             	System.out.print(<span class="hljs-string">"ID: "</span> + id);
             	System.out.print(<span class="hljs-string">", Age: "</span> + age);
             	System.out.print(<span class="hljs-string">", First: "</span> + first);
             	System.out.println(<span class="hljs-string">", Last: "</span> + last);
          	}
          	<span class="hljs-comment">//STEP 6: 清理环境</span>
          	rs.close();
          	stmt.close();
          	conn.close();
       	}<span class="hljs-keyword">catch</span>(SQLException se){
          	<span class="hljs-comment">//处理 JDBC 错误</span>
          	se.printStackTrace();
       	}<span class="hljs-keyword">catch</span>(Exception e){
          	<span class="hljs-comment">//处理 Class.forName() 引起的错误</span>
          	e.printStackTrace();
       	}<span class="hljs-keyword">finally</span>{
          	<span class="hljs-comment">// finally 代码库来关闭资源</span>
          	<span class="hljs-keyword">try</span>{
            	<span class="hljs-keyword">if</span>(stmt!=<span class="hljs-keyword">null</span>)
                	stmt.close();
          	}<span class="hljs-keyword">catch</span>(SQLException se2){
          	}<span class="hljs-comment">// 不做任何处理</span>
          	<span class="hljs-keyword">try</span>{
           		<span class="hljs-keyword">if</span>(conn!=<span class="hljs-keyword">null</span>)
                	conn.close();
            }<span class="hljs-keyword">catch</span>(SQLException se){
               	se.printStackTrace();
            }
       	}
       	System.out.println(<span class="hljs-string">"Goodbye!"</span>);
	}
}</code></pre><p>从上面的通用 JDBC 代码可以看到，利用 Java 原生提供的 java.sql.* 包可以完成注册驱动，创建连接，执行查询，处理结果等一系列一整套操作。</p>
<p>而 Spring-JDBC 对于 Java 原生提供的 JDBC ，对一系列数据及操作进行了整合：</p>
<ol>
<li>实现了 DataSource 接口，用于整合数据源配置，将各种零散的属性值（诸如 URL、用户名、 密码等）整合成完整的一个对象，便于重用；也实现了 getConnection(…) 接口，便于直接通过 DataSource 获取连接。</li>
<li>对执行查询的流程进行了封装。</li>
<li>对结果集的处理提供了多种接口，针对不同的应用场景可自由选择所必须的实现类。例如直接通过 JDBC 获得 Bean ，而无需如上例 39-42 行所示，逐一编码进行提取。</li>
</ol>
<p>本节提供对《Spring-JDBC 源码学习》完整学习过程的一个梳理：</p>
<ol>
<li><a href="http://blog.csdn.net/dormousenone/article/details/79035440">JdbcTemplate</a> 一节作为学习 Spring-jdbc 的切入点，是 org.springframework.jdbc.core 包中的核心类，是一个提供不同场景下数据库操作的模板类。主要描述其持有的属性 DataSource 等以及其实现的方法。</li>
<li><a href="http://blog.csdn.net/dormousenone/article/details/79037012">DataSource</a> 一节承接 JdbcTemplate 一节，提供 Spring-jdbc 对数据源的一个包装与应用。同时描述其核心方法 getConnection(…) 的实现。</li>
<li><a href="http://blog.csdn.net/dormousenone/article/details/79042212">DriverManager</a> 描述其对不同数据库供应商提供的驱动的管理与使用方法。同时简单描述通过具体驱动获得一个连接的实现。</li>
<li><a href="http://blog.csdn.net/dormousenone/article/details/79046865">PreparedStatement &amp; CallableStatement</a> 一节主要表述 Spring-jdbc 如何对执行查询的流程进行了封装。特别是对于 PreparedStatement 与 CallableStatement 这类预置可变 SQL 语句，在执行前必须对其中可变参数进行补全的 Statement 。</li>
<li><a href="http://blog.csdn.net/dormousenone/article/details/79062275">ResultSet</a> 描述 Spring-jdbc 如何对结果集进行处理，提供了多种不同的接口实现不同的处理逻辑。这种封装后的操作可以极大地简化直接使用 Java 原生 JDBC 所必须的硬编码提取数据的问题。</li>
</ol>
<h2>JdbcTemplate</h2>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fn90ghu9ufj30ki0jm75t.jpg" alt=""></p>
<p>JdbcTemplate 类作为 org.springframework.core 包下的核心类，对 Java 实现的 JDBC 进行了一定程度的封装，可以简化 JDBC 的使用，同时避免许多常见的错误。由该类来执行 JDBC 工作流，应用程序只需要提供 SQL 语句就可以获得 DB 执行结果（😀，当然实际操作上没有描述的这么简单）。</p>
<p><strong>使用 JdbcTemplate 类只需要实现两个回调接口 PreparedStatementCreator (创建一个 PreparedStatement，给定连接，提供 SQL 语句以及必要的参数), ResultSetExtractor (用于花式获取结果集)。当然，不实现上述两个接口也可以进行简单的数据库操作，比如只通过 JdbcTemplate 获取一个连接(Connection) 或者执行一个静态 SQL Update。</strong></p>
<p><em>看不懂无所谓，先继续向下看，会做更详细的讲解。</em></p>
<h3>JdbcAccessor</h3>
<p>首先了解 JdbcTemplate 的实现，JdbcTemplate 继承了 JdbcAccessor 抽象类，该抽象类有两个主要属性—— <strong>DataSource dataSource</strong> &amp; <strong>SQLExceptionTranslator exceptionTranslator</strong> ，以及一个懒加载标识符 <strong>lazyInit</strong> 。</p>
<p>其中，</p>
<ul>
<li>DataSource 可以认为是一个存储有与数据库相关的属性实例，主要方法包括 <code>Connection getConnection()</code> &amp; <code>Connection getConnection(String username, String password)</code> 。</li>
<li>SQLExceptionTranslator 利用策略模式将 Java 定义的 SQLException 转换成 Spring 声明的 DataAccessException。</li>
</ul>
<p>JdbcAccessor 实现的 InitializingBean 接口，InitializingBean 接口为 Bean 提供了一个初始化实例的方法 —— afterPropertiesSet() 方法，凡是继承该接口的类，一般都在类构造方法中执行该方法。同样的，声明初始化实例调用的方法还可采用 <code>&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;myInitMethod&quot;/&gt;</code> 在初始化 bean 时执行 myInitMethod() 方法。具体执行顺序为 ：</p>
<ol>
<li>bean 的属性注入</li>
<li>调用 afterPropertiesSet() 方法</li>
<li>执行 myInitMethod() 方法</li>
</ol>
<p>此处继承该接口是为了实现 DataSource 验证以及 SQLExceptionTranslator 的懒加载 OR NOT 的选择。</p>
<pre><code class="hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>{
	<span class="hljs-keyword">if</span> (getDataSource() == <span class="hljs-keyword">null</span>) {	<span class="hljs-comment">// 判断是否注入了 DataSource</span>
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Property 'dataSource' is required"</span>);
	}
	<span class="hljs-keyword">if</span> (!isLazyInit()) {	<span class="hljs-comment">// 根据懒加载标识符选择执行与否</span>
		getExceptionTranslator();	<span class="hljs-comment">// 获取一个 SQLExceptionTranslator 实例</span>
	}
}</code></pre><p>该方法在 BeanFactory 完成该 bean 的依赖注入后执行，将首先判断 DataSource 是否已经被注入，再根据懒加载标识符来决定是否实例化一个 SQLExceptionTranslator 。</p>
<h3>JdbcOperations</h3>
<p>同时，JdbcTemplate 类实现了 JdbcOperations 接口，该接口定义了基本的 JDBC 操作。基本方法如下：</p>
<ol>
<li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li>
<li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li>
<li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li>
<li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li>
</ol>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncp2ncqd6j31j00au0uv.jpg" alt=""></p>
<p>其它的 execute(…) , query(…), update(…) 等最终都将调用上述 4 种方法其一来完成目的。</p>
<p>详细观察上述方法的入参， ConnectionCallback, StatementCallback, PreparedStatementCallback 和 CallableStatementCallback 四个 Callback 接口，分别都是函数式接口，其中的唯一方法 doInXXX() 将在 execute() 中被调用，以此实现获得 ResultSet 并返回 Result 。execute 中调用 doInXXX() 的通用代码如下 （以 Statement 为例）：</p>
<p><em>对于不理解<strong>回调</strong>的同学，请自行了解概念</em></p>
<pre><code class="hljs"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(StatementCallback&lt;T&gt; action)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>{
	<span class="hljs-comment">// 通过工具类 DataSourceUtils 获取一个连接</span>
  	Connection con = DataSourceUtils.getConnection(obtainDataSource());
  	<span class="hljs-comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span>
	Statement stmt = <span class="hljs-keyword">null</span>;
	<span class="hljs-keyword">try</span> {
		stmt = con.createStatement();	<span class="hljs-comment">// 通过连接(Connection)获取一个 Statement</span>
		applyStatementSettings(stmt);	<span class="hljs-comment">// 配置 Statement 参数</span>
      	<span class="hljs-comment">// 回调执行 doInXXX() 方法, 并获得 result</span>
		T result = action.doInStatement(stmt);	
		handleWarnings(stmt);
		<span class="hljs-keyword">return</span> result;
	}
	<span class="hljs-keyword">catch</span> (SQLException ex) {
		<span class="hljs-comment">// Release Connection early, to avoid potential connection pool deadlock</span>
		<span class="hljs-comment">// in the case when the exception translator hasn't been initialized yet.</span>
		String sql = getSql(action);
		JdbcUtils.closeStatement(stmt);
		stmt = <span class="hljs-keyword">null</span>;
		DataSourceUtils.releaseConnection(con, getDataSource());
		con = <span class="hljs-keyword">null</span>;
		<span class="hljs-keyword">throw</span> translateException(<span class="hljs-string">"StatementCallback"</span>, sql, ex);
	}
	<span class="hljs-keyword">finally</span> {
		JdbcUtils.closeStatement(stmt);
		DataSourceUtils.releaseConnection(con, getDataSource());
	}
}</code></pre><p>对于 Statement, PreparedStatement, CallableStatement 的区别，首先下图表现了三个接口的继承关系。</p>
<ul>
<li>Statement 可以支持静态 SQL 语句</li>
<li>PreparedStatement 支持可变参数的 SQL 语句</li>
<li>CallableStatement 支持可变参数的 SQL 语句，并且支持定制 DB 的输出结果</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncpaec17yj30ew0hcdh7.jpg" alt=""></p>
<h2>DataSource</h2>
<p>上一节在粗略地了解了 JdbcTemplate 提供的方法之后，下面先来对 DataSource 做一点了解。</p>
<h3>Java 提供的 DataSource 定义</h3>
<p>DataSource 是 Java 核心库提供的接口。位于 javax.sql package 下。</p>
<p>DataSource 接口可以被视作是一个提供物理 DB 实例连接(Connection) 的工厂，通过 DataSource 持有的各种属性（包括 DB Url, Username, Password 等）来获取一个连接(Connection) 。DataSource 接口有三种不同的实现方案：</p>
<ol>
<li>最基本的实现——生产一个标准连接(Connection) 对象</li>
<li>连接池方案——生产会被自动添加到连接池的对象</li>
<li>分布式事物实现——生产一个可以支持分布式事物，并默认被添加到连接池的连接对象</li>
</ol>
<p>包括两个对外提供连接(Connection) 对象的方法，</p>
<pre><code class="hljs"><span class="hljs-function">Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException</span>;
<span class="hljs-function">Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</code></pre><p>其父接口 CommonDataSource 提供设置/获取 LogWriter，登录 DB 超时时间和获取父 Logger 的方法。</p>
<h3>Spring-JDBC 扩展的 DataSource 定义</h3>
<p>在 Spring-jdbc 下，DataSources 最顶级的类是 AbstractDataSource ，对 DataSource 的所有父接口方法做了实现。但保留 getConnection() 方法由子类实现。</p>
<p>在 AbstractDriverBasedDataSource 中，定义了大量的参数，诸如 url, username 等，这些都被用来定位并定义与数据库实例的连接。</p>
<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractDriverBasedDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDataSource</span> </span>{

   <span class="hljs-meta">@Nullable</span>
   <span class="hljs-keyword">private</span> String url;

   <span class="hljs-meta">@Nullable</span>
   <span class="hljs-keyword">private</span> String username;

   <span class="hljs-meta">@Nullable</span>
   <span class="hljs-keyword">private</span> String password;

   <span class="hljs-meta">@Nullable</span>
   <span class="hljs-keyword">private</span> String catalog;

   <span class="hljs-meta">@Nullable</span>
   <span class="hljs-keyword">private</span> String schema;

   <span class="hljs-meta">@Nullable</span>
   <span class="hljs-comment">// 可以看到此处有一个 Properties 类</span>
   <span class="hljs-keyword">private</span> Properties connectionProperties;
   
   <span class="hljs-comment">// 省略若干方法</span>
  

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>{
      	<span class="hljs-comment">// 调用内部方法 getConnectionFromDriver()</span>
		<span class="hljs-keyword">return</span> getConnectionFromDriver(getUsername(), getPassword());
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
      	<span class="hljs-comment">// 调用内部方法 getConnectionFromDriver()</span>
		<span class="hljs-keyword">return</span> getConnectionFromDriver(username, password);
	}
  
   <span class="hljs-comment">// 定义了一个获取 Connection 的方法，由 getConnection() 方法调用，</span>
   <span class="hljs-comment">// 此方法主要是将属性做了一个整合</span>
   <span class="hljs-comment">// 具体获取 Connection 的逻辑仍然下放到子类实现 见 40 行</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">getConnectionFromDriver</span><span class="hljs-params">(@Nullable String username, @Nullable String password)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
		Properties mergedProps = <span class="hljs-keyword">new</span> Properties();
		Properties connProps = getConnectionProperties();
		<span class="hljs-keyword">if</span> (connProps != <span class="hljs-keyword">null</span>) {
			mergedProps.putAll(connProps);
		}
		<span class="hljs-keyword">if</span> (username != <span class="hljs-keyword">null</span>) {
			mergedProps.setProperty(<span class="hljs-string">"user"</span>, username);
		}
		<span class="hljs-keyword">if</span> (password != <span class="hljs-keyword">null</span>) {
			mergedProps.setProperty(<span class="hljs-string">"password"</span>, password);
		}
		
     	<span class="hljs-comment">// 获取 Connection 逻辑下放</span>
		Connection con = getConnectionFromDriver(mergedProps);
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.catalog != <span class="hljs-keyword">null</span>) {
			con.setCatalog(<span class="hljs-keyword">this</span>.catalog);
		}
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.schema != <span class="hljs-keyword">null</span>) {
			con.setSchema(<span class="hljs-keyword">this</span>.schema);
		}
		<span class="hljs-keyword">return</span> con;
	}
  
  	<span class="hljs-comment">// 该类中获取 Connection 的方法是抽象方法</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Connection <span class="hljs-title">getConnectionFromDriver</span><span class="hljs-params">(Properties props)</span> <span class="hljs-keyword">throws</span> SQLException</span>;

}</code></pre><p>整合方案为将除 url 外的所有参数整合在同一个 Properties 对象中 (其中，Properties 可以被认为是一个线程安全的 Hash Map) 。最终调用 <code>Connection getConnectionFromDriver(Properties props)</code> 获取连接。</p>
<p>AbstractDriverBasedDataSource 抽象类的两个子类 DriverManagerDataSource 和 SimpleDriverDataSource 都以不同方式获得了连接(Connection)，但总结而言，获取连接(Connection) 的任务被委托给了 Driver 来实现（其中，Driver 有 Java 定义接口，并由各数据库提供商提供，例如 MySQL 提供了 mysql-connector-java-XXX.jar 来完成针对相应数据库的具体实现）。</p>
<pre><code class="hljs"><span class="hljs-comment">// ----------------------------</span>
<span class="hljs-comment">// SimpleDriverDataSource 的实现</span>
<span class="hljs-comment">// ----------------------------</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">getConnectionFromDriver</span><span class="hljs-params">(Properties props)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
	Driver driver = getDriver();
	String url = getUrl();
	Assert.notNull(driver, <span class="hljs-string">"Driver must not be null"</span>);
	<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
		logger.debug(<span class="hljs-string">"Creating new JDBC Driver Connection to ["</span> + url + <span class="hljs-string">"]"</span>);
	}
  	<span class="hljs-comment">// 哈哈，重点在这... driver 在该类中被预先注入</span>
	<span class="hljs-keyword">return</span> driver.connect(url, props);
}

<span class="hljs-comment">// -----------------------------</span>
<span class="hljs-comment">// DriverManagerDataSource 的实现</span>
<span class="hljs-comment">// -----------------------------</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">getConnectionFromDriver</span><span class="hljs-params">(Properties props)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
	String url = getUrl();
	Assert.state(url != <span class="hljs-keyword">null</span>, <span class="hljs-string">"'url' not set"</span>);
	<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) {
		logger.debug(<span class="hljs-string">"Creating new JDBC DriverManager Connection to ["</span> + url + <span class="hljs-string">"]"</span>);
	}
  	<span class="hljs-comment">// 调了个内部函数</span>
	<span class="hljs-keyword">return</span> getConnectionFromDriverManager(url, props);
}

<span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">getConnectionFromDriverManager</span><span class="hljs-params">(String url, Properties props)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
    <span class="hljs-comment">// 委托给 DriverManager 类来获取连接</span>
    <span class="hljs-comment">// DriverManager 的主要操作是遍历在该管理类中注册的 Driver</span>
    <span class="hljs-comment">// 每个 Driver 实例都去尝试一下，能不能获得一个连接</span>
    <span class="hljs-comment">// 第一次在某个 Driver 中拿到一个连接即返回连接 (Connection)</span>
	<span class="hljs-keyword">return</span> DriverManager.getConnection(url, props);
}</code></pre><p>简要的类图如下：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fncrgqcjqoj31es15ajxj.jpg" alt=""></p>
<h2>DriverManager</h2>
<p>上面提到 DataSource 获取连接(Connection) 的操作实质上将委托具体的 Driver 来提供 Connection 。有两种不同的方式，包括经由 DriverManager 遍历所有处于管理下的 Driver 尝试获取连接，或者在 DataSource 实例中直接声明一个特定的 Driver 来获取连接。</p>
<p>对于获取连接的具体操作，挖坑-待填。只描述简单的数据库供应商提供的 Driver 如何与 java 相联系。</p>
<p>###在 DriverManager 中注册 Driver 实例</p>
<p>通常在与数据库交互逻辑的 Java 代码中，都会有 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> (此处以 MySQL 提供的 mysql-connector-java-XXX.jar 为例，下同）的代码块，加载指定的 com.mysql.jdbc.Driver 为 java.lang.Class 类。</p>
<p><em>当然，在 JDBC 4.0 标准下，可以不必再显示声明 <code>Class.forName(&quot;&quot;)</code> 语句，Driver 也同样会在 DriverManager 初始化时自动注册。</em></p>
<pre><code class="hljs"><span class="hljs-comment">// Class 类中对于 forName(String className) 的方法</span>
<span class="hljs-comment">// 作用为返回一个 java.lang.Class 实例。</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className) <span class="hljs-keyword">throws</span> ClassNotFoundException {...}</code></pre><p>同时， JVM 在加载类的过程中会执行类中的 static 代码块。下述 row 10 ~ 16 的代码片段将被执行。唯一的逻辑就是 new 一个 com.mysql.jdbc.Driver 实例，并将实例注册(registerDriver) 到 <strong>java.sql.DriverManager</strong> 中。</p>
<pre><code class="hljs"><span class="hljs-keyword">package</span> com.mysql.jdbc;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">sql</span>.<span class="hljs-title">Driver</span> </span>{
	<span class="hljs-comment">// ~ Static fields/initializers</span>
	<span class="hljs-comment">// ---------------------------------------------</span>

	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// Register ourselves with the DriverManager</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-keyword">static</span> {
		<span class="hljs-keyword">try</span> {
			java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());
		} <span class="hljs-keyword">catch</span> (SQLException E) {
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Can't register driver!"</span>);
		}
	}

	<span class="hljs-comment">// ~ Constructors</span>
	<span class="hljs-comment">// -----------------------------------------------------------</span>

	<span class="hljs-comment">/**
	 * Construct a new driver and register it with DriverManager
	 * 
	 * <span class="hljs-doctag">@throws</span> SQLException
	 *             if a database error occurs.
	 */</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>{
		<span class="hljs-comment">// Required for Class.forName().newInstance()</span>
	}
}</code></pre><p>下面再来看一下 DriverManager 中的 registerDriver() 方法。</p>
<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DriverManager</span> </span>{

  	<span class="hljs-comment">// DriverManager 维护一个线程安全的 Driver 列表</span>
  	<span class="hljs-comment">// 此处的 DriverInfo 里面即包装了 Driver </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = 
      	<span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();

  	<span class="hljs-comment">// 在 DriverManager 中注册 Driver</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDriver</span><span class="hljs-params">(java.sql.Driver driver)</span>
        <span class="hljs-keyword">throws</span> SQLException </span>{
        registerDriver(driver, <span class="hljs-keyword">null</span>);
    }
  
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDriver</span><span class="hljs-params">(java.sql.Driver driver,
            DriverAction da)</span>
        <span class="hljs-keyword">throws</span> SQLException </span>{

      	<span class="hljs-comment">/* 如果当前 Driver 不在列表中，即添加到列表。 */</span>
        <span class="hljs-keyword">if</span>(driver != <span class="hljs-keyword">null</span>) {
            registeredDrivers.addIfAbsent(<span class="hljs-keyword">new</span> DriverInfo(driver, da));
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// This is for compatibility with the original DriverManager</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
        }

        println(<span class="hljs-string">"registerDriver: "</span> + driver);

    }
}</code></pre><h3>通过 DriverManager 获取连接(Connection)</h3>
<p>上一节有提到过可以通过 DriverManager 来遍历获取连接，也可以直接声明具体 Driver 并获取连接。下面代码展示的是通过 DriverManager 获取连接的操作。 <s>哈哈哈，反正最后都是由具体驱动实现获取连接。</s></p>
<pre><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DriverManager</span> </span>{
  	<span class="hljs-comment">// 获取连接的 public 接口 (1)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url,
		java.util.Properties info)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
		<span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));
	}
	<span class="hljs-comment">// 获取连接的 public 接口 (2)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url,
        String user, String password)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
        java.util.Properties info = <span class="hljs-keyword">new</span> java.util.Properties();

        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>) {
            info.put(<span class="hljs-string">"user"</span>, user);
        }
        <span class="hljs-keyword">if</span> (password != <span class="hljs-keyword">null</span>) {
            info.put(<span class="hljs-string">"password"</span>, password);
        }

        <span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));
    }
	<span class="hljs-comment">// 获取连接的 public 接口 (3)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url)</span>
        <span class="hljs-keyword">throws</span> SQLException </span>{
        java.util.Properties info = <span class="hljs-keyword">new</span> java.util.Properties();
        <span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));
    }
 
  	<span class="hljs-comment">// 获取连接的内部逻辑实现</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(
        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> 
      	<span class="hljs-keyword">throws</span> SQLException </span>{
        <span class="hljs-comment">/*
         * When callerCl is null, we should check the application's
         * (which is invoking this class indirectly)
         * classloader, so that the JDBC driver class outside rt.jar
         * can be loaded from here.
         */</span>
        ClassLoader callerCL = caller != <span class="hljs-keyword">null</span> ? caller.getClassLoader() : <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">synchronized</span>(DriverManager.class) {
            <span class="hljs-comment">// synchronize loading of the correct classloader.</span>
            <span class="hljs-keyword">if</span> (callerCL == <span class="hljs-keyword">null</span>) {
                callerCL = Thread.currentThread().getContextClassLoader();
            }
        }
		<span class="hljs-comment">// url 是定位 DBMS 最重要的参数，不能为空</span>
        <span class="hljs-keyword">if</span>(url == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(<span class="hljs-string">"The url cannot be null"</span>, <span class="hljs-string">"08001"</span>);
        }

        println(<span class="hljs-string">"DriverManager.getConnection(\""</span> + url + <span class="hljs-string">"\")"</span>);

      	<span class="hljs-comment">// 遍历所有注册的 Driver ，并都尝试获取连接(Connection)</span>
        SQLException reason = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">for</span>(DriverInfo aDriver : registeredDrivers) {
          	<span class="hljs-comment">// 判断注册的 Driver 是否由 ClassLoader callerCL 加载，不是则跳过</span>
            <span class="hljs-keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) {
                <span class="hljs-keyword">try</span> {
                    println(<span class="hljs-string">"    trying "</span> + aDriver.driver.getClass().getName());
                    <span class="hljs-comment">// 获取连接，:) 还是由 driver 实例自行提供</span>
                  	Connection con = aDriver.driver.connect(url, info);
                    <span class="hljs-keyword">if</span> (con != <span class="hljs-keyword">null</span>) {
                        <span class="hljs-comment">// Success!</span>
                        println(<span class="hljs-string">"getConnection returning "</span> + 
                                aDriver.driver.getClass().getName());
                        <span class="hljs-keyword">return</span> (con);
                    }
                } <span class="hljs-keyword">catch</span> (SQLException ex) {
                    <span class="hljs-keyword">if</span> (reason == <span class="hljs-keyword">null</span>) {
                        reason = ex;
                    }
                }

            } <span class="hljs-keyword">else</span> {
                println(<span class="hljs-string">"    skipping: "</span> + aDriver.getClass().getName());
            }

        }

        <span class="hljs-comment">// 如果运行到下列代码，则表明获取连接失败，抛出错误</span>
        <span class="hljs-keyword">if</span> (reason != <span class="hljs-keyword">null</span>)    {
            println(<span class="hljs-string">"getConnection failed: "</span> + reason);
            <span class="hljs-keyword">throw</span> reason;
        }

        println(<span class="hljs-string">"getConnection: no suitable driver found for "</span>+ url);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(<span class="hljs-string">"No suitable driver found for "</span>+ url, <span class="hljs-string">"08001"</span>);
    }

}</code></pre><p><em>简单的提一嘴，Connection 仍然只是一个针对 Java -&gt; DB Server 的上层接口，如果想要更深层次地了解 Connection 与 DB Server 的交互，可以尝试去看一下 com.mysql.jdbc.MysqlIO 类，MySQL 实现的 JDBC4Connection 类也是在使用该类来实现对 DB Server 交互。（哈哈，只看过 MySQL 提供的 Driver 包）。</em></p>
<h2>PreparedStatement &amp; CallableStatement</h2>
<p>在了解了 DataSource 获取连接(Connection) 的实质以及 JdbcTemplate 的通用接口之后，使用 Spring-jdbc 进行数据库相关的操作可以直截了当的利用如下代码进行实现（此处仅展示通过 Java 硬编码的形式进行实现，XML 配置方法类似）。</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{
  	<span class="hljs-comment">// 定义数据源</span>
	DriverManagerDataSource dataSource = <span class="hljs-keyword">new</span> DriverManagerDataSource();
  	<span class="hljs-comment">// 配置参数</span>
	dataSource.setUrl(<span class="hljs-string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;?&lt;props&gt;"</span>);
   	dataSource.setUsername(<span class="hljs-string">"&lt;username&gt;"</span>);
    dataSource.setPassword(<span class="hljs-string">"&lt;passwd&gt;"</span>);
  	
  	<span class="hljs-comment">// 实例化一个 JDBC 工具类</span>
  	JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);
  	<span class="hljs-comment">// 执行相关 CRUD 操作	</span>
  	jdbcTemplate.execute();
}</code></pre><p>回顾第一节所讲的 JdbcTemplate 的 4 个基础方法：</p>
<ol>
<li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li>
<li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li>
<li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li>
<li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndsm5tl7aj30zg0byq47.jpg" alt=""></p>
<p>四个基础方法都有一个特定的回调函数将通过预配置的 DataSource 得到的 Connection 或 更进一步的 Statement or PreparedStatement or CallableStatement 作为入参来执行定义的唯一方法。</p>
<p>以 <code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code> 为例来了解一下方法的核心逻辑。</p>
<pre><code class="hljs"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(StatementCallback&lt;T&gt; action)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>{
	<span class="hljs-comment">// 通过工具类 DataSourceUtils 获取一个连接</span>
  	Connection con = DataSourceUtils.getConnection(obtainDataSource());
  	<span class="hljs-comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span>
	Statement stmt = <span class="hljs-keyword">null</span>;
	<span class="hljs-keyword">try</span> {
		stmt = con.createStatement();	<span class="hljs-comment">// 通过连接(Connection)获取一个 Statement</span>
		applyStatementSettings(stmt);	<span class="hljs-comment">// 配置 Statement 参数</span>
      	<span class="hljs-comment">// 回调执行 doInXXX() 方法, 并获得 result</span>
		T result = action.doInStatement(stmt);	
		handleWarnings(stmt);
		<span class="hljs-keyword">return</span> result;
    } <span class="hljs-keyword">catch</span>() {
      
    } <span class="hljs-keyword">finally</span> {
      
    }
}</code></pre><p>但是，对于 PreparedStatement 和 CallableStatement 而言，获取一个 <em>XXX</em>Statement 的方式就有所不同了。</p>
<pre><code class="hljs"><span class="hljs-comment">// 获取 Statement 实例</span>
Statement stmt = con.createStatement();</code></pre><pre><code class="hljs"><span class="hljs-comment">// 获取 PreparedStatement 实例</span>
<span class="hljs-comment">// psc 是一个 PreparedStatementCreator 接口实现的实例</span>
PreparedStatement ps = psc.createPreparedStatement(con);</code></pre><pre><code class="hljs"><span class="hljs-comment">// 获取 CallableStatement 实例</span>
<span class="hljs-comment">// csc 是一个 CallableStatementCreator 接口实现的实例</span>
CallableStatement cs = csc.createCallableStatement(con);</code></pre><p>可以看到 Statement 直接通过 Connection 获取实例，但是 PreparedStatement 和 CallableStatement 就有所不同，其区别就在于 PreparedStatement 和 CallableStatement 两个 Statement 都是可以定制入参的，更甚者， CallableStatement 可以定制 DB 执行结果的出参。当然，核心还是 <code>con.prepareStatement() OR con.prepareCall()</code> 方法，只不过是将获取 XXXStatement 的操作下放给 XXXStatementCreator 实例类实现，给予使用者重复的自主权，同时也是逻辑解耦的一种操作。</p>
<p>例如：</p>
<p>SimplePreparedStatementCreator 这个 PreparedStatementCreator 接口的实现类，只是简单的调用了 <code>con.prepareStatement(sql)</code> 方法。</p>
<pre><code class="hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimplePreparedStatementCreator</span> 
  	<span class="hljs-keyword">implements</span> <span class="hljs-title">PreparedStatementCreator</span>, <span class="hljs-title">SqlProvider</span> </span>{

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String sql;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title">createPreparedStatement</span><span class="hljs-params">(Connection con)</span> 
      	<span class="hljs-keyword">throws</span> SQLException </span>{
		<span class="hljs-keyword">return</span> con.prepareStatement(<span class="hljs-keyword">this</span>.sql);
	}
}</code></pre><p>而对于 PreparedStatementCreatorImpl ，在 createPreparedStatement(Connection con) 的实现上，又添加了更多的操作。</p>
<pre><code class="hljs"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreparedStatementCreatorImpl</span>
		<span class="hljs-keyword">implements</span> <span class="hljs-title">PreparedStatementCreator</span>, <span class="hljs-title">PreparedStatementSetter</span>, <span class="hljs-title">SqlProvider</span>, <span class="hljs-title">ParameterDisposer</span> </span>{

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String actualSql;

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;?&gt; parameters;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title">createPreparedStatement</span><span class="hljs-params">(Connection con)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
		PreparedStatement ps;
		<span class="hljs-keyword">if</span> (generatedKeysColumnNames != <span class="hljs-keyword">null</span> || returnGeneratedKeys) {
			<span class="hljs-keyword">if</span> (generatedKeysColumnNames != <span class="hljs-keyword">null</span>) {
              	<span class="hljs-comment">// 获取一个 PreparedStatement 实例，下同</span>
				ps = con.prepareStatement(<span class="hljs-keyword">this</span>.actualSql, 
                                          generatedKeysColumnNames);
			}
			<span class="hljs-keyword">else</span> {
				ps = con.prepareStatement(<span class="hljs-keyword">this</span>.actualSql, 
                                         PreparedStatement.RETURN_GENERATED_KEYS);
			}
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (resultSetType == ResultSet.TYPE_FORWARD_ONLY 
                 &amp;&amp; !updatableResults) {
			ps = con.prepareStatement(<span class="hljs-keyword">this</span>.actualSql);
		}
		<span class="hljs-keyword">else</span> {
			ps = con.prepareStatement(<span class="hljs-keyword">this</span>.actualSql, resultSetType,
				updatableResults ? ResultSet.CONCUR_UPDATABLE : 
                                      ResultSet.CONCUR_READ_ONLY);
		}
      	<span class="hljs-comment">// 将可变 SQL (例如 SELECT * FROM msg WHERE id = ?) 的 ? 用实际参数替换</span>
		setValues(ps);
		<span class="hljs-keyword">return</span> ps;
	}
}</code></pre><p>从上述两种 PreparedStatementCreator 接口的不同实现，也可以从另一种角度理解到，函数式接口将获取目标出参的具体逻辑交给使用者定义，给予了使用者充分的自主权，同时也是一种业务逻辑的解耦。</p>
<p>在上面代码 PreparedStatementCreatorImpl 类的实现中，我们看到第 32 行代码 <code>setValue(ps)</code> 。此处的方法是由接口 PreparedStatementSetter 定义的。主要目的是将可变 SQL 中的 ? 参数用实际参数进行一个替换。</p>
<pre><code class="hljs"><span class="hljs-comment">// 以 SQL (SELECT * FROM msg WHERE id = ? AND day = ?) 为例</span>
<span class="hljs-comment">/** 纯 Java 核心库的实现 PreparedStatement 参数注入 */</span>
ps.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">1763</span>);
ps.setString(<span class="hljs-number">2</span>, <span class="hljs-string">"2018-01-01"</span>);
ps.executeQuery();

<span class="hljs-comment">/** 以 Spring-jdbc 实现 PreparedStatement 参数注入 */</span>
<span class="hljs-comment">// setValues() 由接口 PreparedStatementSetter 定义，封装了注入参数的具体实现逻辑</span>
<span class="hljs-comment">// 可以由使用者自行定义</span>
setValues(ps);	
ps.executeQuery();</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndyybh4q1j31kw0u3afx.jpg" alt=""></p>
<p>上面类图表示了 PreparedStatementSetter 及其实现类的相关依赖。</p>
<p>Setter 的主要目标即为对 SQL 中的 ? 参数进行注入。</p>
<p><s>个人精力有限，对Spring-jdbc在Statement上对参数注入的回调理解有限。</s></p>
<h2>ResultSet</h2>
<p>在前几节已经提到讲了数据源、驱动管理器以及 Statement 之后，利用 JDBC 的最重要的目的就是对 DB 进行操作，并获得预期结果。对于查询语句而言，结果应该是若干记录行；就更新语句而言，结果可能是影响的行数。而 Spring-jdbc 对 ResultSet 额外进行的封装，即是将原本散乱的结果进行一个整合，例如整合成一个(一组)完整的 Bean 来进行展示。</p>
<p>在 JdbcTemplate 中，四个基本方法入参都包括一个回调接口，而在执行回调获得 ResultSet 之后，方法并不是直接返回，而是进行了一定的操作。</p>
<p>以一个 PreparedStatementCallback 的实例类为例，在 doInPreparedStatement() 方法中，获得了 ResultSet ，但是仍通过 rse.extractData(rs) 语句进行了处理后再返回结果</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">doInPreparedStatement</span><span class="hljs-params">(PreparedStatement ps)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
  	<span class="hljs-comment">// 声明一个 ResultSet </span>
	ResultSet rs = <span class="hljs-keyword">null</span>;
	<span class="hljs-keyword">try</span> {
		<span class="hljs-keyword">if</span> (pss != <span class="hljs-keyword">null</span>) {	<span class="hljs-comment">// setValues() 方法填充 PreparedStatement 中的可变参数 ? </span>
			pss.setValues(ps);
		}
		rs = ps.executeQuery();	<span class="hljs-comment">// 执行查询 sql ，获取结果</span>
		<span class="hljs-keyword">return</span> rse.extractData(rs);	<span class="hljs-comment">// 重点... 该语句一定是对结果进行了一些操作.</span>
	}
	<span class="hljs-keyword">finally</span> {
		JdbcUtils.closeResultSet(rs);
		<span class="hljs-keyword">if</span> (pss <span class="hljs-keyword">instanceof</span> ParameterDisposer) {
			((ParameterDisposer) pss).cleanupParameters();
		}
	}
}</code></pre><p>在来看一下究竟在返回结果前进行了什么操作。</p>
<p>由于是一个回调接口的实现类，rse 应该在外部方法中。</p>
<pre><code class="hljs"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">query</span><span class="hljs-params">(
		PreparedStatementCreator psc, @Nullable <span class="hljs-keyword">final</span> PreparedStatementSetter pss, 
  		<span class="hljs-keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span>
		<span class="hljs-keyword">throws</span> DataAccessException </span>{

	<span class="hljs-keyword">return</span> execute(psc, <span class="hljs-keyword">new</span> PreparedStatementCallback&lt;T&gt;() {
		<span class="hljs-meta">@Override</span>
		<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">doInPreparedStatement</span><span class="hljs-params">(PreparedStatement ps)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
			...	
        }
	});
}</code></pre><p>可以看到 rse 是一个 ResultSetExtractor&lt;T&gt; 的实例。从名称上可以看出 Extractor 即为提取器，结果集提取器。</p>
<pre><code class="hljs"><span class="hljs-comment">/** 函数式接口，提供的唯一方法为 extractData(...) */</span>
<span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResultSetExtractor</span>&lt;<span class="hljs-title">T</span>&gt; </span>{

	<span class="hljs-meta">@Nullable</span>
	<span class="hljs-function">T <span class="hljs-title">extractData</span><span class="hljs-params">(ResultSet rs)</span> <span class="hljs-keyword">throws</span> SQLException, DataAccessException</span>;

}</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fndzz0pqnrj31a60i676v.jpg" alt=""></p>
<p>Spring-jdbc 中现有的实现有三个类，其中 RowCallbackHandlerResultSetExtractor 和 RowMapperResultSetExtractor 两个类从上面类图及命名即可看出，两个是作为一个适配器而存在的，将 extractData() 进行转换，分别由 RowCallbackHandler 和 RowMapper 实例进行具体操作。而 AbstractLobStreamingResultSetExtractor 类从名称上看，也是一个类似流操作的实现类(其中的 Lob 指的是 DB 中的 BLOB 与 CLOB 类型，在 Spring-jdbc 中也加入了额外的支持) 。</p>
<h3>RowCallbackHandler</h3>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh2uw3a0aj30h20jeta4.jpg" alt=""></p>
<p>从名称上看，这是一个与 ResultSet 结果集行相关的回调接口。processRow(ResultSet rs) 方法将处理行相关的逻辑。</p>
<p>从它的一个实现类 RowCountCallbackHandler 来说，其最主要的私有属性 rowCount 即是统计 ResultSet 的结果行数。下面是一个具体使用的该类的案例：</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{

    DriverManagerDataSource dataSource = <span class="hljs-keyword">new</span> DriverManagerDataSource();
    dataSource.setUrl(<span class="hljs-string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>);
    dataSource.setUsername(<span class="hljs-string">"&lt;username&gt;"</span>);
    dataSource.setPassword(<span class="hljs-string">"&lt;password&gt;"</span>);

    JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);
    RowCountCallbackHandler rcch = <span class="hljs-keyword">new</span> RowCountCallbackHandler();

    jdbcTemplate.query(<span class="hljs-string">"SELECT * FROM info WHERE id='2018'"</span>, (RowCallbackHandler) rcch);
	
  	System.out.println(rcch.getRowCount());	<span class="hljs-comment">//获取结果集行数</span>
    System.out.println(rcch.getColumnCount());	<span class="hljs-comment">// 获取结果集列数</span>
    <span class="hljs-keyword">for</span> (String arg : rcch.getColumnNames()) {	<span class="hljs-comment">// 打印结果集每一列名称</span>
        System.out.println(<span class="hljs-string">"ColumnNames : "</span> + arg);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : rcch.getColumnTypes()) {	<span class="hljs-comment">// 打印结果集每一列类型(Types 为枚举类)</span>
        System.out.println(<span class="hljs-string">"ColumnTypes : "</span> + i);
    }
}</code></pre><p>具体查看 RowCountCallbackHandler 类的 processRow() 方法可以看到，其获取列相关信息都来自于 ResultSetMetaData 。而结果行数来源于 Iterator 迭代。</p>
<pre><code class="hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRow</span><span class="hljs-params">(ResultSet rs)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rowCount == <span class="hljs-number">0</span>) {
		ResultSetMetaData rsmd = rs.getMetaData();
		<span class="hljs-keyword">this</span>.columnCount = rsmd.getColumnCount();
		<span class="hljs-keyword">this</span>.columnTypes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.columnCount];
		<span class="hljs-keyword">this</span>.columnNames = <span class="hljs-keyword">new</span> String[<span class="hljs-keyword">this</span>.columnCount];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.columnCount; i++) {
			<span class="hljs-keyword">this</span>.columnTypes[i] = rsmd.getColumnType(i + <span class="hljs-number">1</span>);
			<span class="hljs-keyword">this</span>.columnNames[i] = JdbcUtils.lookupColumnName(rsmd, i + <span class="hljs-number">1</span>);
		}
		<span class="hljs-comment">// could also get column names</span>
	}
	processRow(rs, <span class="hljs-keyword">this</span>.rowCount++);
}</code></pre><h3>RowMapper</h3>
<p>上面 RowCallbackHandler 接口从逻辑上划分是用于处理 ResultSet 元数据信息的。而 RowMapper 较上一个接口而言，有更高的实用性。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh3h739kaj30z60nago4.jpg" alt=""></p>
<p>特别是其实现类 BeanPropertyRowMapper&lt;T&gt; 可以将散乱的 ResultSet 的结果数据整理成一个个 Object Bean 作为返回结果。而省去了对逐一读取 ResultSet 行记录并填充 Bean 属性的麻烦。</p>
<pre><code class="hljs">JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);

BeanPropertyRowMapper&lt;Model&gt; rowMapper = <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Model.class);
List&lt;Model&gt; list = jdbcTemplate.query(<span class="hljs-string">"SELECT * FROM info WHERE id = '2018'"</span>, rowMapper);
<span class="hljs-comment">/** 获得的 Model list 的对应属性将通过 Java 的反射机制进行填充
 *	List&lt;Model&gt; list 即结果
 */</span></code></pre><p>当然，要求是 Model 类中的属性与 DB table 中的列名保持一致（大小写无要求）。</p>
<p>而其它两个类的实现也是基于反射机制，实现其相应的业务逻辑。</p>
<pre><code class="hljs">__                    __                  
 / _| __ _ _ __   __ _ / _| ___ _ __   __ _ 
| |_ / _` | '_ \ / _` | |_ / _ \ '_ \ / _` |
|  _| (_| | | | | (_| |  _|  __/ | | | (_| |
|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |
                 |___/                |___/</code></pre></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/post","query":{"fullUrl":"/2018-01-15-Spring-JDBC-Code-Reading"},"buildId":"xx4WXnl7odya2QE7dUtyW","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/post" src="https://www.ffutop.com/blog/_next/static/xx4WXnl7odya2QE7dUtyW/pages/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/xx4WXnl7odya2QE7dUtyW/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.966200943f7869d2249d.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.2d2aeb3a0a1eb931bc6e.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>