<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/XgNVO0Or_GCOPc0sVklZL/pages/index.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/XgNVO0Or_GCOPc0sVklZL/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.b54d8442e6b63c30cad4.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.a1d4ae30.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.f85dcf60.chunk.css"/></head><body><div id="__next"><header class="component-header"><h1 class="title">ffutop</h1><ul class="nav-items"><li><a href="/blog/index">博客</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/about">关于</a></li></ul></header><div><main class="main"><div><h1>理解 Linux Kernel (5) - 文件系统(宏观描述)</h1><div><p>用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。</p>
<pre><code class="language-shell">$ ls
Applications Network      Users        bin          data         etc          net          sbin         usr
Library      System       Volumes      cores        dev          home         private      tmp          var
</code></pre>
<p>但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?</p></div></div><div><h1>理解 Linux Kernel (6) - read &amp; write</h1><div><p><a href="https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/">前一篇</a>已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。</p>
<p>首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式</p>
<pre><code class="language-c">#include &#x3C;stdio.h>
#include &#x3C;stdlib.h>
#include &#x3C;string.h>
#include &#x3C;unistd.h>
#include &#x3C;fcntl.h>
#include &#x3C;errno.h>
#include &#x3C;sys/types.h>
#include &#x3C;sys/stat.h>

int panic()
{
    fprintf(stderr, "%s (errno=%d)\n", strerror(errno), errno);
    return -1;
}

int main(int argc, char *argv[])
{
    /* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */
    int fd = open("/root/frw.txt", O_RDWR | O_CREAT);
    if (fd == -1)
        return panic();

    /* 向文件写入 Hello World! 共计 12 个字符 */
    ssize_t wsize = write(fd, "Hello World!", 12);
    if (wsize == -1)
        return panic();

    /* 重定位文件读写指针 */
    off_t off = lseek(fd, 0, SEEK_SET);
    if (off == -1)
        return panic();

    char* buf = (char *) malloc(wsize);
    /* 读取文件内容 */
    ssize_t rsize = read(fd, buf, wsize);
    if (rsize == -1)
        return panic();

    printf("%s\n", buf);
    free(buf);
    /* 关闭文件 */
    int stat = close(fd);
    if (stat == -1)
        return panic();

    return 0;
}
</code></pre></div></div><div><h1>正则表达式指数爆炸</h1><div><h2>背景</h2>
<p>昨天接触到一个很有意思的问题, 公司测试环境一台机器 CPU 跑到了 400%，导致该机器上的所有服务都挂掉了。</p>
<p>最后查到的原因竟然是正则表达式所引起的，大大出乎意料啊。虽然早就知道正则效率很差，但绝对没有想到会导致整个机器上服务崩溃的情况。</p>
<p>先简单展示下问题正则:</p>
<pre><code class="language-java">String regex = "(\\w+,?)+";
String val = "abcdefghijklmno,abcdefghijklmno+";
System.out.println(val.matches(regex));
</code></pre>
<p>最终的执行时间是 17s 左右。</p>
<p>相反，如果改成 <code>String val = "abcdefghijklmno,abcdefghijklmno"</code> ，实际执行时间 1ms 左右。</p>
<p>哈哈，完全不是一个量级的结果。</p>
<p>最后，当然是要找原因了:&#x3C; 当然，有其它重要的事在耽搁，没时间去看 Java Regex 源码。不过，从正则本身下手反而是个好事情。毕竟几乎所有的编程语言都有对正则的支持。而同样的，都存在着这样的问题。那就可以大胆猜想其实是和语言本身无关，而在于正则规范本身了。</p>
<p>先给个结果，罪魁祸首就是<code>指数爆炸</code></p></div></div><div><h1>SQL 注入</h1><div><p>说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。</p>
<p>最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。</p>
<p>更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: "我用不用现成的工具只是取决于我想不想自己再写一套"</p>
<p>当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。</p></div></div><div><h1>理解 Linux Kernel (7) - 字符设备</h1><div><p>相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。</p>
<p>回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。</p>
<p>那么，常见的字符设备有什么？显示器、键盘、鼠标。</p></div></div><div><h1></h1><div><p>title: 理解 Linux Kernel (8) - 网络
author: fangfeng
date: 2019-01-15
tags:</p>
<ul>
<li>Linux</li>
<li>Kernel</li>
<li>Network</li>
</ul>
<hr>
<p>{% pdf <a href="https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview">https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview</a> %}</p></div></div><div><h1></h1><div><p>title: 字符集与字符编码
author: fangfeng
date: 2019-02-02
tags:</p>
<ul>
<li>Unicode</li>
<li>Character Encoding</li>
</ul>
<hr>
<p>{% pdf <a href="https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview">https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview</a> %}</p></div></div><div><h1>【Java】API 参数误定义的后果</h1><div><p>工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。</p>
<p>想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！</p>
<p>想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把<code>void add(int)</code> API 改写成 <code>int add(int)</code>，可能得到的大多数回答都是可以。</p></div></div><div><h1>理解 Linux Kernel (9) - IO Multiplexing</h1><div><p><a href="./2019-01-15-understand-Kernel-8/">前一篇</a>已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 <code>struct sock</code> 对象，将其逐级从网络接口层逐级提升到网络层、传输层...最终添加到接收队列 <code>sk_receive_queue</code> 中；用户进程通过 <code>read</code>、<code>recv</code>、<code>recvfrom</code> 等命令检查并获取 <code>sk_receive_queue</code> 中的数据。</p>
<p>整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。</p>
<p>那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（<code>select</code>, <code>poll</code>, <code>epoll</code>）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 <code>select</code> 和 <code>epoll</code> 两类系统调用的实现进行探究。</p></div></div><div><a href="/page/NaN">上一页</a><a href="/page/NaN">下一页</a></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/","query":{"mdDatasParts":[{"url":"2018-10-14-understand-Kernel-5","fileName":"2018-10-14-understand-Kernel-5.md","title":"理解 Linux Kernel (5) - 文件系统(宏观描述)","author":"fangfeng","date":"2018-10-14T00:00:00.000Z","tags":["Kernel","Linux","File System"],"content":"\u003cp\u003e用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ ls\nApplications Network      Users        bin          data         etc          net          sbin         usr\nLibrary      System       Volumes      cores        dev          home         private      tmp          var\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?\u003c/p\u003e\n\u003ch2\u003e文件系统的形式\u003c/h2\u003e\n\u003cp\u003e首先我们假设文件是简单地存储在存储设备(硬盘等)某一块连续区域的。\u003c/p\u003e\n\u003cp\u003e那么如何在小则几百G，大则几十T甚至更大的存储设备上找到具体的某一文件，并读取的内存中呢?\u003c/p\u003e\n\u003cp\u003e最普通的，就只能在存储设备上一字节一字节的查找，直到找到相应的目标文件。是不是可以想象，这会很慢很慢。\u003c/p\u003e\n\u003cp\u003e有没有快一点的？很容易想到，参考类似字典的形式就可以了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e目录形式\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e文件内容可能很大，但相比之下，文件名就小了很多(就算不同目录下同名文件很多，但是记录全路径名也代价不大。当然了，如果都是小文件、空文件，那就不一样了)\u003c/p\u003e\n\u003cp\u003e通过为所有文件通过文件名编一个目录，指明每个文件在存储设备上的具体位置。这样需要扫描的内容就会小很多，也能更快地定位到文件内容。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e逐级目录\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e仅仅只编制一个目录，那么层次目录又有什么实际意义吗？只是为了方便用户分类不同功能、目的的文件吗？\u003c/p\u003e\n\u003cp\u003e利用逐级目录，可以考虑对次级目录的内容编制上一级目录。通过顶级目录定位次级目录的内容，次级目录定位再次级目录，最后对应目录下的文件的内容。\u003c/p\u003e\n\u003ch2\u003e文件系统的组织\u003c/h2\u003e\n\u003cp\u003e在之前的理解里，文件系统是接管了整个存储设备。似乎文件系统和存储设备就是直接关联的，两个不可分割。没有建立文件系统的硬盘就不能使用，而没有硬盘，文件系统就没有了载体。\u003c/p\u003e\n\u003cp\u003e但是，在学习 Linux 的过程中，似乎发现也并不是这么一回事。没有直接硬盘，文件系统一样可以存在。一直都有在使用 \u003ccode\u003e.img\u003c/code\u003e 磁盘映像文件，只是没有意识到，这意识文件系统的一种载体。同样的，没有文件系统，在操作系统启动的过程中，一样是可以加载各种内容，乃至预置的文件信息。\u003c/p\u003e\n\u003cp\u003e在 Linux 中，最常见的文件系统就是 ext2, ext3, ext4 之流了。偶尔也有听过用过，比如说准备接入新的硬盘的时候。但是，真正里面是什么样的。还真不了解，ext2,3,4 的区别，也根本不知道。\u003c/p\u003e\n\u003cp\u003e当然了，本次也并不会对这些内容进行描述。由于一直在学习 Linux 0.11 版本的源码，接下来要描述的文件系统，也就是 0.11 版本直接使用的 minix 文件系统了。\u003c/p\u003e\n\u003cp\u003e最开始，当然是应该有一个感官的印象，才能更方便地来理解文件系统的组织形式啦!\u003c/p\u003e\n\u003ch3\u003e创建文件系统\u003c/h3\u003e\n\u003cp\u003e这里我们创建一个 512 KB 大小的文件系统\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emkfs\u003c/code\u003e 应该是最简单的方式了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ touch disk.img            # 磁盘映像文件 (由于没有额外的磁盘，就以此作为新创建的 minix 文件系统的载体)\n$ dd if=/dev/zero of=disk.img bs=1024 count=512     # 先将文件的大小扩展到 512 KB ，否则在创建文件系统的时候会失败\n512+0 records in\n512+0 records out\n524288 bytes (524 kB, 512 KiB) copied, 0.00216049 s, 243 MB/s\n$ mkfs.minix disk.img 512   # 创建文件系统\n192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode\n512 blocks                  # 总共 512 个磁盘块\nFirstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的\nZonesize=1024               # 每个磁盘块的大小为 1024 B\nMaxsize=268966912           # 单一文件的最大大小\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e先来看看目前 disk.img 里面的内容\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ hexdump disk.img\n0000000 0000 0000 0000 0000 0000 0000 0000 0000\n*                                                   # * 表示这段数据全为 0\n0000400 00c0 0200 0001 0001 000a 0000 1c00 1008\n0000410 138f 0001 0000 0000 0000 0000 0000 0000\n0000420 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000800 0003 0000 0000 0000 0000 0000 0000 0000\n0000810 0000 0000 0000 0000 fffe ffff ffff ffff\n0000820 ffff ffff ffff ffff ffff ffff ffff ffff\n*                                                   # * 表示这段数据全为 ff ( * 总是表示与前一段数据一致的省略)\n0000c00 0003 0000 0000 0000 0000 0000 0000 0000\n0000c10 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000c30 0000 0000 0000 0000 0000 0000 0000 ff80\n0000c40 ffff ffff ffff ffff ffff ffff ffff ffff\n*\n0001000 41ed 0000 0040 0000 cf12 5bd3 0200 000a\n0001010 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0002800 0001 002e 0000 0000 0000 0000 0000 0000\n0002810 0000 0000 0000 0000 0000 0000 0000 0000\n0002820 0001 2e2e 0000 0000 0000 0000 0000 0000\n0002830 0000 0000 0000 0000 0000 0000 0000 0000\n0002840 0000 622e 6461 6c62 636f 736b 0000 0000\n0002850 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0080000                                             # 截止字节，0x80000 = 512 KB 并不存在\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e似乎并没有太多的感觉，现在我们往 disk.img 这个磁盘映像文件中添些内容再来看看。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ mount disk.img /mnt   # 把 disk.img 挂载到 /mnt 目录下\n$ cd /mnt\n$ echo \"#include \u0026#x3C;stdio.h\u003e\" \u003e hello.c       # 创建 hello.c 文件，并写入 #include \u0026#x3C;stdio.h\u003e \n$ umount /mnt           # 解挂 disk.img\n$ hexdump -C disk.img\n00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|\n00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000420  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|\n00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|\n*\n00000c00  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000c10  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000c30  00 00 00 00 00 00 00 00  00 00 00 00 00 00 80 ff  |................|\n00000c40  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|\n*\n00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|\n00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|\n00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|\n00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include \u0026#x3C;stdio.|\n00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h\u003e..............|\n00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00080000\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e很明显，我们看到了 \u003ccode\u003e#include \u0026#x3C;stdio.h\u003e\u003c/code\u003e 字样的内容，同时也出现了 \u003ccode\u003ehello.c\u003c/code\u003e 的文件名。\u003c/p\u003e\n\u003cp\u003e需要注意，文件名和文件内容是相互割裂的，并没有直接存储在一起。\u003c/p\u003e\n\u003ch3\u003e文件系统存储结构\u003c/h3\u003e\n\u003cp\u003e那么，配合着上面的内容来看看文件系统的组织结构。\u003c/p\u003e\n\u003cp\u003e首先可以注意到的是，每一段非零的数据的开始地址，基本都是在 \u003ccode\u003e0x0000, 0x0400, 0x0800, 0x0c00, 0x1000\u003c/code\u003e 。间隔了 0x0400 = 1KB，这就是最基本的块的大小。\u003c/p\u003e\n\u003cp\u003eMinix 文件系统将 1024 B 作为基本块的大小。\u003ccode\u003edisk.img\u003c/code\u003e 这个 512 KB 的磁盘映像文件，也就恰好被分割成 512 块。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ mkfs.minix disk.img 512   # 创建文件系统\n192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode\n512 blocks                  # 总共 512 个磁盘块\nFirstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的\nZonesize=1024               # 每个磁盘块的大小为 1024 B\nMaxsize=268966912           # 单一文件的最大大小\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在回过头来看看前面创建文件系统的时候的信息，相信也就能够看懂一部分了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e块的作用划分\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e那么，每个块如何进行使用呢？\u003c/p\u003e\n\u003cp\u003e首先，最开始的一个块并不会直接使用。我们知道引导程序应该出现在引导盘最开始 512 B。但是，有些盘有引导程序，有些盘又没有，如何处理呢？\u003c/p\u003e\n\u003cp\u003e文件系统结构中，默认地不对第一个 1024 B 的块进行操作，即原本是什么数据就是什么数据，与文件系统并不相干。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fwnnc753epj31kw04tq35.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e除了引导块，之后还有超级块，inode 位图，逻辑块位图，inode 区块，数据区块\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e超级块\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e真正对 MINIX 文件系统起着统领性作用的，是超级块(第二个块)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct super_block {\n unsigned short s_ninodes;          /* i 节点的数量 */\n unsigned short s_nzones;           /* 总区块数量 */\n unsigned short s_imap_blocks;      /* i 节点位图的数量 */\n unsigned short s_zmap_blocks;      /* 区块位图的数量 */\n unsigned short s_firstdatazone;    /* 第一个数据块的编号 */\n unsigned short s_log_zone_size;    /* log2(磁盘块大小 / 逻辑块大小) */\n unsigned long s_max_size;          /* 单文件的最大长度 */\n unsigned short s_magic;            /* 文件系统的魔数 */\n\n /* 下面的内容是在内存中使用的，并不会在磁盘上进行读写 */\n struct buffer_head * s_imap[8];\n struct buffer_head * s_zmap[8];\n unsigned short s_dev;\n struct m_inode * s_isup;\n struct m_inode * s_imount;\n unsigned long s_time;\n struct task_struct * s_wait;\n unsigned char s_lock;\n unsigned char s_rd_only;\n unsigned char s_dirt;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e结合着 \u003ccode\u003edisk.img\u003c/code\u003e 的数据来看看。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|\n00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n\n0x00c0  -\u003e 192 个 i 节点\n0x0200  -\u003e 512 个逻辑块\n0x0001  -\u003e 一个i节点位图\n0x0001  -\u003e 一个逻辑块位图\n0x000a  -\u003e 第一个数据块编号为 10 \n0x0000  -\u003e log2(磁盘块大小 / 逻辑块大小) = 0 ，即磁盘块大小 = 逻辑块大小 = 1024 B\n0x10081c00 -\u003e 单文件最大 268966912 B \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003einode 位图\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003einode 位图的数据比较简单，是通过设置比特位 0、1 的方式，来直接表明相应编号的 i 节点是否存在。\n默认 i 节点从 1 号开始编号，0 号节点在 inode 位图上一定设置为 1 \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|\n00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e总共 192 个 i 节点，加上 0 号节点总计需占用 193 位 ( = 193 / 8 = 24 字节 + 1 位)\u003c/p\u003e\n\u003cp\u003e其余多余的位，全部置位为 1 。\u003c/p\u003e\n\u003cp\u003e位图存储的最初数据 0x07 (注意，小端存储法) = 0b111\u003c/p\u003e\n\u003cp\u003e由此，总共有1号和2号i节点。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e逻辑块位图\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e类似的，逻辑块位图是为了表明第n个逻辑块存储有数据，或处于空闲状态。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003einode 区块\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e参照前面讲过的字典目录的形式，inode 就是一种分级编排后的目录。\u003c/p\u003e\n\u003cp\u003e当然，说目录可能还会引发误解。这里无论是对于操作系统下的目录或是文件，每一个都对应着一个独特的 inode\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct d_inode {\n unsigned short i_mode;     /* 文件类型和属性 (rwx 位) */\n unsigned short i_uid;      /* 文件所有者 id */\n unsigned long i_size;      /* 文件大小 */\n unsigned long i_time;      /* 修改时间 */\n unsigned char i_gid;       /* 文件所在组 id */\n unsigned char i_nlinks;    /* 有多少个链接数 (有多少个文件目录项指向该 i 节点) */\n unsigned short i_zone[9];  /* 文件数据所占用数据盘的指针 */\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e每个i节点的数据分别 32 字节\u003c/p\u003e\n\u003cp\u003e同样的，结合 \u003ccode\u003edisk.img\u003c/code\u003e 的数据来看\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|\n00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|\n00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n\n0x41ed  -\u003e \n0x0000  -\u003e  文件所有者为 0 即 root\n0x00000060  -\u003e  文件大小为 96 B\n0x5bd40de5  -\u003e  文件最后修改时间为 Unix TimeStamp 1540623845 =\u003e 2018/10/27 15:4:5\n0x00    -\u003e  文件所在组 id\n0x02    -\u003e  有两个文件目录项指向1号i节点\n0x000a  -\u003e  1 号 i 节点指向的第0块数据为第10个逻辑块(即第1个数据块)\n0x0000  =\u003e  由于数据比较小，后面的 i_zone[1] ~ i_zone[8] 均为 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ei_zone 指向的是数据实际存储的数据块的位置。\u003c/p\u003e\n\u003cp\u003e但是，仅仅只有 9 个指针，每个数据块能存储 1024 B ，是远远达不到之前所描述的单文件 \u003ccode\u003e0x10081c00 = 268966912 B\u003c/code\u003e 的上限的。\u003c/p\u003e\n\u003cp\u003e事实上，minix 在实际处理的过程中，把前7个指针作为直接数据块指针，最多存储 7168 B 数据。\u003c/p\u003e\n\u003cp\u003ei_zone[7] 表示一次间接指针，指向某一个数据块，但是该数据块每2字节作为一个指针，指向真正的数据块。\u003c/p\u003e\n\u003cp\u003ei_zone[8] 表示二次间接指针。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fwnu3zrwuij310y0m6abj.jpg\"\u003e\nCopied from Linux 内核完全注释V3.0\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e数据块\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e最后，我们看看数据块的内容，也希望能够更好地来理解 Linux 目录和文件的异同。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|\n00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include \u0026#x3C;stdio.|\n00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h\u003e..............|\n00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在i节点区块上，我们看到有1号i节点和2号i节点已经被使用了。\u003c/p\u003e\n\u003cp\u003e0x2800 ~ 0x2860 的位置表示的就是 1 号i节点的数据。事实上这是一个目录(当然，怎么区分目录还是文件，在i节点区块的 i_mode 字段已经描述过了)\u003c/p\u003e\n\u003cp\u003e对于目录文件，当然是用来记载目录项的，每个目录项占用 32 字节。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这里需要进行说明，MINIX 1.0 版本的文件系统似乎是对每个目录项占用 16 字节的。\u003c/p\u003e\n\u003cp\u003e这里提供一个 Linux 0.11 版本的仿真运行结果以供证明\n\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fwnuexcwx7j30nw0c8745.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e上面描述的 \u003ccode\u003edisk.img\u003c/code\u003e 是在 Ubuntu 16.04 LTS 下跑出来的结果，所有确实出现了一些差别。\n至于具体的一个规范，目前还没有找到，所有这部分只能做模糊处理了，勿怪。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e前2个字节用来表示该目录项所对应的 i 节点编号。之后的30个字节用来描述该目录项的名字。\u003c/p\u003e\n\u003cp\u003e因此，对 0x2800 ~ 0x2860 的数据进行重建的结果就是 \u003ccode\u003e. .. hello.c\u003c/code\u003e 三个目录项了。其中，由于是根目录，\u003ccode\u003e.\u003c/code\u003e 和 \u003ccode\u003e..\u003c/code\u003e 所指向的i节点的相同的，都是1号i节点。\u003c/p\u003e\n\u003cp\u003e而 hello.c 文件指向的是 2 号i节点。\u003c/p\u003e\n\u003cp\u003e哈哈，2号i节点的数据内容就在 0x2c00 开始的位置。通过右侧的 ASCII 结果我们也可以看到。\u003c/p\u003e\n\u003cp\u003e当然，之前说过每个数据块是 1024 B ，那么数据块多余的部分，就是留空咯，而不会被其它i节点占用(除非该文件or目录被完全移除了)\u003c/p\u003e\n\u003ch2\u003e小结\u003c/h2\u003e\n\u003cp\u003e到此为止，文件系统宏观的描述就已经完结了。\u003c/p\u003e\n\u003cp\u003e下一节将对操作系统如何使用文件系统进行描述。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ ls\nApplications Network      Users        bin          data         etc          net          sbin         usr\nLibrary      System       Volumes      cores        dev          home         private      tmp          var\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?\u003c/p\u003e"},{"url":"2018-11-11-understand-Kernel-6","fileName":"2018-11-11-understand-Kernel-6.md","title":"理解 Linux Kernel (6) - read \u0026 write","author":"fangfeng","date":"2018-11-11T00:00:00.000Z","tags":["Linux","Kernel","File System","read \u0026 write"],"content":"\u003cp\u003e\u003ca href=\"https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/\"\u003e前一篇\u003c/a\u003e已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。\u003c/p\u003e\n\u003cp\u003e首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \u0026#x3C;stdio.h\u003e\n#include \u0026#x3C;stdlib.h\u003e\n#include \u0026#x3C;string.h\u003e\n#include \u0026#x3C;unistd.h\u003e\n#include \u0026#x3C;fcntl.h\u003e\n#include \u0026#x3C;errno.h\u003e\n#include \u0026#x3C;sys/types.h\u003e\n#include \u0026#x3C;sys/stat.h\u003e\n\nint panic()\n{\n    fprintf(stderr, \"%s (errno=%d)\\n\", strerror(errno), errno);\n    return -1;\n}\n\nint main(int argc, char *argv[])\n{\n    /* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */\n    int fd = open(\"/root/frw.txt\", O_RDWR | O_CREAT);\n    if (fd == -1)\n        return panic();\n\n    /* 向文件写入 Hello World! 共计 12 个字符 */\n    ssize_t wsize = write(fd, \"Hello World!\", 12);\n    if (wsize == -1)\n        return panic();\n\n    /* 重定位文件读写指针 */\n    off_t off = lseek(fd, 0, SEEK_SET);\n    if (off == -1)\n        return panic();\n\n    char* buf = (char *) malloc(wsize);\n    /* 读取文件内容 */\n    ssize_t rsize = read(fd, buf, wsize);\n    if (rsize == -1)\n        return panic();\n\n    printf(\"%s\\n\", buf);\n    free(buf);\n    /* 关闭文件 */\n    int stat = close(fd);\n    if (stat == -1)\n        return panic();\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e高速缓冲区初始化\u003c/h2\u003e\n\u003cp\u003e上一篇已经描述过了，文件系统的结构、包括数据，都是持久化地存储在存储设备中的。\u003c/p\u003e\n\u003cp\u003e但是，我们应该也隐约的了解另一个事实，文件读写操作并不会直接操作存储设备上的数据，而是先经过一个称之为高速缓冲的内存区域。\u003c/p\u003e\n\u003cp\u003e那么，高速缓冲是什么? 究竟承担什么工作? 先来看看它的初始化流程吧。\u003c/p\u003e\n\u003cp\u003e首先回到 \u003ccode\u003emain.c\u003c/code\u003e (内核代码的主函数)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid main(void) \n{\n    ROOT_DEV = ORIG_ROOT_DEV;\n    drive_info = DRIVE_INFO;\n    memory_end = (1\u0026#x3C;\u0026#x3C;20) + (EXT_MEM_K\u0026#x3C;\u0026#x3C;10);\n    memory_end \u0026#x26;= 0xfffff000;\n    if (memory_end \u003e 16*1024*1024)\n        memory_end = 16*1024*1024;\n    if (memory_end \u003e 12*1024*1024)\n        buffer_memory_end = 4*1024*1024;\n    else if (memory_end \u003e 6*1024*1024)\n        buffer_memory_end = 2*1024*1024;\n    else\n        buffer_memory_end = 1*1024*1024;\n    main_memory_start = buffer_memory_end;\n#ifdef RAMDISK\n    main_memory_start += rd_init(main_memory_start, RAMDISK*1024);\n#endif\n    mem_init(main_memory_start,memory_end);\n    trap_init();\n    blk_dev_init();\n    chr_dev_init();\n    tty_init();\n    time_init();\n    sched_init();                       // 第四篇已经讲过，负责任务调度模块的初始化\n    buffer_init(buffer_memory_end);     // 本篇的起始，负责缓冲区的初始化\n    hd_init();\n    floppy_init();\n    sti();\n    move_to_user_mode();\n    if (!fork()) {      /* we count on this going ok */\n        init();\n    }\n    for(;;) pause();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebuffer_init(buffer_memory_end);\u003c/code\u003e 用来初始化缓冲区。此处有几个原因:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eCPU 读写操作如果直接操作外存，速度上是一个极大的考验。毕竟内存已经较之 CPU 速度慢，外存的读写速度就更慢了。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e解耦，其实读写操作并不仅仅发生在外存(块存储设备)，同样的，字符设备等等也都会需要读写操作，增加中间层可以封装变化。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e更多，个人了解有限...\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct buffer_head {\n char * b_data;\n unsigned long b_blocknr;\n unsigned short b_dev;\n unsigned char b_uptodate;\n unsigned char b_dirt;\n unsigned char b_count;\n unsigned char b_lock;\n struct task_struct * b_wait;\n struct buffer_head * b_prev;\n struct buffer_head * b_next;\n struct buffer_head * b_prev_free;\n struct buffer_head * b_next_free;\n};\n\n/* from fs/buffer.c */\nvoid buffer_init(long buffer_end)\n{\n    struct buffer_head * h = start_buffer;\n    void * b;\n    int i;\n\n    if (buffer_end == 1\u0026#x3C;\u0026#x3C;20)\n        b = (void *) (640*1024);\n    else\n        b = (void *) buffer_end;\n    while ( (b -= BLOCK_SIZE) \u003e= ((void *) (h+1)) ) {\n        h-\u003eb_dev = 0;\n        h-\u003eb_dirt = 0;\n        h-\u003eb_count = 0;\n        h-\u003eb_lock = 0;\n        h-\u003eb_uptodate = 0;\n        h-\u003eb_wait = NULL;\n        h-\u003eb_next = NULL;\n        h-\u003eb_prev = NULL;\n        h-\u003eb_data = (char *) b;\n        h-\u003eb_prev_free = h-1;\n        h-\u003eb_next_free = h+1;\n        h++;\n        NR_BUFFERS++;\n        /* 跳过 640K ~ 1M 的显存和 BIOS RAM 部分 */\n        if (b == (void *) 0x100000)\n            b = (void *) 0xA0000;\n    }\n    h--;\n    free_list = start_buffer;\n    free_list-\u003eb_prev_free = h;\n    h-\u003eb_next_free = free_list;\n    for (i=0;i\u0026#x3C;NR_HASH;i++)\n        hash_table[i]=NULL;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e缓冲块的所有关键信息都由 \u003ccode\u003ebuffer_head\u003c/code\u003e 数据结构进行记录, 至于有多少个 \u003ccode\u003ebuffer_head\u003c/code\u003e? 只能说能划分多少就划分多少。\u003c/p\u003e\n\u003cp\u003e比较直观的结构信息如下\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fwy2iag1exj31kw0k1dgb.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e在 \u003ccode\u003emain.c\u003c/code\u003e 中已经提前确认了内核程序占用内存的大小，缓冲区大小以及主内存大小。\u003c/p\u003e\n\u003cp\u003e在高速缓冲区的开始位置，都用来存储 \u003ccode\u003ebuffer_head\u003c/code\u003e 的信息，与每个缓冲块(从缓冲区结束位置开始分配)一一对应，直到中间某个位置不足以分配缓冲块为止。\u003c/p\u003e\n\u003cp\u003e另外的信息，就是可以看到一个 \u003ccode\u003ehash_table\u003c/code\u003e 数据结构了。\u003c/p\u003e\n\u003cp\u003e应该都能够想象，每个缓存块与外存中的数据块相对应，通过设备号 + 数据块号进行唯一定位。但是，如何快速查找需要操作的数据块是否已经存在与高速缓存中了呢? 显然直接遍历查找是不太可靠的办法。采用开放地址法的哈希表能够协助快速定位缓冲块。\u003c/p\u003e\n\u003ch2\u003e挂载文件系统\u003c/h2\u003e\n\u003cp\u003e既然高速缓冲区都准备就绪了，那么文件系统是否已经挂载了呢? 很遗憾，知道 \u003ccode\u003emain()\u003c/code\u003e 调用 \u003ccode\u003einit()\u003c/code\u003e 函数之前，文件系统依然没有挂载，也就是说，CPU 仍然只能通过基本输入输出对存储设备进行相当初级的 IO 操作。\u003c/p\u003e\n\u003cp\u003e那么，什么时候才能去挂载根目录呢?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* from init/main.c */\n/* 由 main() 触发 */\nvoid init(void)\n{\n    int pid,i;\n    /* 这是比较重要的一环了，开始挂载的起始动作 */\n    setup((void *) \u0026#x26;drive_info);\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esetup\u003c/code\u003e 函数做了什么呢？这是一个内嵌汇编，主要做的就是触发系统调用 \u003ccode\u003eint 0x80\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e__inline__ int setup(void * BIOS) { \n    long __res; \n    __asm__ volatile (\n            \"int $0x80\" \n            : \"=a\" (__res) \n            : \"0\" (0),\"b\" ((long)(BIOS))\n    ); \n    if (__res \u003e= 0) \n        return (int) __res; \n    errno = -__res; \n    return -1; \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中看到给出的 \u003ccode\u003eEAX = 0\u003c/code\u003e, 查表(表在 \u003ccode\u003einclude/linux/sys.h\u003c/code\u003e 里) 可以知道触发的是 \u003ccode\u003esys_setup\u003c/code\u003e 函数(函数位于 \u003ccode\u003ekernel/blk_drv/hd.c\u003c/code\u003e)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* This may be used only once, enforced by 'static int callable' */\nint sys_setup(void * BIOS)\n{\n    static int callable = 1;\n    int i,drive;\n    unsigned char cmos_disks;\n    struct partition *p;\n    struct buffer_head * bh;\n\n    /* setup 只允许被调用一次 */\n    if (!callable)\n        return -1;\n    callable = 0;\n    /* 可以强制在源码中指定硬盘参数, 所以加了宏定义作判断*/\n#ifndef HD_TYPE\n    for (drive=0 ; drive\u0026#x3C;2 ; drive++) {\n        hd_info[drive].cyl = *(unsigned short *) BIOS;\n        hd_info[drive].head = *(unsigned char *) (2+BIOS);\n        hd_info[drive].wpcom = *(unsigned short *) (5+BIOS);\n        hd_info[drive].ctl = *(unsigned char *) (8+BIOS);\n        hd_info[drive].lzone = *(unsigned short *) (12+BIOS);\n        hd_info[drive].sect = *(unsigned char *) (14+BIOS);\n        BIOS += 16;\n    }\n    if (hd_info[1].cyl)\n        NR_HD=2;\n    else\n        NR_HD=1;\n#endif\n    for (i=0 ; i\u0026#x3C;NR_HD ; i++) {\n        hd[i*5].start_sect = 0;\n        hd[i*5].nr_sects = hd_info[i].head*\n                hd_info[i].sect*hd_info[i].cyl;\n    }\n\n    /*\n        We querry CMOS about hard disks : it could be that\n        we have a SCSI/ESDI/etc controller that is BIOS\n        compatable with ST-506, and thus showing up in our\n        BIOS table, but not register compatable, and therefore\n        not present in CMOS.\n\n        Furthurmore, we will assume that our ST-506 drives\n        \u0026#x3C;if any\u003e are the primary drives in the system, and\n        the ones reflected as drive 1 or 2.\n\n        The first drive is stored in the high nibble of CMOS\n        byte 0x12, the second in the low nibble.  This will be\n        either a 4 bit drive type or 0xf indicating use byte 0x19\n        for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.\n\n        Needless to say, a non-zero value means we have\n        an AT controller hard disk for that drive.\n\n\n    */\n\n    if ((cmos_disks = CMOS_READ(0x12)) \u0026#x26; 0xf0)\n        if (cmos_disks \u0026#x26; 0x0f)\n            NR_HD = 2;\n        else\n            NR_HD = 1;\n    else\n        NR_HD = 0;\n    for (i = NR_HD ; i \u0026#x3C; 2 ; i++) {\n        hd[i*5].start_sect = 0;\n        hd[i*5].nr_sects = 0;\n    }\n    /* 更进一步设置每个盘的参数 */\n    for (drive=0 ; drive\u0026#x3C;NR_HD ; drive++) {\n        /* 0x300 和 0x305 分别代表两个硬盘 */\n        /* 读取每个硬盘的第一块数据 (1024B) */\n        if (!(bh = bread(0x300 + drive*5,0))) {\n            printk(\"Unable to read partition table of drive %d\\n\\r\",\n                drive);\n            panic(\"\");\n        }\n        /* 判断硬盘有效性 */\n        if (bh-\u003eb_data[510] != 0x55 || (unsigned char)\n            bh-\u003eb_data[511] != 0xAA) {\n            printk(\"Bad partition table on drive %d\\n\\r\",drive);\n            panic(\"\");\n        }\n        /* 读取分区表 (位于 引导扇区第 446 字节开始处 */\n        p = 0x1BE + (void *)bh-\u003eb_data;\n        for (i=1;i\u0026#x3C;5;i++,p++) {\n            hd[i+5*drive].start_sect = p-\u003estart_sect;\n            hd[i+5*drive].nr_sects = p-\u003enr_sects;\n        }\n        brelse(bh);\n    }\n    if (NR_HD)\n        printk(\"Partition table%s ok.\\n\\r\",(NR_HD\u003e1)?\"s\":\"\");\n    rd_load();              /* 尝试创建并加载虚拟盘 */\n    mount_root();           /* mount 根文件系统 */\n    return (0);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e终于到了挂载文件系统的时候了\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emount_root\u003c/code\u003e 用来做初级的初始化工作。同时，上一节已经描述过了，存储设备的超级块是用了记录整个文件系统最重要的结构。\u003c/p\u003e\n\u003cp\u003e那么通过将超级块的信息读取到内存，也就可以将内存与外存的文件系统相互联系起来了。\u003c/p\u003e\n\u003cp\u003e下面这段代码最重要的内容就是 \u003ccode\u003eread_super()\u003c/code\u003e 函数了 .\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid mount_root(void)\n{\n    int i,free;\n    struct super_block * p;\n    struct m_inode * mi;\n\n    if (32 != sizeof (struct d_inode))\n        panic(\"bad i-node size\");\n    /* 先初始化文件表，该版本操作系统限制最大同时打开 NR_FILE(64个) 文件 */\n    for(i=0;i\u0026#x3C;NR_FILE;i++)\n        /* f_count = 0 表明没有被引用 */\n        file_table[i].f_count=0;\n    /* 如果引导盘是软盘的话，提示插入根文件系统盘 */\n    if (MAJOR(ROOT_DEV) == 2) {\n        printk(\"Insert root floppy and press ENTER\");\n        wait_for_keypress();\n    }\n    /* 初始化内存超级块数据结构 (总共 8 个) */\n    for(p = \u0026#x26;super_block[0] ; p \u0026#x3C; \u0026#x26;super_block[NR_SUPER] ; p++) {\n        p-\u003es_dev = 0;\n        p-\u003es_lock = 0;\n        p-\u003es_wait = NULL;\n    }\n    /* Hint: 读取超级块的信息，挂载根文件系统重要的部分(代码请往下翻) */\n    if (!(p=read_super(ROOT_DEV)))\n        panic(\"Unable to mount root\");\n    /* 读取文件系统的 1 号i节点 (即该设备上文件系统的根节点) */\n    if (!(mi=iget(ROOT_DEV,ROOT_INO)))\n        panic(\"Unable to read root i-node\");\n    mi-\u003ei_count += 3 ;  /* NOTE! it is logically used 4 times, not 1 */\n    p-\u003es_isup = p-\u003es_imount = mi;\n    /* 应该还记得吧，current 指的是当前的任务(任务1)，以后所有的任务都会由任务1或任务1的子任务进行派生，也就意味着 current-\u003eroot 会一直复制过去\n     * 到这里为止，应该认为根文件系统以及被挂载了。是不是跟被耍了一样?\n     */\n    current-\u003epwd = mi;\n    current-\u003eroot = mi;\n    free=0;\n    i=p-\u003es_nzones;\n    /* 统计还有多少空闲数据块以及多少可用i节点 (附上一张启动过程中打印的信息) */\n    while (-- i \u003e= 0)\n        if (!set_bit(i\u0026#x26;8191,p-\u003es_zmap[i\u003e\u003e13]-\u003eb_data))\n            free++;\n    printk(\"%d/%d free blocks\\n\\r\",free,p-\u003es_nzones);\n    free=0;\n    i=p-\u003es_ninodes+1;\n    while (-- i \u003e= 0)\n        if (!set_bit(i\u0026#x26;8191,p-\u003es_imap[i\u003e\u003e13]-\u003eb_data))\n            free++;\n    printk(\"%d/%d free inodes\\n\\r\",free,p-\u003es_ninodes);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fwz8kvvgbpj30l006i3yb.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e重要要的部分，\u003ccode\u003eread_super(int dev)\u003c/code\u003e，用于读取超级块的数据\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic struct super_block * read_super(int dev)\n{\n    struct super_block * s;\n    struct buffer_head * bh;\n    int i,block;\n\n    if (!dev)\n        return NULL;\n    check_disk_change(dev);\n    /* 如果该超级块已经在内存中了，那么就直接使用 (和这里挂载根文件系统的流程无关) */\n    if (s = get_super(dev))\n        return s;\n    /* 设备超级块不在内存中，就先找一个空闲的内存超级块 (总共维护 8 个超级块数据结构) */\n    for (s = 0+super_block ;; s++) {\n        if (s \u003e= NR_SUPER+super_block)\n            return NULL;\n        if (!s-\u003es_dev)\n            break;\n    }\n    s-\u003es_dev = dev;\n    s-\u003es_isup = NULL;\n    s-\u003es_imount = NULL;\n    s-\u003es_time = 0;\n    s-\u003es_rd_only = 0;\n    s-\u003es_dirt = 0;\n    lock_super(s);\n    /* 通过 block read 读取设备第一个物理块 (每个物理块 1024 B) */\n    if (!(bh = bread(dev,1))) {\n        s-\u003es_dev=0;\n        free_super(s);\n        return NULL;\n    }\n    /* 复制一份超级块的数据 */\n    *((struct d_super_block *) s) =\n        *((struct d_super_block *) bh-\u003eb_data);\n    /* 释放缓冲区的数据 */\n    brelse(bh);\n    /* 验证魔数, 该版本操作系统只支持 1.0 版 Minix 文件系统，魔数 0x137F */\n    if (s-\u003es_magic != SUPER_MAGIC) {\n        s-\u003es_dev = 0;\n        free_super(s);\n        return NULL;\n    }\n    /* 先清空内存中的数据 */\n    for (i=0;i\u0026#x3C;I_MAP_SLOTS;i++)\n        s-\u003es_imap[i] = NULL;\n    for (i=0;i\u0026#x3C;Z_MAP_SLOTS;i++)\n        s-\u003es_zmap[i] = NULL;\n    block=2;\n    /* 读取 i 节点位图块 */\n    for (i=0 ; i \u0026#x3C; s-\u003es_imap_blocks ; i++)\n        if (s-\u003es_imap[i]=bread(dev,block))\n            block++;\n        else\n            break;\n    /* 读取数据块位图 */\n    for (i=0 ; i \u0026#x3C; s-\u003es_zmap_blocks ; i++)\n        if (s-\u003es_zmap[i]=bread(dev,block))\n            block++;\n        else\n            break;\n    if (block != 2+s-\u003es_imap_blocks+s-\u003es_zmap_blocks) {\n        for(i=0;i\u0026#x3C;I_MAP_SLOTS;i++)\n            brelse(s-\u003es_imap[i]);\n        for(i=0;i\u0026#x3C;Z_MAP_SLOTS;i++)\n            brelse(s-\u003es_zmap[i]);\n        s-\u003es_dev=0;\n        free_super(s);\n        return NULL;\n    }\n    s-\u003es_imap[0]-\u003eb_data[0] |= 1;\n    s-\u003es_zmap[0]-\u003eb_data[0] |= 1;\n    /* 与前面的 wait_on_super() 对应(解开lock标志) */\n    free_super(s);\n    return s;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e是不是觉得也没什么，就这样根文件系统已经挂载了? 毫无实感是吧。\u003c/p\u003e\n\u003ch2\u003eExtra: 普通挂载\u003c/h2\u003e\n\u003cp\u003e既然讲过了根文件系统的挂载。那就顺带着讲讲普通文件系统的挂载吧。\u003c/p\u003e\n\u003cp\u003e相信从命令上来讲应该比较简单也比较熟悉吧。\u003ccode\u003emount disk.img /mnt\u003c/code\u003e 也算是挂载到 /mnt 下了\u003c/p\u003e\n\u003cp\u003e但是，究竟是怎么实现的呢?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_mount(char * dev_name, char * dir_name, int rw_flag)\n{\n    struct m_inode * dev_i, * dir_i;\n    struct super_block * sb;\n    int dev;\n\n    /** \n     * 省略大部分判断逻辑, 主要就是:\n     * 1. 判断 dev_name 所属的设备号，读取该设备上的超级块\n     * 2. 读取 dir_name (需要挂载到的位置)，判定是否允许被挂载(比如根节点不允许挂其它设备)\n     */\n    ...\n\n    /* 设置超级块的 mount 标志 */\n    sb-\u003es_imount=dir_i;\n    /* 设置该 i 节点的 mount 标志 */\n    dir_i-\u003ei_mount=1;\n    dir_i-\u003ei_dirt=1;        /* NOTE! we don't iput(dir_i) */\n    return 0;           /* we do that in umount */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e文件读写\u003c/h2\u003e\n\u003cp\u003e前面讲了这么多，终于到了最关心的部分了。当然，也并不是说前面的内容不重要，事实上，相当重要，只是都隐藏在了内核引导的过程中，且调用频度低，才导致了没有存在感。但是这恰恰才是支持文件读写的基石。\u003c/p\u003e\n\u003cp\u003e不多说废话，下面就要开始文件读写的内容。\u003c/p\u003e\n\u003ch3\u003e打开文件\u003c/h3\u003e\n\u003cp\u003e打开文件的函数原型是 \u003ccode\u003eint open(const char * filename, int flag, ...);\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e当然，此类系统调用最终的实现都是 \u003ccode\u003eint 0x80\u003c/code\u003e , 明确一个调用号，然后就陷入内核态了。\u003c/p\u003e\n\u003cp\u003e内核态下调用的函数是: \u003ccode\u003eint sys_open(const char * filename,int flag,int mode)\u003c/code\u003e \u003c/p\u003e\n\u003cp\u003e来看看细节:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_open(const char * filename,int flag,int mode)\n{\n    struct m_inode * inode;\n    struct file * f;\n    int i,fd;\n\n    /*\n     * current 是由内核数据段维护的当前任务的指针\n     * umask 是指当前任务在新建文件时的默认掩码\n     *   例如 Linux 默认是 022, 即新建文件被禁止了组用户与其它用户的写权限\n     * 这里是先确定新建文件的权限\n     */\n    mode \u0026#x26;= 0777 \u0026#x26; ~current-\u003eumask;\n    /*\n     * 文件描述符，每个文件单独维护一套，以数字标记\n     * 找一个空闲的文件描述符项\n     */\n    for(fd=0 ; fd\u0026#x3C;NR_OPEN ; fd++)\n        if (!current-\u003efilp[fd])\n            break;\n    if (fd\u003e=NR_OPEN)\n        return -EINVAL;\n    /*\n     * 顾名思义，设置在调用 exec() 函数时主动关闭的文件\n     * exec() 通常与 fork() 联用，fork() 负责复制一个任务，而 exec 负责替换新任务的代码和数据段(从而产生一个新的任务)\n     * 这里的声明即是复位 fd 位置的标志，允许子任务也持有相同的文件描述符项\n     */\n    current-\u003eclose_on_exec \u0026#x26;= ~(1\u0026#x3C;\u0026#x3C;fd);\n    f=0+file_table;\n    /* 在文件表中找一项空闲的 */\n    for (i=0 ; i\u0026#x3C;NR_FILE ; i++,f++)\n        if (!f-\u003ef_count) break;\n    if (i\u003e=NR_FILE)\n        return -EINVAL;\n    /* 当前任务的文件描述符项指向文件表项, 同时文件表项的引用计数+1*/\n    (current-\u003efilp[fd]=f)-\u003ef_count++;\n    /* 调用 open_namei 打开文件，如果失败则释放刚才占用的文件结构，并返回错误码 */\n    if ((i=open_namei(filename,flag,mode,\u0026#x26;inode))\u0026#x3C;0) {\n        current-\u003efilp[fd]=NULL;\n        f-\u003ef_count=0;\n        return i;\n    }\n    /* \n     * 对不同的文件进行不同的特殊处理, 毕竟有 \"一切皆文件\" 的口号嘛\n     * 诸如字符设备等也都是文件\n     */\n/* ttys are somewhat special (ttyxx major==4, tty major==5) */\n    if (S_ISCHR(inode-\u003ei_mode))\n        if (MAJOR(inode-\u003ei_zone[0])==4) {\n            if (current-\u003eleader \u0026#x26;\u0026#x26; current-\u003etty\u0026#x3C;0) {\n                current-\u003etty = MINOR(inode-\u003ei_zone[0]);\n                tty_table[current-\u003etty].pgrp = current-\u003epgrp;\n            }\n        } else if (MAJOR(inode-\u003ei_zone[0])==5)\n            if (current-\u003etty\u0026#x3C;0) {\n                iput(inode);\n                current-\u003efilp[fd]=NULL;\n                f-\u003ef_count=0;\n                return -EPERM;\n            }\n/* Likewise with block-devices: check for floppy_change */\n    if (S_ISBLK(inode-\u003ei_mode))\n        check_disk_change(inode-\u003ei_zone[0]);\n    /* 初始化内存文件结构的各个参数 */\n    f-\u003ef_mode = inode-\u003ei_mode;\n    f-\u003ef_flags = flag;\n    f-\u003ef_count = 1;\n    f-\u003ef_inode = inode;\n    f-\u003ef_pos = 0;\n    return (fd);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在整个打开文件的过程中，除了真正去文件系统查找文件的时候用到了文件名，其它时候，都将是以文件描述符进行交互的。\u003c/p\u003e\n\u003cp\u003e再看看更细节的方面，毕竟就目前来说，我们跳过了最重要的一环 \u003ccode\u003eopen_namei\u003c/code\u003e ，从而看似整个流程都简单了很多很多。\u003c/p\u003e\n\u003cp\u003e通常我们在编码过程中都是通过绝对地址/相对地址来唯一定位一个文件。因此，就必然存在逐级寻找文件的过程\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic struct m_inode * get_dir(const char * pathname)\n{\n    char c;\n    const char * thisname;\n    struct m_inode * inode;\n    struct buffer_head * bh;\n    int namelen,inr,idev;\n    struct dir_entry * de;\n\n    /* 判定当前任务设定的根节点是否有效 */\n    if (!current-\u003eroot || !current-\u003eroot-\u003ei_count)\n        panic(\"No root inode\");\n    /* 判定当前路径i节点是否有效 */\n    if (!current-\u003epwd || !current-\u003epwd-\u003ei_count)\n        panic(\"No cwd inode\");\n    /* \n     * 这里的 get_fs_byte(..) 是宏定义，fs 指的是 FS 段寄存器\n     * Linux 内核将 DS, ES 用于内核数据段, 用 FS 指向局部描述符表的当前任务数据段\n     * 这里可以简单理解成取字符数组的第一个字节\n     */\n    if ((c=get_fs_byte(pathname))=='/') {\n        inode = current-\u003eroot;\n        pathname++;\n    } else if (c)\n        inode = current-\u003epwd;\n    else\n        return NULL;    /* empty name is bad */\n    inode-\u003ei_count++;\n    while (1) {\n        thisname = pathname;\n        if (!S_ISDIR(inode-\u003ei_mode) || !permission(inode,MAY_EXEC)) {\n            iput(inode);\n            return NULL;\n        }\n        for(namelen=0;(c=get_fs_byte(pathname++))\u0026#x26;\u0026#x26;(c!='/');namelen++)\n            /* nothing */ ;\n        if (!c)\n            return inode;\n        if (!(bh = find_entry(\u0026#x26;inode,thisname,namelen,\u0026#x26;de))) {\n            iput(inode);\n            return NULL;\n        }\n        inr = de-\u003einode;\n        idev = inode-\u003ei_dev;\n        brelse(bh);\n        iput(inode);\n        if (!(inode = iget(idev,inr)))\n            return NULL;\n    }\n}\n\n/*\n *  dir_namei()\n *\n * 处理路径 pathname, 处理成i节点表示的最终一级目录+目录下文件名(也可能pathname表示的就是目录)\n */\nstatic struct m_inode * dir_namei(const char * pathname, int * namelen, const char ** name)\n{\n    char c;\n    const char * basename;\n    struct m_inode * dir;\n\n    if (!(dir = get_dir(pathname)))\n        return NULL;\n    basename = pathname;\n    while (c=get_fs_byte(pathname++))\n        if (c=='/')\n            basename=pathname;\n    *namelen = pathname-basename-1;\n    *name = basename;\n    return dir;\n}\n\n/*\n *  open_namei()\n *\n * namei for open - this is in fact almost the whole open-routine.\n */\nint open_namei(const char * pathname, int flag, int mode,\n    struct m_inode ** res_inode)\n{\n    const char * basename;\n    int inr,dev,namelen;\n    struct m_inode * dir, *inode;\n    struct buffer_head * bh;\n    struct dir_entry * de;\n\n    if ((flag \u0026#x26; O_TRUNC) \u0026#x26;\u0026#x26; !(flag \u0026#x26; O_ACCMODE))\n        flag |= O_WRONLY;\n    mode \u0026#x26;= 0777 \u0026#x26; ~current-\u003eumask;\n    mode |= I_REGULAR;\n    if (!(dir = dir_namei(pathname,\u0026#x26;namelen,\u0026#x26;basename)))\n        return -ENOENT;\n    /* 如果给的 pathname 是一个目录 */\n    if (!namelen) {         /* special case: '/usr/' etc */\n        if (!(flag \u0026#x26; (O_ACCMODE|O_CREAT|O_TRUNC))) {\n            *res_inode=dir;\n            return 0;\n        }\n        iput(dir);\n        return -EISDIR;\n    }\n    /* 找到目录对应的i节点的数据块 */\n    bh = find_entry(\u0026#x26;dir,basename,namelen,\u0026#x26;de);\n    if (!bh) {\n        if (!(flag \u0026#x26; O_CREAT)) {\n            iput(dir);\n            return -ENOENT;\n        }\n        if (!permission(dir,MAY_WRITE)) {\n            iput(dir);\n            return -EACCES;\n        }\n        inode = new_inode(dir-\u003ei_dev);\n        if (!inode) {\n            iput(dir);\n            return -ENOSPC;\n        }\n        inode-\u003ei_uid = current-\u003eeuid;\n        inode-\u003ei_mode = mode;\n        inode-\u003ei_dirt = 1;\n        bh = add_entry(dir,basename,namelen,\u0026#x26;de);\n        if (!bh) {\n            inode-\u003ei_nlinks--;\n            iput(inode);\n            iput(dir);\n            return -ENOSPC;\n        }\n        de-\u003einode = inode-\u003ei_num;\n        bh-\u003eb_dirt = 1;\n        brelse(bh);\n        iput(dir);\n        *res_inode = inode;\n        return 0;\n    }\n    inr = de-\u003einode;\n    dev = dir-\u003ei_dev;\n    brelse(bh);\n    iput(dir);\n    if (flag \u0026#x26; O_EXCL)\n        return -EEXIST;\n    if (!(inode=iget(dev,inr)))\n        return -EACCES;\n    if ((S_ISDIR(inode-\u003ei_mode) \u0026#x26;\u0026#x26; (flag \u0026#x26; O_ACCMODE)) ||\n        !permission(inode,ACC_MODE(flag))) {\n        iput(inode);\n        return -EPERM;\n    }\n    inode-\u003ei_atime = CURRENT_TIME;\n    if (flag \u0026#x26; O_TRUNC)\n        truncate(inode);\n    *res_inode = inode;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e文件写入\u003c/h3\u003e\n\u003cp\u003e接下来就要进行文件写入的流程了\u003c/p\u003e\n\u003cp\u003e如何陷入内核态函数就不再细说了，相信看过这么多系统调用之后，也能知道基本上系统调用在内核态对应的函数都是以 sys_ 形式出现的\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_write(unsigned int fd,char * buf,int count)\n{\n    struct file * file;\n    struct m_inode * inode;\n\n    /* 非法 fd , 抛异常 */\n    if (fd\u003e=NR_OPEN || count \u0026#x3C;0 || !(file=current-\u003efilp[fd]))\n        return -EINVAL;\n    /* count = 0，无需写入数据 */\n    if (!count)\n        return 0;\n    inode=file-\u003ef_inode;\n    /* 针对不同的i节点类型，有不同的写入函数 */\n    if (inode-\u003ei_pipe)\n        return (file-\u003ef_mode\u0026#x26;2)?write_pipe(inode,buf,count):-EIO;\n    if (S_ISCHR(inode-\u003ei_mode))\n        return rw_char(WRITE,inode-\u003ei_zone[0],buf,count,\u0026#x26;file-\u003ef_pos);\n    if (S_ISBLK(inode-\u003ei_mode))\n        return block_write(inode-\u003ei_zone[0],\u0026#x26;file-\u003ef_pos,buf,count);\n    if (S_ISREG(inode-\u003ei_mode))\n        return file_write(inode,file,buf,count);\n    printk(\"(Write)inode-\u003ei_mode=%06o\\n\\r\",inode-\u003ei_mode);\n    return -EINVAL;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e看看对于常规文件是怎么操作的吧。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint file_write(struct m_inode * inode, struct file * filp, char * buf, int count)\n{\n    off_t pos;      /* 偏移量 */\n    int block,c;\n    struct buffer_head * bh;\n    char * p;\n    int i=0;\n\n    /* 如果是 Append 模式，把偏移量重置到文件末尾 */\n    if (filp-\u003ef_flags \u0026#x26; O_APPEND) \n        pos = inode-\u003ei_size;\n    /* 否则就使用当前文件数据结构持有的偏移量 */\n    /*\n        附上数据结构  file 的内容 \n        struct file {\n            unsigned short f_mode;\n            unsigned short f_flags;\n            unsigned short f_count;\n            struct m_inode * f_inode;\n            off_t f_pos;    每个打开的文件都将持有当前的偏移值\n        };\n     */\n    else\n        pos = filp-\u003ef_pos;\n    /* 逐字符向缓冲区写入数据 */\n    while (i\u0026#x3C;count) {\n        /* 最开始当然是创建在磁盘上占用一个数据块了 (如果文件对应的块不存在的话) */\n        if (!(block = create_block(inode,pos/BLOCK_SIZE)))\n            break;\n        /* 根据数据块获得相应的缓冲块 */\n        if (!(bh=bread(inode-\u003ei_dev,block)))\n            break;\n        /* 在缓冲块中的偏移量 */\n        c = pos % BLOCK_SIZE;\n        /* 定位到具体的缓冲区的内存地址 */\n        p = c + bh-\u003eb_data;\n        bh-\u003eb_dirt = 1;\n        /* 当前这个缓冲块还有多少字节可写 */\n        c = BLOCK_SIZE-c;\n        /* 如果需要写入的数据量少于 c */\n        if (c \u003e count-i) c = count-i;\n        /* 添加偏移量计数, 更新数据结构中维护的值 */\n        pos += c;\n        if (pos \u003e inode-\u003ei_size) {\n            inode-\u003ei_size = pos;\n            inode-\u003ei_dirt = 1;\n        }\n        i += c;\n        /* 向缓冲块逐字节写入数据 */\n        while (c--\u003e0)\n            *(p++) = get_fs_byte(buf++);\n        /* 释放对缓冲块的占用，当然，在释放前会完成缓冲块\u0026#x3C;-\u003e外存数据块的同步 */\n        brelse(bh);\n    }\n    inode-\u003ei_mtime = CURRENT_TIME;\n    if (!(filp-\u003ef_flags \u0026#x26; O_APPEND)) {\n        /* 非 APPEND 模式，更新文件读写指针(偏移量); APPEND 模式是使用 inode-\u003ei_size ，所有就不需要在这里更新了 */\n        filp-\u003ef_pos = pos;\n        inode-\u003ei_ctime = CURRENT_TIME;\n    }\n    return (i?i:-1);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e是不是觉得也没有什么太高大上的操作。确实如此，更多关于缓存块与文件系统数据块的同步都已经被包装到 bread(), brelse() 中了。\u003c/p\u003e\n\u003cp\u003e不过，暂时无需细究。总之到此为止，先要有一个基础的观念: 所有与外存储器(这里也包括控制台等)进行数据交互都必须经过缓冲区\u003c/p\u003e\n\u003cp\u003e缓冲区封装了对外存储器的全部操作，而提供给 CPU 更高效的 I/O 操作，当然，也更为简单快捷\u003c/p\u003e\n\u003ch3\u003e文件读取\u003c/h3\u003e\n\u003cp\u003e至于文件读取，也基本类似了，所以也就不再深入描述。\u003c/p\u003e\n\u003cp\u003e当然，要注意的就是，在本篇开始的部分提供的例程中，write \u0026#x26; read 中插入了 \u003ccode\u003eoff_t off = lseek(fd, 0, SEEK_SET);\u003c/code\u003e  这样的代码。\u003c/p\u003e\n\u003cp\u003e原因应该也能够想到，学习 \u003ccode\u003esys_write(..)\u003c/code\u003e 的时候我们已经看到，任务对同一个文件在内存中维护了一个文件读写偏移量。因此，要读取刚才写入的内容，就不得不先改动这个读写偏移量了\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_read(unsigned int fd,char * buf,int count)\n{\n    struct file * file;\n    struct m_inode * inode;\n\n    if (fd\u003e=NR_OPEN || count\u0026#x3C;0 || !(file=current-\u003efilp[fd]))\n        return -EINVAL;\n    if (!count)\n        return 0;\n    verify_area(buf,count);\n    inode = file-\u003ef_inode;\n    if (inode-\u003ei_pipe)\n        return (file-\u003ef_mode\u0026#x26;1)?read_pipe(inode,buf,count):-EIO;\n    if (S_ISCHR(inode-\u003ei_mode))\n        return rw_char(READ,inode-\u003ei_zone[0],buf,count,\u0026#x26;file-\u003ef_pos);\n    if (S_ISBLK(inode-\u003ei_mode))\n        return block_read(inode-\u003ei_zone[0],\u0026#x26;file-\u003ef_pos,buf,count);\n    if (S_ISDIR(inode-\u003ei_mode) || S_ISREG(inode-\u003ei_mode)) {\n        if (count+file-\u003ef_pos \u003e inode-\u003ei_size)\n            count = inode-\u003ei_size - file-\u003ef_pos;\n        if (count\u0026#x3C;=0)\n            return 0;\n        return file_read(inode,file,buf,count);\n    }\n    printk(\"(Read)inode-\u003ei_mode=%06o\\n\\r\",inode-\u003ei_mode);\n    return -EINVAL;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e小结\u003c/h2\u003e\n\u003cp\u003e这篇对文件系统的代码层面的描述，仅仅只是捡了一个相当有限的片面 (常规文件读写)。从文件系统的挂载开始提供了一个读写的完整流程介绍(当然，很多细节是缺失的，不过不要着急)。\u003c/p\u003e\n\u003cp\u003e虽然平常都能够了解到一个比较模糊的前提，文件读写需要利用缓冲区，但是究竟什么是缓存区，如何使用都不会有太多的概念。本篇最大的重点，就是首先请读者们建立起一个基础性的对缓冲区的了解。事实上，这个中介在 I/O 中扮演了相当重要的角色。而且内存也为其提供了相当大的一份空间，差不多有 1/4 了。\u003c/p\u003e\n\u003cp\u003e跨了差不多半个多月来写，上下文的承接可能有些生硬了，甚至不一致了... 尴尬...\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e\u003ca href=\"https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/\"\u003e前一篇\u003c/a\u003e已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。\u003c/p\u003e\n\u003cp\u003e首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \u0026#x3C;stdio.h\u003e\n#include \u0026#x3C;stdlib.h\u003e\n#include \u0026#x3C;string.h\u003e\n#include \u0026#x3C;unistd.h\u003e\n#include \u0026#x3C;fcntl.h\u003e\n#include \u0026#x3C;errno.h\u003e\n#include \u0026#x3C;sys/types.h\u003e\n#include \u0026#x3C;sys/stat.h\u003e\n\nint panic()\n{\n    fprintf(stderr, \"%s (errno=%d)\\n\", strerror(errno), errno);\n    return -1;\n}\n\nint main(int argc, char *argv[])\n{\n    /* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */\n    int fd = open(\"/root/frw.txt\", O_RDWR | O_CREAT);\n    if (fd == -1)\n        return panic();\n\n    /* 向文件写入 Hello World! 共计 12 个字符 */\n    ssize_t wsize = write(fd, \"Hello World!\", 12);\n    if (wsize == -1)\n        return panic();\n\n    /* 重定位文件读写指针 */\n    off_t off = lseek(fd, 0, SEEK_SET);\n    if (off == -1)\n        return panic();\n\n    char* buf = (char *) malloc(wsize);\n    /* 读取文件内容 */\n    ssize_t rsize = read(fd, buf, wsize);\n    if (rsize == -1)\n        return panic();\n\n    printf(\"%s\\n\", buf);\n    free(buf);\n    /* 关闭文件 */\n    int stat = close(fd);\n    if (stat == -1)\n        return panic();\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e"},{"url":"2018-11-16-regex-exponential-explosion","fileName":"2018-11-16-regex-exponential-explosion.md","title":"正则表达式指数爆炸","author":"fangfeng","date":"2018-11-16T00:00:00.000Z","tags":["regular expression","指数爆炸"],"content":"\u003ch2\u003e背景\u003c/h2\u003e\n\u003cp\u003e昨天接触到一个很有意思的问题, 公司测试环境一台机器 CPU 跑到了 400%，导致该机器上的所有服务都挂掉了。\u003c/p\u003e\n\u003cp\u003e最后查到的原因竟然是正则表达式所引起的，大大出乎意料啊。虽然早就知道正则效率很差，但绝对没有想到会导致整个机器上服务崩溃的情况。\u003c/p\u003e\n\u003cp\u003e先简单展示下问题正则:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eString regex = \"(\\\\w+,?)+\";\nString val = \"abcdefghijklmno,abcdefghijklmno+\";\nSystem.out.println(val.matches(regex));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最终的执行时间是 17s 左右。\u003c/p\u003e\n\u003cp\u003e相反，如果改成 \u003ccode\u003eString val = \"abcdefghijklmno,abcdefghijklmno\"\u003c/code\u003e ，实际执行时间 1ms 左右。\u003c/p\u003e\n\u003cp\u003e哈哈，完全不是一个量级的结果。\u003c/p\u003e\n\u003cp\u003e最后，当然是要找原因了:\u0026#x3C; 当然，有其它重要的事在耽搁，没时间去看 Java Regex 源码。不过，从正则本身下手反而是个好事情。毕竟几乎所有的编程语言都有对正则的支持。而同样的，都存在着这样的问题。那就可以大胆猜想其实是和语言本身无关，而在于正则规范本身了。\u003c/p\u003e\n\u003cp\u003e先给个结果，罪魁祸首就是\u003ccode\u003e指数爆炸\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e追本溯源\u003c/h2\u003e\n\u003cp\u003e这里并不准备一步一步地阐述正则的，如果真的是零基础的话，推荐先看一下 \u003ca href=\"https://github.com/ziishaned/learn-regex/blob/master/README-cn.md\"\u003e学习正则\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e就事论事，还是以 \u003ccode\u003eregex ::= (\\w+,?)+\u003c/code\u003e 作为示例来进行说明。\u003c/p\u003e\n\u003cp\u003e首先需要了解的是 \u003ccode\u003eval.matches(regex)\u003c/code\u003e 所要进行的工作是判断 \u003ccode\u003eval\u003c/code\u003e 全串是否符合 \u003ccode\u003eregex\u003c/code\u003e 正则模式。而正则所要做的工作就是尝试所有的匹配可能性(当然，对于 \u003ccode\u003eval\u003c/code\u003e 这个串来说，最后匹配到 \u003ccode\u003eabcd..,abcd..mno+\u003c/code\u003e 的 \u003ccode\u003e+\u003c/code\u003e 的时候一定是失败的，因为 \u003ccode\u003eregex\u003c/code\u003e 并不匹配 \u003ccode\u003e+\u003c/code\u003e)\u003c/p\u003e\n\u003cp\u003e简单扩展一下对\u003ccode\u003e尝试所有匹配可能性\u003c/code\u003e这句话的描述:\u003c/p\u003e\n\u003cp\u003e我们以 \u003ccode\u003e()\u003c/code\u003e 对应 \u003ccode\u003eregex\u003c/code\u003e 中的一组 \u003ccode\u003e(\\w+,?)\u003c/code\u003e ，而最后一个 \u003ccode\u003e+\u003c/code\u003e 表示一个或多个(即允许存在多个\u003ccode\u003e()\u003c/code\u003e)\u003c/p\u003e\n\u003cp\u003e对 \u003ccode\u003eval\u003c/code\u003e 串的匹配可能性有\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e(abcdefghijklmno,)(abcdefghijklmno)+\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e(abcd)(efghijklmno,)(abcdefghijklmno)+\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e(abcdefghijklmno,)(abcdef)(ghijklmno)+\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e(abc)(defghijklmno,)(abcde)(fg)(hijklmno)+\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e...\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e有相当多的匹配可能，不再一一详述(事实上，光靠个人手工根本列举不完。\u003c/p\u003e\n\u003cp\u003e那么到底会有多少中匹配可能性呢?\u003c/p\u003e\n\u003cp\u003e下面我们就来简单计算一下:\u003c/p\u003e\n\u003cp\u003e首先，我们把 \u003ccode\u003e(\\w+,?)+\u003c/code\u003e 这个正则扩展一下，它与下列这些串都是等价的 \u003ccode\u003e(\\w+,|\\w+)+\u003c/code\u003e, \u003ccode\u003e(\\w+,)?(\\w+)?(\\w+,?)+\u003c/code\u003e, \u003ccode\u003e(\\w+,)?(\\w+)?(\\w+)?(\\w+,?)+\u003c/code\u003e ...\u003c/p\u003e\n\u003cp\u003e也就是说，我们能够至少把 \u003ccode\u003eabcdefghijklmno,abcdefghijklmno+\u003c/code\u003e 按照匹配串划分出1组，2组，3组...30组(因为每个组至少需要一个\u003ccode\u003e\\w\u003c/code\u003e )\u003c/p\u003e\n\u003cp\u003e不过这个按照1组，2组...去计算可能性的话实在是费力不讨好的事情。用组合数学来考虑这个问题\u003c/p\u003e\n\u003cp\u003e首先，整个 \u003ccode\u003eabcdefghijklmno,abcdefghijklmno+\u003c/code\u003e 的开始应该有一个左括号 \u003ccode\u003e(\u003c/code\u003e，即 \u003ccode\u003e(abcdefghijklmno,abcdefghijklmno+\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e其次，到 \u003ccode\u003e,\u003c/code\u003e 为止至少应该有一个右左括号 \u003ccode\u003e)(\u003c/code\u003e，即 \u003ccode\u003e(abcdefghijklmno,)(abcdefghijklmno+\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e再次，由于到 \u003ccode\u003eo+\u003c/code\u003e 为止一定匹配失败，因此，\u003ccode\u003e+\u003c/code\u003e 之前应该有一个 \u003ccode\u003e)\u003c/code\u003e, 即 \u003ccode\u003e(abcdefghijklmno,)(abcdefghijklmno)+\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e至于其他字符间的空隙，除了 \u003ccode\u003eo,\u003c/code\u003e 之间不能存在右左括号 \u003ccode\u003e)(\u003c/code\u003e ，其他字符间都可以随意插入 \u003ccode\u003e)(\u003c/code\u003e (至于为什么是右左括号，表示前一个组的结束与新的组的开始)\u003c/p\u003e\n\u003cp\u003e那么总共有多少种可能? \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e插入零个右左括号 \u003ccode\u003e)(\u003c/code\u003e , \u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmsubsup\u003e\u003cmi\u003eC\u003c/mi\u003e\u003cmn\u003e28\u003c/mn\u003e\u003cmn\u003e0\u003c/mn\u003e\u003c/msubsup\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eC_{28}^0\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1.0622159999999998em;vertical-align:-0.24810799999999997em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07153em;\"\u003eC\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t vlist-t2\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141079999999999em;\"\u003e\u003cspan style=\"top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mtight\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e0\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-s\"\u003e​\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.24810799999999997em;\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e = 1 种可行方案\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e插入一个右左括号 \u003ccode\u003e)(\u003c/code\u003e , \u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmsubsup\u003e\u003cmi\u003eC\u003c/mi\u003e\u003cmn\u003e28\u003c/mn\u003e\u003cmn\u003e1\u003c/mn\u003e\u003c/msubsup\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eC_{28}^1\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1.0622159999999998em;vertical-align:-0.24810799999999997em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07153em;\"\u003eC\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t vlist-t2\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141079999999999em;\"\u003e\u003cspan style=\"top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mtight\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-s\"\u003e​\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.24810799999999997em;\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e = 28 种可行方案 (总共 28 个可用字符间隙)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e插入两个右左括号 \u003ccode\u003e)(\u003c/code\u003e , \u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmsubsup\u003e\u003cmi\u003eC\u003c/mi\u003e\u003cmn\u003e28\u003c/mn\u003e\u003cmn\u003e2\u003c/mn\u003e\u003c/msubsup\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eC_{28}^2\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1.0622159999999998em;vertical-align:-0.24810799999999997em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07153em;\"\u003eC\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t vlist-t2\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141079999999999em;\"\u003e\u003cspan style=\"top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mtight\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-s\"\u003e​\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.24810799999999997em;\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e 种可行方案\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e...\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e插入28个右左括号 \u003ccode\u003e)(\u003c/code\u003e , \u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmsubsup\u003e\u003cmi\u003eC\u003c/mi\u003e\u003cmn\u003e28\u003c/mn\u003e\u003cmn\u003e28\u003c/mn\u003e\u003c/msubsup\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eC_{28}^{28}\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1.0622159999999998em;vertical-align:-0.24810799999999997em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07153em;\"\u003eC\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t vlist-t2\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141079999999999em;\"\u003e\u003cspan style=\"top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mtight\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mtight\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-s\"\u003e​\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.24810799999999997em;\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e 种可行方案\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e累加的结果为 \u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmsubsup\u003e\u003cmi\u003eC\u003c/mi\u003e\u003cmn\u003e28\u003c/mn\u003e\u003cmn\u003e1\u003c/mn\u003e\u003c/msubsup\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmsubsup\u003e\u003cmi\u003eC\u003c/mi\u003e\u003cmn\u003e28\u003c/mn\u003e\u003cmn\u003e2\u003c/mn\u003e\u003c/msubsup\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmsubsup\u003e\u003cmi\u003eC\u003c/mi\u003e\u003cmn\u003e28\u003c/mn\u003e\u003cmn\u003e3\u003c/mn\u003e\u003c/msubsup\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmi mathvariant=\"normal\"\u003e.\u003c/mi\u003e\u003cmi mathvariant=\"normal\"\u003e.\u003c/mi\u003e\u003cmi mathvariant=\"normal\"\u003e.\u003c/mi\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmsubsup\u003e\u003cmi\u003eC\u003c/mi\u003e\u003cmn\u003e28\u003c/mn\u003e\u003cmn\u003e28\u003c/mn\u003e\u003c/msubsup\u003e\u003cmo\u003e=\u003c/mo\u003e\u003cmsup\u003e\u003cmn\u003e2\u003c/mn\u003e\u003cmn\u003e28\u003c/mn\u003e\u003c/msup\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eC_{28}^1 + C_{28}^2 + C_{28}^3 + ... + C_{28}^{28} = 2^{28}\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1.0622159999999998em;vertical-align:-0.24810799999999997em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07153em;\"\u003eC\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t vlist-t2\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141079999999999em;\"\u003e\u003cspan style=\"top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mtight\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-s\"\u003e​\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.24810799999999997em;\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1.0622159999999998em;vertical-align:-0.24810799999999997em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07153em;\"\u003eC\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t vlist-t2\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141079999999999em;\"\u003e\u003cspan style=\"top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mtight\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-s\"\u003e​\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.24810799999999997em;\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1.0622159999999998em;vertical-align:-0.24810799999999997em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07153em;\"\u003eC\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t vlist-t2\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141079999999999em;\"\u003e\u003cspan style=\"top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mtight\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e3\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-s\"\u003e​\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.24810799999999997em;\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e.\u003c/span\u003e\u003cspan class=\"mord\"\u003e.\u003c/span\u003e\u003cspan class=\"mord\"\u003e.\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1.0622159999999998em;vertical-align:-0.24810799999999997em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07153em;\"\u003eC\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t vlist-t2\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141079999999999em;\"\u003e\u003cspan style=\"top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mtight\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mtight\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-s\"\u003e​\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.24810799999999997em;\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord\"\u003e2\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141079999999999em;\"\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mtight\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e可想而知为什么会花 17s 了吧。毕竟达到了 2500 万以上的计算量级，加上 regex 本身就是偏慢的。\u003c/p\u003e\n\u003cp\u003e至于为什么把 \u003ccode\u003eabcdefghijklmno,abcdefghijklmno+\u003c/code\u003e 串的 \u003ccode\u003e+\u003c/code\u003e 去掉就变快了？理由也很简单，\u003ccode\u003ematches(regex)\u003c/code\u003e 在正则串与原串匹配上之后就会快速结束，因为结果只需要告知某次匹配成功了即可。而失败的匹配会不断地尝试所有的可能性。\u003c/p\u003e\n\u003ch2\u003e解决方案\u003c/h2\u003e\n\u003cp\u003e至于解决方案，从上面的原因就可以看到，拒绝在贪婪组模式下(\u003ccode\u003e(...)+\u003c/code\u003e) 的组内多模式匹配可能。即 \u003ccode\u003e(a+a+)+\u003c/code\u003e 是不能被允许的，而 \u003ccode\u003e(a+b+)+\u003c/code\u003e 是可靠的。\u003c/p\u003e\n\u003cp\u003e写得仓促，如有根源性错误，欢迎指正。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.regular-expressions.info/catastrophic.html\"\u003eCatastrophic Backtracking(灾难性回溯)\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e背景\u003c/h2\u003e\n\u003cp\u003e昨天接触到一个很有意思的问题, 公司测试环境一台机器 CPU 跑到了 400%，导致该机器上的所有服务都挂掉了。\u003c/p\u003e\n\u003cp\u003e最后查到的原因竟然是正则表达式所引起的，大大出乎意料啊。虽然早就知道正则效率很差，但绝对没有想到会导致整个机器上服务崩溃的情况。\u003c/p\u003e\n\u003cp\u003e先简单展示下问题正则:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eString regex = \"(\\\\w+,?)+\";\nString val = \"abcdefghijklmno,abcdefghijklmno+\";\nSystem.out.println(val.matches(regex));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最终的执行时间是 17s 左右。\u003c/p\u003e\n\u003cp\u003e相反，如果改成 \u003ccode\u003eString val = \"abcdefghijklmno,abcdefghijklmno\"\u003c/code\u003e ，实际执行时间 1ms 左右。\u003c/p\u003e\n\u003cp\u003e哈哈，完全不是一个量级的结果。\u003c/p\u003e\n\u003cp\u003e最后，当然是要找原因了:\u0026#x3C; 当然，有其它重要的事在耽搁，没时间去看 Java Regex 源码。不过，从正则本身下手反而是个好事情。毕竟几乎所有的编程语言都有对正则的支持。而同样的，都存在着这样的问题。那就可以大胆猜想其实是和语言本身无关，而在于正则规范本身了。\u003c/p\u003e\n\u003cp\u003e先给个结果，罪魁祸首就是\u003ccode\u003e指数爆炸\u003c/code\u003e\u003c/p\u003e"},{"url":"2018-12-15-sql-injection","fileName":"2018-12-15-sql-injection.md","title":"SQL 注入","author":"fangfeng","date":"2018-12-15T00:00:00.000Z","tags":["Security","SQL"],"content":"\u003cp\u003e说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。\u003c/p\u003e\n\u003cp\u003e最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。\u003c/p\u003e\n\u003cp\u003e更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: \"我用不用现成的工具只是取决于我想不想自己再写一套\"\u003c/p\u003e\n\u003cp\u003e当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。\u003c/p\u003e\n\u003ch2\u003e概要\u003c/h2\u003e\n\u003cp\u003eSQL 注入漏洞究竟会产生怎么样的危害性，仅仅只是绕过某些登录账号密码的验证? 只是绕过某些访问限制实现特权内容的访问?\u003c/p\u003e\n\u003cp\u003e此前我的认识也仅仅只是停留在这里。可谁曾想，SQL SELECT 语句真的是功能强大啊。通过各种各样的字符串拼接，最终能达到的目的，可以说把整个数据库的内容拖下来也不为过。当然，这也是限定在没有实现分库分表，数据库查询账号的权限过大的前提下。\u003c/p\u003e\n\u003cp\u003e不过，这也就够了。只有真正认识到问题的严重性，最终才会想着去做出一些改善。\u003c/p\u003e\n\u003ch2\u003eSQL 注入技术\u003c/h2\u003e\n\u003ch3\u003e基于布尔的注入\u003c/h3\u003e\n\u003cp\u003e最早接触到 SQL 注入问题，还是两个月前。操作的内容也相当简单，猜解某账号的密码。\u003c/p\u003e\n\u003cp\u003e某接口提供了查询账号的功能，后台的拼接 SQL 可以简单理解成 \u003ccode\u003eSELECT * FROM users WHERE username = '${}'\u003c/code\u003e 。其中 \u003ccode\u003e${}\u003c/code\u003e 就是直接使用的接口请求参数。\u003c/p\u003e\n\u003cp\u003e而接口的请求结果会根据 SQL 查询的结果，有或没有记录呈现两个不同的页面。\u003c/p\u003e\n\u003cp\u003e这算是最简单容易的 SQL 注入了，也是凭借个人能力直接能够想到注入点的问题了。\u003c/p\u003e\n\u003cp\u003e最先做的就是猜解存储密码字段的字段名究竟是什么? 很好，符合常理的设计，直接就是 \u003ccode\u003epasswd\u003c/code\u003e 。\u003c/p\u003e\n\u003cp\u003e下面就是苦力工作，利用 SQL LIKE 操作符，逐一去猜每一位。\u003ccode\u003e${}\u003c/code\u003e 的注入内容就类似 \u003ccode\u003eadmin' AND passwd LIKE '?%\u003c/code\u003e 这里的问号就是逐一猜解的内容(1-9a-zA-Z + 特殊符号)\u003c/p\u003e\n\u003cp\u003e至于为什么利用 LIKE 操作符，很明确，减少猜解的次数。否则，在密码未知的情况下，即使六位密码也有猜解百万次。而 LIKE 操作符能将猜解次数降为线性，\u003ccode\u003e密码长度 * 字符集数\u003c/code\u003e 次\u003c/p\u003e\n\u003cp\u003e这里仅仅用了 \u003ccode\u003eAND\u003c/code\u003e，但熟悉了一个，其它就基本类似了。\u003c/p\u003e\n\u003cp\u003e如果登录也能够注入，认证 SQL 类似 \u003ccode\u003eSELECT * FROM users WHERE username = '${}' AND passwd = '${}'\u003c/code\u003e，那么直接在第一个 \u003ccode\u003e${}\u003c/code\u003e 处注入 \u003ccode\u003eadmin' OR 1=1; --\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003e基于时间的注入\u003c/h3\u003e\n\u003cp\u003e绝大多数时候，注入绝对没有这么简单。也许注入点背后的拼接 SQL 并不对返回值产生影响。例如仅仅只是为了从 DB 查询用户信息，并打一条日志，返回的永远是静态日志（当然，我知道这个例子不恰当，无奈目前只能想到这个）。\u003c/p\u003e\n\u003cp\u003e既然拼接 SQL 总是存在，但没法给我们一个直观的注入成功 OR 失败的提示。那么，时间就成了一个最好的判断。毕竟是阻塞式的执行。\u003c/p\u003e\n\u003cp\u003e还是以 \u003ccode\u003eSELECT * FROM users WHERE username = '${}'\u003c/code\u003e 为例，使用类似 \u003ccode\u003eadmin' AND IF(passwd LIKE '5%', SLEEP(5), 1);--\u003c/code\u003e 的 PAYLOAD ，当满足 \u003ccode\u003epasswd\u003c/code\u003e 以 5 开始时，则 IF 判断进入 \u003ccode\u003eSLEEP(5)\u003c/code\u003e ，根据网页的响应时长就可以进行相应的判断。\u003c/p\u003e\n\u003ch3\u003e基于报错的注入\u003c/h3\u003e\n\u003cp\u003e这应该也算一种比较容易自动化的注入方式了。其实在猜解存储密码字段的字段名时，前面也是这样用的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e\u003e SELECT * FROM users WHERE password ='1';\nERROR 1054 (42S22): Unknown column 'password' in 'where clause'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果程序不做任何处理，对 SQL 错误直接抛出，那么，通过这个就能获得相当多的信息。\u003c/p\u003e\n\u003cp\u003e由于这部分接触不深，仅仅给出 sqlmap 提的 PAYLOAD\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAND (SELECT [RANDNUM] FROM(SELECT COUNT(*),CONCAT('[DELIMITER_START]',([QUERY]),'[DELIMITER_STOP]',FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e很标准的 PAYLOAD，而且完全可以。\u003ccode\u003eINFORMATION_SCHEMA\u003c/code\u003e 库的表对所有用户都可查，因此不存在授权的问题。而且表中数据至少大于等于 3 条。\u003c/p\u003e\n\u003cp\u003e这个 PAYLOAD 一定导致报错的主因，就是对 \u003ccode\u003eRAND()\u003c/code\u003e 与 \u003ccode\u003eGROUP BY\u003c/code\u003e 的配合应用。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUse of a column with RAND() values in an ORDER BY or GROUP BY clause may yield unexpected results because for either clause a RAND() expression can be evaluated multiple times for the same row, each time returning a different result. If the goal is to retrieve rows in random order, you can use a statement like this:\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e而真正想要得到的内容，通过 \u003ccode\u003eCONCAT('[DELIMITER_START]',([QUERY]),'[DELIMITER_STOP]',FLOOR(RAND(0)*2))x\u003c/code\u003e 得到，\u003ccode\u003e[QUERY]\u003c/code\u003e 就是真正想要注入的完整SQL串。\u003c/p\u003e\n\u003cp\u003e而这里的 \u003ccode\u003eDELIMITER_START\u003c/code\u003e \u003ccode\u003eDELIMITER_STOP\u003c/code\u003e 作为界定符，帮助程序提取 \u003ccode\u003e[QUERY]\u003c/code\u003e 得到的结果。否则，直接对请求返回的结果进行过滤可真是太困难了。\u003c/p\u003e\n\u003ch3\u003e联合查询注入\u003c/h3\u003e\n\u003cp\u003e联合查询，应该算是最顾名思义的注入方式。使用 \u003ccode\u003eUNION\u003c/code\u003e 在原 SQL 已经限定了查询表的前提下，获得数据库其它库表的信息。\u003c/p\u003e\n\u003cp\u003eLIKE: \u003ccode\u003e1' UNION SELECT * FROM users;--\u003c/code\u003e 这样的 PAYLOAD。\u003c/p\u003e\n\u003ch3\u003e堆查询注入\u003c/h3\u003e\n\u003cp\u003e我想这应该是最让人摸不着头脑的命名方式了。\u003c/p\u003e\n\u003cp\u003e形象化的，我们利用 PAYLOAD 来进行说明。\u003ccode\u003e1'; INSERT INTO users (user, passwd) VALUES ('aaa', 'aaa');--\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e看起来和 UNION 挺像的哈，都是补充上一个 OR 多个 SQL 。当然，也是有区别的，否则为什么会出现这样一种技术呢。\u003c/p\u003e\n\u003cp\u003e最大的区别，就是堆查询注入能够完成 \u003ccode\u003eUPDATE\u003c/code\u003e, \u003ccode\u003eINSERT\u003c/code\u003e, \u003ccode\u003eDELETE\u003c/code\u003e 等操作，毕竟，UNION 联合的只能是作为查询了（可能说法不太恰当，但姑且这样吧）\u003c/p\u003e\n\u003ch3\u003e另类注入\u003c/h3\u003e\n\u003cp\u003e之前的几种，我们都是利用了 \u003ccode\u003eSELECT\u003c/code\u003e 完成的注入，那么对于 \u003ccode\u003eINSERT\u003c/code\u003e, \u003ccode\u003eUPDATE\u003c/code\u003e 之类的语句是否有注入的可能呢。当然也是存在可能的。\u003c/p\u003e\n\u003cp\u003e不过，精力有限，而且目前看来也不需要做到这一步。暂时挖个坑吧。不填\u003c/p\u003e\n\u003ch2\u003eSQLMAP\u003c/h2\u003e\n\u003cp\u003e简单的了解了几种注入原理之后，还是要看看 SQL 注入神器的——\u003ccode\u003eSQLMAP\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e也算是尝试了好久才真正了解它的强大之处。此处强烈推荐 DVWA，\u003ccode\u003eDamn Vulnerable Web Application\u003c/code\u003e，一个用来合法攻击的工具。\u003c/p\u003e\n\u003cp\u003e部署方式也是开箱可用，只要有 docker，直接 \u003ccode\u003edocker run --rm -it -p 80:80 vulnerables/web-dvwa\u003c/code\u003e 即可完成部署。\u003c/p\u003e\n\u003cp\u003e对于将 DVWA 安全级别设置为 low 时，仅仅只需要执行下列命令就可以获取到 DB 里几乎完整的信息。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ sqlmap -u http://127.0.0.1/vulnerabilities/sqli/\\?id\\=1\\\u0026#x26;Submit\\=Submit\\# --cookie=\"PHPSESSID=jhton35qahj78l3unjea9k2lf7;security=low\" -v 3 --banner\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当然，换一下相关获取的内容，例如把 \u003ccode\u003e--banner\u003c/code\u003e 换成 \u003ccode\u003e--dump\u003c/code\u003e ，我们借此来简单看看 SQL 注入漏洞的可怕之处\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e[10:41:39] [INFO] using default dictionary\ndo you want to use common password suffixes? (slow!) [y/N]\n[10:41:40] [INFO] starting dictionary-based cracking (md5_generic_passwd)\n[10:41:40] [INFO] starting 8 processes\n[10:41:42] [INFO] cracked password 'abc123' for hash 'e99a18c428cb38d5f260853678922e03'\n[10:41:44] [INFO] cracked password 'charley' for hash '8d3533d75ae2c3966d7e0d4fcc69216b'\n[10:41:47] [INFO] cracked password 'letmein' for hash '0d107d09f5bbe40cade3de5c71e9e9b7'\n[10:41:49] [INFO] cracked password 'password' for hash '5f4dcc3b5aa765d61d8327deb882cf99'\n[10:41:53] [DEBUG] post-processing table dump\nDatabase: dvwa\nTable: users\n[5 entries]\n+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+\n| user_id | avatar                      | user    | password                                    | last_name | first_name | last_login          | failed_login |\n+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+\n| 1       | /hackable/users/admin.jpg   | admin   | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin     | admin      | 2018-12-15 00:42:31 | 0            |\n| 2       | /hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123)   | Brown     | Gordon     | 2018-12-15 00:42:31 | 0            |\n| 3       | /hackable/users/1337.jpg    | 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b (charley)  | Me        | Hack       | 2018-12-15 00:42:31 | 0            |\n| 4       | /hackable/users/pablo.jpg   | pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein)  | Picasso   | Pablo      | 2018-12-15 00:42:31 | 0            |\n| 5       | /hackable/users/smithy.jpg  | smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith     | Bob        | 2018-12-15 00:42:31 | 0            |\n+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里就可以看到 \u003ccode\u003edvwa.users\u003c/code\u003e 表的全部内容，甚至连简单密码都帮你完成了爆破。\u003c/p\u003e\n\u003cp\u003e更多内容可以自行尝试，说真的，这个工具相当强大。如果仅仅说我针对某型数据库(例如 MySQL)完成诸如基于报错的注入，在不考虑鲁棒性的情况下，完全可以做到。但是支持超10余种数据库，且自动完成注入的全过程...\u003c/p\u003e\n\u003ch2\u003e预编译 SQL\u003c/h2\u003e\n\u003cp\u003e提了这么多，究竟 SQL 注入就不能够预防吗? 当然可以，不然整个网络环境下的WEB应用不得都完蛋了。有釜底抽薪的处理方式吗，也有。\u003c/p\u003e\n\u003cp\u003e预编译 SQL 就是一个超级 OK 的解决方案。同时在使用上也能够明显提升 DB 查询效率\u003c/p\u003e\n\u003cp\u003e我相信预编译 SQL 很多人写过，毕竟借助例如 MyBatis 框架，能够快速实现 SQL 预编译语句的编写。同时在求学过程中估计也都用过 Java 原生 JDBC 的 \u003ccode\u003ePreparedStatement\u003c/code\u003e 。\u003c/p\u003e\n\u003cp\u003e那么，与 MySQL 交互时的预编译 SQL 是怎么样地填上了占位符呢? 先来看看再说\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003emysql\u003e prepare {name} from 'SELECT * FROM users WHERE user=? AND passwd=?'; # 这里的 {name} 可以自定义命名，无需 {}\n\nmysql\u003e set @a='admin', @b='password';     # 声明变量，并赋值\n\nmysql\u003e execute {name} using @a, @b;     # 提供变量并执行预编译 SQL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我想看到这里应该就应该能够明白了吧，MySQL 对于预编译 SQL 的每一个占位符，都已经认定了是单一的元素，也就不可能存在允许打破已有预编译结果的内容了。\u003c/p\u003e\n\u003cp\u003e即使真的注入了 \u003ccode\u003eadmin OR 1=1\u003c/code\u003e 之类的内容，也是会被认为这是一个完整的字符串，用来替代 \u003ccode\u003euser\u003c/code\u003e 字段或 \u003ccode\u003epasswd\u003c/code\u003e 字段，根本不可能重新拆解。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e __                    __                  \n/ _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。\u003c/p\u003e\n\u003cp\u003e最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。\u003c/p\u003e\n\u003cp\u003e更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: \"我用不用现成的工具只是取决于我想不想自己再写一套\"\u003c/p\u003e\n\u003cp\u003e当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。\u003c/p\u003e"},{"url":"2018-12-28-understand-Kernel-7","fileName":"2018-12-28-understand-Kernel-7.md","title":"理解 Linux Kernel (7) - 字符设备","author":"fangfeng","date":"2018-12-28T00:00:00.000Z","tags":["Linux","Kernel","Char Dev"],"content":"\u003cp\u003e相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。\u003c/p\u003e\n\u003cp\u003e回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。\u003c/p\u003e\n\u003cp\u003e那么，常见的字符设备有什么？显示器、键盘、鼠标。\u003c/p\u003e\n\u003ch2\u003e宏观概览\u003c/h2\u003e\n\u003cp\u003e通常在我们的认识中，命令行终端就被认为是与一套字符设备相配合来使用的。很正常嘛。我们打开一个 Shell ，通过键盘输入一些字符，配合显示器把这些经过加工的字符展示出来。\u003c/p\u003e\n\u003cp\u003e那么，是不是就意味着 Shell 作为一个任务(进程)，以键盘设备作为标准输入，以显示设备作为标准输出?\u003c/p\u003e\n\u003cp\u003e看看一个 1 号任务 \u003ccode\u003e/bin/bash\u003c/code\u003e 的文件描述符说明吧。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ ls -al\ntotal 0\ndr-x------ 2 root root  0 Dec 13 23:20 .\ndr-xr-xr-x 9 root root  0 Dec 13 23:20 ..\nlrwx------ 1 root root 64 Dec 13 23:20 0 -\u003e /dev/pts/0\nlrwx------ 1 root root 64 Dec 13 23:20 1 -\u003e /dev/pts/0\nlrwx------ 1 root root 64 Dec 13 23:20 2 -\u003e /dev/pts/0\nlrwx------ 1 root root 64 Dec 25 01:09 255 -\u003e /dev/pts/0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里文件描述符 0, 1, 2 分别表示任务的标准输入、标准输出、标准错误。这些内容在表现形式上做了一个链接。\u003c/p\u003e\n\u003cp\u003e那么，\u003ccode\u003e/dev/pts/0\u003c/code\u003e 是什么? \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003ecrw--w---- 1 root tty 136, 0 Dec 13 23:20 /dev/pts/0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e一个字符设备。到此为止，似乎和最初预想的有比较大的区别。至少在假象中，至少是一个输入(键盘)，一个输出(显示器)。怎么就混成了一个呢？\u003c/p\u003e\n\u003cp\u003e本来是怎么都想不通的，但后来配合\"Unix一切皆文件\"的信条，总算是有点明白了。\u003c/p\u003e\n\u003cp\u003e相信大家都有这这样的经历，某个程序是以键盘输入作为标准输入的。其实就和上面👆展示的一样 \u003ccode\u003e0 -\u003e /dev/pts/0\u003c/code\u003e 。那么，有没有考虑过这整套流程是怎么协作的呢？\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyjvtjiu0zj31980oqmxe.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e对于程序来说，我们还是普通的调用 \u003ccode\u003eread\u003c/code\u003e, \u003ccode\u003ewrite\u003c/code\u003e 等经过封装的函数，来读取一个所谓的文件。\u003c/p\u003e\n\u003cp\u003e但对于文件是字符设备时，最终调用的就是 \u003ccode\u003etty_read\u003c/code\u003e, \u003ccode\u003etty_write\u003c/code\u003e 了。通俗的讲，大概率的就是键盘作为输入，显示器作为输出了。\u003c/p\u003e\n\u003ch2\u003e源码剖析\u003c/h2\u003e\n\u003ch3\u003e文件读写\u003c/h3\u003e\n\u003cp\u003e这部分上一篇已经介绍过了，不做过多说明。\u003c/p\u003e\n\u003cp\u003e简单回顾下 \u003ccode\u003esys_read\u003c/code\u003e 函数\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_read(unsigned int fd,char * buf,int count)\n{\n    struct file * file;\n    struct m_inode * inode;\n\n    if (fd\u003e=NR_OPEN || count\u0026#x3C;0 || !(file=current-\u003efilp[fd]))\n        return -EINVAL;\n    if (!count)\n        return 0;\n    verify_area(buf,count);\n    inode = file-\u003ef_inode;\n    if (inode-\u003ei_pipe)\n        return (file-\u003ef_mode\u0026#x26;1)?read_pipe(inode,buf,count):-EIO;\n    /* 确认到i节点描述的是字符设备 */\n    if (S_ISCHR(inode-\u003ei_mode)) \n        return rw_char(READ,inode-\u003ei_zone[0],buf,count,\u0026#x26;file-\u003ef_pos);\n    if (S_ISBLK(inode-\u003ei_mode))\n        return block_read(inode-\u003ei_zone[0],\u0026#x26;file-\u003ef_pos,buf,count);\n    if (S_ISDIR(inode-\u003ei_mode) || S_ISREG(inode-\u003ei_mode)) {\n        if (count+file-\u003ef_pos \u003e inode-\u003ei_size)\n            count = inode-\u003ei_size - file-\u003ef_pos;\n        if (count\u0026#x3C;=0)\n            return 0;\n        return file_read(inode,file,buf,count);\n    }\n    printk(\"(Read)inode-\u003ei_mode=%06o\\n\\r\",inode-\u003ei_mode);\n    return -EINVAL;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003eS_ISCHR()\u003c/code\u003e 就是在对i节点的类型进行判别，从而进行不同的分发。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic crw_ptr crw_table[]={\n    NULL,       /* nodev */\n    rw_memory,  /* /dev/mem etc */\n    NULL,       /* /dev/fd */\n    NULL,       /* /dev/hd */\n    rw_ttyx,    /* /dev/ttyx */\n    rw_tty,     /* /dev/tty */\n    NULL,       /* /dev/lp */\n    NULL};      /* unnamed pipes */\n/**\n * 这段还是涉及到分发，由不同的设备号(dev) 来确定执行函数 (ttyx, 串口终端; tty, 控制台终端; mem, /dev/mem 等)\n * crw_ptr 是 C 语言中常见的函数指针。由dev号来确定调用哪个函数\n */\nint rw_char(int rw,int dev, char * buf, int count, off_t * pos)\n{\n    crw_ptr call_addr;\n\n    if (MAJOR(dev)\u003e=NRDEVS)\n        return -ENODEV;\n    if (!(call_addr=crw_table[MAJOR(dev)]))\n        return -ENODEV;\n    return call_addr(rw,MINOR(dev),buf,count,pos);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e执行到 \u003ccode\u003erw_tty\u003c/code\u003e, \u003ccode\u003erw_ttyx\u003c/code\u003e 两个函数，就将对读/写进行区分，并由特定的函数进行处理。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic int rw_ttyx(int rw,unsigned minor,char * buf,int count,off_t * pos)\n{\n    return ((rw==READ)?tty_read(minor,buf,count):\n        tty_write(minor,buf,count));\n}\n\nstatic int rw_tty(int rw,unsigned minor,char * buf,int count, off_t * pos)\n{\n    if (current-\u003etty\u0026#x3C;0)\n        return -EPERM;\n    return rw_ttyx(rw,current-\u003etty,buf,count,pos);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到此为止，应该能够基本了解了字符设备，作为 Linux 的文件，所应该有的读写的相关支持。\u003c/p\u003e\n\u003cp\u003e但是，究竟读、写的内容在哪呢？比如正规文件，都很容易地可以理解到，就是从磁盘中取出某个/某几个盘块的内容即可。字符设备的IO要从哪里取(往哪里送)数据呢?\u003c/p\u003e\n\u003ch3\u003e字符设备驱动\u003c/h3\u003e\n\u003cp\u003e对于设备驱动这个概念，至今没有搞清楚。不过，这不妨碍对代码的理解。反正对于字符设备驱动来说，也就是 Linux 内核中的一些软件层面的代码，与普通代码的唯一区别，就是对外设硬件做了相应的交互支持。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fykyc6lo9pj31i40u0ac8.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e承接操作系统的字符设备接口，\u003ccode\u003etty_read\u003c/code\u003e、\u003ccode\u003etty_write\u003c/code\u003e 负责读入和写出。\u003c/p\u003e\n\u003cp\u003e从哪里读？\u003ccode\u003esecondary\u003c/code\u003e 数据队列；往哪里写？\u003ccode\u003ewrite_q\u003c/code\u003e 数据队列。\u003c/p\u003e\n\u003cp\u003e同时，也可以看到，与这些队列直接相关的，就是我们熟知的键盘和显示器了。是不是有了点豁然开朗的感觉。\u003c/p\u003e\n\u003cp\u003e好，我们先来看看这里描述的三个队列究竟是怎么工作的。这里就不得不先看看内存中抽象出来的描述终端的数据结构 \u003ccode\u003etty_struct\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/**\n * copied from include/linux/tty.h\n */\nstruct tty_struct {\n    struct termios termios;     /* terminal IO conf */\n    int pgrp;                   /* 所属进程组 */\n    int stopped;                /* 停止标志 */\n    void (*write)(struct tty_struct * tty); /* 终端写函数指针 */\n    struct tty_queue read_q;    /* 终端读队列 */\n    struct tty_queue write_q;   /* 终端写队列 */\n    struct tty_queue secondary; /* 终端辅助队列 */\n};\n\n/**\n * copied from include/termios.h\n */\nstruct termios {                /* terminal IO 属性 */\n    unsigned long c_iflag;      /* input mode flags */\n    unsigned long c_oflag;      /* output mode flags */\n    unsigned long c_cflag;      /* control mode flags */\n    unsigned long c_lflag;      /* local mode flags */\n    unsigned char c_line;       /* line discipline */\n    unsigned char c_cc[NCCS];   /* control characters */\n};\n\n/**\n * copied from include/linux/tty.h\n */\nstruct tty_queue {\n    unsigned long data;         /* 字符行数量 | 串口终端则存储端口号 */\n    unsigned long head;         /* 头指针 */\n    unsigned long tail;         /* 尾指针 */\n    struct task_struct * proc_list; /* 等待该终端的任务队列 */\n    char buf[TTY_BUF_SIZE];     /* 队列的缓冲区 */\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于任何任务需要读写字符设备(这里指终端设备)，最终直接读取/写入到的就是 \u003ccode\u003esecondary\u003c/code\u003e 和 \u003ccode\u003ewrite_q\u003c/code\u003e。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e这里可能有个小小的疑问? 为什么读终端设备不是读 \u003ccode\u003eread_q\u003c/code\u003e 呢？\u003c/p\u003e\n\u003cp\u003e其实也比较好解释，相信日常在操作命令行的时候，我们在键盘上敲击的键位与显示器上实际展示的内容是不相匹配的。最普通的，我们键入了 \u003cstrong\u003edelete(删除键)\u003c/strong\u003e，为什么不是一个 \u003cstrong\u003edelete\u003c/strong\u003e 对应的 ascii (当然，这里请先忽视非打印字符的问题)，而是删除了最后一个字符呢？完全可以想象，反正任何键位与驱动交互的时候都是传入一串二进制码嘛。\u003c/p\u003e\n\u003cp\u003e这里的 \u003ccode\u003esecondary\u003c/code\u003e 完成的就是怎么一个工作，\u003ccode\u003eread_q\u003c/code\u003e 存储的是所有的外设(这里是键盘)的输入，并原样存储。而到了 \u003ccode\u003esecondary\u003c/code\u003e 就是经过相应的加工，诸如控制字符之类的都展现了各自的意义，并完成一些加工工作，而不再仅仅只是普通地展示了。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e另外，可能还有一个问题。虽然我们已经习惯了在命令行交互时，所有的输入都将直接在显示器上进行展示，好像我们在直接往显示器上写内容。但是，前面我们描述的内容都是，键盘设备作为输入，是要写到 \u003ccode\u003eread_q\u003c/code\u003e 乃至 \u003ccode\u003esecondary\u003c/code\u003e 并最终作为进程的输入的。在显示器上显示并不是它本来应该干的事情 (比较显示器上展示的应该是 \u003ccode\u003ewrite_q\u003c/code\u003e 的内容，也就是进程的标准输出)\u003c/p\u003e\n\u003cp\u003e事实上，这仅仅只是一个回显，将 \u003ccode\u003esecondary\u003c/code\u003e 队列的内容复制了一份到写队列，也就呈现出让显示器打印相应键盘输入的效果了。\u003c/p\u003e\n\u003cp\u003e同时，这也就能够直接解释为什么我们在使用 \u003ccode\u003epasswd\u003c/code\u003e, \u003ccode\u003esu\u003c/code\u003e, \u003ccode\u003esudo\u003c/code\u003e 等命令时，要求输入密码都是不在显示器上回显的。实现也相当简单了嘛。把 tty_struct.termios 的相应控制属性 (ECHO) 重置，就可以实现不回显的效果了。\u003c/p\u003e\n\u003ch3\u003e终端设备交互\u003c/h3\u003e\n\u003cp\u003e最后一部分，应该也是最关心的了。外设如何与操作系统完成交互。其实也能够想得到了——中断。\u003c/p\u003e\n\u003cp\u003e在操作系统初始化时，就把中断描述符表的中断表项配置得当。之后的事情就是等待键盘等外设输入的中断信号了。\u003c/p\u003e\n\u003cp\u003e又看回到了 \u003ccode\u003einit/main.c\u003c/code\u003e 程序\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid main(void)\n{\n    ...\n    trap_init();\n    blk_dev_init();\n    chr_dev_init(); /* 块设备相关初始化, 方法体是空的，没有实现 */\n    tty_init();     /* tty 终端设备初始化 */\n    time_init();\n    sched_init();\n    buffer_init(buffer_memory_end);\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e/**\n * Copied from kernel/chr_drv/tty_io.c\n * 终端设备初识化\n */\nvoid tty_init(void)\n{\n    /** 串口设备初始化 */\n    rs_init();\n    /** 控制台设备初始化 */\n    con_init();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至于为什么有两种初始化方式。这来源于终端又区分为控制台终端与串口终端，区别就是一个是直接建立在主机上，串口终端是通过串行接口连接到主机的。当然，这都是古老的方式了，细节就不太清楚了。\u003c/p\u003e\n\u003cp\u003e下面来看看 \u003ccode\u003econ_init()\u003c/code\u003e 做了哪些工作(\u003ccode\u003ers_init()\u003c/code\u003e 的内容请自行了解)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid con_init(void)\n{\n    register unsigned char a;\n    char *display_desc = \"????\";\n    char *display_ptr;\n\n    /**\n     * 读取 setup.s 程序预处理的内容\n     * 包括显示器的各种配置参数\n     */\n    video_num_columns = ORIG_VIDEO_COLS;\n    video_size_row = video_num_columns * 2;\n    video_num_lines = ORIG_VIDEO_LINES;\n    video_page = ORIG_VIDEO_PAGE;\n    video_erase_char = 0x0720;\n\n    /**\n     * 读取显示器的配置并进行相关设置 (省略代码)\n     */\n    ...\n\n    origin  = video_mem_start;\n    scr_end = video_mem_start + video_num_lines * video_size_row;\n    top = 0;\n    bottom  = video_num_lines;\n\n    gotoxy(ORIG_X,ORIG_Y);\n    /** 设置陷阱门 */\n    set_trap_gate(0x21,\u0026#x26;keyboard_interrupt);\n    outb_p(inb_p(0x21)\u0026#x26;0xfd,0x21);\n    a=inb_p(0x61);\n    outb_p(a|0x80,0x61);\n    outb(a,0x61);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e应该能够看到最重要的内容就是\u003cstrong\u003e设置键盘中断陷阱门\u003c/strong\u003e了。\u003c/p\u003e\n\u003cp\u003e之后只有静静地等待键位敲击，也就能够产生硬件中断，从而让 \u003ccode\u003eread_q\u003c/code\u003e 获得到相应的字符输入。\u003c/p\u003e\n\u003cp\u003e至于键盘中断的相应处理流程，这里不再详述。简述一些步骤:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e产生硬中断 \u003ccode\u003ekeyboard_interrupt\u003c/code\u003e，由程序 \u003ccode\u003eKeyboard.s\u003c/code\u003e 的汇编代码进行处理\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e根据不同的键盘(US 键盘、德式键盘等等)将获得的键位信号进行相应的字符转换(查转换表)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e调用 \u003ccode\u003edo_tty_interrupt\u003c/code\u003e 处理函数 (确认是给哪个终端的信号)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e调用 \u003ccode\u003ecopy_to_cooked(tty)\u003c/code\u003e ，即完成 \u003ccode\u003eread_q\u003c/code\u003e 到 \u003ccode\u003esecondary\u003c/code\u003e 的相关加工。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。\u003c/p\u003e\n\u003cp\u003e回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。\u003c/p\u003e\n\u003cp\u003e那么，常见的字符设备有什么？显示器、键盘、鼠标。\u003c/p\u003e"},{"url":"2019-01-15-understand-Kernel-8","fileName":"2019-01-15-understand-Kernel-8.md","content":"\u003cp\u003etitle: 理解 Linux Kernel (8) - 网络\nauthor: fangfeng\ndate: 2019-01-15\ntags:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinux\u003c/li\u003e\n\u003cli\u003eKernel\u003c/li\u003e\n\u003cli\u003eNetwork\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e{% pdf \u003ca href=\"https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview\"\u003ehttps://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview\u003c/a\u003e %}\u003c/p\u003e","digest":"\u003cp\u003etitle: 理解 Linux Kernel (8) - 网络\nauthor: fangfeng\ndate: 2019-01-15\ntags:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinux\u003c/li\u003e\n\u003cli\u003eKernel\u003c/li\u003e\n\u003cli\u003eNetwork\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e{% pdf \u003ca href=\"https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview\"\u003ehttps://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview\u003c/a\u003e %}\u003c/p\u003e"},{"url":"2019-02-02-unicode","fileName":"2019-02-02-unicode.md","content":"\u003cp\u003etitle: 字符集与字符编码\nauthor: fangfeng\ndate: 2019-02-02\ntags:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUnicode\u003c/li\u003e\n\u003cli\u003eCharacter Encoding\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e{% pdf \u003ca href=\"https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview\"\u003ehttps://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview\u003c/a\u003e %}\u003c/p\u003e","digest":"\u003cp\u003etitle: 字符集与字符编码\nauthor: fangfeng\ndate: 2019-02-02\ntags:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUnicode\u003c/li\u003e\n\u003cli\u003eCharacter Encoding\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e{% pdf \u003ca href=\"https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview\"\u003ehttps://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview\u003c/a\u003e %}\u003c/p\u003e"},{"url":"2019-02-27-Java-Fatal-API","fileName":"2019-02-27-Java-Fatal-API.md","title":"【Java】API 参数误定义的后果","author":"fangfeng","date":"2019-02-27T00:00:00.000Z","tags":["Java","API"],"content":"\u003cp\u003e工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。\u003c/p\u003e\n\u003cp\u003e想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！\u003c/p\u003e\n\u003cp\u003e想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把\u003ccode\u003evoid add(int)\u003c/code\u003e API 改写成 \u003ccode\u003eint add(int)\u003c/code\u003e，可能得到的大多数回答都是可以。\u003c/p\u003e\n\u003ch2\u003e看山是山\u003c/h2\u003e\n\u003cp\u003e首先举一个具体点的例子来描述（为了方便，就不定义\u003ccode\u003eCountService\u003c/code\u003e的接口类了）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.ffutop.signature;\n\n/**\n * 主类\n * @author fangfeng\n * @since 2019-02-26\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        CountService countService = new CountService();\n        countService.add(1);\n        System.out.println(String.format(\"currentValue = %d\", countService.getCurrentValue()));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.ffutop.signature;\n\n/**\n * @author fangfeng\n * @since 2019-02-26\n */\npublic class CountService {\n\n    private int currentValue = 0;\n\n    /**\n     * 请把 add(int) 理解成 API\n     * 虽然已经做了实现\n     */\n    public void add(int addend) {\n        currentValue += addend;\n    }\n\n    public int getCurrentValue() {\n        return currentValue;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在已经有 \u003ccode\u003evoid add(int)\u003c/code\u003e 方法，完成的工作是累加。现在要把 API 改成 \u003ccode\u003eint add(int)\u003c/code\u003e，是否可以呢？看似本来没有返回值，现在只是加上一个返回值，对于原来的代码没有任何问题，而新代码又能拿到int类型的返回值，皆大欢喜啊。\u003c/p\u003e\n\u003ch2\u003e看山不是山\u003c/h2\u003e\n\u003cp\u003e先给大家执行下代码吧！（请严格按照顺序，且避免使用IDE，否则将得不到预想的结果）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ # 准备好两个类的代码（CountService的API是 `void add(int)`）\n$ # 编译Main类\n$ javac com/ffutop/signature/Main.java\n$  \n$ # 修改CountService的API为`int add(int)`\n$ # 编译 CountService 类\n$ javac com/ffutop/signature/CountService.java\n$ \n$ # 执行主程序\n$ java com.ffutop.signature.Main\nException in thread \"main\" java.lang.NoSuchMethodError: com.ffutop.signature.CountService.add(I)V\n    at com.ffutop.signature.Main.main(Main.java:11)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e很遗憾，执行失败了，报了个Error（没有这样的方法）。方法写的是 \u003ccode\u003ecom.ffutop.signature.CountService.add(I)V\u003c/code\u003e 。简单的翻译一下就是需要\u003ccode\u003e类名+方法名=x.y.CountService.add\u003c/code\u003e，且入参为int，出参为void的方法（想了解更多请优先学习\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4\"\u003eJava ClassFile Format\u003c/a\u003e）。\u003c/p\u003e\n\u003cp\u003e那么，现在得到的结论是不行。\u003c/p\u003e\n\u003ch2\u003e看山还是山\u003c/h2\u003e\n\u003cp\u003e那么，就一定不行吗？都是同名方法，不同参数。凭什么改个入参是可以的，改个出参就不行了。\u003c/p\u003e\n\u003cp\u003e从 Java 的角度来说，一定不行。“同一类中不能存在两个名字及描述符完全相同的方法”\u003c/p\u003e\n\u003cp\u003e但是，如果从 JVM 的角度来说，完全是可行的。“在class文件中，两个方法可以拥有完全相同的特征签名，前提是返回值不能相同”\u003c/p\u003e\n\u003cp\u003e什么意思呢？我们都知道建立在 JVM 之上的语言不只有 Java。像 Groovy、Kotlin 等语言都实现了各自的区别于 Java 独有的特征。这些特征的实现都是依赖于 JVM，但为什么 Java 没有呢？只能说 Java 语言的规范是 JVM 的子集（好像这话有点不严谨啊）\u003c/p\u003e\n\u003cp\u003e通过直接操作字节码，就能够达到在同一个类中建立两个同名、相同入参，但返回值不同的方法。\n先通过\u003ccode\u003ejavap\u003c/code\u003e命令看看最终提供的\u003ccode\u003eCountService.class\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ javap com.ffutop.signature.CountService\npublic class com.ffutop.signature.CountService {\n  public int add(int);\n  public com.ffutop.signature.CountService();\n  public void add(int);\n  public int getCurrentValue();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e有两个同名的方法\u003ccode\u003eadd(int)\u003c/code\u003e，至于执行，也会相当顺利。\u003c/p\u003e\n\u003cp\u003e还是写个程序来说明，在原有 \u003ccode\u003eMain.java\u003c/code\u003e 的基础上，再创建一个全限定名为 \u003ccode\u003ecom.ffutop.signature.other.Main2\u003c/code\u003e 的类\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.ffutop.signature.other;\nimport com.ffutop.signature.CountService;\n\n/**\n * @author fangfeng\n * @since 2019-02-27\n */\npublic class Main2 {\n\n    public static void main(String[] args) {\n        CountService countService = new CountService();\n        System.out.println(String.format(\"currentValue = %d\", countService.add(1)));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e与 Main.java 比较，很明显的就是一个调用了 \u003ccode\u003eCountService\u003c/code\u003e 的 \u003ccode\u003eint add(int)\u003c/code\u003e 方法，而另一个调用 \u003ccode\u003evoid add(int)\u003c/code\u003e 方法。\u003c/p\u003e\n\u003cp\u003e那么是否有效呢？先来验证一下（这里要模拟的一个场景是，CountService 类(只有 \u003ccode\u003evoid add(int)\u003c/code\u003e 方法)作为二方库C.jar version 1.0 的主要服务类。CountService 类(同时有 \u003ccode\u003evoid add(int)\u003c/code\u003e 和 \u003ccode\u003eint add(int)\u003c/code\u003e 方法)作为二方库C.jar version 2.0 的主要服务类。Main 类根据 C.jar version 1.0 做的编译，而 Main2 类根据 C.jar version 2.0 做的编译。在 Main 和 Main2 类运行时只提供 C.jar version 2.0）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ # 编译 Main 类和 CountService 类\n$ javac com/ffutop/signature/Main.java\n$\n$ # 操作 CountService.class 字节码，增加方法 `int add(int)` \n$ # 通过 ASM 实现，详见附录源码 com/ffutop/signature/support/Generator.java\n$ \n$ # 编译 Main2 类 (提供 classpath，即根据 CountService.class 编译)\n$ javac com/ffutop/signature/other/Main2.java -classpath .\n$\n$ # 验证\n$ java com.ffutop.signature.Main\ncurrentValue = 1\n$ java com.ffutop.signature.other.Main2\ncurrentValue = 1\n$ # OK，验证通过\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e一旦 API 定义错误，并已经作为二方库提供给调用方。后果必然是灾难性的。至少，只能重新定义 API 。如果对于入参定义错误，Java 语言级别也能够支持。但如果是返回值，如果非要保持方法名一致，那就不得不下沉到 JVM 级别来进行处理了。当然，在工程项目中是否应该直接操作字节码？至少个人还没直接接触过。\u003c/p\u003e\n\u003cp\u003e做个记录，未来可以翻一翻，至少是一种可行的解决方案。\u003c/p\u003e\n\u003cp\u003eUpdate: 如果直接操作字节码为添加了不同返回值的同名同参数方法，可能引起调用方静态编译失败。此操作需慎之又慎。也许提供类加载器加载时的字节码操作能更加完美地解决这个问题。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/signature.zip\"\u003e源码.zip\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。\u003c/p\u003e\n\u003cp\u003e想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！\u003c/p\u003e\n\u003cp\u003e想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把\u003ccode\u003evoid add(int)\u003c/code\u003e API 改写成 \u003ccode\u003eint add(int)\u003c/code\u003e，可能得到的大多数回答都是可以。\u003c/p\u003e"},{"url":"2019-03-05-understand-Kernel-9","fileName":"2019-03-05-understand-Kernel-9.md","title":"理解 Linux Kernel (9) - IO Multiplexing","author":"fangfeng","date":"2019-03-05T00:00:00.000Z","tags":["Linux","Kernel","IO Model"],"content":"\u003cp\u003e\u003ca href=\"./2019-01-15-understand-Kernel-8/\"\u003e前一篇\u003c/a\u003e已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 \u003ccode\u003estruct sock\u003c/code\u003e 对象，将其逐级从网络接口层逐级提升到网络层、传输层...最终添加到接收队列 \u003ccode\u003esk_receive_queue\u003c/code\u003e 中；用户进程通过 \u003ccode\u003eread\u003c/code\u003e、\u003ccode\u003erecv\u003c/code\u003e、\u003ccode\u003erecvfrom\u003c/code\u003e 等命令检查并获取 \u003ccode\u003esk_receive_queue\u003c/code\u003e 中的数据。\u003c/p\u003e\n\u003cp\u003e整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。\u003c/p\u003e\n\u003cp\u003e那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（\u003ccode\u003eselect\u003c/code\u003e, \u003ccode\u003epoll\u003c/code\u003e, \u003ccode\u003eepoll\u003c/code\u003e）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 \u003ccode\u003eselect\u003c/code\u003e 和 \u003ccode\u003eepoll\u003c/code\u003e 两类系统调用的实现进行探究。\u003c/p\u003e\n\u003ch2\u003eSELECT\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eselect\u003c/code\u003e 是一种比较古老的系统调用方式，存在着许多的调用限制。当然，相对的也就比较容易理解。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eselect\u003c/code\u003e 系统调用最初的逻辑就是对超时时间的相关操作，完成从用户数据段到内核数据段的数据拷贝工作，而使用 \u003ccode\u003ecopy_from_user\u003c/code\u003e 的目的，虽然看似比较晦涩，不如大家在用户程序中普通调用的memcpy，但究其原因，是为了处理MMU相关的问题。将内核复制的数据timeval做一定的取整操作（因为硬件中断的精度可能达不到timeval所描述的粒度，故根据HZ做取整，恰好为时钟中断周期的整数倍）。调用 \u003ccode\u003ecore_sys_select\u003c/code\u003e 进行真正的轮询操作（当然，好像也算不上真正的逻辑，还有一层核心的调用呢）。结束后的操作当然是准备更新timeval。因为进行轮询的结果有两种，一种是因为超时而结束 \u003ccode\u003ecore_sys_select\u003c/code\u003e 函数调用；另一种是得到了一个或多个准备就绪的数据，才结束调用并返回。显然，因为第二种结果而更新timeval有着一定的实际意义——到底等待了多久。不过这里需要注意的是，不是所有的Linux系统都支持对timeval做更新。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage long sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n            fd_set __user *exp, struct timeval __user *tvp)\n{\n    s64 timeout = -1;\n    struct timeval tv;\n    int ret;\n\n    /* 如果设置了超时时间 */\n    if (tvp) {\n        if (copy_from_user(\u0026#x26;tv, tvp, sizeof(tv)))\n            return -EFAULT;\n\n        /* 计时器不能设置为负数 */\n        if (tv.tv_sec \u0026#x3C; 0 || tv.tv_usec \u0026#x3C; 0)\n            return -EINVAL;\n\n        /* Cast to u64 to make GCC stop complaining */\n        /* 对 timeout 做一定的处理，根据时钟周期对 usec 进行取整 */\n        if ((u64)tv.tv_sec \u003e= (u64)MAX_INT64_SECONDS)\n            timeout = -1;   /* 无限等待 */\n        else {\n            timeout = DIV_ROUND_UP(tv.tv_usec, USEC_PER_SEC/HZ);\n            timeout += tv.tv_sec * HZ;\n        }\n    }\n\n    /* 核心的 select 实现逻辑 */\n    ret = core_sys_select(n, inp, outp, exp, \u0026#x26;timeout);\n\n    /* 如果设置了超时时间 */\n    if (tvp) {\n        struct timeval rtv;\n\n        if (current-\u003epersonality \u0026#x26; STICKY_TIMEOUTS)\n            goto sticky;\n        rtv.tv_usec = jiffies_to_usecs(do_div((*(u64*)\u0026#x26;timeout), HZ));\n        rtv.tv_sec = timeout;\n        if (timeval_compare(\u0026#x26;rtv, \u0026#x26;tv) \u003e= 0)\n            rtv = tv;\n        /* 内核数据-\u003e用户数据的拷贝，更新距离超时剩余的时间间隔 */\n        if (copy_to_user(tvp, \u0026#x26;rtv, sizeof(rtv))) {\nsticky:\n            /*\n             * 如果应用程序把timeval放在只读内存中，内核就无需特别的更新它\n             * If an application puts its timeval in read-only\n             * memory, we don't want the Linux-specific update to\n             * the timeval to cause a fault after the select has\n             * completed successfully. However, because we're not\n             * updating the timeval, we can't restart the system\n             * call.\n             */\n            if (ret == -ERESTARTNOHAND)\n                ret = -EINTR;\n        }\n    }\n\n    return ret;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecore_sys_select\u003c/code\u003e 也没有太多核心操作，完全是在为三个位图——输入、输出、错误从用户数据段到内核数据段的拷贝工作，以及在结束 \u003ccode\u003edo_select\u003c/code\u003e 调用后的反向拷贝操作。不过，无论是 \u003ccode\u003esys_select\u003c/code\u003e 还是 \u003ccode\u003ecore_sys_select\u003c/code\u003e 都将各自需要完成的工作分割得非常清晰，一个完成timeval的处理工作，另一个完成位图的处理。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/*\n * 内核数据-位图的准备，调用do_select完成核心的逻辑\n */\nstatic int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n               fd_set __user *exp, s64 *timeout)\n{\n    fd_set_bits fds;\n    void *bits;\n    int ret, max_fds;\n    unsigned int size;\n    struct fdtable *fdt;\n    /*\n     * 在栈中定义较小的数组，减少堆内存的占用，同时可以更快；\n     * SELECT_STACK_ALLOC = 256\n     */\n    long stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n    ret = -EINVAL;\n    if (n \u0026#x3C; 0)\n        goto out_nofds;\n\n    /* max_fds can increase, so grab it once to avoid race */\n    /* max_fds 可能同时在增加，所以提前获取一份固定的拷贝避免竞争 */\n    rcu_read_lock();\n    /* 获取当前任务的文件描述符表 */\n    fdt = files_fdtable(current-\u003efiles);\n    max_fds = fdt-\u003emax_fds;\n    rcu_read_unlock();\n    if (n \u003e max_fds)\n        n = max_fds;\n\n    /*\n     * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n     * since we used fdset we need to allocate memory in units of\n     * long-words.\n     */\n    size = FDS_BYTES(n);\n    bits = stack_fds;\n    if (size \u003e sizeof(stack_fds) / 6) {\n        /* Not enough space in on-stack array; must use kmalloc */\n        /* 栈数组大小不足；使用 kmalloc 获取新的空间 */\n        ret = -ENOMEM;\n        bits = kmalloc(6 * size, GFP_KERNEL);\n        if (!bits)\n            goto out_nofds;\n    }\n    fds.in      = bits;\n    fds.out     = bits +   size;\n    fds.ex      = bits + 2*size;\n    fds.res_in  = bits + 3*size;\n    fds.res_out = bits + 4*size;\n    fds.res_ex  = bits + 5*size;\n\n    /* 用户数据段的数据 inp、outp、exp 往内核数据段 fds.xxx 拷贝 */\n    if ((ret = get_fd_set(n, inp, fds.in)) ||\n        (ret = get_fd_set(n, outp, fds.out)) ||\n        (ret = get_fd_set(n, exp, fds.ex)))\n        goto out;\n    /* fds.res_xxx 作为 do_select 的执行结果，预置为0，表示每一位相应的fd都未准备就绪 */\n    zero_fd_set(n, fds.res_in);\n    zero_fd_set(n, fds.res_out);\n    zero_fd_set(n, fds.res_ex);\n\n    /* 交由 do_select 完成真正核心的操作 */\n    ret = do_select(n, \u0026#x26;fds, timeout);\n\n    if (ret \u0026#x3C; 0)\n        goto out;\n    if (!ret) {\n        ret = -ERESTARTNOHAND;\n        if (signal_pending(current))\n            goto out;\n        ret = 0;\n    }\n\n    /* 将结果集拷贝回用户数据段的 inp、outp、exp 中 */\n    if (set_fd_set(n, inp, fds.res_in) ||\n        set_fd_set(n, outp, fds.res_out) ||\n        set_fd_set(n, exp, fds.res_ex))\n        ret = -EFAULT;\n\nout:\n    if (bits != stack_fds)\n        kfree(bits);\nout_nofds:\n    return ret;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e终于是核心的逻辑了，逐一地将当前任务挂到相应文件的等待队列上，并等待调用 \u003ccode\u003epoll\u003c/code\u003e 函数被唤醒\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint do_select(int n, fd_set_bits *fds, s64 *timeout)\n{\n    struct poll_wqueues table;\n    poll_table *wait;\n    int retval, i;\n\n    rcu_read_lock();\n    /* 确认fds.xxx所需轮询的fd全部全部处于打开状态，同时返回最大的fd */\n    retval = max_select_fd(n, fds);\n    rcu_read_unlock();\n\n    if (retval \u0026#x3C; 0)\n        return retval;\n    n = retval;\n\n    /* 把当前任务放入自己的等待队列中 */\n    poll_initwait(\u0026#x26;table);\n    wait = \u0026#x26;table.pt;\n    /* 如果超时时间为0，即无需等待 */\n    if (!*timeout)\n        wait = NULL;\n    retval = 0;\n    /* 无限循环 */\n    for (;;) {\n        unsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n        long __timeout;\n\n        set_current_state(TASK_INTERRUPTIBLE);\n\n        inp = fds-\u003ein; outp = fds-\u003eout; exp = fds-\u003eex;\n        rinp = fds-\u003eres_in; routp = fds-\u003eres_out; rexp = fds-\u003eres_ex;\n\n        for (i = 0; i \u0026#x3C; n; ++rinp, ++routp, ++rexp) {\n            unsigned long in, out, ex, all_bits, bit = 1, mask, j;\n            unsigned long res_in = 0, res_out = 0, res_ex = 0;\n            const struct file_operations *f_op = NULL;\n            struct file *file = NULL;\n\n            in = *inp++; out = *outp++; ex = *exp++;\n            all_bits = in | out | ex;\n            if (all_bits == 0) {\n                i += __NFDBITS;\n                continue;\n            }\n\n            /* 对 unsigned long 的每一位进行确认 */\n            for (j = 0; j \u0026#x3C; __NFDBITS; ++j, ++i, bit \u0026#x3C;\u0026#x3C;= 1) {\n                int fput_needed;\n                /* 超过需检测的最大的文件描述符 */\n                if (i \u003e= n)\n                    break;\n                /* 该 fd 无需检测，直接下一个 */\n                if (!(bit \u0026#x26; all_bits))\n                    continue;\n                /* 获取相应的文件实例 */\n                file = fget_light(i, \u0026#x26;fput_needed);\n                if (file) {\n                    f_op = file-\u003ef_op;\n                    mask = DEFAULT_POLLMASK;\n                    /* 对于套接字，调用的是sock_poll，在poll成功时将唤醒wait队列的任务（即把当前任务唤醒）*/\n                    if (f_op \u0026#x26;\u0026#x26; f_op-\u003epoll)\n                        mask = (*f_op-\u003epoll)(file, retval ? NULL : wait);\n                    fput_light(file, fput_needed);\n                    if ((mask \u0026#x26; POLLIN_SET) \u0026#x26;\u0026#x26; (in \u0026#x26; bit)) {\n                        res_in |= bit;\n                        retval++;\n                    }\n                    if ((mask \u0026#x26; POLLOUT_SET) \u0026#x26;\u0026#x26; (out \u0026#x26; bit)) {\n                        res_out |= bit;\n                        retval++;\n                    }\n                    if ((mask \u0026#x26; POLLEX_SET) \u0026#x26;\u0026#x26; (ex \u0026#x26; bit)) {\n                        res_ex |= bit;\n                        retval++;\n                    }\n                }\n                /* 主动让出CPU片，等待重新调度（提前设置了最高优先级PREEMPT_ACTIVE）*/\n                cond_resched();\n            }\n            if (res_in)\n                *rinp = res_in;\n            if (res_out)\n                *routp = res_out;\n            if (res_ex)\n                *rexp = res_ex;\n        }\n        wait = NULL;\n        if (retval || !*timeout || signal_pending(current))\n            break;\n        if(table.error) {\n            retval = table.error;\n            break;\n        }\n\n        if (*timeout \u0026#x3C; 0) {\n            /* Wait indefinitely */\n            __timeout = MAX_SCHEDULE_TIMEOUT;\n        } else if (unlikely(*timeout \u003e= (s64)MAX_SCHEDULE_TIMEOUT - 1)) {\n            /* Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in a loop */\n            __timeout = MAX_SCHEDULE_TIMEOUT - 1;\n            *timeout -= __timeout;\n        } else {\n            __timeout = *timeout;\n            *timeout = 0;\n        }\n        /* 进入延时唤醒状态，待定预定的超时时间 */\n        __timeout = schedule_timeout(__timeout);\n        if (*timeout \u003e= 0)\n            *timeout += __timeout;\n    }\n    __set_current_state(TASK_RUNNING);\n\n    poll_freewait(\u0026#x26;table);\n\n    return retval;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e总结来看，\u003ccode\u003eselect\u003c/code\u003e 完全能够支持IO多路复用。至少比用户程序自行实现轮询优秀得多。但是，也存在着一些明显的缺陷：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e支持的文件描述符存在上限，默认是1024。\u003c/li\u003e\n\u003cli\u003e每次陷入内核态 \u003ccode\u003eselect\u003c/code\u003e 函数之后，都需要按位遍历所有的文件描述符（无论该fd是否存在），max(fd)越大，开销越大。\u003c/li\u003e\n\u003cli\u003e每次调用 \u003ccode\u003eselect\u003c/code\u003e 都需要将fd集合从用户态复制到内核态，max(fd)越大，开销越大。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eEPOLL\u003c/h2\u003e\n\u003cp\u003e简单地描述过 \u003ccode\u003eselect\u003c/code\u003e 系统调用之后，我们着重来聊一聊 \u003ccode\u003eepoll\u003c/code\u003e 的实现。毕竟 \u003ccode\u003eselect\u003c/code\u003e 和 \u003ccode\u003epoll\u003c/code\u003e 的复杂度是 \u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eO\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003eN\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eO(N)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003eO\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e，而 \u003ccode\u003eepoll\u003c/code\u003e 只是 \u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eO\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003elog\u003c/mi\u003e\u003cmo\u003e⁡\u003c/mo\u003e\u003cmi\u003eN\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eO(\\log{N})\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003eO\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mop\"\u003elo\u003cspan style=\"margin-right:0.01389em;\"\u003eg\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e （当然，这里对时间复杂度的比较维度不同，稍候细讲）。\u003ccode\u003eepoll\u003c/code\u003e 区别于传统I/O复用模型的最大特色在于：它将创建并维护一个 \u003ccode\u003eeventpoll\u003c/code\u003e 实例，并通过注册请 \u003ccode\u003eepoll\u003c/code\u003e 对新的文件描述符进行监听，这意味着数据从用户数据区到内核数据区的拷贝只有一次；相对的，传统方式在每次轮询时，都需要全量地将数据从用户数据区拷贝到内核数据区。 \u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eepoll_create\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eepoll_create\u003c/code\u003e 负责创建一个新的 \u003ccode\u003eeventpoll\u003c/code\u003e 实例。这里的size并没有实际意义（由于历史原因而存在），传入的参数将被忽略。看源码总是件有意思的事，这个size被描述成了检查精神健全的标志...\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage long sys_epoll_create(int size)\n{\n    int error, fd = -1;\n    struct eventpoll *ep;\n    struct inode *inode;\n    struct file *file;\n\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_create(%d)\\n\",\n             current, size));\n\n    /*\n     * 精神健全检测(size)；同时建立内部数据结构 struct eventpoll\n     */\n    error = -EINVAL;\n    if (size \u0026#x3C;= 0 || (error = ep_alloc(\u0026#x26;ep)) != 0)\n        goto error_return;\n\n    /*\n     * 创建一个新的文件描述符，文件数据结构和i节点\n     */\n    error = anon_inode_getfd(\u0026#x26;fd, \u0026#x26;inode, \u0026#x26;file, \"[eventpoll]\",\n                 \u0026#x26;eventpoll_fops, ep);\n    if (error)\n        goto error_free;\n\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_create(%d) = %d\\n\",\n             current, size, fd));\n\n    return fd;\n\nerror_free:\n    ep_free(ep);\nerror_return:\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_create(%d) = %d\\n\",\n             current, size, error));\n    return error;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcly1g0qi7lrtgzj31eu0u075i.jpg\" alt=\"Epoll Create | Model\"\u003e\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eepoll_ctl\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eepoll_ctl\u003c/code\u003e 顾名思义——\u003ccode\u003eepoll\u003c/code\u003e控制器，用于增加、修改、删除监听的事件。这里 \u003ccode\u003eepfd\u003c/code\u003e 用于找到 \u003ccode\u003eeventpoll\u003c/code\u003e 实例，\u003ccode\u003efd\u003c/code\u003e 表示需要监听的文件描述符，\u003ccode\u003eop\u003c/code\u003e 区分增删改，\u003ccode\u003eevent\u003c/code\u003e 表示监听的具体事件描述。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage long sys_epoll_ctl(int epfd, int op, int fd,\n                  struct epoll_event __user *event)\n{\n    int error;\n    struct file *file, *tfile;\n    struct eventpoll *ep;\n    struct epitem *epi;\n    struct epoll_event epds;\n\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)\\n\",\n             current, epfd, op, fd, event));\n\n    error = -EFAULT;\n    /* 如果是增改操作，需要把事件描述拷贝到内核数据区; 删除操作不需要 */\n    if (ep_op_has_event(op) \u0026#x26;\u0026#x26;\n        copy_from_user(\u0026#x26;epds, event, sizeof(struct epoll_event)))\n        goto error_return;\n\n    /* Get the \"struct file *\" for the eventpoll file */\n    error = -EBADF;\n    file = fget(epfd);\n    if (!file)\n        goto error_return;\n\n    /* Get the \"struct file *\" for the target file */\n    tfile = fget(fd);\n    if (!tfile)\n        goto error_fput;\n\n    /* 需要监听的文件描述符必须支持文件操作 poll */\n    error = -EPERM;\n    if (!tfile-\u003ef_op || !tfile-\u003ef_op-\u003epoll)\n        goto error_tgt_fput;\n\n    /* 需要确保不能把epfd作为被监听的fd加入 */\n    error = -EINVAL;\n    if (file == tfile || !is_file_epoll(file))\n        goto error_tgt_fput;\n\n    /* \n     * 这里的文件描述符一定是指eventpoll实例对应的文件描述符\n     * 因此直接从中拿私有数据--预定义的*eventpoll\n     */\n    ep = file-\u003eprivate_data;\n\n    mutex_lock(\u0026#x26;ep-\u003emtx);\n\n    /*\n     * 从RB树中查找已经维护起来的监听事件\n     * 当然，必须先把这个RB树结构锁定，防止查找时结构改变\n     */\n    epi = ep_find(ep, tfile, fd);\n\n    error = -EINVAL;\n    switch (op) {\n    case EPOLL_CTL_ADD:     // 新增监听\n        if (!epi) {\n            epds.events |= POLLERR | POLLHUP;\n\n            error = ep_insert(ep, \u0026#x26;epds, tfile, fd);\n        } else\n            error = -EEXIST;\n        break;\n    case EPOLL_CTL_DEL:     // 删除监听\n        if (epi)\n            error = ep_remove(ep, epi);\n        else\n            error = -ENOENT;\n        break;\n    case EPOLL_CTL_MOD:     // 修改监听\n        if (epi) {\n            epds.events |= POLLERR | POLLHUP;\n            error = ep_modify(ep, epi, \u0026#x26;epds);\n        } else\n            error = -ENOENT;\n        break;\n    }\n    mutex_unlock(\u0026#x26;ep-\u003emtx);\n\nerror_tgt_fput:\n    fput(tfile);\nerror_fput:\n    fput(file);\nerror_return:\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d\\n\",\n             current, epfd, op, fd, event, error));\n\n    return error;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的核心操作，就是往 \u003ccode\u003eeventpoll\u003c/code\u003e 实例中增删改监听的事件。以 \u003ccode\u003eep_insert\u003c/code\u003e 为例，先看看怎么新增监听。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* 实例化 epitem */\nif (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))\n    goto error_return;\n/* 对 epitem 实例进行初始化数据 */\nep_rb_initnode(\u0026#x26;epi-\u003erbn);\nINIT_LIST_HEAD(\u0026#x26;epi-\u003erdllink);\nINIT_LIST_HEAD(\u0026#x26;epi-\u003efllink);\nINIT_LIST_HEAD(\u0026#x26;epi-\u003epwqlist);\nepi-\u003eep = ep;\n/* 构建struct epoll_filefd，作为rb_tree比较不同的key */\nep_set_ffd(\u0026#x26;epi-\u003effd, tfile, fd);\nepi-\u003eevent = *event;\nepi-\u003enwait = 0;\nepi-\u003enext = EP_UNACTIVE_PTR;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来要接触的就是一段比较烧脑的逻辑。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epoll_table\u003c/code\u003e 是在 VFS 实现中相当重要的一个数据结构，用来与\u003ccode\u003epoll\u003c/code\u003e配合（这里的\u003ccode\u003epoll\u003c/code\u003e是指文件操作中的，而不是\u003ccode\u003epoll()\u003c/code\u003e系统调用）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct poll_table_struct {\n    poll_queue_proc _qproc;\n} poll_table;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中\u003ccode\u003epoll_queue_proc\u003c/code\u003e是一个函数指针\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e为了让 \u003ccode\u003eepitem\u003c/code\u003e 更方便地追踪 \u003ccode\u003epoll_queue_proc\u003c/code\u003e，\u003ccode\u003eepoll_ctl\u003c/code\u003e 中使用了一个 \u003ccode\u003eep_pqueue\u003c/code\u003e 的数据结构来包装 \u003ccode\u003epoll_table\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* 使用 queue 回调函数初始化 poll table */\nepq.epi = epi;\ninit_poll_funcptr(\u0026#x26;epq.pt, ep_ptable_queue_proc);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcly1g0qwphhnz0j30xa0o6aan.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e之后就是把这个 \u003ccode\u003epoll_table\u003c/code\u003e 作为钩子方法挂载到被监控的文件上\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003erevents = tfile-\u003ef_op-\u003epoll(tfile, \u0026#x26;epq.pt);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里以 \u003ccode\u003etcp_poll\u003c/code\u003e 为例，先看看这段逻辑怎么实现的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic unsigned int sock_poll(struct file *file, poll_table *wait)\n{\n    struct socket *sock;\n    /* 获取 struct sock 内核套接字数据结构 */\n    sock = file-\u003eprivate_data;\n    return sock-\u003eops-\u003epoll(file, sock, wait);\n}\n\nunsigned int tcp_poll(struct file *file, struct socket *sock, poll_table *wait)\n{\n    unsigned int mask;\n    struct sock *sk = sock-\u003esk;\n    struct tcp_sock *tp = tcp_sk(sk);\n\n    /*\n     * 这里将调用 poll_table *wait 维护的回调函数\n     * 将持有 eventpoll 实例的进程注册到 sk 的等待队列中\n     */\n    poll_wait(file, sk-\u003esk_sleep, wait);\n    if (sk-\u003esk_state == TCP_LISTEN)\n        return inet_csk_listen_poll(sk);\n\n    /*\n     * 这里省略了部分逻辑，主要是负责处理 struct sock 接收到的事件\n     * 处理成 mask 并返回\n     */\n    ...\n\n    return mask;\n}\n\nstatic inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)\n{\n    if (p \u0026#x26;\u0026#x26; wait_address)\n        p-\u003eqproc(filp, wait_address, p);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再来看看epoll定义的回调函数的实现。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n                 poll_table *pt)\n{\n    struct epitem *epi = ep_item_from_epqueue(pt);\n    struct eppoll_entry *pwq;\n\n    if (epi-\u003enwait \u003e= 0 \u0026#x26;\u0026#x26; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n        init_waitqueue_func_entry(\u0026#x26;pwq-\u003ewait, ep_poll_callback);\n        pwq-\u003ewhead = whead;\n        pwq-\u003ebase = epi;\n        /* 添加到 struct sock 等待队列队首 */\n        add_wait_queue(whead, \u0026#x26;pwq-\u003ewait);\n        list_add_tail(\u0026#x26;pwq-\u003ellink, \u0026#x26;epi-\u003epwqlist);\n        epi-\u003enwait++;\n    } else {\n        /* We have to signal that an error occurred */\n        epi-\u003enwait = -1;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到此为止，\u003ccode\u003eep_insert\u003c/code\u003e 核心的逻辑已经介绍完毕。主要就是将当前的 \u003ccode\u003eeventpoll\u003c/code\u003e 实例注册到监听目标（文件描述符）的等待队列上，并注册\u003ccode\u003eep_poll_callback\u003c/code\u003e作为回调函数。回调函数实现是怎样呢？\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n    int pwake = 0;\n    unsigned long flags;\n    /* 获取 wait 结构维护的 epitem 实例 */\n    struct epitem *epi = ep_item_from_wait(wait);\n    struct eventpoll *ep = epi-\u003eep;\n\n    // ... code omitted...\n    /* \n     * 把当前的 epitem 实例添加到 eventpoll 实例的就绪队列中 \n     * 这是显然的，毕竟此回调函数只有在fd准备就绪后被回调\n     */\n    list_add_tail(\u0026#x26;epi-\u003erdllink, \u0026#x26;ep-\u003erdllist);\n\nis_linked:\n    /* 如果 wait 结构维护的进程处于Sleeping状态，则将其唤醒并加入任务就绪队列 */\n    if (waitqueue_active(\u0026#x26;ep-\u003ewq))\n        __wake_up_locked(\u0026#x26;ep-\u003ewq, TASK_UNINTERRUPTIBLE |\n                 TASK_INTERRUPTIBLE);\n    if (waitqueue_active(\u0026#x26;ep-\u003epoll_wait))\n        pwake++;\n\nout_unlock:\n    spin_unlock_irqrestore(\u0026#x26;ep-\u003elock, flags);\n\n    /* We have to call this outside the lock */\n    if (pwake)\n        ep_poll_safewake(\u0026#x26;psw, \u0026#x26;ep-\u003epoll_wait);\n\n    return 1;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003ccode\u003eepoll_wait\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e处理完所有的监听事件的维护，用户程序需要通过 \u003ccode\u003eepoll_wait\u003c/code\u003e 与 \u003ccode\u003eeventpoll\u003c/code\u003e 实例进行交互，并被告知所有正在监听中的事件是否发生。由于 \u003ccode\u003eepoll_wait\u003c/code\u003e 的整个逻辑基本上都是在进行错误检测，此处不表。我们只关注其中的核心逻辑，即调用的 \u003ccode\u003eep_poll\u003c/code\u003e 函数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,\n           int maxevents, long timeout)\n{\n    int res, eavail;\n    unsigned long flags;\n    long jtimeout;\n    wait_queue_t wait;\n\n    /*\n     * Calculate the timeout by checking for the \"infinite\" value ( -1 )\n     * and the overflow condition. The passed timeout is in milliseconds,\n     * that why (t * HZ) / 1000.\n     */\n    jtimeout = (timeout \u0026#x3C; 0 || timeout \u003e= EP_MAX_MSTIMEO) ?\n        MAX_SCHEDULE_TIMEOUT : (timeout * HZ + 999) / 1000;\n\nretry:\n    spin_lock_irqsave(\u0026#x26;ep-\u003elock, flags);\n\n    res = 0;\n    /* \n     * 如果 eventpoll 实例的就绪队列为空，表明有没任何监听的事件发生。\n     * 主动让进程陷入Sleeping状态，知道被 ep_poll_callback() 唤醒\n     */\n    if (list_empty(\u0026#x26;ep-\u003erdllist)) {\n        init_waitqueue_entry(\u0026#x26;wait, current);\n        wait.flags |= WQ_FLAG_EXCLUSIVE;\n        __add_wait_queue(\u0026#x26;ep-\u003ewq, \u0026#x26;wait);\n\n        for (;;) {\n            /*\n             * We don't want to sleep if the ep_poll_callback() sends us\n             * a wakeup in between. That's why we set the task state\n             * to TASK_INTERRUPTIBLE before doing the checks.\n             */\n            set_current_state(TASK_INTERRUPTIBLE);\n            if (!list_empty(\u0026#x26;ep-\u003erdllist) || !jtimeout)\n                break;\n            if (signal_pending(current)) {\n                res = -EINTR;\n                break;\n            }\n\n            spin_unlock_irqrestore(\u0026#x26;ep-\u003elock, flags);\n            /* 主动陷入Sleeping状态 */\n            jtimeout = schedule_timeout(jtimeout);\n            spin_lock_irqsave(\u0026#x26;ep-\u003elock, flags);\n        }\n        __remove_wait_queue(\u0026#x26;ep-\u003ewq, \u0026#x26;wait);\n\n        set_current_state(TASK_RUNNING);\n    }\n\n    /* Is it worth to try to dig for events ? */\n    eavail = !list_empty(\u0026#x26;ep-\u003erdllist);\n\n    spin_unlock_irqrestore(\u0026#x26;ep-\u003elock, flags);\n\n    /*\n     * 将监听到的事件拷贝到用户空间。如果没有事件就绪且还没超时，就再抱着\n     * 希望试一次。\n     */\n    if (!res \u0026#x26;\u0026#x26; eavail \u0026#x26;\u0026#x26;\n        !(res = ep_send_events(ep, events, maxevents)) \u0026#x26;\u0026#x26; jtimeout)\n        goto retry;\n\n    return res;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eExtra\u003c/h3\u003e\n\u003cp\u003e这部分的数据结构配合着一些胶水代码比较难以理解，最好配合着类图看看（个人使用，不一定适合各位）\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1g0rmx65dzhj324y0t8di4.jpg\"\u003e\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eLinux Kernel 2.6.24\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://idndx.com/2014/09/01/the-implementation-of-epoll-1/\"\u003eThe Implementation of epoll(1)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://idndx.com/2014/09/02/the-implementation-of-epoll-2/\"\u003eThe Implementation of epoll(2)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://idndx.com/2014/09/22/the-implementation-of-epoll-3/\"\u003eThe Implementation of epoll(3)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://idndx.com/2015/07/08/the-implementation-of-epoll-4/\"\u003eThe Implementation of epoll(4)\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e\u003ca href=\"./2019-01-15-understand-Kernel-8/\"\u003e前一篇\u003c/a\u003e已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 \u003ccode\u003estruct sock\u003c/code\u003e 对象，将其逐级从网络接口层逐级提升到网络层、传输层...最终添加到接收队列 \u003ccode\u003esk_receive_queue\u003c/code\u003e 中；用户进程通过 \u003ccode\u003eread\u003c/code\u003e、\u003ccode\u003erecv\u003c/code\u003e、\u003ccode\u003erecvfrom\u003c/code\u003e 等命令检查并获取 \u003ccode\u003esk_receive_queue\u003c/code\u003e 中的数据。\u003c/p\u003e\n\u003cp\u003e整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。\u003c/p\u003e\n\u003cp\u003e那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（\u003ccode\u003eselect\u003c/code\u003e, \u003ccode\u003epoll\u003c/code\u003e, \u003ccode\u003eepoll\u003c/code\u003e）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 \u003ccode\u003eselect\u003c/code\u003e 和 \u003ccode\u003eepoll\u003c/code\u003e 两类系统调用的实现进行探究。\u003c/p\u003e"}],"items":32,"pages":4,"currentPage":2},"buildId":"XgNVO0Or_GCOPc0sVklZL","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/" src="https://www.ffutop.com/blog/_next/static/XgNVO0Or_GCOPc0sVklZL/pages/index.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/XgNVO0Or_GCOPc0sVklZL/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.b54d8442e6b63c30cad4.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>