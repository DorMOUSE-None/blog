<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/_kHFDZs2rntv1kq9Ewo5u/pages/index.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/_kHFDZs2rntv1kq9Ewo5u/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.74c43a0e96cfe845a889.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.a1d4ae30.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.6dcae34a.chunk.css"/></head><body><div id="__next"><header class="component-header"><h1 class="title">ffutop</h1><ul class="nav-items"><li><a href="/blog/index">博客</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/about">关于</a></li></ul></header><div><main class="main"><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-01-15-Spring-JDBC-Code-Reading">Spring JDBC 源码学习</a></h1><div><h2>概览</h2>
<p>在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。</p></div></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-03-01-区块链简单介绍">区块链技术概述</a></h1><div><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg" alt="区块链简单结构"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg" alt="Merkle tree"></p></div></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-06-11-ASM-ClassReader">ASM - ClassReader 与 Java ClassFile 文件格式</a></h1><div><h2>Java ClassFile 文件格式</h2>
<p>读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。
<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The class File Format(Java SE 8)</a> </p>
<blockquote>
<p>u1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)</p>
</blockquote>
<pre><code class="language-c++">ClassFile {
    u4             magic;                                   // 魔数(magic) 固定为 0xCAFEBABE
    u2             minor_version;                           // 次版本号
    u2             major_version;                           // 主版本号
    u2             constant_pool_count;                     // 常量池 constant_pool 的数量 + 1, 最大为 (2&#x3C;&#x3C;16 - 1) = 65535
    cp_info        constant_pool[constant_pool_count-1];    // 常量池 取值下标为 [1, constant_pool_count)
    u2             access_flags;                            // 对类 or 接口的访问权限和属性的标志的掩码
    u2             this_class;                              // 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)
    u2             super_class;                             // 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标
    u2             interfaces_count;                        // 直接父接口的数量
    u2             interfaces[interfaces_count];            // 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i&#x3C;interfaces_count), 指向的类型为 CONSTANT_Class_info)
    u2             fields_count;                            // 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)
    field_info     fields[fields_count];                    // 字段的详细声明, 不包含继承来的字段
    u2             methods_count;                           // 方法数量
    method_info    methods[methods_count];                  // 方法的详细声明, 不包括继承来的方法
    u2             attributes_count;                        // 属性数量
    attribute_info attributes[attributes_count];            // 属性的详细声明
}
</code></pre></div></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-06-21-java-memory-model">java-memory-model</a></h1><div><h2>JVM 运行时数据区</h2>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg"></p></div></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-06-25-ASM-Core">ASM 核心包基本内容漫谈</a></h1><div><blockquote>
<p>本文描述的 ASM 指的是 OW2 ASM</p>
</blockquote>
<h2>ASM-Core 的结构</h2>
<p><em>首先是一些概述性的内容。</em></p>
<p>由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。
因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)</p>
<p>从核心包声明的类来看，主要包括:</p>
<ol>
<li>
<p>ClassReader - 作为结构化对象，将接收(accept)访问者的访问</p>
</li>
<li>
<p>几种访问者抽象类以及相应的实现类</p>
</li>
</ol>
<ul>
<li>AnnotationVisitor -> AnnotationWriter</li>
<li>ClassVisitor -> ClassWriter</li>
<li>FieldVisitor -> FieldWriter</li>
<li>MethodVisitor -> MethodWriter</li>
<li>ModuleVisitor -> ModuleWriter</li>
</ul>
<ol start="3">
<li>
<p>Opcodes &#x26; Constants - ClassFile 中描述的大量常量符号与值</p>
</li>
<li>
<p>其它一些辅助的类</p>
</li>
</ol>
<ul>
<li>Attribute - 用于处理非标准化的属性(ClassFile 允许<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">JVMS</a> 中未定义的 Attribute)</li>
<li>ByteArray - 动态可自适应的 byte[] (字节数组)</li>
<li>Context - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象</li>
<li>Symbol - 用于表示 ClassFile 中描述的 Constant 的基类</li>
<li>SymbolTable - 用于存储常量池对象</li>
<li>其它内容省略</li>
</ul></div></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-06-28-ASM-VerifyError">ASM-VerifyError错误信息解决</a></h1><div><h2>报错信息</h2>
<pre><code class="language-java">java.lang.VerifyError: class net.sf.cglib.core.DebuggingClassWriter overrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V
</code></pre></div></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-07-04-JDK-Permission">Java 安全访问与权限控制</a></h1><div><h2>绪论</h2>
<p><em>本文只是对 Java 安全访问与权限控制的基础性探究。</em></p>
<p><strong>本节与全文内容无关，如无兴趣阅读，可以跳过</strong></p>
<p>了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行"自动发现"和加载。
这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要
1. 在 <code>META-INF.services</code> 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容
2. 由项目的注册管理器触发下列 Java 代码</p>
<pre><code class="language-java">{
    ServiceLoader&#x3C;XxxPolicy> xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);
    for (Iterator&#x3C;XxxPolicy> it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) {
        XxxPolicy xxxPolicy = it.next();
        // ... more code ...
    }
}
</code></pre>
<p>就可以完成一个新的 SPI 策略的注册工作。</p>
<p>但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-.jar 在注册 Driver 相关的代码。
发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:</p>
<pre><code class="language-java">AccessController.doPrivileged(new PrivilegedAction&#x3C;Void>() {
    public Void run() {

        ServiceLoader&#x3C;Driver> loadedDrivers = ServiceLoader.load(Driver.class);
        Iterator&#x3C;Driver> driversIterator = loadedDrivers.iterator();

        try{
            while(driversIterator.hasNext()) {
            driversIterator.next();
            }
        } catch(Throwable t) {
                // Do nothing
        }
        return null;
    }
});
</code></pre>
<p>诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。</p>
<p>为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。</p></div></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-07-10-CGlib-Enhancer">CGlib Enhancer 主流程源码解析</a></h1><div><h2>前言</h2>
<p>此博文写作的目的: </p>
<ul>
<li>(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。</li>
<li>基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。</li>
</ul></div></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-07-13-How-to-easily-get-CGlib-generated-code">如何方便地获取 CGlib 生成类</a></h1><div><h2>配置参数</h2>
<p><strong>命令行使用</strong></p>
<p>在 java 启动命令中添加参数配置项 <code>-Dcglib.debugLocation=&#x3C;Custom Path></code></p>
<p><strong>编码实现</strong></p>
<p>在执行 CGlib 获取新生成类之前，调用 <code>System.setProperty("cglib.debugLocation", &#x3C;Custom Path>)</code></p></div></div></div><div><a href="/blog/page/2">下一页</a></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/","query":{"mdDatasParts":[{"url":"2018-01-15-Spring-JDBC-Code-Reading","fileName":"2018-01-15-Spring-JDBC-Code-Reading.md","title":"Spring JDBC 源码学习","author":"fangfeng","date":"2018-01-15T00:00:00.000Z","tags":["Spring","JDBC"],"content":"\u003ch2\u003e概览\u003c/h2\u003e\n\u003cp\u003e在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e/**\n * copied from https://www.tutorialspoint.com/jdbc/jdbc-sample-code.htm\n * updated by DorMOUSENone\n */\n\n//STEP 1. 引入必须的包\nimport java.sql.*;\n\npublic class Example {\n    // JDBC 驱动名 与 DB URL \n    static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\";  \n    static final String DB_URL = \"jdbc:mysql://\u0026#x3C;host\u003e:\u0026#x3C;port\u003e/\u0026#x3C;dbName\u003e\";\n\n    // 数据库登录验证 (用户名、密码等)\n    static final String USER = \"username\";\n    static final String PASS = \"password\";\n   \n    public static void main(String[] args) {\n        Connection conn = null;\n        Statement stmt = null;\n        try{\n            //STEP 2: 注册驱动(注册到驱动管理器 DriverManager 类中)\n            Class.forName(\"com.mysql.jdbc.Driver\");\n\n            //STEP 3: 创建一个连接\n            System.out.println(\"Connecting to database...\");\n            conn = DriverManager.getConnection(DB_URL,USER,PASS);\n\n            //STEP 4: 执行一个查询\n            System.out.println(\"Creating statement...\");\n            stmt = conn.createStatement();\n            String sql;\n            sql = \"SELECT id, first, last, age FROM Employees\";\n            ResultSet rs = stmt.executeQuery(sql);\n\n            //STEP 5: 将结果从结果集(ResultSet)中取出\n            while(rs.next()){\n                //根据列名逐一取出数据\n                int id  = rs.getInt(\"id\");\n                int age = rs.getInt(\"age\");\n                String first = rs.getString(\"first\");\n                String last = rs.getString(\"last\");\n\n                //展示结果\n                System.out.print(\"ID: \" + id);\n                System.out.print(\", Age: \" + age);\n                System.out.print(\", First: \" + first);\n                System.out.println(\", Last: \" + last);\n            }\n            //STEP 6: 清理环境\n            rs.close();\n            stmt.close();\n            conn.close();\n        }catch(SQLException se){\n            //处理 JDBC 错误\n            se.printStackTrace();\n        }catch(Exception e){\n            //处理 Class.forName() 引起的错误\n            e.printStackTrace();\n        }finally{\n            // finally 代码库来关闭资源\n            try{\n                if(stmt!=null)\n                    stmt.close();\n            }catch(SQLException se2){\n            }// 不做任何处理\n            try{\n                if(conn!=null)\n                    conn.close();\n            }catch(SQLException se){\n                se.printStackTrace();\n            }\n        }\n        System.out.println(\"Goodbye!\");\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从上面的通用 JDBC 代码可以看到，利用 Java 原生提供的 java.sql.* 包可以完成注册驱动，创建连接，执行查询，处理结果等一系列一整套操作。\u003c/p\u003e\n\u003cp\u003e而 Spring-JDBC 对于 Java 原生提供的 JDBC ，对一系列数据及操作进行了整合：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e实现了 DataSource 接口，用于整合数据源配置，将各种零散的属性值（诸如 URL、用户名、 密码等）整合成完整的一个对象，便于重用；也实现了 getConnection(…) 接口，便于直接通过 DataSource 获取连接。\u003c/li\u003e\n\u003cli\u003e对执行查询的流程进行了封装。\u003c/li\u003e\n\u003cli\u003e对结果集的处理提供了多种接口，针对不同的应用场景可自由选择所必须的实现类。例如直接通过 JDBC 获得 Bean ，而无需如上例 39-42 行所示，逐一编码进行提取。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e本节提供对《Spring-JDBC 源码学习》完整学习过程的一个梳理：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"http://blog.csdn.net/dormousenone/article/details/79035440\"\u003eJdbcTemplate\u003c/a\u003e 一节作为学习 Spring-jdbc 的切入点，是 org.springframework.jdbc.core 包中的核心类，是一个提供不同场景下数据库操作的模板类。主要描述其持有的属性 DataSource 等以及其实现的方法。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://blog.csdn.net/dormousenone/article/details/79037012\"\u003eDataSource\u003c/a\u003e 一节承接 JdbcTemplate 一节，提供 Spring-jdbc 对数据源的一个包装与应用。同时描述其核心方法 getConnection(…) 的实现。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://blog.csdn.net/dormousenone/article/details/79042212\"\u003eDriverManager\u003c/a\u003e 描述其对不同数据库供应商提供的驱动的管理与使用方法。同时简单描述通过具体驱动获得一个连接的实现。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://blog.csdn.net/dormousenone/article/details/79046865\"\u003ePreparedStatement \u0026#x26; CallableStatement\u003c/a\u003e 一节主要表述 Spring-jdbc 如何对执行查询的流程进行了封装。特别是对于 PreparedStatement 与 CallableStatement 这类预置可变 SQL 语句，在执行前必须对其中可变参数进行补全的 Statement 。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://blog.csdn.net/dormousenone/article/details/79062275\"\u003eResultSet\u003c/a\u003e 描述 Spring-jdbc 如何对结果集进行处理，提供了多种不同的接口实现不同的处理逻辑。这种封装后的操作可以极大地简化直接使用 Java 原生 JDBC 所必须的硬编码提取数据的问题。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eJdbcTemplate\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fn90ghu9ufj30ki0jm75t.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eJdbcTemplate 类作为 org.springframework.core 包下的核心类，对 Java 实现的 JDBC 进行了一定程度的封装，可以简化 JDBC 的使用，同时避免许多常见的错误。由该类来执行 JDBC 工作流，应用程序只需要提供 SQL 语句就可以获得 DB 执行结果（😀，当然实际操作上没有描述的这么简单）。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e使用 JdbcTemplate 类只需要实现两个回调接口 PreparedStatementCreator (创建一个 PreparedStatement，给定连接，提供 SQL 语句以及必要的参数), ResultSetExtractor (用于花式获取结果集)。当然，不实现上述两个接口也可以进行简单的数据库操作，比如只通过 JdbcTemplate 获取一个连接(Connection) 或者执行一个静态 SQL Update。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e看不懂无所谓，先继续向下看，会做更详细的讲解。\u003c/em\u003e\u003c/p\u003e\n\u003ch3\u003eJdbcAccessor\u003c/h3\u003e\n\u003cp\u003e首先了解 JdbcTemplate 的实现，JdbcTemplate 继承了 JdbcAccessor 抽象类，该抽象类有两个主要属性—— \u003cstrong\u003eDataSource dataSource\u003c/strong\u003e \u0026#x26; \u003cstrong\u003eSQLExceptionTranslator exceptionTranslator\u003c/strong\u003e ，以及一个懒加载标识符 \u003cstrong\u003elazyInit\u003c/strong\u003e 。\u003c/p\u003e\n\u003cp\u003e其中，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDataSource 可以认为是一个存储有与数据库相关的属性实例，主要方法包括 \u003ccode\u003eConnection getConnection()\u003c/code\u003e \u0026#x26; \u003ccode\u003eConnection getConnection(String username, String password)\u003c/code\u003e 。\u003c/li\u003e\n\u003cli\u003eSQLExceptionTranslator 利用策略模式将 Java 定义的 SQLException 转换成 Spring 声明的 DataAccessException。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eJdbcAccessor 实现的 InitializingBean 接口，InitializingBean 接口为 Bean 提供了一个初始化实例的方法 —— afterPropertiesSet() 方法，凡是继承该接口的类，一般都在类构造方法中执行该方法。同样的，声明初始化实例调用的方法还可采用 \u003ccode\u003e\u0026#x3C;bean id=\"\" class=\"\" init-method=\"myInitMethod\"/\u003e\u003c/code\u003e 在初始化 bean 时执行 myInitMethod() 方法。具体执行顺序为 ：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ebean 的属性注入\u003c/li\u003e\n\u003cli\u003e调用 afterPropertiesSet() 方法\u003c/li\u003e\n\u003cli\u003e执行 myInitMethod() 方法\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e此处继承该接口是为了实现 DataSource 验证以及 SQLExceptionTranslator 的懒加载 OR NOT 的选择。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic void afterPropertiesSet() {\n    if (getDataSource() == null) {  // 判断是否注入了 DataSource\n        throw new IllegalArgumentException(\"Property 'dataSource' is required\");\n    }\n    if (!isLazyInit()) {    // 根据懒加载标识符选择执行与否\n        getExceptionTranslator();   // 获取一个 SQLExceptionTranslator 实例\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e该方法在 BeanFactory 完成该 bean 的依赖注入后执行，将首先判断 DataSource 是否已经被注入，再根据懒加载标识符来决定是否实例化一个 SQLExceptionTranslator 。\u003c/p\u003e\n\u003ch3\u003eJdbcOperations\u003c/h3\u003e\n\u003cp\u003e同时，JdbcTemplate 类实现了 JdbcOperations 接口，该接口定义了基本的 JDBC 操作。基本方法如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(ConnectionCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(StatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(PreparedStatementCreator psc, PreparedStatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(CallableStatementCreator csc, CallableStatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fncp2ncqd6j31j00au0uv.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e其它的 execute(…) , query(…), update(…) 等最终都将调用上述 4 种方法其一来完成目的。\u003c/p\u003e\n\u003cp\u003e详细观察上述方法的入参， ConnectionCallback, StatementCallback, PreparedStatementCallback 和 CallableStatementCallback 四个 Callback 接口，分别都是函数式接口，其中的唯一方法 doInXXX() 将在 execute() 中被调用，以此实现获得 ResultSet 并返回 Result 。execute 中调用 doInXXX() 的通用代码如下 （以 Statement 为例）：\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e对于不理解\u003cstrong\u003e回调\u003c/strong\u003e的同学，请自行了解概念\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic \u0026#x3C;T\u003e T execute(StatementCallback\u0026#x3C;T\u003e action) throws DataAccessException {\n    // 通过工具类 DataSourceUtils 获取一个连接\n    Connection con = DataSourceUtils.getConnection(obtainDataSource());\n    // 一个 Statement 空实例，PreparedStatement, CallableStatement 类似\n    Statement stmt = null;\n    try {\n        stmt = con.createStatement();   // 通过连接(Connection)获取一个 Statement\n        applyStatementSettings(stmt);   // 配置 Statement 参数\n        // 回调执行 doInXXX() 方法, 并获得 result\n        T result = action.doInStatement(stmt);  \n        handleWarnings(stmt);\n        return result;\n    }\n    catch (SQLException ex) {\n        // Release Connection early, to avoid potential connection pool deadlock\n        // in the case when the exception translator hasn't been initialized yet.\n        String sql = getSql(action);\n        JdbcUtils.closeStatement(stmt);\n        stmt = null;\n        DataSourceUtils.releaseConnection(con, getDataSource());\n        con = null;\n        throw translateException(\"StatementCallback\", sql, ex);\n    }\n    finally {\n        JdbcUtils.closeStatement(stmt);\n        DataSourceUtils.releaseConnection(con, getDataSource());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于 Statement, PreparedStatement, CallableStatement 的区别，首先下图表现了三个接口的继承关系。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStatement 可以支持静态 SQL 语句\u003c/li\u003e\n\u003cli\u003ePreparedStatement 支持可变参数的 SQL 语句\u003c/li\u003e\n\u003cli\u003eCallableStatement 支持可变参数的 SQL 语句，并且支持定制 DB 的输出结果\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fncpaec17yj30ew0hcdh7.jpg\"\u003e\u003c/p\u003e\n\u003ch2\u003eDataSource\u003c/h2\u003e\n\u003cp\u003e上一节在粗略地了解了 JdbcTemplate 提供的方法之后，下面先来对 DataSource 做一点了解。\u003c/p\u003e\n\u003ch3\u003eJava 提供的 DataSource 定义\u003c/h3\u003e\n\u003cp\u003eDataSource 是 Java 核心库提供的接口。位于 javax.sql package 下。\u003c/p\u003e\n\u003cp\u003eDataSource 接口可以被视作是一个提供物理 DB 实例连接(Connection) 的工厂，通过 DataSource 持有的各种属性（包括 DB Url, Username, Password 等）来获取一个连接(Connection) 。DataSource 接口有三种不同的实现方案：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e最基本的实现——生产一个标准连接(Connection) 对象\u003c/li\u003e\n\u003cli\u003e连接池方案——生产会被自动添加到连接池的对象\u003c/li\u003e\n\u003cli\u003e分布式事物实现——生产一个可以支持分布式事物，并默认被添加到连接池的连接对象\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e包括两个对外提供连接(Connection) 对象的方法，\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eConnection getConnection() throws SQLException;\nConnection getConnection(String username, String password) throws SQLException;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其父接口 CommonDataSource 提供设置/获取 LogWriter，登录 DB 超时时间和获取父 Logger 的方法。\u003c/p\u003e\n\u003ch3\u003eSpring-JDBC 扩展的 DataSource 定义\u003c/h3\u003e\n\u003cp\u003e在 Spring-jdbc 下，DataSources 最顶级的类是 AbstractDataSource ，对 DataSource 的所有父接口方法做了实现。但保留 getConnection() 方法由子类实现。\u003c/p\u003e\n\u003cp\u003e在 AbstractDriverBasedDataSource 中，定义了大量的参数，诸如 url, username 等，这些都被用来定位并定义与数据库实例的连接。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic abstract class AbstractDriverBasedDataSource extends AbstractDataSource {\n\n   @Nullable\n   private String url;\n\n   @Nullable\n   private String username;\n\n   @Nullable\n   private String password;\n\n   @Nullable\n   private String catalog;\n\n   @Nullable\n   private String schema;\n\n   @Nullable\n   // 可以看到此处有一个 Properties 类\n   private Properties connectionProperties;\n   \n   // 省略若干方法\n  \n\n    @Override\n    public Connection getConnection() throws SQLException {\n        // 调用内部方法 getConnectionFromDriver()\n        return getConnectionFromDriver(getUsername(), getPassword());\n    }\n\n    @Override\n    public Connection getConnection(String username, String password) throws SQLException {\n        // 调用内部方法 getConnectionFromDriver()\n        return getConnectionFromDriver(username, password);\n    }\n  \n   // 定义了一个获取 Connection 的方法，由 getConnection() 方法调用，\n   // 此方法主要是将属性做了一个整合\n   // 具体获取 Connection 的逻辑仍然下放到子类实现 见 40 行\n   protected Connection getConnectionFromDriver(@Nullable String username, @Nullable String password) throws SQLException {\n        Properties mergedProps = new Properties();\n        Properties connProps = getConnectionProperties();\n        if (connProps != null) {\n            mergedProps.putAll(connProps);\n        }\n        if (username != null) {\n            mergedProps.setProperty(\"user\", username);\n        }\n        if (password != null) {\n            mergedProps.setProperty(\"password\", password);\n        }\n        \n        // 获取 Connection 逻辑下放\n        Connection con = getConnectionFromDriver(mergedProps);\n        if (this.catalog != null) {\n            con.setCatalog(this.catalog);\n        }\n        if (this.schema != null) {\n            con.setSchema(this.schema);\n        }\n        return con;\n    }\n  \n    // 该类中获取 Connection 的方法是抽象方法\n    protected abstract Connection getConnectionFromDriver(Properties props) throws SQLException;\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e整合方案为将除 url 外的所有参数整合在同一个 Properties 对象中 (其中，Properties 可以被认为是一个线程安全的 Hash Map) 。最终调用 \u003ccode\u003eConnection getConnectionFromDriver(Properties props)\u003c/code\u003e 获取连接。\u003c/p\u003e\n\u003cp\u003eAbstractDriverBasedDataSource 抽象类的两个子类 DriverManagerDataSource 和 SimpleDriverDataSource 都以不同方式获得了连接(Connection)，但总结而言，获取连接(Connection) 的任务被委托给了 Driver 来实现（其中，Driver 有 Java 定义接口，并由各数据库提供商提供，例如 MySQL 提供了 mysql-connector-java-XXX.jar 来完成针对相应数据库的具体实现）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ----------------------------\n// SimpleDriverDataSource 的实现\n// ----------------------------\n@Override\nprotected Connection getConnectionFromDriver(Properties props) throws SQLException {\n    Driver driver = getDriver();\n    String url = getUrl();\n    Assert.notNull(driver, \"Driver must not be null\");\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Creating new JDBC Driver Connection to [\" + url + \"]\");\n    }\n    // 哈哈，重点在这... driver 在该类中被预先注入\n    return driver.connect(url, props);\n}\n\n// -----------------------------\n// DriverManagerDataSource 的实现\n// -----------------------------\n@Override\nprotected Connection getConnectionFromDriver(Properties props) throws SQLException {\n    String url = getUrl();\n    Assert.state(url != null, \"'url' not set\");\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Creating new JDBC DriverManager Connection to [\" + url + \"]\");\n    }\n    // 调了个内部函数\n    return getConnectionFromDriverManager(url, props);\n}\n\nprotected Connection getConnectionFromDriverManager(String url, Properties props) throws SQLException {\n    // 委托给 DriverManager 类来获取连接\n    // DriverManager 的主要操作是遍历在该管理类中注册的 Driver\n    // 每个 Driver 实例都去尝试一下，能不能获得一个连接\n    // 第一次在某个 Driver 中拿到一个连接即返回连接 (Connection)\n    return DriverManager.getConnection(url, props);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e简要的类图如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fncrgqcjqoj31es15ajxj.jpg\"\u003e\u003c/p\u003e\n\u003ch2\u003eDriverManager\u003c/h2\u003e\n\u003cp\u003e上面提到 DataSource 获取连接(Connection) 的操作实质上将委托具体的 Driver 来提供 Connection 。有两种不同的方式，包括经由 DriverManager 遍历所有处于管理下的 Driver 尝试获取连接，或者在 DataSource 实例中直接声明一个特定的 Driver 来获取连接。\u003c/p\u003e\n\u003cp\u003e对于获取连接的具体操作，挖坑-待填。只描述简单的数据库供应商提供的 Driver 如何与 java 相联系。\u003c/p\u003e\n\u003cp\u003e###在 DriverManager 中注册 Driver 实例\u003c/p\u003e\n\u003cp\u003e通常在与数据库交互逻辑的 Java 代码中，都会有 \u003ccode\u003eClass.forName(\"com.mysql.jdbc.Driver\")\u003c/code\u003e (此处以 MySQL 提供的 mysql-connector-java-XXX.jar 为例，下同）的代码块，加载指定的 com.mysql.jdbc.Driver 为 java.lang.Class 类。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e当然，在 JDBC 4.0 标准下，可以不必再显示声明 \u003ccode\u003eClass.forName(\"\")\u003c/code\u003e 语句，Driver 也同样会在 DriverManager 初始化时自动注册。\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Class 类中对于 forName(String className) 的方法\n// 作用为返回一个 java.lang.Class 实例。\npublic static Class\u0026#x3C;?\u003e forName(String className) throws ClassNotFoundException {...}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e同时， JVM 在加载类的过程中会执行类中的 static 代码块。下述 row 10 ~ 16 的代码片段将被执行。唯一的逻辑就是 new 一个 com.mysql.jdbc.Driver 实例，并将实例注册(registerDriver) 到 \u003cstrong\u003ejava.sql.DriverManager\u003c/strong\u003e 中。 \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.mysql.jdbc;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n    // ~ Static fields/initializers\n    // ---------------------------------------------\n\n    //\n    // Register ourselves with the DriverManager\n    //\n    static {\n        try {\n            java.sql.DriverManager.registerDriver(new Driver());\n        } catch (SQLException E) {\n            throw new RuntimeException(\"Can't register driver!\");\n        }\n    }\n\n    // ~ Constructors\n    // -----------------------------------------------------------\n\n    /**\n     * Construct a new driver and register it with DriverManager\n     * \n     * @throws SQLException\n     *             if a database error occurs.\n     */\n    public Driver() throws SQLException {\n        // Required for Class.forName().newInstance()\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e下面再来看一下 DriverManager 中的 registerDriver() 方法。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DriverManager {\n\n    // DriverManager 维护一个线程安全的 Driver 列表\n    // 此处的 DriverInfo 里面即包装了 Driver \n    private final static CopyOnWriteArrayList\u0026#x3C;DriverInfo\u003e registeredDrivers = \n        new CopyOnWriteArrayList\u0026#x3C;\u003e();\n\n    // 在 DriverManager 中注册 Driver\n    public static synchronized void registerDriver(java.sql.Driver driver)\n        throws SQLException {\n        registerDriver(driver, null);\n    }\n  \n    public static synchronized void registerDriver(java.sql.Driver driver,\n            DriverAction da)\n        throws SQLException {\n\n        /* 如果当前 Driver 不在列表中，即添加到列表。 */\n        if(driver != null) {\n            registeredDrivers.addIfAbsent(new DriverInfo(driver, da));\n        } else {\n            // This is for compatibility with the original DriverManager\n            throw new NullPointerException();\n        }\n\n        println(\"registerDriver: \" + driver);\n\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e通过 DriverManager 获取连接(Connection)\u003c/h3\u003e\n\u003cp\u003e上一节有提到过可以通过 DriverManager 来遍历获取连接，也可以直接声明具体 Driver 并获取连接。下面代码展示的是通过 DriverManager 获取连接的操作。 \u003cdel\u003e哈哈哈，反正最后都是由具体驱动实现获取连接。\u003c/del\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DriverManager {\n    // 获取连接的 public 接口 (1)\n    public static Connection getConnection(String url,\n        java.util.Properties info) throws SQLException {\n        return (getConnection(url, info, Reflection.getCallerClass()));\n    }\n    // 获取连接的 public 接口 (2)\n    public static Connection getConnection(String url,\n        String user, String password) throws SQLException {\n        java.util.Properties info = new java.util.Properties();\n\n        if (user != null) {\n            info.put(\"user\", user);\n        }\n        if (password != null) {\n            info.put(\"password\", password);\n        }\n\n        return (getConnection(url, info, Reflection.getCallerClass()));\n    }\n    // 获取连接的 public 接口 (3)\n    public static Connection getConnection(String url)\n        throws SQLException {\n        java.util.Properties info = new java.util.Properties();\n        return (getConnection(url, info, Reflection.getCallerClass()));\n    }\n \n    // 获取连接的内部逻辑实现\n    private static Connection getConnection(\n        String url, java.util.Properties info, Class\u0026#x3C;?\u003e caller) \n        throws SQLException {\n        /*\n         * When callerCl is null, we should check the application's\n         * (which is invoking this class indirectly)\n         * classloader, so that the JDBC driver class outside rt.jar\n         * can be loaded from here.\n         */\n        ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;\n        synchronized(DriverManager.class) {\n            // synchronize loading of the correct classloader.\n            if (callerCL == null) {\n                callerCL = Thread.currentThread().getContextClassLoader();\n            }\n        }\n        // url 是定位 DBMS 最重要的参数，不能为空\n        if(url == null) {\n            throw new SQLException(\"The url cannot be null\", \"08001\");\n        }\n\n        println(\"DriverManager.getConnection(\\\"\" + url + \"\\\")\");\n\n        // 遍历所有注册的 Driver ，并都尝试获取连接(Connection)\n        SQLException reason = null;\n\n        for(DriverInfo aDriver : registeredDrivers) {\n            // 判断注册的 Driver 是否由 ClassLoader callerCL 加载，不是则跳过\n            if(isDriverAllowed(aDriver.driver, callerCL)) {\n                try {\n                    println(\"    trying \" + aDriver.driver.getClass().getName());\n                    // 获取连接，:) 还是由 driver 实例自行提供\n                    Connection con = aDriver.driver.connect(url, info);\n                    if (con != null) {\n                        // Success!\n                        println(\"getConnection returning \" + \n                                aDriver.driver.getClass().getName());\n                        return (con);\n                    }\n                } catch (SQLException ex) {\n                    if (reason == null) {\n                        reason = ex;\n                    }\n                }\n\n            } else {\n                println(\"    skipping: \" + aDriver.getClass().getName());\n            }\n\n        }\n\n        // 如果运行到下列代码，则表明获取连接失败，抛出错误\n        if (reason != null)    {\n            println(\"getConnection failed: \" + reason);\n            throw reason;\n        }\n\n        println(\"getConnection: no suitable driver found for \"+ url);\n        throw new SQLException(\"No suitable driver found for \"+ url, \"08001\");\n    }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003e简单的提一嘴，Connection 仍然只是一个针对 Java -\u003e DB Server 的上层接口，如果想要更深层次地了解 Connection 与 DB Server 的交互，可以尝试去看一下 com.mysql.jdbc.MysqlIO 类，MySQL 实现的 JDBC4Connection 类也是在使用该类来实现对 DB Server 交互。（哈哈，只看过 MySQL 提供的 Driver 包）。\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003ePreparedStatement \u0026#x26; CallableStatement\u003c/h2\u003e\n\u003cp\u003e在了解了 DataSource 获取连接(Connection) 的实质以及 JdbcTemplate 的通用接口之后，使用 Spring-jdbc 进行数据库相关的操作可以直截了当的利用如下代码进行实现（此处仅展示通过 Java 硬编码的形式进行实现，XML 配置方法类似）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String... args) {\n    // 定义数据源\n    DriverManagerDataSource dataSource = new DriverManagerDataSource();\n    // 配置参数\n    dataSource.setUrl(\"jdbc:mysql://\u0026#x3C;host\u003e:\u0026#x3C;port\u003e/\u0026#x3C;dbName\u003e?\u0026#x3C;props\u003e\");\n    dataSource.setUsername(\"\u0026#x3C;username\u003e\");\n    dataSource.setPassword(\"\u0026#x3C;passwd\u003e\");\n    \n    // 实例化一个 JDBC 工具类\n    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n    // 执行相关 CRUD 操作 \n    jdbcTemplate.execute();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e回顾第一节所讲的 JdbcTemplate 的 4 个基础方法：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(ConnectionCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(StatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(PreparedStatementCreator psc, PreparedStatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(CallableStatementCreator csc, CallableStatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fndsm5tl7aj30zg0byq47.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e四个基础方法都有一个特定的回调函数将通过预配置的 DataSource 得到的 Connection 或 更进一步的 Statement or PreparedStatement or CallableStatement 作为入参来执行定义的唯一方法。\u003c/p\u003e\n\u003cp\u003e以 \u003ccode\u003e\u0026#x3C;T\u003e T execute(StatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e 为例来了解一下方法的核心逻辑。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic \u0026#x3C;T\u003e T execute(StatementCallback\u0026#x3C;T\u003e action) throws DataAccessException {\n    // 通过工具类 DataSourceUtils 获取一个连接\n    Connection con = DataSourceUtils.getConnection(obtainDataSource());\n    // 一个 Statement 空实例，PreparedStatement, CallableStatement 类似\n    Statement stmt = null;\n    try {\n        stmt = con.createStatement();   // 通过连接(Connection)获取一个 Statement\n        applyStatementSettings(stmt);   // 配置 Statement 参数\n        // 回调执行 doInXXX() 方法, 并获得 result\n        T result = action.doInStatement(stmt);  \n        handleWarnings(stmt);\n        return result;\n    } catch() {\n      \n    } finally {\n      \n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是，对于 PreparedStatement 和 CallableStatement 而言，获取一个 \u003cem\u003eXXX\u003c/em\u003eStatement 的方式就有所不同了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 获取 Statement 实例\nStatement stmt = con.createStatement();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 获取 PreparedStatement 实例\n// psc 是一个 PreparedStatementCreator 接口实现的实例\nPreparedStatement ps = psc.createPreparedStatement(con);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 获取 CallableStatement 实例\n// csc 是一个 CallableStatementCreator 接口实现的实例\nCallableStatement cs = csc.createCallableStatement(con);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 Statement 直接通过 Connection 获取实例，但是 PreparedStatement 和 CallableStatement 就有所不同，其区别就在于 PreparedStatement 和 CallableStatement 两个 Statement 都是可以定制入参的，更甚者， CallableStatement 可以定制 DB 执行结果的出参。当然，核心还是 \u003ccode\u003econ.prepareStatement() OR con.prepareCall()\u003c/code\u003e 方法，只不过是将获取 XXXStatement 的操作下放给 XXXStatementCreator 实例类实现，给予使用者重复的自主权，同时也是逻辑解耦的一种操作。\u003c/p\u003e\n\u003cp\u003e例如：\u003c/p\u003e\n\u003cp\u003eSimplePreparedStatementCreator 这个 PreparedStatementCreator 接口的实现类，只是简单的调用了 \u003ccode\u003econ.prepareStatement(sql)\u003c/code\u003e 方法。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static class SimplePreparedStatementCreator \n    implements PreparedStatementCreator, SqlProvider {\n\n    private final String sql;\n\n    @Override\n    public PreparedStatement createPreparedStatement(Connection con) \n        throws SQLException {\n        return con.prepareStatement(this.sql);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e而对于 PreparedStatementCreatorImpl ，在 createPreparedStatement(Connection con) 的实现上，又添加了更多的操作。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate class PreparedStatementCreatorImpl\n        implements PreparedStatementCreator, PreparedStatementSetter, SqlProvider, ParameterDisposer {\n\n    private final String actualSql;\n\n    private final List\u0026#x3C;?\u003e parameters;\n\n    @Override\n    public PreparedStatement createPreparedStatement(Connection con) throws SQLException {\n        PreparedStatement ps;\n        if (generatedKeysColumnNames != null || returnGeneratedKeys) {\n            if (generatedKeysColumnNames != null) {\n                // 获取一个 PreparedStatement 实例，下同\n                ps = con.prepareStatement(this.actualSql, \n                                          generatedKeysColumnNames);\n            }\n            else {\n                ps = con.prepareStatement(this.actualSql, \n                                         PreparedStatement.RETURN_GENERATED_KEYS);\n            }\n        }\n        else if (resultSetType == ResultSet.TYPE_FORWARD_ONLY \n                 \u0026#x26;\u0026#x26; !updatableResults) {\n            ps = con.prepareStatement(this.actualSql);\n        }\n        else {\n            ps = con.prepareStatement(this.actualSql, resultSetType,\n                updatableResults ? ResultSet.CONCUR_UPDATABLE : \n                                      ResultSet.CONCUR_READ_ONLY);\n        }\n        // 将可变 SQL (例如 SELECT * FROM msg WHERE id = ?) 的 ? 用实际参数替换\n        setValues(ps);\n        return ps;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从上述两种 PreparedStatementCreator 接口的不同实现，也可以从另一种角度理解到，函数式接口将获取目标出参的具体逻辑交给使用者定义，给予了使用者充分的自主权，同时也是一种业务逻辑的解耦。\u003c/p\u003e\n\u003cp\u003e在上面代码 PreparedStatementCreatorImpl 类的实现中，我们看到第 32 行代码 \u003ccode\u003esetValue(ps)\u003c/code\u003e 。此处的方法是由接口 PreparedStatementSetter 定义的。主要目的是将可变 SQL 中的 ? 参数用实际参数进行一个替换。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 以 SQL (SELECT * FROM msg WHERE id = ? AND day = ?) 为例\n/** 纯 Java 核心库的实现 PreparedStatement 参数注入 */\nps.setInt(1, 1763);\nps.setString(2, \"2018-01-01\");\nps.executeQuery();\n\n/** 以 Spring-jdbc 实现 PreparedStatement 参数注入 */\n// setValues() 由接口 PreparedStatementSetter 定义，封装了注入参数的具体实现逻辑\n// 可以由使用者自行定义\nsetValues(ps);  \nps.executeQuery();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fndyybh4q1j31kw0u3afx.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e上面类图表示了 PreparedStatementSetter 及其实现类的相关依赖。\u003c/p\u003e\n\u003cp\u003eSetter 的主要目标即为对 SQL 中的 ? 参数进行注入。\u003c/p\u003e\n\u003cp\u003e\u003cdel\u003e个人精力有限，对Spring-jdbc在Statement上对参数注入的回调理解有限。\u003c/del\u003e\u003c/p\u003e\n\u003ch2\u003eResultSet\u003c/h2\u003e\n\u003cp\u003e在前几节已经提到讲了数据源、驱动管理器以及 Statement 之后，利用 JDBC 的最重要的目的就是对 DB 进行操作，并获得预期结果。对于查询语句而言，结果应该是若干记录行；就更新语句而言，结果可能是影响的行数。而 Spring-jdbc 对 ResultSet 额外进行的封装，即是将原本散乱的结果进行一个整合，例如整合成一个(一组)完整的 Bean 来进行展示。\u003c/p\u003e\n\u003cp\u003e在 JdbcTemplate 中，四个基本方法入参都包括一个回调接口，而在执行回调获得 ResultSet 之后，方法并不是直接返回，而是进行了一定的操作。\u003c/p\u003e\n\u003cp\u003e以一个 PreparedStatementCallback 的实例类为例，在 doInPreparedStatement() 方法中，获得了 ResultSet ，但是仍通过 rse.extractData(rs) 语句进行了处理后再返回结果\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic T doInPreparedStatement(PreparedStatement ps) throws SQLException {\n    // 声明一个 ResultSet \n    ResultSet rs = null;\n    try {\n        if (pss != null) {  // setValues() 方法填充 PreparedStatement 中的可变参数 ? \n            pss.setValues(ps);\n        }\n        rs = ps.executeQuery(); // 执行查询 sql ，获取结果\n        return rse.extractData(rs); // 重点... 该语句一定是对结果进行了一些操作.\n    }\n    finally {\n        JdbcUtils.closeResultSet(rs);\n        if (pss instanceof ParameterDisposer) {\n            ((ParameterDisposer) pss).cleanupParameters();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在来看一下究竟在返回结果前进行了什么操作。\u003c/p\u003e\n\u003cp\u003e由于是一个回调接口的实现类，rse 应该在外部方法中。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic \u0026#x3C;T\u003e T query(\n        PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, \n        final ResultSetExtractor\u0026#x3C;T\u003e rse)\n        throws DataAccessException {\n\n    return execute(psc, new PreparedStatementCallback\u0026#x3C;T\u003e() {\n        @Override\n        public T doInPreparedStatement(PreparedStatement ps) throws SQLException {\n            ... \n        }\n    });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 rse 是一个 ResultSetExtractor 的实例。从名称上可以看出 Extractor 即为提取器，结果集提取器。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e/** 函数式接口，提供的唯一方法为 extractData(...) */\n@FunctionalInterface\npublic interface ResultSetExtractor\u0026#x3C;T\u003e {\n\n    @Nullable\n    T extractData(ResultSet rs) throws SQLException, DataAccessException;\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fndzz0pqnrj31a60i676v.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eSpring-jdbc 中现有的实现有三个类，其中 RowCallbackHandlerResultSetExtractor 和 RowMapperResultSetExtractor 两个类从上面类图及命名即可看出，两个是作为一个适配器而存在的，将 extractData() 进行转换，分别由 RowCallbackHandler 和 RowMapper 实例进行具体操作。而 AbstractLobStreamingResultSetExtractor 类从名称上看，也是一个类似流操作的实现类(其中的 Lob 指的是 DB 中的 BLOB 与 CLOB 类型，在 Spring-jdbc 中也加入了额外的支持) 。\u003c/p\u003e\n\u003ch3\u003eRowCallbackHandler\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fnh2uw3a0aj30h20jeta4.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e从名称上看，这是一个与 ResultSet 结果集行相关的回调接口。processRow(ResultSet rs) 方法将处理行相关的逻辑。\u003c/p\u003e\n\u003cp\u003e从它的一个实现类 RowCountCallbackHandler 来说，其最主要的私有属性 rowCount 即是统计 ResultSet 的结果行数。下面是一个具体使用的该类的案例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String[] args) throws ClassNotFoundException {\n\n    DriverManagerDataSource dataSource = new DriverManagerDataSource();\n    dataSource.setUrl(\"jdbc:mysql://\u0026#x3C;host\u003e:\u0026#x3C;port\u003e/\u0026#x3C;dbName\u003e\");\n    dataSource.setUsername(\"\u0026#x3C;username\u003e\");\n    dataSource.setPassword(\"\u0026#x3C;password\u003e\");\n\n    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n    RowCountCallbackHandler rcch = new RowCountCallbackHandler();\n\n    jdbcTemplate.query(\"SELECT * FROM info WHERE id='2018'\", (RowCallbackHandler) rcch);\n    \n    System.out.println(rcch.getRowCount()); //获取结果集行数\n    System.out.println(rcch.getColumnCount());  // 获取结果集列数\n    for (String arg : rcch.getColumnNames()) {  // 打印结果集每一列名称\n        System.out.println(\"ColumnNames : \" + arg);\n    }\n    for (int i : rcch.getColumnTypes()) {   // 打印结果集每一列类型(Types 为枚举类)\n        System.out.println(\"ColumnTypes : \" + i);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e具体查看 RowCountCallbackHandler 类的 processRow() 方法可以看到，其获取列相关信息都来自于 ResultSetMetaData 。而结果行数来源于 Iterator 迭代。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic final void processRow(ResultSet rs) throws SQLException {\n    if (this.rowCount == 0) {\n        ResultSetMetaData rsmd = rs.getMetaData();\n        this.columnCount = rsmd.getColumnCount();\n        this.columnTypes = new int[this.columnCount];\n        this.columnNames = new String[this.columnCount];\n        for (int i = 0; i \u0026#x3C; this.columnCount; i++) {\n            this.columnTypes[i] = rsmd.getColumnType(i + 1);\n            this.columnNames[i] = JdbcUtils.lookupColumnName(rsmd, i + 1);\n        }\n        // could also get column names\n    }\n    processRow(rs, this.rowCount++);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eRowMapper\u003c/h3\u003e\n\u003cp\u003e上面 RowCallbackHandler 接口从逻辑上划分是用于处理 ResultSet 元数据信息的。而 RowMapper 较上一个接口而言，有更高的实用性。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fnh3h739kaj30z60nago4.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e特别是其实现类 BeanPropertyRowMapper 可以将散乱的 ResultSet 的结果数据整理成一个个 Object Bean 作为返回结果。而省去了对逐一读取 ResultSet 行记录并填充 Bean 属性的麻烦。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n\nBeanPropertyRowMapper\u0026#x3C;Model\u003e rowMapper = new BeanPropertyRowMapper\u0026#x3C;\u003e(Model.class);\nList\u0026#x3C;Model\u003e list = jdbcTemplate.query(\"SELECT * FROM info WHERE id = '2018'\", rowMapper);\n/** 获得的 Model list 的对应属性将通过 Java 的反射机制进行填充\n *  List\u0026#x3C;Model\u003e list 即结果\n */\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当然，要求是 Model 类中的属性与 DB table 中的列名保持一致（大小写无要求）。\u003c/p\u003e\n\u003cp\u003e而其它两个类的实现也是基于反射机制，实现其相应的业务逻辑。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e概览\u003c/h2\u003e\n\u003cp\u003e在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。\u003c/p\u003e"},{"url":"2018-03-01-区块链简单介绍","fileName":"2018-03-01-区块链简单介绍.md","title":"区块链技术概述","author":"fangfeng","date":"2018-03-01T00:00:00.000Z","tags":["BlockChain","Smart Contract"],"content":"\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg\" alt=\"区块链简单结构\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg\" alt=\"Merkle tree\"\u003e\u003c/p\u003e\n\u003ch2\u003e基本工作流程\u003c/h2\u003e\n\u003ch3\u003e新交易发起流程\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e用户通过公/私钥与区块链网络进行交互\u003c/li\u003e\n\u003cli\u003e处理用户交易的节点向网络邻节点广播用户交易\u003c/li\u003e\n\u003cli\u003e邻节点验证交易的有效性；可信，继续向其它邻节点广播；不可信，丢弃。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e新区块产生流程\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e矿工尝试将一个时间区间内的交易进行打包形成新区块（怎么打包，看下文）\u003c/li\u003e\n\u003cli\u003e生产出新区块的矿工节点向网络广播新区块\u003c/li\u003e\n\u003cli\u003e收到新区块的网络节点验证该区块的有效性\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca href=\"https://blockchain.info/zh-cn\"\u003e比特币区块浏览器\u003c/a\u003e      更多\u003ca href=\"https://en.wikipedia.org/wiki/Metric_prefix\"\u003e国际单位制前缀\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e网络共识\u003c/h2\u003e\n\u003cp\u003e所有区块链网络节点需要对交易以及其在新区块里面的顺序达成一致（交易的有效性以及交易的打包顺序）。\u003c/p\u003e\n\u003cp\u003e可能出现：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e女巫攻击——单一实体以多重身份重复对新区块结果进行表决（少数人抓住了网络的投票权）\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98\"\u003e拜占庭将军问题\u003c/a\u003e——分布式对等网络的通信容错问题\u003cul\u003e\n\u003cli\u003e不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动\u003cul\u003e\n\u003cli\u003e成员计算机可能出错而发送错误信息\u003c/li\u003e\n\u003cli\u003e网络的不可靠性\u003c/li\u003e\n\u003cli\u003e从而影响网络共识的达成，破坏一致性。\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e不解决的话可能导致——区块链分叉\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e解决方案：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e工作量证明（proof-of-work, PoW），权益证明(proof-of-stake, PoS)，白名单机制（仅适用于私有网络）等\u003c/li\u003e\n\u003cli\u003e实用拜占庭容错算法\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e局限\u003c/h3\u003e\n\u003cp\u003e网络共识机制的实现导致了：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e交易吞吐量\u003c/li\u003e\n\u003cli\u003e更高的交易时延。交易确认时间（只有打包的新区块中才交易才会被承认）。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e共识机制的伸缩可以一定程度上解决上述问题\u003c/p\u003e\n\u003ch2\u003e资产交易\u003c/h2\u003e\n\u003cp\u003e简单交易状态描述，以集中式数据库为例\u003c/p\u003e\n\u003cp\u003e假设初始状态为\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e-------------------------\n| 资产类型 | 所有者 | 数量 |\n-------------------------\n|   CNY   |  防风  |  10 |\n-------------------------\n|   CNY   |  红薯  |  0  |\n-------------------------\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e防风 向 红薯 转账 2 CNY \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e-------------------------\n| 资产类型 | 所有者 | 数量 |\n-------------------------\n|   CNY   |  防风  |  8  |\n-------------------------\n|   CNY   |  红薯  |  2  |\n-------------------------\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e数据库中相应记录的更改完成了资产的交易过程。\u003c/p\u003e\n\u003cp\u003e在区块链中，仍然将分布式链看作是一个达成共识的集中式数据库\u003c/p\u003e\n\u003cp\u003e那么现在的初始状态可以表示成\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e---------------------------------\n| 资产类型 |     所有者     | 数量 |\n---------------------------------\n|   IOTA  |  防风 pub_key  | 10  |\n---------------------------------\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在的所有者由公钥表示，想要修改记录必须提供对应的密钥。\u003c/p\u003e\n\u003cp\u003e例如，防风 向 红薯 转账 2 IOTA ，需要提供防风的私钥和红薯的公钥。交易记录修改结果：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e---------------------------------\n| 资产类型 |     所有者     | 数量 |\n---------------------------------\n                                 被删除了         |   IOTA  |  防风 pub_key  | 10  |\n---------------------------------\n|   IOTA  |  红薯 pub_key  |  2  |\n---------------------------------\n|   IOTA  |  防风 pub_key  |  8  |\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e交易的概念流程：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e定位防风所有的资产记录行\u003c/li\u003e\n\u003cli\u003e删除该行前验证密钥\u003c/li\u003e\n\u003cli\u003e确认该记录没有被别的交易使用（双花问题，双重交易）\u003c/li\u003e\n\u003cli\u003e写入新的正确的记录（红薯获得的资产 \u0026#x26; 防风剩余的资产），确保交易前与交易后资产总额不变\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e上面的模型 —— 基于比特币的交易模型(UTXO \u003cem\u003emodel\u003c/em\u003e)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e适合于数字标记资产的传输与追踪\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e概念：UTXO (unspent transaction outputs) 未花费的交易输出：数据库现有的记录\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e---------------------------------\u003c/p\u003e\n\u003cp\u003e另一种模型常用于智能合约 —— 基于账号的模型(account-based \u003cem\u003emodel\u003c/em\u003e)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e提供了建立多步骤执行的基本机制\u003c/strong\u003e \u003c/p\u003e\n\u003ch3\u003e资产如何产生\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e比特币：\u003cul\u003e\n\u003cli\u003e矿工节点允许在挖出的新节点中加入一种 coinbase 类型的交易（不存在交易输入，新资产数额有比特币链提前定义）\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e在创始新代币的时候全额发行\u003c/li\u003e\n\u003cli\u003e其它机制\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e区块链特性\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e一种健壮的、真正的分布式对等系统，它能容忍节点故障。\u003c/li\u003e\n\u003cli\u003e能够识别冲突和分叉并自动解决的网络，以便收敛到单一的、公认的唯一状态。（区块链永远选择最长的分支来达成网络上的共识）\u003c/li\u003e\n\u003cli\u003e网络活动的透明性、可验证性、可审计性。我们能获取可验证的过程，无论它们是否交换和跟踪数字资产，还是数据驱动的交互。每一个行为，都存有公开的与网络交互的记录，并以此来消除人为的矛盾。\u003c/li\u003e\n\u003cli\u003e这是一种可以标记不同信息的触发者的方法，并且能够在没有中央权威的情况下强制执行。\u003c/li\u003e\n\u003cli\u003e这是一个使得不信任双方根据可预测的、确定性的方式交互的系统。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e智能合约\u003c/h2\u003e\n\u003cp\u003e自动化地执行一系列合约条款的交易协议\u003c/p\u003e\n\u003cp\u003e智能合约是存储在区块链中的脚本（认识上可以与关系型数据库的存储过程类似）。\u003c/p\u003e\n\u003cp\u003e以基于账号的模型为例对合约执行进行描述：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e假设定义一个合约，包括三个方法\n\n(1) “存储”——合约的“存款”功能允许 防风（通过防风的密钥验证）将若干单位的X存入合约中；\n(2) “交易”——“交易”功能允许任何人向合约发送5单位Y，并从合约持有的X中返回1单位给交易方；\n(3) “撤销”——“撤销”功能允许 防风 取出合约中存有的所有资产。\n\n    请注意，上述“存款”和“撤销”功能被限制为只允许被 防风（实际上是防风的私钥）调用。当然，这只有由于上述合约由防风制定。若人为的制定一个所有人都能调用任何功能的合约也是允许的（虽然这在事实上没有意义）。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e那么在基于账户的模型下，可以认为 拥有“存储”、“交易”、“撤销”方法的合约持有一个单独的账户（与用户所持有的账户等价）。\u003c/p\u003e\n\u003cp\u003e在上述合约下，这个账户将可能持有一定数量的资产。除了只能按照预定的合约步骤对资产进行处置之外，其它与用户持有的账户别无二致。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e  __                    __\n / _| __ _ _ __   __ _ / _| ___ _ __   __ _\n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/\n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg\" alt=\"区块链简单结构\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg\" alt=\"Merkle tree\"\u003e\u003c/p\u003e"},{"url":"2018-06-11-ASM-ClassReader","fileName":"2018-06-11-ASM-ClassReader.md","title":"ASM - ClassReader 与 Java ClassFile 文件格式","author":"fangfeng","date":"2018-06-11T00:00:00.000Z","tags":[],"content":"\u003ch2\u003eJava ClassFile 文件格式\u003c/h2\u003e\n\u003cp\u003e读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。\n\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\"\u003eThe class File Format(Java SE 8)\u003c/a\u003e \u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eu1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-c++\"\u003eClassFile {\n    u4             magic;                                   // 魔数(magic) 固定为 0xCAFEBABE\n    u2             minor_version;                           // 次版本号\n    u2             major_version;                           // 主版本号\n    u2             constant_pool_count;                     // 常量池 constant_pool 的数量 + 1, 最大为 (2\u0026#x3C;\u0026#x3C;16 - 1) = 65535\n    cp_info        constant_pool[constant_pool_count-1];    // 常量池 取值下标为 [1, constant_pool_count)\n    u2             access_flags;                            // 对类 or 接口的访问权限和属性的标志的掩码\n    u2             this_class;                              // 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)\n    u2             super_class;                             // 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标\n    u2             interfaces_count;                        // 直接父接口的数量\n    u2             interfaces[interfaces_count];            // 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i\u0026#x3C;interfaces_count), 指向的类型为 CONSTANT_Class_info)\n    u2             fields_count;                            // 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)\n    field_info     fields[fields_count];                    // 字段的详细声明, 不包含继承来的字段\n    u2             methods_count;                           // 方法数量\n    method_info    methods[methods_count];                  // 方法的详细声明, 不包括继承来的方法\n    u2             attributes_count;                        // 属性数量\n    attribute_info attributes[attributes_count];            // 属性的详细声明\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过 \u003ccode\u003ejavac Xxx.java\u003c/code\u003e 命令得到的 \u003ccode\u003eXxx.class\u003c/code\u003e 文件严格按照定义的 ClassFile 文件格式以8比特的字节为单位进行存储。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e下面的例子都将通过 Trie.java (实际代码见本文最后) 以及其经编译后的文件 Trie.class 做基本的介绍。\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003emagic, minor_verion \u0026#x26; major_version\u003c/h3\u003e\n\u003cp\u003e通过命令 \u003ccode\u003exxd Trie.class\u003c/code\u003e 查看 Trie.class 的十六进制编码，前16字节的内容如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到前4字节的内容 \u003ccode\u003e0xcafebabe\u003c/code\u003e，没有实际意义，但是作为其是能否被JVM(Java Virtual Machine, Java虚拟机)接收的Class文件的一个校验。\u003c/p\u003e\n\u003cp\u003e紧接着的4个字节包括\u003ccode\u003e次版本号\u003c/code\u003e 和 \u003ccode\u003e主版本号\u003c/code\u003e，暂时不做深入。\u003c/p\u003e\n\u003ch3\u003e常量池 constant_pool\u003c/h3\u003e\n\u003cp\u003e从第10个字节开始(从第0字节开始计数)，连续的两个字节表示常量池中各种 CONSTANT 的总个数+1 (constant_pool_count)。constant_pool_count 只有2字节也就意味着: 常量池的最大常量数量为 (2\u0026#x3C;\u0026#x3C;16 - 1) = 65535 (当然，貌似在这个量级上，也从没见过有谁能够维护这样一个大JAVA类文件了)。\u003c/p\u003e\n\u003cp\u003e可以看到 constant_pool_count 的内容为 \u003ccode\u003e0x008f = 143\u003c/code\u003e ，即对于常量池的声明可以认为是 \u003ccode\u003ecp_info constant_pool[142]\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003ecp_info {\n    u1 tag;\n    u1 info[]; \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e利用 JDK 自带的 \u003ccode\u003ejavap\u003c/code\u003e 来查看 \u003ccode\u003eTrie.class\u003c/code\u003e 文件(\u003ccode\u003ejavap -v Trie.class\u003c/code\u003e)，可以对 cp_info 的格式有一个粗浅但形象化的认识(结果见\u003cstrong\u003e附录2\u003c/strong\u003e)\n其中第一列的内容 \u003ccode\u003e#? = ?\u003c/code\u003e \u003ccode\u003e#?\u003c/code\u003e表示id，\u003ccode\u003e= ?\u003c/code\u003e表示一个 cp_info 的实际类型，有 \u003ccode\u003ecp_info.tag\u003c/code\u003e 指定，具体映射表为\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eConstant Type\u003c/th\u003e\n\u003cth\u003eValue\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Class\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e7\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Fieldref\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e9\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Methodref\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e10\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_InterfaceMethodref\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e11\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_String\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e8\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Integer\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Float\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e4\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Long\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Double\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e6\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_NameAndType\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e12\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Utf8\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_MethodHandle\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e15\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_MethodType\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e16\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_InvokeDynamic\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e18\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Module\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e19\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCONSTANT_Package\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e20\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e在 Java ClassFile 的格式定义中，同时定义了每种 \u003ccode\u003eCONSTANT\u003c/code\u003e 的长度与格式。\n例如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c++\"\u003eCONSTANT_Class_info {\n    u1 tag;\n    u2 name_index;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-c++\"\u003eCONSTANT_Fieldref_info {\n     u1 tag;\n     u2 class_index;\n     u2 name_and_type_index;\n}\nCONSTANT_Methodref_info {\n  u1 tag;\n  u2 class_index;\n  u2 name_and_type_index;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e更多的 \u003ccode\u003eCONSTANT_XXX\u003c/code\u003e 的格式定义见 \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4\"\u003eClassFile CONSTANT_XXX 结构\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e简单解析一下 cp_info[1]。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.\n\n#1 = Methodref          #36.#75       // java/lang/Object.\"\u0026#x3C;init\u003e\":()V\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecp_info[1].tag = 0x0a = 10\u003c/code\u003e，即 cp_info[1] 的类型为 Methodref 。\n之后就直接套用 \u003ccode\u003eCONSTANT_Methodref_info\u003c/code\u003e 的数据结构定义的格式\n\u003ccode\u003ecp_info[1].class_index = 0x0024 = 36\u003c/code\u003e，即 cp_info[1].class_index 表示的类名指向常量池第 36 个元素表示的类\n\u003ccode\u003ecp_info[1].name_and_type_index = 0x004b = 75\u003c/code\u003e。表示指向的是常量池第 75 个元素表示的 NameAndType 结构\u003c/p\u003e\n\u003cp\u003e对于这部分内容的理解，如果觉得有能够阅读英文文档，可以参考 \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\"\u003eThe Java® Virtual Machine Specification Chap 4.\u003c/a\u003e\n否则，可以选择 \u003ca href=\"http://icyfenix.iteye.com/blog/1256329\"\u003eJava 虚拟机规范(Java SE 7 版) 第四章\u003c/a\u003e\n并尝试根据经编译后.class文件的二进制码进行人工解析，以加深对此的理解。\u003c/p\u003e\n\u003ch3\u003emore...\u003c/h3\u003e\n\u003cp\u003e更多内容于此基本类似，均属于已经被严格预定义的规范化格式，对此进行解析即可得到相应的内容。\u003c/p\u003e\n\u003ch2\u003eASM 概览\u003c/h2\u003e\n\u003ch3\u003e包结构\u003c/h3\u003e\n\u003cp\u003easm, asm-analysis, asm-commons, asm-tree, asm-util, asm-xml 模块基于 Maven 的组织形式，并包含有单元测试的内容。\u003c/p\u003e\n\u003cp\u003easm-test 实现了对上述模块的单元测试的整合。\u003c/p\u003e\n\u003cp\u003ebenchmarks 定义了一些基本的 JMH 基准测试来衡量ASM的表现\u003c/p\u003e\n\u003cp\u003egradle 包含了一些 Gradle 包装器，来辅助 Linux or Windows 脚本的调用请求\u003c/p\u003e\n\u003cp\u003etools 包含两个 Gradle 项目来帮助 ASM 生成 Artifacts 。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1frywra01upj308g0akmxr.jpg\" alt=\"ASM Structure\"\u003e\u003c/p\u003e\n\u003ch3\u003e代码组织形式\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"http://asm.ow2.io/asm-package-dependencies.svg\" alt=\"Code Organization\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eorg.objectweb.asm 作为核心包，定义了 ASM 访问者 API 以及两个核心类 ClassReader \u0026#x26; ClassWriter 来读写编译后的 Java 类。该包不依赖于其他包，且可单独使用\u003c/li\u003e\n\u003cli\u003eorg.objectweb.asm.signature 提供了读写泛型签名的 API\u003c/li\u003e\n\u003cli\u003eorg.objectweb.asm.tree 提供了类 DOM API 与类 SAX API。\u003c/li\u003e\n\u003cli\u003eorg.objectweb.asm.tree.analysis 基于 .tree 提供了静态字节码分析框架\u003c/li\u003e\n\u003cli\u003eorg.objectweb.asm.commons 提供了一些基于 core 和 tree 包的类适配器。\u003c/li\u003e\n\u003cli\u003eorg.objectweb.asm.util 提供了一些用于 DEBUG 的访问者类与适配器类\u003c/li\u003e\n\u003cli\u003eorg.objectweb.asm.xml 目前已经被 @Deprecated 。提供了类文件与 XML 互相转换的能力\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e综上，asm 核心包是最为复杂的一个模块，而其它诸如 tree, util, xml 等都只是提供了将 JAVA 类从一种高级表示形态转换为另一种的能力。signature 也相当简单，提供了解析和打印简单语法的能力。\u003c/p\u003e\n\u003ch3\u003e主要数据结构\u003c/h3\u003e\n\u003cp\u003e核心包由 28 个类(接口) 组成。如果不考虑 Opcodes 接口, 5 个抽象访问者类(AnnotationVistitor, ClassVisitor, FieldVisitor, MethodVisitor and ModuleVisitor), 6 个工具类(ConstantDynamic, Contants, Handle, Type, TypePath and TypeReference), 剩下 16 个类的由下图提供一个粗略的展示。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"http://asm.ow2.io/asm-package-overview.svg\"\u003e\u003c/p\u003e\n\u003cp\u003e编译类到访问事件的转换只由一个类 ClassReader 以及辅助类 Context 完成。其逆过程由以 ClassWriter 为核心的其它 14 个类完成。\u003c/p\u003e\n\u003ch3\u003eClassReader\u003c/h3\u003e\n\u003cp\u003eClassReader 作为 ASM 核心包解析现有 .class 的唯一工具，组织形式相当简单。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在构造函数中完成对常量池和引导方法的解析\u003cul\u003e\n\u003cli\u003e存储每个常量池项目的起始偏移量 cpInfoOffsets\u003c/li\u003e\n\u003cli\u003e存储每个引导方法的起始偏移量 bootstrapMethodOffsets\u003c/li\u003e\n\u003cli\u003e存储最长字符串常量的大小 maxStringLength\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e  ClassReader(final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {\n    this.b = classFileBuffer;   // .class 文件缓存\n    // 检查主版本号, 第6,7个字节(从0字节开始计数)\n    if (checkClassVersion \u0026#x26;\u0026#x26; readShort(classFileOffset + 6) \u003e Opcodes.V11) {\n      throw new IllegalArgumentException(\n          \"Unsupported class file major version \" + readShort(classFileOffset + 6));\n    }\n    // 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节\n    int constantPoolCount = readUnsignedShort(classFileOffset + 8);     // 读取无符号short, 即读取连续两字节作为一个short值\n    cpInfoOffsets = new int[constantPoolCount];                         // 每个常量的偏移位置\n    cpInfoValues = new Object[constantPoolCount];                       // 每个常量的实例对象\n    int currentCpInfoIndex = 1;\n    int currentCpInfoOffset = classFileOffset + 10;\n    int currentMaxStringLength = 0;                                     // 最长字符串常量\n    while (currentCpInfoIndex \u0026#x3C; constantPoolCount) {\n      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;\n      int cpInfoSize;\n      switch (classFileBuffer[currentCpInfoOffset]) {\n        case Symbol.CONSTANT_FIELDREF_TAG:\n        case Symbol.CONSTANT_METHODREF_TAG:\n        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n        case Symbol.CONSTANT_INTEGER_TAG:\n        case Symbol.CONSTANT_FLOAT_TAG:\n        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n        case Symbol.CONSTANT_DYNAMIC_TAG:\n          cpInfoSize = 5;\n          break;\n        case Symbol.CONSTANT_LONG_TAG:\n        case Symbol.CONSTANT_DOUBLE_TAG:\n          cpInfoSize = 9;\n          currentCpInfoIndex++;\n          break;\n        case Symbol.CONSTANT_UTF8_TAG:\n          cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);\n          if (cpInfoSize \u003e currentMaxStringLength) {\n            // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate\n            // of the length in characters of the corresponding string, and is much cheaper to\n            // compute than this exact length.\n            currentMaxStringLength = cpInfoSize;\n          }\n          break;\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n          cpInfoSize = 4;\n          break;\n        case Symbol.CONSTANT_CLASS_TAG:\n        case Symbol.CONSTANT_STRING_TAG:\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\n        case Symbol.CONSTANT_PACKAGE_TAG:\n        case Symbol.CONSTANT_MODULE_TAG:\n          cpInfoSize = 3;\n          break;\n        default:\n          throw new IllegalArgumentException();\n      }\n      currentCpInfoOffset += cpInfoSize;\n    }\n    this.maxStringLength = currentMaxStringLength;\n    // The Classfile's access_flags field is just after the last constant pool entry.\n    this.header = currentCpInfoOffset;\n\n    // 读取 BootstrapMethods 属性(如果存在)\n    int currentAttributeOffset = getFirstAttributeOffset();\n    int[] currentBootstrapMethodOffsets = null;\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i \u003e 0; --i) {\n      // 读取每个 attribute_info 的属性名和属性长度\n      String attributeName = readUTF8(currentAttributeOffset, new char[maxStringLength]);\n      int attributeLength = readInt(currentAttributeOffset + 2);\n      currentAttributeOffset += 6;\n      // 如果当前属性名为 BootstrapMethods ，则进入处理逻辑\n      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        // Read the num_bootstrap_methods field and create an array of this size.\n        currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];\n        // Compute and store the offset of each 'bootstrap_methods' array field entry.\n        int currentBootstrapMethodOffset = currentAttributeOffset + 2;\n        for (int j = 0; j \u0026#x3C; currentBootstrapMethodOffsets.length; ++j) {\n          currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;\n          // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\n          // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\n          currentBootstrapMethodOffset +=\n              4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\n        }\n      }\n      currentAttributeOffset += attributeLength;\n    }\n    this.bootstrapMethodOffsets = currentBootstrapMethodOffsets;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。\n但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。\u003c/p\u003e\n\u003cp\u003e这部分的内容在 accept(...) 和 readXXX(...) 中将得到解析。\u003c/p\u003e\n\u003cp\u003e主要流程类似:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e读取当前内容的偏移量(相较于整个 byte[])\u003c/li\u003e\n\u003cli\u003e解析当前的内容\u003c/li\u003e\n\u003cli\u003e调用 visitXXX 方法\u003c/li\u003e\n\u003cli\u003e在 visitXXX 方法中进行相关的处理\u003c/li\u003e\n\u003cli\u003evisitEnd\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e附录1 Trie.java\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage me.fangfeng.filter;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\n\n/**\n * @author fangfeng\n * @since 2018/5/16\n */\npublic class Trie {\n    \n    private static int MAX_ITEM = 700000;\n    private static int AVG_LENGTH = 11;\n    private static int MAX_NODE = MAX_ITEM * AVG_LENGTH;\n    private static int CHAR_NUM = 10;\n\n    int[][] nxt = new int[MAX_NODE][CHAR_NUM];\n    boolean[] flag = new boolean[MAX_NODE];\n    int trieIndex = 0;\n\n    void insert(long number) {\n        int tmpIndex = 0;\n        for (;number != 0;number /= 10) {\n            if (nxt[tmpIndex][(int) (number % 10)] == 0) {\n                nxt[tmpIndex][(int) (number % 10)] = ++trieIndex;\n            }\n            tmpIndex = nxt[tmpIndex][(int) (number % 10)];\n        }\n        flag[tmpIndex] = true;\n    }\n\n    boolean query(long number) {\n        int tmpIndex = 0;\n        for (;number != 0;number /= 10) {\n            if (nxt[tmpIndex][(int) (number % 10)] == 0) {\n                return false;\n            }\n            tmpIndex = nxt[tmpIndex][(int) (number % 10)];\n        }\n        return flag[tmpIndex];\n    }\n\n    public static void main(String... args) throws FileNotFoundException, IOException {\n\n        long start = System.currentTimeMillis();\n\n        String ruleFilePath = args[0];\n        String sendFilePath = args[1];\n        String outFilePath = args[2];\n\n        BufferedReader ruleReader = new BufferedReader(new InputStreamReader(new FileInputStream(ruleFilePath)));\n        BufferedReader sendReader = new BufferedReader(new InputStreamReader(new FileInputStream(sendFilePath)));\n\n        BufferedWriter outWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outFilePath)));\n\n        Trie trie = new Trie();\n        String mobile;\n        while((mobile = ruleReader.readLine()) != null) {\n            trie.insert(Long.parseLong(mobile));\n        }\n        ruleReader.close();\n\n        while((mobile = sendReader.readLine()) != null) {\n            if(trie.query(Long.parseLong(mobile)) == false) {\n                outWriter.write(mobile);\n                outWriter.newLine();\n            }\n        }\n        sendReader.close();\n\n        outWriter.flush();\n        outWriter.close();\n\n        long end = System.currentTimeMillis();\n        System.out.println(String.format(\"exec success! used %d ms\", end - start));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e附录2 Constant pool\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eConstant pool:\n    #1 = Methodref          #36.#75       // java/lang/Object.\"\u0026#x3C;init\u003e\":()V\n    #2 = Fieldref           #23.#76       // me/fangfeng/filter/Trie.MAX_NODE:I\n    #3 = Fieldref           #23.#77       // me/fangfeng/filter/Trie.CHAR_NUM:I\n    #4 = Class              #49           // \"[[I\"\n    #5 = Fieldref           #23.#78       // me/fangfeng/filter/Trie.nxt:[[I\n    #6 = Fieldref           #23.#79       // me/fangfeng/filter/Trie.flag:[Z\n    #7 = Fieldref           #23.#80       // me/fangfeng/filter/Trie.trieIndex:I\n    #8 = Long               10l\n   #10 = Methodref          #81.#82       // java/lang/System.currentTimeMillis:()J\n   #11 = Class              #83           // java/io/BufferedReader\n   #12 = Class              #84           // java/io/InputStreamReader\n   #13 = Class              #85           // java/io/FileInputStream\n   #14 = Methodref          #13.#86       // java/io/FileInputStream.\"\u0026#x3C;init\u003e\":(Ljava/lang/String;)V\n   #15 = Methodref          #12.#87       // java/io/InputStreamReader.\"\u0026#x3C;init\u003e\":(Ljava/io/InputStream;)V\n   #16 = Methodref          #11.#88       // java/io/BufferedReader.\"\u0026#x3C;init\u003e\":(Ljava/io/Reader;)V\n   #17 = Class              #89           // java/io/BufferedWriter\n   #18 = Class              #90           // java/io/OutputStreamWriter\n   #19 = Class              #91           // java/io/FileOutputStream\n   #20 = Methodref          #19.#86       // java/io/FileOutputStream.\"\u0026#x3C;init\u003e\":(Ljava/lang/String;)V\n   #21 = Methodref          #18.#92       // java/io/OutputStreamWriter.\"\u0026#x3C;init\u003e\":(Ljava/io/OutputStream;)V\n   #22 = Methodref          #17.#93       // java/io/BufferedWriter.\"\u0026#x3C;init\u003e\":(Ljava/io/Writer;)V\n   #23 = Class              #94           // me/fangfeng/filter/Trie\n   #24 = Methodref          #23.#75       // me/fangfeng/filter/Trie.\"\u0026#x3C;init\u003e\":()V\n   #25 = Methodref          #11.#95       // java/io/BufferedReader.readLine:()Ljava/lang/String;\n   #26 = Methodref          #96.#97       // java/lang/Long.parseLong:(Ljava/lang/String;)J\n   #27 = Methodref          #23.#98       // me/fangfeng/filter/Trie.insert:(J)V\n   #28 = Methodref          #11.#99       // java/io/BufferedReader.close:()V\n   #29 = Methodref          #23.#100      // me/fangfeng/filter/Trie.query:(J)Z\n   #30 = Methodref          #17.#101      // java/io/BufferedWriter.write:(Ljava/lang/String;)V\n   #31 = Methodref          #17.#102      // java/io/BufferedWriter.newLine:()V\n   #32 = Methodref          #17.#103      // java/io/BufferedWriter.flush:()V\n   #33 = Methodref          #17.#99       // java/io/BufferedWriter.close:()V\n   #34 = Fieldref           #81.#104      // java/lang/System.out:Ljava/io/PrintStream;\n   #35 = String             #105          // exec success! used %d ms\n   #36 = Class              #106          // java/lang/Object\n   #37 = Methodref          #96.#107      // java/lang/Long.valueOf:(J)Ljava/lang/Long;\n   #38 = Methodref          #108.#109     // java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n   #39 = Methodref          #110.#111     // java/io/PrintStream.println:(Ljava/lang/String;)V\n   #40 = Integer            700000\n   #41 = Fieldref           #23.#112      // me/fangfeng/filter/Trie.MAX_ITEM:I\n   #42 = Fieldref           #23.#113      // me/fangfeng/filter/Trie.AVG_LENGTH:I\n   #43 = Utf8               MAX_ITEM\n   #44 = Utf8               I\n   #45 = Utf8               AVG_LENGTH\n   #46 = Utf8               MAX_NODE\n   #47 = Utf8               CHAR_NUM\n   #48 = Utf8               nxt\n   #49 = Utf8               [[I\n   #50 = Utf8               flag\n   #51 = Utf8               [Z\n   #52 = Utf8               trieIndex\n   #53 = Utf8               \u0026#x3C;init\u003e\n   #54 = Utf8               ()V\n   #55 = Utf8               Code\n   #56 = Utf8               LineNumberTable\n   #57 = Utf8               insert\n   #58 = Utf8               (J)V\n   #59 = Utf8               StackMapTable\n   #60 = Utf8               query\n   #61 = Utf8               (J)Z\n   #62 = Utf8               main\n   #63 = Utf8               ([Ljava/lang/String;)V\n   #64 = Class              #114          // \"[Ljava/lang/String;\"\n   #65 = Class              #115          // java/lang/String\n   #66 = Class              #83           // java/io/BufferedReader\n   #67 = Class              #89           // java/io/BufferedWriter\n   #68 = Class              #94           // me/fangfeng/filter/Trie\n   #69 = Utf8               Exceptions\n   #70 = Class              #116          // java/io/FileNotFoundException\n   #71 = Class              #117          // java/io/IOException\n   #72 = Utf8               \u0026#x3C;clinit\u003e\n   #73 = Utf8               SourceFile\n   #74 = Utf8               Trie.java\n   #75 = NameAndType        #53:#54       // \"\u0026#x3C;init\u003e\":()V\n   #76 = NameAndType        #46:#44       // MAX_NODE:I\n   #77 = NameAndType        #47:#44       // CHAR_NUM:I\n   #78 = NameAndType        #48:#49       // nxt:[[I\n   #79 = NameAndType        #50:#51       // flag:[Z\n   #80 = NameAndType        #52:#44       // trieIndex:I\n   #81 = Class              #118          // java/lang/System\n   #82 = NameAndType        #119:#120     // currentTimeMillis:()J\n   #83 = Utf8               java/io/BufferedReader\n   #84 = Utf8               java/io/InputStreamReader\n   #85 = Utf8               java/io/FileInputStream\n   #86 = NameAndType        #53:#121      // \"\u0026#x3C;init\u003e\":(Ljava/lang/String;)V\n   #87 = NameAndType        #53:#122      // \"\u0026#x3C;init\u003e\":(Ljava/io/InputStream;)V\n   #88 = NameAndType        #53:#123      // \"\u0026#x3C;init\u003e\":(Ljava/io/Reader;)V\n   #89 = Utf8               java/io/BufferedWriter\n   #90 = Utf8               java/io/OutputStreamWriter\n   #91 = Utf8               java/io/FileOutputStream\n   #92 = NameAndType        #53:#124      // \"\u0026#x3C;init\u003e\":(Ljava/io/OutputStream;)V\n   #93 = NameAndType        #53:#125      // \"\u0026#x3C;init\u003e\":(Ljava/io/Writer;)V\n   #94 = Utf8               me/fangfeng/filter/Trie\n   #95 = NameAndType        #126:#127     // readLine:()Ljava/lang/String;\n   #96 = Class              #128          // java/lang/Long\n   #97 = NameAndType        #129:#130     // parseLong:(Ljava/lang/String;)J\n   #98 = NameAndType        #57:#58       // insert:(J)V\n   #99 = NameAndType        #131:#54      // close:()V\n  #100 = NameAndType        #60:#61       // query:(J)Z\n  #101 = NameAndType        #132:#121     // write:(Ljava/lang/String;)V\n  #102 = NameAndType        #133:#54      // newLine:()V\n  #103 = NameAndType        #134:#54      // flush:()V\n  #104 = NameAndType        #135:#136     // out:Ljava/io/PrintStream;\n  #105 = Utf8               exec success! used %d ms\n  #106 = Utf8               java/lang/Object\n  #107 = NameAndType        #137:#138     // valueOf:(J)Ljava/lang/Long;\n  #108 = Class              #115          // java/lang/String\n  #109 = NameAndType        #139:#140     // format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n  #110 = Class              #141          // java/io/PrintStream\n  #111 = NameAndType        #142:#121     // println:(Ljava/lang/String;)V\n  #112 = NameAndType        #43:#44       // MAX_ITEM:I\n  #113 = NameAndType        #45:#44       // AVG_LENGTH:I\n  #114 = Utf8               [Ljava/lang/String;\n  #115 = Utf8               java/lang/String\n  #116 = Utf8               java/io/FileNotFoundException\n  #117 = Utf8               java/io/IOException\n  #118 = Utf8               java/lang/System\n  #119 = Utf8               currentTimeMillis\n  #120 = Utf8               ()J\n  #121 = Utf8               (Ljava/lang/String;)V\n  #122 = Utf8               (Ljava/io/InputStream;)V\n  #123 = Utf8               (Ljava/io/Reader;)V\n  #124 = Utf8               (Ljava/io/OutputStream;)V\n  #125 = Utf8               (Ljava/io/Writer;)V\n  #126 = Utf8               readLine\n  #127 = Utf8               ()Ljava/lang/String;\n  #128 = Utf8               java/lang/Long\n  #129 = Utf8               parseLong\n  #130 = Utf8               (Ljava/lang/String;)J\n  #131 = Utf8               close\n  #132 = Utf8               write\n  #133 = Utf8               newLine\n  #134 = Utf8               flush\n  #135 = Utf8               out\n  #136 = Utf8               Ljava/io/PrintStream;\n  #137 = Utf8               valueOf\n  #138 = Utf8               (J)Ljava/lang/Long;\n  #139 = Utf8               format\n  #140 = Utf8               (Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n  #141 = Utf8               java/io/PrintStream\n  #142 = Utf8               println\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e[1]: \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\"\u003ehttps://docs.oracle.com/javase/specs/jvms/se8/html/index.html\u003c/a\u003e \"Java Virtual Machine Specification\"\n[2]: \u003ca href=\"http://icyfenix.iteye.com/blog/1256329\"\u003ehttp://icyfenix.iteye.com/blog/1256329\u003c/a\u003e \"Java虚拟机规范（Java SE 7 中文版）\"\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003eJava ClassFile 文件格式\u003c/h2\u003e\n\u003cp\u003e读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。\n\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\"\u003eThe class File Format(Java SE 8)\u003c/a\u003e \u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eu1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-c++\"\u003eClassFile {\n    u4             magic;                                   // 魔数(magic) 固定为 0xCAFEBABE\n    u2             minor_version;                           // 次版本号\n    u2             major_version;                           // 主版本号\n    u2             constant_pool_count;                     // 常量池 constant_pool 的数量 + 1, 最大为 (2\u0026#x3C;\u0026#x3C;16 - 1) = 65535\n    cp_info        constant_pool[constant_pool_count-1];    // 常量池 取值下标为 [1, constant_pool_count)\n    u2             access_flags;                            // 对类 or 接口的访问权限和属性的标志的掩码\n    u2             this_class;                              // 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)\n    u2             super_class;                             // 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标\n    u2             interfaces_count;                        // 直接父接口的数量\n    u2             interfaces[interfaces_count];            // 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i\u0026#x3C;interfaces_count), 指向的类型为 CONSTANT_Class_info)\n    u2             fields_count;                            // 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)\n    field_info     fields[fields_count];                    // 字段的详细声明, 不包含继承来的字段\n    u2             methods_count;                           // 方法数量\n    method_info    methods[methods_count];                  // 方法的详细声明, 不包括继承来的方法\n    u2             attributes_count;                        // 属性数量\n    attribute_info attributes[attributes_count];            // 属性的详细声明\n}\n\u003c/code\u003e\u003c/pre\u003e"},{"url":"2018-06-21-java-memory-model","fileName":"2018-06-21-java-memory-model.md","title":"java-memory-model","author":"fangfeng","date":"2018-06-21T00:00:00.000Z","tags":["Java","JVM","Memory Model"],"content":"\u003ch2\u003eJVM 运行时数据区\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg\"\u003e\u003c/p\u003e\n\u003ch3\u003ePC寄存器\u003c/h3\u003e\n\u003cp\u003e与操作系统中的PC寄存器功能基本一致。毕竟 JVM 建立的初衷就是模拟一台机器。\n指向存储在\u003cstrong\u003e方法区\u003c/strong\u003e的字节码methods_info部分的内存地址。\u003c/p\u003e\n\u003ch3\u003e虚拟机栈\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e虚拟机栈\u003c/strong\u003e用于存储\u003cstrong\u003e栈帧\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003e本地方法栈\u003c/h3\u003e\n\u003cp\u003e用于支持 native 方法的执行\u003c/p\u003e\n\u003ch3\u003e栈帧\u003c/h3\u003e\n\u003cp\u003e存储在\u003cstrong\u003e虚拟机栈\u003c/strong\u003e中，主要包括\u003cstrong\u003e局部变量表\u003c/strong\u003e和\u003cstrong\u003e操作数栈\u003c/strong\u003e(又称\u003cstrong\u003e当前栈帧的操作数栈\u003c/strong\u003e)以及\u003cstrong\u003e运行时常量池的引用\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e仍然有必要区别两个概念: 操作数 \u0026#x26; 指令\u003c/em\u003e\n\u003cem\u003e指令指使操作数进行相关操作的基本命令\u003c/em\u003e\n\u003cem\u003e操作数通常指整数、浮点数以及类型引用等\u003c/em\u003e\u003c/p\u003e\n\u003ch3\u003e方法区\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e方法区\u003c/strong\u003e是多个线程共享的一块区域，主要用于存储I/O操作中读入的类/接口的字节码(ClassFile 文件)\n包括有 constant_pool, field_info, method_info, attribute_info 等\u003c/p\u003e\n\u003ch3\u003eJava堆\u003c/h3\u003e\n\u003cp\u003e用于存储各种类的实例对象\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003eJVM 运行时数据区\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg\"\u003e\u003c/p\u003e"},{"url":"2018-06-25-ASM-Core","fileName":"2018-06-25-ASM-Core.md","title":"ASM 核心包基本内容漫谈","author":"fangfeng","date":"2018-06-25T00:00:00.000Z","tags":["Java","ASM","Visitor Pattern"],"content":"\u003cblockquote\u003e\n\u003cp\u003e本文描述的 ASM 指的是 OW2 ASM\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eASM-Core 的结构\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003e首先是一些概述性的内容。\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。\n因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)\u003c/p\u003e\n\u003cp\u003e从核心包声明的类来看，主要包括:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eClassReader - 作为结构化对象，将接收(accept)访问者的访问\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e几种访问者抽象类以及相应的实现类\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eAnnotationVisitor -\u003e AnnotationWriter\u003c/li\u003e\n\u003cli\u003eClassVisitor -\u003e ClassWriter\u003c/li\u003e\n\u003cli\u003eFieldVisitor -\u003e FieldWriter\u003c/li\u003e\n\u003cli\u003eMethodVisitor -\u003e MethodWriter\u003c/li\u003e\n\u003cli\u003eModuleVisitor -\u003e ModuleWriter\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\n\u003cp\u003eOpcodes \u0026#x26; Constants - ClassFile 中描述的大量常量符号与值\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e其它一些辅助的类\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eAttribute - 用于处理非标准化的属性(ClassFile 允许\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html\"\u003eJVMS\u003c/a\u003e 中未定义的 Attribute)\u003c/li\u003e\n\u003cli\u003eByteArray - 动态可自适应的 byte[] (字节数组)\u003c/li\u003e\n\u003cli\u003eContext - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象\u003c/li\u003e\n\u003cli\u003eSymbol - 用于表示 ClassFile 中描述的 Constant 的基类\u003c/li\u003e\n\u003cli\u003eSymbolTable - 用于存储常量池对象\u003c/li\u003e\n\u003cli\u003e其它内容省略\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eClassFile 文件格式\u003c/h2\u003e\n\u003cp\u003e本节的内容可以参阅 \u003ca href=\"https://dormouse-none.github.io/2018-06-11-ASM-ClassReader/\"\u003eClassFile 文件格式\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eClassFile 是 ASM 操作字节码的基础与前提。在 JVMS 定义了 .class 文件格式之后，ASM 才在此基础上进行了对 ClassFile 的字节码操作。\u003c/p\u003e\n\u003cp\u003e因此，无论如何，个人认为在真正开始了解 ASM 之前，通读一遍 ClassFile 文件格式是完全有必要的。并且，在基本了解 ClassFile 内容的基础上，\n尝试对某个 .class 文件进行手工解析也不失为一种加深理解的途径。\u003c/p\u003e\n\u003ch2\u003eVisitor Pattern\u003c/h2\u003e\n\u003cp\u003e由于 ASM 的实现采用了偏门的访问者模式。因此，了解访问者模式也是一个必不可少的重要环节。同时在了解后也将为源码阅读者提供更清晰的解读思路。\u003c/p\u003e\n\u003cp\u003e《设计模式：可复用面向对象软件的基础》一书的“5.11 VISITOR(访问者)——对象行为型模式”提供了很详尽的解释。\u003c/p\u003e\n\u003cp\u003e本人对这方面的不甚了解，推荐自行查找资料。\u003c/p\u003e\n\u003ch2\u003eClassReader\u003c/h2\u003e\n\u003cp\u003eClassReader 是解析现有的 .class 文件的基本工具。同时，ClassReader 也作为一个内容的持有者，与 SymboleTable 配合，来满足访问者基本的访问需求。\u003c/p\u003e\n\u003cp\u003e刨除大量的内部私有方法，ClassReader 对外开放的接口相当简单。最核心的方法仅包括 ClassReader(...) 以及 accetp(...)\u003c/p\u003e\n\u003ch3\u003eClassReader(...) 构造方法\u003c/h3\u003e\n\u003cp\u003e顾名思义，构造方法用于实例化 ClassReader 对象，包括一些必须的变量的初始化。\u003c/p\u003e\n\u003cp\u003e在构造函数中完成的初始化内容包括:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e校验版本号\u003c/li\u003e\n\u003cli\u003e存储每个常量池项目的起始偏移量 cpInfoOffsets\u003c/li\u003e\n\u003cli\u003e存储每个引导方法的起始偏移量 bootstrapMethodOffsets\u003c/li\u003e\n\u003cli\u003e存储最长字符串常量的大小 maxStringLength\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e  ClassReader(final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {\n    this.b = classFileBuffer;   // .class 文件缓存\n    // 检查主版本号, 第6,7个字节(从0字节开始计数)\n    if (checkClassVersion \u0026#x26;\u0026#x26; readShort(classFileOffset + 6) \u003e Opcodes.V11) {\n      throw new IllegalArgumentException(\n          \"Unsupported class file major version \" + readShort(classFileOffset + 6));\n    }\n    // 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节\n    int constantPoolCount = readUnsignedShort(classFileOffset + 8);     // 读取无符号short, 即读取连续两字节作为一个short值\n    cpInfoOffsets = new int[constantPoolCount];                         // 每个常量的偏移位置\n    cpInfoValues = new Object[constantPoolCount];                       // 每个常量的实例对象\n    int currentCpInfoIndex = 1;\n    int currentCpInfoOffset = classFileOffset + 10;\n    int currentMaxStringLength = 0;                                     // 最长字符串常量\n    while (currentCpInfoIndex \u0026#x3C; constantPoolCount) {\n      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;\n      int cpInfoSize;\n      switch (classFileBuffer[currentCpInfoOffset]) {\n        case Symbol.CONSTANT_FIELDREF_TAG:\n        case Symbol.CONSTANT_METHODREF_TAG:\n        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n        case Symbol.CONSTANT_INTEGER_TAG:\n        case Symbol.CONSTANT_FLOAT_TAG:\n        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n        case Symbol.CONSTANT_DYNAMIC_TAG:\n          cpInfoSize = 5;\n          break;\n        case Symbol.CONSTANT_LONG_TAG:\n        case Symbol.CONSTANT_DOUBLE_TAG:\n          cpInfoSize = 9;\n          currentCpInfoIndex++;\n          break;\n        case Symbol.CONSTANT_UTF8_TAG:\n          cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);\n          if (cpInfoSize \u003e currentMaxStringLength) {\n            // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate\n            // of the length in characters of the corresponding string, and is much cheaper to\n            // compute than this exact length.\n            currentMaxStringLength = cpInfoSize;\n          }\n          break;\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n          cpInfoSize = 4;\n          break;\n        case Symbol.CONSTANT_CLASS_TAG:\n        case Symbol.CONSTANT_STRING_TAG:\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\n        case Symbol.CONSTANT_PACKAGE_TAG:\n        case Symbol.CONSTANT_MODULE_TAG:\n          cpInfoSize = 3;\n          break;\n        default:\n          throw new IllegalArgumentException();\n      }\n      currentCpInfoOffset += cpInfoSize;\n    }\n    this.maxStringLength = currentMaxStringLength;\n    // The Classfile's access_flags field is just after the last constant pool entry.\n    this.header = currentCpInfoOffset;\n\n    // 读取 BootstrapMethods 属性(如果存在)\n    int currentAttributeOffset = getFirstAttributeOffset();\n    int[] currentBootstrapMethodOffsets = null;\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i \u003e 0; --i) {\n      // 读取每个 attribute_info 的属性名和属性长度\n      String attributeName = readUTF8(currentAttributeOffset, new char[maxStringLength]);\n      int attributeLength = readInt(currentAttributeOffset + 2);\n      currentAttributeOffset += 6;\n      // 如果当前属性名为 BootstrapMethods ，则进入处理逻辑\n      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        // Read the num_bootstrap_methods field and create an array of this size.\n        currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];\n        // Compute and store the offset of each 'bootstrap_methods' array field entry.\n        int currentBootstrapMethodOffset = currentAttributeOffset + 2;\n        for (int j = 0; j \u0026#x3C; currentBootstrapMethodOffsets.length; ++j) {\n          currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;\n          // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\n          // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\n          currentBootstrapMethodOffset +=\n              4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\n        }\n      }\n      currentAttributeOffset += attributeLength;\n    }\n    this.bootstrapMethodOffsets = currentBootstrapMethodOffsets;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。\n但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。\u003c/p\u003e\n\u003ch3\u003eaccept(...)\u003c/h3\u003e\n\u003cp\u003e访问者模式的核心操作就是结构化对象接受(accept)访问者对象实例的访问，并将结构化内容完全暴露给访问者。\u003c/p\u003e\n\u003cp\u003e从抽象的方法角度看，可以理解成:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e  // --- 结构化对象的 accept() 方法 ---\n  public void accept(Visitor visitor) {\n    visitor.visit(this);\n  }\n\n  // --- 访问者对象的 visit() 方法 ---\n  public Xxx visit(Element element) {\n    // 若干关于 element 的读操作 + 其它操作\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void accept(\n      final ClassVisitor classVisitor,\n      final Attribute[] attributePrototypes,\n      final int parsingOptions) {\n    // 定义 Context 作为辅助类，暂存被访问过程的“累积状态”\n    Context context = new Context();\n    context.attributePrototypes = attributePrototypes;\n    /**\n     * 解析选项: \n     * 1. SKIP_CODE - 不解析 CODE 属性 \n     * 2. SKIP_DEBUG - 不解析 DEBUG 相关的属性(例如SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable, LineNumberTable)\n     * 4. SKIP_FRAMES - 跳过对 StackMap 和 StackMapTable 属性的解析\n     * ...\n     */\n    context.parsingOptions = parsingOptions;\n    // 从常量池读取常量所使用的缓冲数字\n    context.charBuffer = new char[maxStringLength];\n\n    // Read the access_flags, this_class, super_class, interface_count and interfaces fields.\n    // 解析访问控制, 当前类, 父类, 接口数量与接口值等\n    char[] charBuffer = context.charBuffer;\n    int currentOffset = header;\n    int accessFlags = readUnsignedShort(currentOffset);\n    String thisClass = readClass(currentOffset + 2, charBuffer);\n    String superClass = readClass(currentOffset + 4, charBuffer);\n    String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];\n    currentOffset += 8;\n    for (int i = 0; i \u0026#x3C; interfaces.length; ++i) {\n      interfaces[i] = readClass(currentOffset, charBuffer);\n      currentOffset += 2;\n    }\n\n    // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n    // - The offset of the InnerClasses attribute, or 0.\n    int innerClassesOffset = 0;\n    // - The offset of the EnclosingMethod attribute, or 0.\n    int enclosingMethodOffset = 0;\n    // - The string corresponding to the Signature attribute, or null.\n    String signature = null;\n    // - The string corresponding to the SourceFile attribute, or null.\n    String sourceFile = null;\n    // - The string corresponding to the SourceDebugExtension attribute, or null.\n    String sourceDebugExtension = null;\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n    int runtimeVisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n    int runtimeInvisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n    int runtimeVisibleTypeAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\n    // - The offset of the Module attribute, or 0.\n    int moduleOffset = 0;\n    // - The offset of the ModulePackages attribute, or 0.\n    int modulePackagesOffset = 0;\n    // - The string corresponding to the ModuleMainClass attribute, or null.\n    String moduleMainClass = null;\n    // - The string corresponding to the NestHost attribute, or null.\n    String nestHostClass = null;\n    // - The offset of the NestMembers attribute, or 0.\n    int nestMembersOffset = 0;\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n    //   This list in the \u0026#x3C;i\u003ereverse order\u0026#x3C;/i\u003e or their order in the ClassFile structure.\n    Attribute attributes = null;\n\n    // 解析 Class 持有的属性\n    int currentAttributeOffset = getFirstAttributeOffset();\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i \u003e 0; --i) {\n      // Read the attribute_info's attribute_name and attribute_length fields.\n      String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n      int attributeLength = readInt(currentAttributeOffset + 2);\n      currentAttributeOffset += 6;\n      // The tests are sorted in decreasing frequency order (based on frequencies observed on\n      // typical classes).\n      if (Constants.SOURCE_FILE.equals(attributeName)) {\n        sourceFile = readUTF8(currentAttributeOffset, charBuffer);\n      } else if (Constants.INNER_CLASSES.equals(attributeName)) {\n        innerClassesOffset = currentAttributeOffset;\n      } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {\n        enclosingMethodOffset = currentAttributeOffset;\n      } else if (Constants.NEST_HOST.equals(attributeName)) {\n        nestHostClass = readClass(currentAttributeOffset, charBuffer);\n      } else if (Constants.NEST_MEMBERS.equals(attributeName)) {\n        nestMembersOffset = currentAttributeOffset;\n      } else if (Constants.SIGNATURE.equals(attributeName)) {\n        signature = readUTF8(currentAttributeOffset, charBuffer);\n      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.DEPRECATED.equals(attributeName)) {\n        accessFlags |= Opcodes.ACC_DEPRECATED;\n      } else if (Constants.SYNTHETIC.equals(attributeName)) {\n        accessFlags |= Opcodes.ACC_SYNTHETIC;\n      } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {\n        sourceDebugExtension =\n            readUTF(currentAttributeOffset, attributeLength, new char[attributeLength]);\n      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.MODULE.equals(attributeName)) {\n        moduleOffset = currentAttributeOffset;\n      } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {\n        moduleMainClass = readClass(currentAttributeOffset, charBuffer);\n      } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {\n        modulePackagesOffset = currentAttributeOffset;\n      } else if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        // This attribute is read in the constructor.\n      } else {\n        Attribute attribute =\n            readAttribute(\n                attributePrototypes,\n                attributeName,\n                currentAttributeOffset,\n                attributeLength,\n                charBuffer,\n                -1,\n                null);\n        attribute.nextAttribute = attributes;\n        attributes = attribute;\n      }\n      currentAttributeOffset += attributeLength;\n    }\n\n    // 第一个 .visit() 。让 ClassVisitor 的实现类处理当前类的版本号, 访问控制标志, 当前类, 结构, 父类, 接口\n    // 具体 visit() 由实现类随意定制。例如，针对于那些有打印功能的访问者实现类，直接打印也不失为一种有效的访问操作\n    // Visit the class declaration. The minor_version and major_version fields start 6 bytes before\n    // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).\n    classVisitor.visit(\n        readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);\n\n    // 访问 SourceFile 和 SourceDebugExtenstion 属性\n    // Visit the SourceFile and SourceDebugExtenstion attributes.\n    if ((parsingOptions \u0026#x26; SKIP_DEBUG) == 0\n        \u0026#x26;\u0026#x26; (sourceFile != null || sourceDebugExtension != null)) {\n      classVisitor.visitSource(sourceFile, sourceDebugExtension);\n    }\n\n    // Visit the Module, ModulePackages and ModuleMainClass attributes.\n    if (moduleOffset != 0) {\n      readModule(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);\n    }\n\n    // Visit the NestHost attribute.\n    if (nestHostClass != null) {\n      classVisitor.visitNestHostExperimental(nestHostClass);\n    }\n\n    // Visit the EnclosingMethod attribute.\n    if (enclosingMethodOffset != 0) {\n      String className = readClass(enclosingMethodOffset, charBuffer);\n      int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);\n      String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);\n      String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);\n      classVisitor.visitOuterClass(className, name, type);\n    }\n\n    // Visit the RuntimeVisibleAnnotations attribute.\n    if (runtimeVisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n      while (numAnnotations-- \u003e 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),\n                currentAnnotationOffset,\n                /* named = */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleAnnotations attribute.\n    if (runtimeInvisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n      while (numAnnotations-- \u003e 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),\n                currentAnnotationOffset,\n                /* named = */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- \u003e 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible = */ true),\n                currentAnnotationOffset,\n                /* named = */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- \u003e 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible = */ false),\n                currentAnnotationOffset,\n                /* named = */ true,\n                charBuffer);\n      }\n    }\n\n    // 访问非标准的属性\n    // Visit the non standard attributes.\n    while (attributes != null) {\n      // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.\n      Attribute nextAttribute = attributes.nextAttribute;\n      attributes.nextAttribute = null;\n      classVisitor.visitAttribute(attributes);\n      attributes = nextAttribute;\n    }\n\n    // Visit the NestedMembers attribute.\n    if (nestMembersOffset != 0) {\n      int numberOfNestMembers = readUnsignedShort(nestMembersOffset);\n      int currentNestMemberOffset = nestMembersOffset + 2;\n      while (numberOfNestMembers-- \u003e 0) {\n        classVisitor.visitNestMemberExperimental(readClass(currentNestMemberOffset, charBuffer));\n        currentNestMemberOffset += 2;\n      }\n    }\n\n    // Visit the InnerClasses attribute.\n    if (innerClassesOffset != 0) {\n      int numberOfClasses = readUnsignedShort(innerClassesOffset);\n      int currentClassesOffset = innerClassesOffset + 2;\n      while (numberOfClasses-- \u003e 0) {\n        classVisitor.visitInnerClass(\n            readClass(currentClassesOffset, charBuffer),\n            readClass(currentClassesOffset + 2, charBuffer),\n            readUTF8(currentClassesOffset + 4, charBuffer),\n            readUnsignedShort(currentClassesOffset + 6));\n        currentClassesOffset += 8;\n      }\n    }\n\n    // 访问字段和方法\n    // Visit the fields and methods.\n    int fieldsCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (fieldsCount-- \u003e 0) {\n      currentOffset = readField(classVisitor, context, currentOffset);\n    }\n    int methodsCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (methodsCount-- \u003e 0) {\n      currentOffset = readMethod(classVisitor, context, currentOffset);\n    }\n\n    // Visit the end of the class.\n    classVisitor.visitEnd();\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e小结\u003c/h3\u003e\n\u003cp\u003e其实，将整个 ClassReader 理解成一个对 .class 字节文件的解析器不失为一种可行的认知。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在构造方法中完成对 .class 文件 minor_version, major_version 的确认。\u003c/li\u003e\n\u003cli\u003e继而完成对整个 Constants_pool 的解析\u003c/li\u003e\n\u003cli\u003e以及 BootstarpMethod 属性的定位\u003c/li\u003e\n\u003cli\u003e之后在 accept(...) 方法中逐一调用相应的访问者实现类实现对不同内容的访问。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e但是，要注意的是，ClassReader 绝对不会涉及到对其解析的 .class 文件内容的写操作。\n所有的写操作都基于不同的目的，在 ClassVisitor 中实现。\u003c/p\u003e\n\u003ch2\u003eClassVisitor\u003c/h2\u003e\n\u003cp\u003eJava .class 的访问者，按照严格的顺序规范逐一调用 \u003c/p\u003e\n\u003cp\u003evisit\n[ visitSource ] [ visitModule ][ visitNestHost ][ visitOuterClass ]\n( visitAnnotation | visitTypeAnnotation | visitAttribute )\u003cem\u003e\n( visitNestMember | visitInnerClass | visitField | visitMethod )\u003c/em\u003e\nvisitEnd.\u003c/p\u003e\n\u003cp\u003e各个 visitXXX 方法\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic abstract class ClassVisitor {\n\n  /**\n   * 访问类的首部\n      */\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {}\n\n  /**\n   * 访问类的源文件名等\n      */\n    public void visitSource(final String source, final String debug) {}\n\n  /**\n   * 访问与类关联的模块\n      */\n    public ModuleVisitor visitModule(final String name, final int access, final String version) {}\n\n  public void visitOuterClass(final String owner, final String name, final String descriptor) {}\n\n  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {}\n\n  public AnnotationVisitor visitTypeAnnotation(\n      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {}\n\n  public void visitAttribute(final Attribute attribute) {}\n\n  public void visitInnerClass(\n      final String name, final String outerName, final String innerName, final int access) {}\n\n  /**\n   * 访问类的变量\n      */\n    public FieldVisitor visitField(\n      final int access,\n      final String name,\n      final String descriptor,\n      final String signature,\n      final Object value) {}\n\n  /**\n   * 访问类的方法\n      */\n    public MethodVisitor visitMethod(\n      final int access,\n      final String name,\n      final String descriptor,\n      final String signature,\n      final String[] exceptions) {}\n\n  public void visitEnd() {}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e随着 visitXxx() 方法的逐一执行，ClassVisitor 将对当前的 .class 文件越来越熟悉，并逐渐补全常量池(由 SymbolTable 持有并维护)\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e到此为止，对整个 ClassReader \u0026#x26; ClassVisitor 将有一个基础而简单的印象。\u003c/p\u003e\n\u003cp\u003eClassReader 通过对 .class 文件字节码的解析而获得对这个类的具体印象(更多的偏向是随意访问 .class 的各种细节)。\u003c/p\u003e\n\u003cp\u003eClassVisitor 通过 visitXxx(...) 方法，由其它对象(可以是 ClassReader, 也可以直接是 Coder)逐渐对其开放一些 .class 的细节，\n但需要 ClassVisitor 自行维护获得的内容(如果有必要的话)。由此得到对 .class 全部内容的了解(当然，如果本身 visitXxx() 得到的内容不全，则了解的自然有限)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cblockquote\u003e\n\u003cp\u003e本文描述的 ASM 指的是 OW2 ASM\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eASM-Core 的结构\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003e首先是一些概述性的内容。\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。\n因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)\u003c/p\u003e\n\u003cp\u003e从核心包声明的类来看，主要包括:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eClassReader - 作为结构化对象，将接收(accept)访问者的访问\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e几种访问者抽象类以及相应的实现类\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eAnnotationVisitor -\u003e AnnotationWriter\u003c/li\u003e\n\u003cli\u003eClassVisitor -\u003e ClassWriter\u003c/li\u003e\n\u003cli\u003eFieldVisitor -\u003e FieldWriter\u003c/li\u003e\n\u003cli\u003eMethodVisitor -\u003e MethodWriter\u003c/li\u003e\n\u003cli\u003eModuleVisitor -\u003e ModuleWriter\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\n\u003cp\u003eOpcodes \u0026#x26; Constants - ClassFile 中描述的大量常量符号与值\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e其它一些辅助的类\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eAttribute - 用于处理非标准化的属性(ClassFile 允许\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html\"\u003eJVMS\u003c/a\u003e 中未定义的 Attribute)\u003c/li\u003e\n\u003cli\u003eByteArray - 动态可自适应的 byte[] (字节数组)\u003c/li\u003e\n\u003cli\u003eContext - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象\u003c/li\u003e\n\u003cli\u003eSymbol - 用于表示 ClassFile 中描述的 Constant 的基类\u003c/li\u003e\n\u003cli\u003eSymbolTable - 用于存储常量池对象\u003c/li\u003e\n\u003cli\u003e其它内容省略\u003c/li\u003e\n\u003c/ul\u003e"},{"url":"2018-06-28-ASM-VerifyError","fileName":"2018-06-28-ASM-VerifyError.md","title":"ASM-VerifyError错误信息解决","author":"fangfeng","date":"2018-06-28T00:00:00.000Z","tags":[],"content":"\u003ch2\u003e报错信息\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ejava.lang.VerifyError: class net.sf.cglib.core.DebuggingClassWriter overrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e背景\u003c/h2\u003e\n\u003cp\u003e项目依赖的 \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCGlib 版本是 2.2.2\u003c/li\u003e\n\u003cli\u003eASM 版本是 3.3.1\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e问题定位\u003c/h2\u003e\n\u003cp\u003e前两天刚粗略通读了 ASM ，结果就遇上这样一个问题。\u003c/p\u003e\n\u003cp\u003e从 \u003ccode\u003enet.sf.cglib.core.DebuggingClassWriter\u003c/code\u003e 看，这是 CGlib 的一个实现类\u003c/p\u003e\n\u003cp\u003e从描述 \u003ccode\u003eoverrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V\u003c/code\u003e\n以及 DebuggingClassWriter 类的字节码反编译结果\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DebuggingClassWriter extends ClassWriter {\n    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n        this.className = name.replace('/', '.');\n        this.superName = superName.replace('/', '.');\n        super.visit(version, access, name, signature, superName, interfaces);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至少应该是 visit(...) 方法要重载的父类的被声明为 final 的 ClassWriter.visit(...) 才导致的问题。\u003c/p\u003e\n\u003cp\u003e但是从 ASM 3.3.1 版本的 ClassWriter 类可以看到\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public void visit(int var1, int var2, String var3, String var4, String var5, String[] var6) {\n        ...\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003evisit 方法并没有被声明为 final 。\u003c/p\u003e\n\u003cp\u003e但是，结合一定的背景知识，ASM 项目在加入了 OW2 组织后的新版本(asm-3.3.1 是未加入 OW2 前的最后一个版本)，\nClassWriter 类的所有 visitXxx(...) 方法都被添加了 \u003ccode\u003efinal\u003c/code\u003e 限制。\u003c/p\u003e\n\u003cp\u003e因此，怀疑是项目实际依赖了高版本的 asm (asm 4.x 及以上)\u003c/p\u003e\n\u003ch2\u003e解决\u003c/h2\u003e\n\u003cp\u003e经过确认，由于整个项目依赖关系复杂，有其它项目引入了 asm-4.1.jar。\n而且由于使用 MAVEN 进行项目依赖管理，asm-4.1.jar 与依赖树根的深度更浅，\n因此，最终打包的 war 里面确实引入了 asm-4.1.jar 。导致了这个问题。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e报错信息\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ejava.lang.VerifyError: class net.sf.cglib.core.DebuggingClassWriter overrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V\n\u003c/code\u003e\u003c/pre\u003e"},{"url":"2018-07-04-JDK-Permission","fileName":"2018-07-04-JDK-Permission.md","title":"Java 安全访问与权限控制","author":"fangfeng","date":"2018-07-04T00:00:00.000Z","tags":["Java","Security","Permission"],"content":"\u003ch2\u003e绪论\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003e本文只是对 Java 安全访问与权限控制的基础性探究。\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e本节与全文内容无关，如无兴趣阅读，可以跳过\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行\"自动发现\"和加载。\n这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要\n1. 在 \u003ccode\u003eMETA-INF.services\u003c/code\u003e 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容\n2. 由项目的注册管理器触发下列 Java 代码\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e{\n    ServiceLoader\u0026#x3C;XxxPolicy\u003e xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);\n    for (Iterator\u0026#x3C;XxxPolicy\u003e it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) {\n        XxxPolicy xxxPolicy = it.next();\n        // ... more code ...\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e就可以完成一个新的 SPI 策略的注册工作。\u003c/p\u003e\n\u003cp\u003e但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-.jar 在注册 Driver 相关的代码。\n发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eAccessController.doPrivileged(new PrivilegedAction\u0026#x3C;Void\u003e() {\n    public Void run() {\n\n        ServiceLoader\u0026#x3C;Driver\u003e loadedDrivers = ServiceLoader.load(Driver.class);\n        Iterator\u0026#x3C;Driver\u003e driversIterator = loadedDrivers.iterator();\n\n        try{\n            while(driversIterator.hasNext()) {\n            driversIterator.next();\n            }\n        } catch(Throwable t) {\n                // Do nothing\n        }\n        return null;\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。\u003c/p\u003e\n\u003cp\u003e为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。\u003c/p\u003e\n\u003ch2\u003e从现象开始...\u003c/h2\u003e\n\u003cp\u003e在通过 \u003ccode\u003ejava\u003c/code\u003e 命令执行本地代码时，偶尔/经常会出现文件I/O操作。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String... args) throws IOException {\n\n    System.out.println(System.getSecurityManager());\n\n    FileInputStream fis = new FileInputStream(\"/Users/fangfeng/test.in\");\n    for (int chr; (chr = fis.read()) != -1;) {\n        System.out.print((char) chr);\n    }\n    fis.close();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e诸如上面这段代码，意在读取外部路径下 \u003ccode\u003etest.in\u003c/code\u003e 文件(不要放在项目路径下，文本内容为 \u003ccode\u003e0123456789\u003c/code\u003e)。当然，还包括打印 System.getSecurityManager().toString() 。\u003c/p\u003e\n\u003cp\u003e正常情况下，这都是能够执行成功，结果为:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003enull\n0123456789\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是，通过在命令行 \u003ccode\u003ejava\u003c/code\u003e 中添加选项 \u003ccode\u003e-Djava.security.manager\u003c/code\u003e，再次执行代码，结果为:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003ejava.lang.SecurityManager@4e25154f\nException in thread \"main\" java.security.AccessControlException: access denied (\"java.io.FilePermission\" \"/Users/fangfeng/test.in\" \"read\")\n    at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)\n    at java.security.AccessController.checkPermission(AccessController.java:884)\n    at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)\n    at java.lang.SecurityManager.checkRead(SecurityManager.java:888)\n    at java.io.FileInputStream.\u0026#x3C;init\u003e(FileInputStream.java:127)\n    at java.io.FileInputStream.\u0026#x3C;init\u003e(FileInputStream.java:93)\n    at me.fangfeng.security.SecurityTest.main(SecurityTest.java:16)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在已经能够获取到 \u003ccode\u003eSystem.getSecuriryManager\u003c/code\u003e 的实例。\n但是想要读取 \u003ccode\u003etest.in\u003c/code\u003e 文件却失败了，表现为 access denied（访问被拒绝）。\u003c/p\u003e\n\u003cp\u003e现在，在用户目录下(这里是 /Users/fangfeng, 不同系统不同用户请做相应修改) 添加 \u003ccode\u003e.java.policy\u003c/code\u003e 文件，添加下列文本:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003egrant {\n    permission java.io.FilePermission \"/Users/fangfeng/test.in\", \"read\";\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再次 \u003ccode\u003ejava -Djava.security.manager \u0026#x3C;class's path\u003e\u003c/code\u003e，不仅能够得到 SecurityManager 的实例，同时也读取到了文本内容。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003ejava.lang.SecurityManager@3af49f1c\n0123456789\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到此为止，应该已经能够感受到 Java 对安全访问的控制在文件I/O上的体现了。\u003c/p\u003e\n\u003ch2\u003e安全控制下的操作\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e在开始下列内容之前，需要提前了解一个前提:\u003c/strong\u003e\n\u003cstrong\u003eJava 对操作权限的控制是通过检查当前线程操作上下文的代码是否存在要求的操作权限实现的(除了特权的声明以及其它还需要控制别的线程上下文权限的情况)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e上一节演示了权限控制下本地代码对本地资源的访问。但是，安全控制真的有必要吗？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e就本地程序而言，不必要。事实上，Java 也确实是这么做的。平时在本地利用 \u003ccode\u003ejava\u003c/code\u003e 命令执行程序，都不会受到任何限制。Java 启动时默认不会装载 SecurityManager，也就不会触发对各种操作的权限验证。\u003c/li\u003e\n\u003cli\u003e可如果程序运行与网络上其它程序交互，甚至直接加载来自网络的字节码。那么，权限控制确实是有必要的。至少，如果不存在权限控制，来自网络的恶意代码访问整台机器的任意资源都将畅通无阻。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eSecurityManager\u003c/h3\u003e\n\u003cp\u003eSecurityManager 是整个访问控制的管理器和基本入口。所有涉及到权限控制的代码，都会类似地存在下列这般的代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eSecurityManager security = System.getSecurityManager();\n// 如果系统存在安全管理器\nif (security != null) {\n    // 调用 SecurityManager 中以 check 开头的方法\n    security.checkXxx(...);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esecurity.checkXxx(...)\u003c/code\u003e 是没有返回值的(除了 checkTopLevelWindow)；对于没有操作权限的代码，直接抛出异常\u003c/p\u003e\n\u003cp\u003e至于到底在 check 什么，Java 中定义了包括文件(File)、套接字(Socket)、网络(Net)、安全性(Security)、运行时(Runtime)、属性(Property)、AWT、反射(Reflect)和可序列化(Serializable) 九类权限。\u003c/p\u003e\n\u003cp\u003e通常，security.checkXxx(...) 方法将构造一个 XxxPermission(...) 对象来调用 SecurityManager 提供的统一方法 checkPermission(Permission) 。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 以 checkRead(name) 为例\npublic void checkRead(String file) {\n    checkPermission(new FilePermission(file, SecurityConstants.FILE_READ_ACTION));\n}\n\n// 调用 checkPermission(Permission) 方法\npublic void checkPermission(Permission perm) {\n    // 直接调用 访问控制器 来对权限进行鉴别\n    java.security.AccessController.checkPermission(perm);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eAccessController\u003c/h3\u003e\n\u003cp\u003eAccessController 用于与访问控制相关的操作和决定。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAccessController 类用于以下三个目的：\u003c/p\u003e\n\u003cp\u003e基于当前生效的安全策略决定是允许还是拒绝对关键系统资源的访问\n将代码标记为享有“特权”，从而影响后续访问决定，以及\n获取当前调用上下文的“快照”，这样便可以相对于已保存的上下文作出其他上下文的访问控制决定\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e小结\u003c/h3\u003e\n\u003cp\u003e总的来说，Java 的访问控制就是通过针对不同的操作构建不同的 Permission 对象，然后通过与 AccessControllerContent 持有的各代码的权限进行比对，\n从而判断代码是否存在相应的访问权限。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e所谓的Permission判断将是对当前线程的调用栈的每个调用者逐一倒序递归，判断是否拥有权限。如果其中的某个代码被声明为 Privileged，则直接认为是拥有权限\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e更多的关于 checkPermission(...) 调用相关的内容，可以自行查阅资料进行学习，在此不做过多陈述。:)\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003e为操作赋权\u003c/h2\u003e\n\u003cp\u003e上一节讲完了如果对当前项目配置了 SecurityManager ，将对各种敏感操作进行访问控制，并且将根据整个调用链被赋予的权限来决定是允许执行还是抛出 access denied。\u003c/p\u003e\n\u003cp\u003e但是，究竟怎么才能够给 code 赋予权限呢？\u003c/p\u003e\n\u003cp\u003e回顾前一节的内容，在基本探究中，其实一个能够看到 \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003egrant {\n    permission java.io.FilePermission \"/Users/fangfeng/test.in\", \"read\";\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这就是一种赋权的操作。\u003c/p\u003e\n\u003cp\u003e通过在指定的文件中写入符合特定规则的代码，来完成对 code 的赋权。\u003ca href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html\"\u003eDefault Policy Implementation and Policy File Syntax\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e在项目启动的时候，默认就会读取 \u003ccode\u003e$JAVA\\_HOME/jre/lib/security/java.policy\u003c/code\u003e 以及 \u003ccode\u003e${user.home}/.java.policy\u003c/code\u003e 两个文件的赋权内容，并做缓存给后面代码使用。\u003c/p\u003e\n\u003cp\u003e当然，Java 也提供指定自定义的赋权文件，通过 -Djava.security.policy= 或者 -Djava.security.policy== 。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e[1]. Java Document - Security. \u003ca href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html\"\u003ehttps://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e绪论\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003e本文只是对 Java 安全访问与权限控制的基础性探究。\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e本节与全文内容无关，如无兴趣阅读，可以跳过\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行\"自动发现\"和加载。\n这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要\n1. 在 \u003ccode\u003eMETA-INF.services\u003c/code\u003e 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容\n2. 由项目的注册管理器触发下列 Java 代码\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e{\n    ServiceLoader\u0026#x3C;XxxPolicy\u003e xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);\n    for (Iterator\u0026#x3C;XxxPolicy\u003e it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) {\n        XxxPolicy xxxPolicy = it.next();\n        // ... more code ...\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e就可以完成一个新的 SPI 策略的注册工作。\u003c/p\u003e\n\u003cp\u003e但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-.jar 在注册 Driver 相关的代码。\n发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eAccessController.doPrivileged(new PrivilegedAction\u0026#x3C;Void\u003e() {\n    public Void run() {\n\n        ServiceLoader\u0026#x3C;Driver\u003e loadedDrivers = ServiceLoader.load(Driver.class);\n        Iterator\u0026#x3C;Driver\u003e driversIterator = loadedDrivers.iterator();\n\n        try{\n            while(driversIterator.hasNext()) {\n            driversIterator.next();\n            }\n        } catch(Throwable t) {\n                // Do nothing\n        }\n        return null;\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。\u003c/p\u003e\n\u003cp\u003e为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。\u003c/p\u003e"},{"url":"2018-07-10-CGlib-Enhancer","fileName":"2018-07-10-CGlib-Enhancer.md","title":"CGlib Enhancer 主流程源码解析","author":"fangfeng","date":"2018-07-10T00:00:00.000Z","tags":["CGlib","ASM"],"content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e此博文写作的目的: \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。\u003c/li\u003e\n\u003cli\u003e基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eEnhancer\u003c/h2\u003e\n\u003cp\u003e从这篇不是官方但更胜于官方文档的 \u003ca href=\"http://mydailyjava.blogspot.com/2013/11/cglib-missing-manual.html\"\u003eCGlib Guide\u003c/a\u003e 来看，它首先提到的第一个类就是 Enhancer。\n其被用于创建 Java 代理类，相较于 Java 标准库的 Proxy 类，它\u003cstrong\u003e特别地\u003c/strong\u003e，能够支持那些没有实现接口的类的代理工作。\u003c/p\u003e\n\u003ch3\u003eEnhancer 简单示例展示\u003c/h3\u003e\n\u003cp\u003e针对现有的 SampleClass 类\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SampleClass {\n    public String test(String input) {\n        return \"Hello World!\";\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用 CGlib 的 Enhancer 对 SampleClass 进行增强，下列操作的目的在于将 test(String) 方法的返回值改写成 \"Hello cglib!\"\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Test\npublic void testFixedValue() {\n    // new 一个 Enhancer 实例\n    Enhancer enhancer = new Enhancer();\n    // 声明使用的父类是 SampleClass\n    enhancer.setSuperclass(SampleClass.class);\n    // 设置回调方法 - 回调方法实现为 FixedValue (固定值) .\n    enhancer.setCallback(new FixedValue() {\n        public Object loadObject() throws Exception {\n            return \"Hello cglib!\";\n        }\n    });\n    // 创建 SampleClass 的代理子类实例\n    SampleClass proxy = (SampleClass) enhancer.create();\n    Assert.assertEquals(\"Hello cglib!\", proxy.test(null));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e简单测试上述代码，可以了解到确实，代理类的 test(String) 方法的返回值被改写了。\n那么，究竟这种操作是如何实现的？下面👇将进行具体的探究。\u003c/p\u003e\n\u003ch2\u003e调用链跟踪\u003c/h2\u003e\n\u003ch3\u003e高度抽象的时序图\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1ft4ifuo997j31jh0st42t.jpg\" alt=\"Enhancer 调用链 时序图\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e下列内容将根据时序图进行组织，根据调用编号(1,2,3...)进行展开\u003c/em\u003e\u003c/p\u003e\n\u003ch3\u003eSeq 1.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Object create() {\n    classOnly = false;\n    argumentTypes = null;\n    return createHelper();\n}\n\npublic Object create(Class[] argumentTypes, Object[] arguments) {\n    classOnly = false;\n    if (argumentTypes == null || arguments == null || argumentTypes.length != arguments.length) {\n        throw new IllegalArgumentException(\"Arguments must be non-null and of equal length\");\n    }\n    this.argumentTypes = argumentTypes;\n    this.arguments = arguments;\n    return createHelper();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述两个 \u003ccode\u003ecreate(...)\u003c/code\u003e 方法。结合上一节的使用示例，可以看到 \u003ccode\u003ecreate()\u003c/code\u003e 对应的\u003cstrong\u003e无参构造\u003c/strong\u003e。\n存在无参构造，那么\u003cstrong\u003e有参的构造方法\u003c/strong\u003e显然也是应该被支持id。\u003ccode\u003ecreate(Class[], Object[])\u003c/code\u003e 正是为了这个目标而存在。通过提供参数类型数组和参数实例数组，可以唯一地定位及调用代理类的特定构造方法。\u003c/p\u003e\n\u003cp\u003e这个方法比较简单，只是将 Enhancer 作为一个数据内容的持有者，重置了新代理类将使用的构造函数参数内容，之后就直接调用了 \u003ccode\u003ecreateHelper()\u003c/code\u003e 。\u003c/p\u003e\n\u003ch3\u003eSeq 2.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Object createHelper() {\n    // 对预声明的回调方法进行验证，要求 [多个回调就必须存在 CallbackFilter 作为调度器]\n    preValidate();\n    // 构建一个对这类增强操作唯一定位的 key\n    Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,\n            ReflectUtils.getNames(interfaces),\n            filter == ALL_ZERO ? null : new WeakCacheKey\u0026#x3C;CallbackFilter\u003e(filter),\n            callbackTypes,\n            useFactory,\n            interceptDuringConstruction,\n            serialVersionUID);\n    this.currentKey = key;\n    // 调用父类通过的 create(...) 方法\n    Object result = super.create(key);\n    return result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSeq 3.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprotected Object create(Object key) {\n    try {\n        // 获取用于 加载 生成类 的 ClassLoader\n        ClassLoader loader = getClassLoader();\n        // 从缓存中加载 这个 ClassLoader 过去加载的相关数据\n        Map\u0026#x3C;ClassLoader, ClassLoaderData\u003e cache = CACHE;\n        ClassLoaderData data = cache.get(loader);\n        // 如果在 缓存 中找不到，则初始化构造关于这个 ClassLoader 的数据实例\n        if (data == null) {\n            // 同步\n            synchronized (AbstractClassGenerator.class) {\n                // 进入同步块后的 再次确认，避免重复初始化构建\n                cache = CACHE;\n                data = cache.get(loader);\n                if (data == null) {\n                    // 构建新的 缓存，拷贝原有的缓存集的内容\n                    Map\u0026#x3C;ClassLoader, ClassLoaderData\u003e newCache = new WeakHashMap\u0026#x3C;ClassLoader, ClassLoaderData\u003e(cache);\n                    // 初始化 ClassLoaderData ，真正的构造操作\n                    data = new ClassLoaderData(loader);\n                    // 添加到缓存中\n                    newCache.put(loader, data);\n                    CACHE = newCache;\n                }\n            }\n        }\n        this.key = key;\n        Object obj = data.get(this, getUseCache());\n        if (obj instanceof Class) {\n            // 初次实例化操作，就是 Class 利用反射来进行实例化\n            return firstInstance((Class) obj);\n        }\n        // 非初次实例化，则是从 ClassLoaderData 中得到的之前维护的内容\n        return nextInstance(obj);\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (Error e) {\n        throw e;\n    } catch (Exception e) {\n        throw new CodeGenerationException(e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这部分内容比较多，且是调用链比较重要的一环。\u003cstrong\u003eSeq 4.\u003c/strong\u003e 和 \u003cstrong\u003eSeq 5.\u003c/strong\u003e 将作为其子内容进行调用，但为了本博文的结构完整， \u003cem\u003eSeq 4. \u0026#x26; Seq5.\u003c/em\u003e 的标题与 \u003cem\u003eSeq 3.\u003c/em\u003e 标题同级\u003c/p\u003e\n\u003ch3\u003eSeq 4.\u003c/h3\u003e\n\u003cp\u003e首先应该认识到，每个被加载的 Class ，在 \u003ccode\u003eequal\u003c/code\u003e 的判断过程中，依据的是同一个 ClassLoader 加载的同一 Class 才被认为是相同的，否则即使 Class 是同一个，但仍会被认为是不同的(由不同的 ClassLoader 加载)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic ClassLoader getClassLoader() {\n    ClassLoader t = classLoader;\n    if (t == null) {\n        t = getDefaultClassLoader();\n    }\n    if (t == null) {\n        t = getClass().getClassLoader();\n    }\n    if (t == null) {\n        t = Thread.currentThread().getContextClassLoader();\n    }\n    if (t == null) {\n        throw new IllegalStateException(\"Cannot determine classloader\");\n    }\n    return t;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因此，在这部分中，首先需要确定的是由哪个 ClassLoader 进行加载的工作。\u003ccode\u003egetClassLoader()\u003c/code\u003e 的确定顺序是:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e具体实现类声明的 \u003cstrong\u003e默认 ClassLoader\u003c/strong\u003e 为第一优先级\u003c/li\u003e\n\u003cli\u003e加载当前类(这里是 Enhancer) 的 ClassLoader 为第二优先级\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e当前线程上下文 ClassLoader\u003c/strong\u003e 为第三优先级\u003c/li\u003e\n\u003cli\u003e抛出异常\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e回到 \u003cstrong\u003eSeq 3.\u003c/strong\u003e 的内容，\n下一步是对当前这个\u003cstrong\u003eAbstractClassGenerator\u003c/strong\u003e 维护的 CACHE 进行处理，如果在 CACHE 中能够得到以确定的 ClassLoader 为 Key 的键值对，则直接获取 ClassLoader 对应的值，否则将进行初始化构建一个新的 ClassLoaderData 作为这个 ClassLoader 的值。\u003c/p\u003e\n\u003ch3\u003eSeq 5.\u003c/h3\u003e\n\u003cp\u003e在构建 ClassLoaderData 的过程中，最重要的一步:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic ClassLoaderData(ClassLoader classLoader) {\n    // ClassLoader 不可为空\n    if (classLoader == null) {\n        throw new IllegalArgumentException(\"classLoader == null is not yet supported\");\n    }\n    // 构建 ClassLoader 的弱引用\n    this.classLoader = new WeakReference\u0026#x3C;ClassLoader\u003e(classLoader);\n    // 写了个后置调用的函数，用于懒加载，只有调用了 load.apply(...) 才会构建 生成类\n    Function\u0026#x3C;AbstractClassGenerator, Object\u003e load =\n            new Function\u0026#x3C;AbstractClassGenerator, Object\u003e() {\n                public Object apply(AbstractClassGenerator gen) {\n                    Class klass = gen.generate(ClassLoaderData.this);\n                    return gen.wrapCachedClass(klass);\n                }\n            };\n    generatedClasses = new LoadingCache\u0026#x3C;AbstractClassGenerator, Object, Object\u003e(GET_KEY, load);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e构建了一个 Function 实例，这个 Function 作为函数式接口，预定义执行的具体流程，但由上下文确定具体的调用时刻。\u003c/p\u003e\n\u003ch3\u003eSeq 6.\u003c/h3\u003e\n\u003cp\u003e在正确得到了 ClassLoader 对应的 ClassLoaderData 之后，ClassLoaderData 的 \u003ccode\u003eget(...)\u003c/code\u003e 方法将在特定的 ClassLoader 之下，进行更具体的加载新生成类的工作。\n当然，这里的前提是新的生成类的字节码已经被构建:)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Object get(AbstractClassGenerator gen, boolean useCache) {\n    // 标记为不使用缓存，直接构建 新的生成类\n    if (!useCache) {\n      return gen.generate(ClassLoaderData.this);\n    }\n    // 使用缓冲的情况\n    else {\n      Object cachedValue = generatedClasses.get(gen);\n      return gen.unwrapCachedValue(cachedValue);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003egen.generate(ClassLoaderData.this)\u003c/code\u003e 这段代码在 \u003ccode\u003eget(...)\u003c/code\u003e 方法和上一小节 \u003ccode\u003eClassLoaderData(...)\u003c/code\u003e 构造方法的 Function 函数式实例都出现了。\u003c/p\u003e\n\u003cp\u003e实际上，这也是触发 ClassLoader 来加载动态生成的新 Class 的唯一入口。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e判断逻辑\u003c/em\u003e 的 \u003ccode\u003eelse\u003c/code\u003e 内容的唯一区别就在于其构建的是一个加载缓存，将真正触发 gen.generate(ClassLoaderData.this) 的逻辑延迟。(不过，最终也还是会进行调用的，:) 这是毋庸置疑的)。\u003c/p\u003e\n\u003ch3\u003eSeq 7.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprotected Class generate(ClassLoaderData data) {\n    Class gen;\n    Object save = CURRENT.get();\n    CURRENT.set(this);\n    try {\n        // 拿到用于加载生成类的 ClassLoader\n        ClassLoader classLoader = data.getClassLoader();\n        if (classLoader == null) {\n            throw new IllegalStateException(\"ClassLoader is null while trying to define class \" +\n                    getClassName() + \". It seems that the loader has been expired from a weak reference somehow. \" +\n                    \"Please file an issue at cglib's issue tracker.\");\n        }\n        // 构建一个合法的 生成类 的类名(非重复)\n        synchronized (classLoader) {\n          String name = generateClassName(data.getUniqueNamePredicate());\n          data.reserveName(name);\n          this.setClassName(name);\n        }\n        if (attemptLoad) {\n            try {\n                // 尝试直接通过 ClassLoader 进行加载\n                gen = classLoader.loadClass(getClassName());\n                return gen;\n            } catch (ClassNotFoundException e) {\n                // ignore\n            }\n        }\n        // 策略下的生成类构建方法\n        byte[] b = strategy.generate(this);\n        // 通过解析字节码的形式获取 生成类的 className\n        String className = ClassNameReader.getClassName(new ClassReader(b));\n        ProtectionDomain protectionDomain = getProtectionDomain();\n        synchronized (classLoader) { // just in case\n            // 反射的形式加载 Class 类\n            if (protectionDomain == null) {\n                gen = ReflectUtils.defineClass(className, b, classLoader);\n            } else {\n                gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);\n            }\n        }\n        return gen;\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (Error e) {\n        throw e;\n    } catch (Exception e) {\n        throw new CodeGenerationException(e);\n    } finally {\n        CURRENT.set(save);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个方法，就是操作字节码，加载 Class 的核心调度方法。\u003c/p\u003e\n\u003cp\u003e可以看到 \u003ccode\u003egenerateClassName(...)\u003c/code\u003e 方法将构建一个当前 ClassLoader 下唯一, 不重复的新的类名。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estrategy.generate(this)\u003c/code\u003e 将通过特定策略实现的形式生成新的字节码\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eReflectUtils.defineClass(className, b, classLoader)\u003c/code\u003e 将使用反射使得 ClassLoader 来加载这个新的生成类。\u003c/p\u003e\n\u003ch3\u003eSeq 8.\u003c/h3\u003e\n\u003cp\u003e生成新的不重复类名这部分不做过多陈述，可以简单进行了解，并熟悉 CGlib 默认的新类名的命名规则\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// DefaultNamePolicy\npublic String getClassName(String prefix, String source, Object key, Predicate names) {\n    if (prefix == null) {\n        prefix = \"net.sf.cglib.empty.Object\";\n    } else if (prefix.startsWith(\"java\")) {\n        prefix = \"$\" + prefix;\n    }\n    String base =\n        prefix + \"$$\" +\n        source.substring(source.lastIndexOf('.') + 1) +\n        getTag() + \"$$\" +\n        Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\n    String attempt = base;\n    int index = 2;\n    while (names.evaluate(attempt))\n        attempt = base + \"_\" + index++;\n    return attempt;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSeq 9.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 下列是 DefaultGeneratorStrategy 的实现\npublic byte[] generate(ClassGenerator cg) throws Exception {\n    DebuggingClassWriter cw = getClassVisitor();\n    transform(cg).generateClass(cw);\n    return transform(cw.toByteArray());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSeq 10.\u003c/h3\u003e\n\u003cp\u003e调用 \u003ccode\u003egenerateClass(ClassVisitor)\u003c/code\u003e 将获得到新类的字节码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void generateClass(ClassVisitor v) throws Exception {\n    // 确定生成类的 父类\n    Class sc = (superclass == null) ? Object.class : superclass;\n\n    // 父类标识符不可以为 final\n    if (TypeUtils.isFinal(sc.getModifiers()))\n        throw new IllegalArgumentException(\"Cannot subclass final class \" + sc.getName());\n    // 获取父类直接声明的构造方法\n    List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));\n    filterConstructors(sc, constructors);\n\n    // Order is very important: must add superclass, then\n    // its superclass chain, then each interface and\n    // its superinterfaces.\n    List actualMethods = new ArrayList();\n    List interfaceMethods = new ArrayList();\n    final Set forcePublic = new HashSet();\n    // 从父类中提取各种信息\n    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);\n\n    List methods = CollectionUtils.transform(actualMethods, new Transformer() {\n        public Object transform(Object value) {\n            Method method = (Method)value;\n            int modifiers = Constants.ACC_FINAL\n                | (method.getModifiers()\n                   \u0026#x26; ~Constants.ACC_ABSTRACT\n                   \u0026#x26; ~Constants.ACC_NATIVE\n                   \u0026#x26; ~Constants.ACC_SYNCHRONIZED);\n            if (forcePublic.contains(MethodWrapper.create(method))) {\n                modifiers = (modifiers \u0026#x26; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;\n            }\n            return ReflectUtils.getMethodInfo(method, modifiers);\n        }\n    });\n\n    ClassEmitter e = new ClassEmitter(v);\n    if (currentData == null) {\n    e.begin_class(Constants.V1_2,\n                  Constants.ACC_PUBLIC,\n                  getClassName(),\n                  Type.getType(sc),\n                  (useFactory ?\n                   TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :\n                   TypeUtils.getTypes(interfaces)),\n                  Constants.SOURCE_FILE);\n    } else {\n        e.begin_class(Constants.V1_2,\n                Constants.ACC_PUBLIC,\n                getClassName(),\n                null,\n                new Type[]{FACTORY},\n                Constants.SOURCE_FILE);\n    }\n    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\n\n    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);\n    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, null);\n    if (!interceptDuringConstruction) {\n        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null);\n    }\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);\n    if (serialVersionUID != null) {\n        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);\n    }\n\n    for (int i = 0; i \u0026#x3C; callbackTypes.length; i++) {\n        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null);\n    }\n    // This is declared private to avoid \"public field\" pollution\n    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, null);\n\n    if (currentData == null) {\n        emitMethods(e, methods, actualMethods);\n        emitConstructors(e, constructorInfo);\n    } else {\n        emitDefaultConstructor(e);\n    }\n    emitSetThreadCallbacks(e);\n    emitSetStaticCallbacks(e);\n    emitBindCallbacks(e);\n\n    if (useFactory || currentData != null) {\n        int[] keys = getCallbackKeys();\n        emitNewInstanceCallbacks(e);\n        emitNewInstanceCallback(e);\n        emitNewInstanceMultiarg(e, constructorInfo);\n        emitGetCallback(e, keys);\n        emitSetCallback(e, keys);\n        emitGetCallbacks(e);\n        emitSetCallbacks(e);\n    }\n\n    e.end_class();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egenerateClass(...)\u003c/code\u003e 执行的操作和 ASM 库的 ClassVisitor 访问 Class 文件结构的流程基本类似。\u003c/p\u003e\n\u003cp\u003e从上述截取到的部分代码，例如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ee.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), \n        (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)),\n        Constants.SOURCE_FILE);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ee.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e都与 \u003ccode\u003eclassVisitor.visit(...)\u003c/code\u003e 以及 \u003ccode\u003eclassVisitor.visitField(...)\u003c/code\u003e 相当类似。而事实上，这些方法的具体实现也确实调用了 cv.visitXxx(...) 。\n毕竟，作为 CGlib 唯一依赖的库，ASM 还是可以说是难以替代的(既然已经有了可用的轮子，又何必重复造呢?)\u003c/p\u003e\n\u003ch2\u003e构造的实例\u003c/h2\u003e\n\u003cp\u003e下面将展示通过 CGlib 生成的新的类(由于生成的是字节码，懒得再自行解析 ClassFile 的内容，所有直接用 \u003ccode\u003eIDEA\u003c/code\u003e 做了字节码的解析)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e首先展示的需要进行增强的 SampleClass 的具体内容\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SampleClass {\n    public String test(String input) {\n        return \"Hello World!\";\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e用于增强的简单代码\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 省略部分代码\npublic static void main(String... args) {\n    Enhancer enhancer = new Enhancer();\n    enhancer.setSuperclass(SampleClass.class);\n    enhancer.setCallback(new FixedValue() {\n        public Object loadObject() throws Exception {\n            return \"Hello cglib!\";\n        }\n    });\n    SampleClass proxy = (SampleClass) enhancer.create();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e动态生成的新的类\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\n// 不用过多关注，只是 CGlib 保证生成类与原有的类一定属于同一包下，偷懒直接把 SampleClass 写在 CGlib 项目里了\npackage net.sf.cglib.samples;\n\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.FixedValue;\n\n/**\n * 新的类名，通过 $$EnhancerByCGLIB 以及 $$7cd64b81(这个是哈希值) 对类名进行唯一区分 \n * 如果还是重复了，在动态生成前会进行类名的检测，并通过增加序号 \"_\u0026#x3C;index\u003e\" 的形式进行进一步区分\n *\n * 可以看到新生成的类继承了 SampleClass \n */\npublic class SampleClass$$EnhancerByCGLIB$$7cd64b81 extends SampleClass implements Factory {\n    private boolean CGLIB$BOUND;\n    public static Object CGLIB$FACTORY_DATA;\n    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;\n    private static final Callback[] CGLIB$STATIC_CALLBACKS;\n\n    // 绑定一个在增强中声明的 Callback 实例\n    private FixedValue CGLIB$CALLBACK_0;\n    // 绑定一个静态的回调调度实例\n    private static Object CGLIB$CALLBACK_FILTER;\n\n    static void CGLIB$STATICHOOK1() {\n        CGLIB$THREAD_CALLBACKS = new ThreadLocal();\n    }\n\n    /**\n      * 对 test(String) 的方法的增强\n      */ \n    public final String test(String var1) {\n        // 在方法块中拿到 Callback 实例\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        // 为空则尝试获取\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        // 触发回调实例的方法获得返回值\n        return (String)var10000.loadObject();\n    }\n\n    /**\n      * 由于此次增强只声明了一个 Callback\n      * 因此所有方法的增强都相同, 都是调用这个回调方法获取\n      */\n    public final boolean equals(Object var1) {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        Object var2 = var10000.loadObject();\n        /**\n         * 但是，此处会尝试强制转型\n         * 同时在最终执行失败的时候直接抛出运行时异常\n         * 毕竟上面增强的时候返回固定值 \"Hello, cglib!\"\n         */\n        return var2 == null ? false : (Boolean)var2;\n    }\n\n    public final String toString() {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return (String)var10000.loadObject();\n    }\n\n    public final int hashCode() {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        Object var1 = var10000.loadObject();\n        return var1 == null ? 0 : ((Number)var1).intValue();\n    }\n\n    protected final Object clone() throws CloneNotSupportedException {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return var10000.loadObject();\n    }\n\n    public SampleClass$$EnhancerByCGLIB$$7cd64b81() {\n        CGLIB$BIND_CALLBACKS(this);\n    }\n\n    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {\n        CGLIB$THREAD_CALLBACKS.set(var0);\n    }\n\n    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {\n        CGLIB$STATIC_CALLBACKS = var0;\n    }\n\n    private static final void CGLIB$BIND_CALLBACKS(Object var0) {\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var1 = (SampleClass$$EnhancerByCGLIB$$7cd64b81)var0;\n        if (!var1.CGLIB$BOUND) {\n            var1.CGLIB$BOUND = true;\n            Object var10000 = CGLIB$THREAD_CALLBACKS.get();\n            if (var10000 == null) {\n                var10000 = CGLIB$STATIC_CALLBACKS;\n                if (CGLIB$STATIC_CALLBACKS == null) {\n                    return;\n                }\n            }\n\n            var1.CGLIB$CALLBACK_0 = (FixedValue)((Callback[])var10000)[0];\n        }\n\n    }\n\n    public Object newInstance(Callback[] var1) {\n        CGLIB$SET_THREAD_CALLBACKS(var1);\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Callback var1) {\n        CGLIB$SET_THREAD_CALLBACKS(new Callback[]{var1});\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {\n        CGLIB$SET_THREAD_CALLBACKS(var3);\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81;\n        switch(var1.length) {\n        case 0:\n            var10000.\u0026#x3C;init\u003e();\n            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n            return var10000;\n        default:\n            throw new IllegalArgumentException(\"Constructor not found\");\n        }\n    }\n\n    public Callback getCallback(int var1) {\n        CGLIB$BIND_CALLBACKS(this);\n        FixedValue var10000;\n        switch(var1) {\n        case 0:\n            var10000 = this.CGLIB$CALLBACK_0;\n            break;\n        default:\n            var10000 = null;\n        }\n\n        return var10000;\n    }\n\n    public void setCallback(int var1, Callback var2) {\n        switch(var1) {\n        case 0:\n            this.CGLIB$CALLBACK_0 = (FixedValue)var2;\n        default:\n        }\n    }\n\n    public Callback[] getCallbacks() {\n        CGLIB$BIND_CALLBACKS(this);\n        return new Callback[]{this.CGLIB$CALLBACK_0};\n    }\n\n    public void setCallbacks(Callback[] var1) {\n        this.CGLIB$CALLBACK_0 = (FixedValue)var1[0];\n    }\n\n    static {\n        CGLIB$STATICHOOK1();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从上面的生成类可以看出来，CGlib 所进行的增强，是在不直接对原有的方法体内容进行改造的基础上(例如上面的 test(String) 方法，没有直接改写成 \u003ccode\u003ereturn \"Hello, cglib!\u003c/code\u003e 的形式)，对方法执行之前入参或者方法执行之后的返回值进行一定的处理。\u003c/p\u003e\n\u003cp\u003e主要使用的形式就是将回调实例与原有方法进行绑定，并通过调用回调方法来实现方法的增强。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e此博文写作的目的: \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。\u003c/li\u003e\n\u003cli\u003e基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。\u003c/li\u003e\n\u003c/ul\u003e"},{"url":"2018-07-13-How-to-easily-get-CGlib-generated-code","fileName":"2018-07-13-How-to-easily-get-CGlib-generated-code.md","title":"如何方便地获取 CGlib 生成类","author":"fangfeng","date":"2018-07-13T00:00:00.000Z","tags":["CGlib","tools"],"content":"\u003ch2\u003e配置参数\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e命令行使用\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 java 启动命令中添加参数配置项 \u003ccode\u003e-Dcglib.debugLocation=\u0026#x3C;Custom Path\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e编码实现\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在执行 CGlib 获取新生成类之前，调用 \u003ccode\u003eSystem.setProperty(\"cglib.debugLocation\", \u0026#x3C;Custom Path\u003e)\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e如何游刃有余地 Debug 掺杂 CGlib 生成类的调用链\u003c/h2\u003e\n\u003cp\u003e经常会遇到，项目中不经意间就遇到了 CGlib 代理，然后对调用链的 Debug 就开始出现断层。继而，对对象或实例变量的跟踪就显得一头雾水。\u003c/p\u003e\n\u003cp\u003e特别是在不了解生成类到底是增强了那些内容的时候，甚至可能连调用链都跟踪不下去了 T_T 。\u003c/p\u003e\n\u003cp\u003e通过 \u003cstrong\u003e配置参数\u003c/strong\u003e 一节的内容，你就可以在你理想的目录 \u003ccode\u003e\u0026#x3C;Custom Path\u003e\u003c/code\u003e 下看到\u003cstrong\u003e所谓黑盒\u003c/strong\u003e中生成类的完成内容了。\u003c/p\u003e\n\u003cp\u003e下面的内容，将简单地介绍如何配合 CGlib 生成类的内容实现: 保证 Debug 的每一步骤可见; 保证 Debug 的过程不会出现\u003cem\u003e黑盒\u003c/em\u003e。\u003c/p\u003e\n\u003ch3\u003e确定 \u003ccode\u003e\u0026#x3C;Custom Path\u003e\u003c/code\u003e 下哪个文件是原有 Java 类的生成类\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic String getClassName(String prefix, String source, Object key, Predicate names) {\n    if (prefix == null) {\n        prefix = \"net.sf.cglib.empty.Object\";\n    } else if (prefix.startsWith(\"java\")) {\n        prefix = \"$\" + prefix;\n    }\n    String base =\n        prefix + \"$$\" +\n        source.substring(source.lastIndexOf('.') + 1) +\n        getTag() + \"$$\" +\n        Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\n    String attempt = base;\n    int index = 2;\n    while (names.evaluate(attempt))\n        attempt = base + \"_\" + index++;\n    return attempt;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCGlib 默认的类名生成策略下，生成类的全限定名将结合原文件的全限定名决定。\u003c/p\u003e\n\u003cp\u003e通常命名如下: \u003ccode\u003e\u0026#x3C;原 Java 类全限定名\u003e$$\u0026#x3C;类似 EnhancerByCGlib\u003e$$\u0026#x3C;生成类核心内容的 hash 值\u003e_\u0026#x3C;index[可能存在]\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e例如: 原有 Java 类全限定名为 me.fangfeng.Test ，则生成类名可能为 \u003ccode\u003eme.fangfeng.Test$$EnhancerByCGlib$$ab1203aa\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e当然，通常情况下会存在一个类名形如 \u003ccode\u003eme.fangfeng.Test$$FastClassBySpring$$...\u003c/code\u003e 的类，这是作为生成类 \u003ccode\u003eme.fangfeng.Test$$EnhancerByCGlib$$ab1203aa\u003c/code\u003e 的辅助类来使用。\u003c/p\u003e\n\u003ch3\u003e简单了解生成类下的调用关系\u003c/h3\u003e\n\u003cp\u003eJava 代码触发被增强的类，将首先调用生成类。但是，这是没办法进行 Debug 的，因为这个生成类的字节码缺少 SourceFile 属性，同时缺少 LineNumberTable 属性。\u003c/p\u003e\n\u003cp\u003e但是，这并不影响对调用链的跟踪。\u003c/p\u003e\n\u003cp\u003eCGlib 的增强，所有的增强逻辑都是以 Callback 实现类的形式来提供的。同时在 CGlib 生成类中也有 Callback 的实例变量来持有这些注入的 Callback 。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原有 Java 类\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1ft8e7kr7qvj30sc0j0wh4.jpg\" alt=\"LogonService.java\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e对应的生成类\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8e9ww4hqj31hg0oojzv.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eanb6c9j31j00lgn1e.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e跟踪 LogonService.addLogon(String var1) 演示\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e当前 LogonService 的生成类全限定名为me.fangfeng.transactionBugs.LogonService\u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eE\u003c/mi\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmi\u003eh\u003c/mi\u003e\u003cmi\u003ea\u003c/mi\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmi\u003ec\u003c/mi\u003e\u003cmi\u003ee\u003c/mi\u003e\u003cmi\u003er\u003c/mi\u003e\u003cmi\u003eB\u003c/mi\u003e\u003cmi\u003ey\u003c/mi\u003e\u003cmi\u003eS\u003c/mi\u003e\u003cmi\u003ep\u003c/mi\u003e\u003cmi\u003er\u003c/mi\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmi\u003eg\u003c/mi\u003e\u003cmi\u003eC\u003c/mi\u003e\u003cmi\u003eG\u003c/mi\u003e\u003cmi\u003eL\u003c/mi\u003e\u003cmi\u003eI\u003c/mi\u003e\u003cmi\u003eB\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eEnhancerBySpringCGLIB\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05764em;\"\u003eE\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003en\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003eh\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ea\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003en\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ec\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ee\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003er\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05017em;\"\u003eB\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.03588em;\"\u003ey\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05764em;\"\u003eS\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ep\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003er\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ei\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003en\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.03588em;\"\u003eg\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07153em;\"\u003eC\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003eG\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003eL\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07847em;\"\u003eI\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05017em;\"\u003eB\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003ebfc1dc3.class; 以下简称为 LogonSerivce$$bfc1dc3 \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e首先，配置 \u003ccode\u003ecglib.debugLocation\u003c/code\u003e 参数，值 = 项目生成的 .class 路径\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e无断点直接运行一次需要处理的逻辑\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e找到 LogonSerive$$bfc1dc3.class, 随意打上一个看似有效的断点\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在各处打上必要的断点，开始进行真正的调试工作\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e代码执行到 \u003ccode\u003eLogonService$$bfc1dc3.class\u003c/code\u003e, 虽然没有真正进入断点位置, 但是可以看到这个 \u003ccode\u003eLogonService$$bfc1dc3\u003c/code\u003e 实例的实例变量信息\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1ft8eq1be61j319w0bwtde.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8egtg1naj31ji0fmgp2.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e比照生成类代码中 addLogon(String var1) 方法体的内容以及展示的实例变量信息。可以看到生成类调用的 Callback 实例是 \u003ccode\u003eCGLIB$CALLBACK_0\u003c/code\u003e\n类型是 CglibAopProxy 的静态内部私有类 DynamicAdvisedInterceptor 。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eu91oscj31gq0ayju5.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e在 intercept(...) 上打个断点，跳过生成类 addLogon(String var1) 方法的下一个调用方法就是 intercept(...) \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e而且事实上，CGlib 生成类的内容基本也就是对调用方法进行的一种转发\u003c/strong\u003e\u003c/p\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e继续 Debug ，对于生成类的内容，人肉了解并定位到触发的 Callback 实例或者 super.Xxx() 方法。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e配置参数\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e命令行使用\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 java 启动命令中添加参数配置项 \u003ccode\u003e-Dcglib.debugLocation=\u0026#x3C;Custom Path\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e编码实现\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在执行 CGlib 获取新生成类之前，调用 \u003ccode\u003eSystem.setProperty(\"cglib.debugLocation\", \u0026#x3C;Custom Path\u003e)\u003c/code\u003e\u003c/p\u003e"}],"items":32,"pages":4,"currentPage":0},"buildId":"_kHFDZs2rntv1kq9Ewo5u","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/" src="https://www.ffutop.com/blog/_next/static/_kHFDZs2rntv1kq9Ewo5u/pages/index.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/_kHFDZs2rntv1kq9Ewo5u/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.74c43a0e96cfe845a889.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>