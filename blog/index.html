<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/YsOqVyLvFnUbWFBFmGa7N/pages/index.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/YsOqVyLvFnUbWFBFmGa7N/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.74c43a0e96cfe845a889.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.a1d4ae30.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.d723af22.chunk.css"/></head><body><div id="__next"><header class="component-header"><h1 class="title">ffutop</h1><ul class="nav-items"><li><a href="/blog/index">博客</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/about">关于</a></li></ul></header><div><main class="main"><div><div class="component-post-digest"><h1 class="title"><a href="/blog2019-04-10-understand-Kernel-10">理解 Linux Kernel(10) - Context of Execution</a></h1><div><p>在进行<a href="https://www.ffutop.com/2018-10-12-understand-Kernel-4/">第四篇(任务调度)</a>行文描述时，就一直闹不清内核所谓的<code>task</code>的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：<strong>我们错误地将理论和实践不加区分地混淆了</strong>。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，<code>task</code> 也就是 <code>Context of Execution</code> 概念在实现上的表征。</p></div><p><a href="/blog2019-04-10-understand-Kernel-10">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2019-03-25-mem-dump">如何获取运行时进程堆栈</a></h1><div><p>前些天看了关于在密码学应用中使用<code>java.lang.String</code>与<code>byte[]</code>的相关讨论，不推荐使用<code>java.lang.String</code>的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。</p>
<h2>/proc/${pid}/maps</h2>
<p>首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从<code>/proc</code>虚拟文件系统中，提供了进程虚拟地址映射。</p>
<pre><code>address                   perm offset   dev   inode                      pathname
556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run
556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run
556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run
55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]
7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so
7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so
7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so
7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so
7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0
7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so
7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0
7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so
7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so
7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0
7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]
7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]
7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
</code></pre></div><p><a href="/blog2019-03-25-mem-dump">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2019-03-19-JANUS">认证与授权·简述</a></h1><div><h2>概述</h2>
<blockquote>
<p>在大多数系统中，都或多或少需要认证授权模型/系统的支持。</p>
</blockquote>
<p>认证/授权是什么？最简单的，我们的系统要求用户必须在“登录”之后才允许进行一些操作。“登录”的过程就是认证；而区别与未登录状态，只允许登录用户进行一些操作，这就是授权。认证与授权相互独立，有协同配合，共同支撑起系统对安全的基本要求。</p></div><p><a href="/blog2019-03-19-JANUS">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2019-03-05-understand-Kernel-9">理解 Linux Kernel (9) - IO Multiplexing</a></h1><div><p><a href="./2019-01-15-understand-Kernel-8/">前一篇</a>已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 <code>struct sock</code> 对象，将其逐级从网络接口层逐级提升到网络层、传输层...最终添加到接收队列 <code>sk_receive_queue</code> 中；用户进程通过 <code>read</code>、<code>recv</code>、<code>recvfrom</code> 等命令检查并获取 <code>sk_receive_queue</code> 中的数据。</p>
<p>整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。</p>
<p>那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（<code>select</code>, <code>poll</code>, <code>epoll</code>）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 <code>select</code> 和 <code>epoll</code> 两类系统调用的实现进行探究。</p></div><p><a href="/blog2019-03-05-understand-Kernel-9">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2019-02-27-Java-Fatal-API">【Java】API 参数误定义的后果</a></h1><div><p>工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。</p>
<p>想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！</p>
<p>想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把<code>void add(int)</code> API 改写成 <code>int add(int)</code>，可能得到的大多数回答都是可以。</p></div><p><a href="/blog2019-02-27-Java-Fatal-API">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2019-02-02-unicode"></a></h1><div><p>title: 字符集与字符编码
author: fangfeng
date: 2019-02-02
tags:</p>
<ul>
<li>Unicode</li>
<li>Character Encoding</li>
</ul>
<hr>
<p>{% pdf <a href="https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview">https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview</a> %}</p></div><p><a href="/blog2019-02-02-unicode">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2019-01-15-understand-Kernel-8"></a></h1><div><p>title: 理解 Linux Kernel (8) - 网络
author: fangfeng
date: 2019-01-15
tags:</p>
<ul>
<li>Linux</li>
<li>Kernel</li>
<li>Network</li>
</ul>
<hr>
<p>{% pdf <a href="https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview">https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview</a> %}</p></div><p><a href="/blog2019-01-15-understand-Kernel-8">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-12-28-understand-Kernel-7">理解 Linux Kernel (7) - 字符设备</a></h1><div><p>相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。</p>
<p>回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。</p>
<p>那么，常见的字符设备有什么？显示器、键盘、鼠标。</p></div><p><a href="/blog2018-12-28-understand-Kernel-7">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-12-15-sql-injection">SQL 注入</a></h1><div><p>说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。</p>
<p>最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。</p>
<p>更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: "我用不用现成的工具只是取决于我想不想自己再写一套"</p>
<p>当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。</p></div><p><a href="/blog2018-12-15-sql-injection">阅读更多</a></p><hr/></div></div><div><a href="/blog/page/2">下一页</a></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/","query":{"mdDatasParts":[{"url":"2019-04-10-understand-Kernel-10","fileName":"2019-04-10-understand-Kernel-10.md","title":"理解 Linux Kernel(10) - Context of Execution","author":"fangfeng","date":"2019-04-10T00:00:00.000Z","tags":["Linux","Kernel","COE"],"content":"\u003cp\u003e在进行\u003ca href=\"https://www.ffutop.com/2018-10-12-understand-Kernel-4/\"\u003e第四篇(任务调度)\u003c/a\u003e行文描述时，就一直闹不清内核所谓的\u003ccode\u003etask\u003c/code\u003e的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：\u003cstrong\u003e我们错误地将理论和实践不加区分地混淆了\u003c/strong\u003e。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，\u003ccode\u003etask\u003c/code\u003e 也就是 \u003ccode\u003eContext of Execution\u003c/code\u003e 概念在实现上的表征。\u003c/p\u003e\n\u003cp\u003e执行的上下文(Context of Execution, COE)，记录了所有程序执行中的状态，包括：CPU状态（寄存器信息等）、MMU状态（页映射）、权限状态（uid、gid等）和一些公共属性（打开的文件、信号处理函数等）。对比理论上的进程/线程概念，粗略地讲就是同一线程组的线程各自持有CPU状态而共享其它状态，而认为两进程不共享任何状态。当然，在内核的概念里，进程/线程只是COE共享部分状态中的一个特例。\u003c/p\u003e\n\u003ch2\u003efork, clone\u003c/h2\u003e\n\u003cp\u003e如果用进程/线程的概念来看，内核提供了 \u003ccode\u003efork\u003c/code\u003e 来完成进程的复制，提供了 \u003ccode\u003eclone\u003c/code\u003e 来处理线程的拷贝，另外还有 \u003ccode\u003evfork\u003c/code\u003e , \u003ccode\u003ekernel_thread\u003c/code\u003e 等。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003esyscall fork\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage int sys_fork(struct pt_regs regs)\n{\n    return do_fork(SIGCHLD, regs.esp, \u0026#x26;regs, 0, NULL, NULL);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003esyscall clone\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage int sys_clone(struct pt_regs regs)\n{\n    unsigned long clone_flags;\n    unsigned long newsp;\n    int __user *parent_tidptr, *child_tidptr;\n    \n    clone_flags = regs.ebx;\n    newsp = regs.ecx;\n    parent_tidptr = (int __user *)regs.edx;\n    child_tidptr = (int __user *)regs.edi;\n    if (!newsp)\n        newsp = regs.esp;\n    return do_fork(clone_flags, newsp, \u0026#x26;regs, 0, parent_tidptr, child_tidptr);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003esyscall vfork\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage int sys_vfork(struct pt_regs regs)\n{\n    return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.esp, \u0026#x26;regs, 0, NULL, NULL);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ekernel function: kernel_thread\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)\n{\n    // ...\n    return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, \u0026#x26;regs, 0, NULL, NULL);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efork\u003c/code\u003e, \u003ccode\u003eclone\u003c/code\u003e, \u003ccode\u003evfork\u003c/code\u003e 的入参怎么和日常使用的系统调用入参不同？且看：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e    .macro PTREGSCALL label, func, arg\n    .globl \\label\n\\label:\n    leaq \\func(%rip),%rax\n    leaq -ARGOFFSET+8(%rsp),\\arg    /* 8 for return address */\n    jmp  ia32_ptregs_common\n    .endm\n\n    CFI_STARTPROC32\n\n    PTREGSCALL stub32_rt_sigreturn, sys32_rt_sigreturn, %rdi\n    PTREGSCALL stub32_sigreturn, sys32_sigreturn, %rdi\n    PTREGSCALL stub32_sigaltstack, sys32_sigaltstack, %rdx\n    PTREGSCALL stub32_sigsuspend, sys32_sigsuspend, %rcx\n    PTREGSCALL stub32_execve, sys32_execve, %rcx\n    PTREGSCALL stub32_fork, sys_fork, %rdi\n    PTREGSCALL stub32_clone, sys32_clone, %rdx\n    PTREGSCALL stub32_vfork, sys_vfork, %rdi\n    PTREGSCALL stub32_iopl, sys_iopl, %rsi\n    PTREGSCALL stub32_rt_sigsuspend, sys_rt_sigsuspend, %rdx\n\nENTRY(ia32_ptregs_common)\n    popq %r11\n    CFI_ENDPROC\n    CFI_STARTPROC32 simple\n    CFI_SIGNAL_FRAME\n    CFI_DEF_CFA rsp,SS+8-ARGOFFSET\n    CFI_REL_OFFSET  rax,RAX-ARGOFFSET\n    CFI_REL_OFFSET  rcx,RCX-ARGOFFSET\n    CFI_REL_OFFSET  rdx,RDX-ARGOFFSET\n    CFI_REL_OFFSET  rsi,RSI-ARGOFFSET\n    CFI_REL_OFFSET  rdi,RDI-ARGOFFSET\n    CFI_REL_OFFSET  rip,RIP-ARGOFFSET\n/*  CFI_REL_OFFSET  cs,CS-ARGOFFSET*/\n/*  CFI_REL_OFFSET  rflags,EFLAGS-ARGOFFSET*/\n    CFI_REL_OFFSET  rsp,RSP-ARGOFFSET\n/*  CFI_REL_OFFSET  ss,SS-ARGOFFSET*/\n    SAVE_REST\n    call *%rax\n    RESTORE_REST\n    jmp  ia32_sysret    /* misbalances the return cache */\n    CFI_ENDPROC\nEND(ia32_ptregs_common)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e进行系统调用时的处理逻辑统一地将这些内容进行了整合，并将CPU状态（所有通用寄存器状态）维护到 \u003ccode\u003estruct pt_regs\u003c/code\u003e 数据块中。总结起来，三种系统调用最终都委托给 \u003ccode\u003edo_fork\u003c/code\u003e 进行实现，只是在参数的选择方面做了不同的预处理。这在用户层的函数原型上就更为明显，\u003ccode\u003efork\u003c/code\u003e 和 \u003ccode\u003evfork\u003c/code\u003e 都不允许参数的调用。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003epid_t fork(void);\n\n/* for x86-32 */\nlong clone(unsigned long flags, void *child_stack,\n        int *ptid, unsigned long newtls,\n        int *ctid);\n\npid_t vfork(void);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再看看 \u003ccode\u003eflags\u003c/code\u003e 有哪些值可选。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/*\n * cloning flags:\n */\n#define CSIGNAL     0x000000ff  /* signal mask to be sent at exit */\n#define CLONE_VM    0x00000100  /* set if VM shared between processes */\n#define CLONE_FS    0x00000200  /* set if fs info shared between processes */\n#define CLONE_FILES 0x00000400  /* set if open files shared between processes */\n#define CLONE_SIGHAND   0x00000800  /* set if signal handlers and blocked signals shared */\n#define CLONE_PTRACE    0x00002000  /* set if we want to let tracing continue on the child too */\n#define CLONE_VFORK 0x00004000  /* set if the parent wants the child to wake it up on mm_release */\n#define CLONE_PARENT    0x00008000  /* set if we want to have the same parent as the cloner */\n#define CLONE_THREAD    0x00010000  /* Same thread group? */\n#define CLONE_NEWNS 0x00020000  /* New namespace group? */\n#define CLONE_SYSVSEM   0x00040000  /* share system V SEM_UNDO semantics */\n#define CLONE_SETTLS    0x00080000  /* create a new TLS for the child */\n#define CLONE_PARENT_SETTID 0x00100000  /* set the TID in the parent */\n#define CLONE_CHILD_CLEARTID    0x00200000  /* clear the TID in the child */\n#define CLONE_DETACHED      0x00400000  /* Unused, ignored */\n#define CLONE_UNTRACED      0x00800000  /* set if the tracing process can't force CLONE_PTRACE on this clone */\n#define CLONE_CHILD_SETTID  0x01000000  /* set the TID in the child */\n#define CLONE_STOPPED       0x02000000  /* Start in stopped state */\n#define CLONE_NEWUTS        0x04000000  /* New utsname group? */\n#define CLONE_NEWIPC        0x08000000  /* New ipcs */\n#define CLONE_NEWUSER       0x10000000  /* New user namespace */\n#define CLONE_NEWPID        0x20000000  /* New pid namespace */\n#define CLONE_NEWNET        0x40000000  /* New network namespace */\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003exxx shared between processes\u003c/code\u003e ，描述即将被创建的新任务将进行哪些状态/资源的共享，而哪些状态需要进行拷贝。\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003edo_fork\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e先看看核心的 \u003ccode\u003edo_fork\u003c/code\u003e 的逻辑。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eHint: 下列代码经过大量的删减\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003elong do_fork(unsigned long clone_flags,\n        unsigned long stack_start,\n        struct pt_regs *regs,\n        unsigned long stack_size,\n        int __user *parent_tidptr,\n        int __user *child_tidptr)\n{\n    p = copy_process(clone_flags, stack_start, regs, stack_size, child_tidptr, NULL);\n    if (!IS_ERR(p)) {\n        nr = (clone_flags \u0026#x26; CLONE_NEWPID) ?\n            task_pid_nr_ns(p, current-\u003ensproxy-\u003epid_ns) :\n                task_pid_vnr(p);\n        if (!(clone_flags \u0026#x26; CLONE_STOPPED))\n            wake_up_new_task(p, clone_flags);\n        else\n            p-\u003estate = TASK_STOPPED;\n    } else {\n        nr = PTR_ERR(p);\n    }\n    return nr;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic struct task_struct *copy_process(unsigned long clone_flags,\n                    unsigned long stack_start,\n                    struct pt_regs *regs,\n                    unsigned long stack_size,\n                    int __user *child_tidptr,\n                    struct pid *pid)\n{\n    /* 预分配 task_struct 数据结构空间 */\n    retval = security_task_create(clone_flags);\n    /* 复制 current 的 task_struct 数据结构 */\n    p = dup_task_struct(current);\n\n    if (nr_threads \u003e= max_threads)\n        goto bad_fork_cleanup_count;\n\n    /* 针对多核CPU，为新任务分配CPU */\n    sched_fork(p, clone_flags);\n    /* 复制 thread_info 数据结构及线程栈 */\n    retval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);\n\n    /* 分配新的 pid */\n    p-\u003epid = pid_nr(pid);\n    /* thread group id = new pid */\n    p-\u003etgid = p-\u003epid;\n    /* 如果标志是 CLONE_THREAD，tgid = 父任务id */\n    if (clone_flags \u0026#x26; CLONE_THREAD)\n        p-\u003etgid = current-\u003etgid;\n\n    p-\u003eset_child_tid = (clone_flags \u0026#x26; CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n    p-\u003eclear_child_tid = (clone_flags \u0026#x26; CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;\n    /*\n     * sigaltstack should be cleared when sharing the same VM\n     */\n    if ((clone_flags \u0026#x26; (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n        p-\u003esas_ss_sp = p-\u003esas_ss_size = 0;\n\n    /* ok, now we should be set up.. */\n    p-\u003eexit_signal = (clone_flags \u0026#x26; CLONE_THREAD) ? -1 : (clone_flags \u0026#x26; CSIGNAL);\n    p-\u003epdeath_signal = 0;\n    p-\u003eexit_state = 0;\n\n    /*\n     * Ok, make it visible to the rest of the system.\n     * We dont wake it up yet.\n     */\n    p-\u003egroup_leader = p;\n    INIT_LIST_HEAD(\u0026#x26;p-\u003ethread_group);\n    INIT_LIST_HEAD(\u0026#x26;p-\u003eptrace_children);\n    INIT_LIST_HEAD(\u0026#x26;p-\u003eptrace_list);\n\n    p-\u003ecpus_allowed = current-\u003ecpus_allowed;\n    if (unlikely(!cpu_isset(task_cpu(p), p-\u003ecpus_allowed) ||\n            !cpu_online(task_cpu(p))))\n        set_task_cpu(p, smp_processor_id());\n\n    /* CLONE_PARENT re-uses the old parent */\n    if (clone_flags \u0026#x26; (CLONE_PARENT|CLONE_THREAD))\n        p-\u003ereal_parent = current-\u003ereal_parent;\n    else\n        p-\u003ereal_parent = current;\n    p-\u003eparent = p-\u003ereal_parent;\n\n    spin_lock(\u0026#x26;current-\u003esighand-\u003esiglock);\n\n    if (clone_flags \u0026#x26; CLONE_THREAD) {\n        p-\u003egroup_leader = current-\u003egroup_leader;\n        list_add_tail_rcu(\u0026#x26;p-\u003ethread_group, \u0026#x26;p-\u003egroup_leader-\u003ethread_group);\n\n        if (!cputime_eq(current-\u003esignal-\u003eit_virt_expires,\n                cputime_zero) ||\n            !cputime_eq(current-\u003esignal-\u003eit_prof_expires,\n                cputime_zero) ||\n            current-\u003esignal-\u003erlim[RLIMIT_CPU].rlim_cur != RLIM_INFINITY ||\n            !list_empty(\u0026#x26;current-\u003esignal-\u003ecpu_timers[0]) ||\n            !list_empty(\u0026#x26;current-\u003esignal-\u003ecpu_timers[1]) ||\n            !list_empty(\u0026#x26;current-\u003esignal-\u003ecpu_timers[2])) {\n            /*\n             * Have child wake up on its first tick to check\n             * for process CPU timers.\n             */\n            p-\u003eit_prof_expires = jiffies_to_cputime(1);\n        }\n    }\n\n    if (likely(p-\u003epid)) {\n        add_parent(p);\n        if (unlikely(p-\u003eptrace \u0026#x26; PT_PTRACED))\n            __ptrace_link(p, current-\u003eparent);\n\n        if (thread_group_leader(p)) {\n            if (clone_flags \u0026#x26; CLONE_NEWPID)\n                p-\u003ensproxy-\u003epid_ns-\u003echild_reaper = p;\n\n            p-\u003esignal-\u003etty = current-\u003esignal-\u003etty;\n            set_task_pgrp(p, task_pgrp_nr(current));\n            set_task_session(p, task_session_nr(current));\n            attach_pid(p, PIDTYPE_PGID, task_pgrp(current));\n            attach_pid(p, PIDTYPE_SID, task_session(current));\n            list_add_tail_rcu(\u0026#x26;p-\u003etasks, \u0026#x26;init_task.tasks);\n            __get_cpu_var(process_counts)++;\n        }\n        attach_pid(p, PIDTYPE_PID, pid);\n        nr_threads++;\n    }\n\n    total_forks++;\n    spin_unlock(\u0026#x26;current-\u003esighand-\u003esiglock);\n    write_unlock_irq(\u0026#x26;tasklist_lock);\n    proc_fork_connector(p);\n    cgroup_post_fork(p);\n    return p;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e根据入参配置的 \u003ccode\u003eflags\u003c/code\u003e ，\u003ccode\u003ecopy_process\u003c/code\u003e 确定了新任务与父任务共享的状态，以及一些需要拷贝的状态。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efork\u003c/code\u003e 产生一个新的任务，与父任务不存在任何资源共享的情况。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eclone\u003c/code\u003e 可高度定制化的系统调用，几乎可以自由组合定制新的任务\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evfork\u003c/code\u003e 历史原因而存在的系统调用，设计目的在于一般 \u003ccode\u003efork\u003c/code\u003e 之后都将调用 \u003ccode\u003eexecve\u003c/code\u003e 来执行全新的任务，也就导致了 \u003ccode\u003efork\u003c/code\u003e 所做的拷贝全部白费，因此搞了个轻量级的 \u003ccode\u003evfork\u003c/code\u003e 来避免做内存的拷贝。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eVFORK\u003c/strong\u003e\nHistoric description\nUnder Linux, fork(2) is implemented using copy-on-write pages, so the only penalty incurred by fork(2) is the time and memory required to duplicate the  parent's page tables, and to create a unique task structure for the child.  However, in the bad old days a fork(2) would require making a complete copy of the caller's data space, often needlessly, since usually immediately afterward an exec(3) is done.  Thus, for greater efficiency, BSD introduced  the  vfork() system call, which did not fully copy the address space of the parent process, but borrowed the parent's memory and thread of control until a call to execve(2) or an exit occurred.  The parent process was suspended while the child was using its resources.   The  use  of vfork() was tricky: for example, not modifying data in the parent process depended on knowing which variables were held in a register.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003epid, tgid\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* 分配新的 pid */\np-\u003epid = pid_nr(pid);\n/* thread group id = new pid */\np-\u003etgid = p-\u003epid;\n/* 如果标志是 CLONE_THREAD，tgid = 父任务id */\nif (clone_flags \u0026#x26; CLONE_THREAD)\n    p-\u003etgid = current-\u003etgid;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epid\u003c/code\u003e 作为每个 \u003ccode\u003etask\u003c/code\u003e 的唯一标识符存在。\u003ccode\u003etgid\u003c/code\u003e 用于指代线程组id，从代码上看也就是进程主线程id。（请原谅我又用了进程/线程的表述）\u003c/p\u003e\n\u003cp\u003e看着没有问题？当然不可能。这段代码可是意味着 \u003ccode\u003epid\u003c/code\u003e 唯一啊，这可不符合日常表述啊。对于系统的终端用户来讲，一个进程可以有一个或多个线程。\u003ccode\u003epid\u003c/code\u003e 可是一直被翻译成进程ID(process id)。难道？\u003c/p\u003e\n\u003cp\u003e这就是本质实现与表面功夫的差别啦。\u003ccode\u003epid_t getpid(void);\u003c/code\u003e, \u003ccode\u003epid_t gettid(void);\u003c/code\u003e 两个系统调用分别被用来提供进程ID和线程ID（请仔细思考下代码实现和对外展示的差距）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/**\n * sys_getpid - return the thread group id of the current process\n *\n * Note, despite the name, this returns the tgid not the pid.  The tgid and\n * the pid are identical unless CLONE_THREAD was specified on clone() in\n * which case the tgid is the same in all threads of the same group.\n *\n * This is SMP safe as current-\u003etgid does not change.\n */\nasmlinkage long sys_getpid(void)\n{\n    return task_tgid_vnr(current);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* Thread ID - the internal kernel \"pid\" */\nasmlinkage long sys_gettid(void)\n{\n    return task_pid_vnr(current);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样就好懂多了吧。用户态通过系统调用取到的 \u003ccode\u003epid\u003c/code\u003e, \u003ccode\u003etid\u003c/code\u003e 已经经过了一层加工，分别映射着内核实现的 \u003ccode\u003etgid\u003c/code\u003e, \u003ccode\u003epid\u003c/code\u003e 。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e额外地：想通过 \u003ccode\u003eps\u003c/code\u003e 查看进程/线程可以使用 \u003ccode\u003eps -eLf\u003c/code\u003e\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003eschedule\u003c/h2\u003e\n\u003cp\u003e再来回顾下任务调度是如何实现的。与\u003ca href=\"https://www.ffutop.com/2018-10-12-understand-Kernel-4/\"\u003e第四篇 任务调度\u003c/a\u003e描述的并无太大不同。要说最大的区分，就是早期版本与时下版本顺时的演进。当然，还有就是多核CPU下的SMP调度。\u003c/p\u003e\n\u003cp\u003e至于多核下的所谓进程/线程如何调度。内核根本认识不到进程/线程的概念，唯一的只有任务(task, or COE)。而每个用户所认为的线程在内核的认识下也是一个任务。因此，所谓用户认识到的多线程并发执行在多核CPU下也就完全是可行的。\u003c/p\u003e\n\u003ch2\u003econcept of Thread\u003c/h2\u003e\n\u003cp\u003e且不论Linux内核没有线程概念的前提，线程的定义总是存在的，而满足其定义的实现，也就可以被称为“线程”。哪些要素组成了线程呢？\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e线程是与其它代码共享进程地址空间的最小执行流\u003c/li\u003e\n\u003cli\u003e诸如栈、寄存器信息、本地线程数据需要保持独立\u003c/li\u003e\n\u003cli\u003e互斥锁(Mutex)、条件变量(Condition Variable)、线程间同步管理的支持\u003c/li\u003e\n\u003cli\u003e...\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e既然都说了Linux内核没有线程概念，现在却又开始提，这不是打脸嘛？OK，具体情况是：内核本身不支持线程，甚至没有线程概念。但其通过GLIBC的NPTL(Native POSIX Thread Library)支持了线程。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在Linux内核2.6出现之前任务是(最小)可调度的对象，当时的Linux不真正支持线程。但是Linux内核有一个系统调用指令\u003ccode\u003eclone()\u003c/code\u003e，这个指令将产生一个调用方任务的拷贝，而且这个拷贝可以与原任务使用同一地址空间。LinuxThreads计划使用这个系统调用来提供一个内核级别的线程支持。但是这个解决方法与真正的POSIX标准有一些不兼容的地方，尤其是在信号处理、进程调度和进程间同步原语方面。\n\u003cem\u003eCopied From \u003ca href=\"https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library\"\u003eWikipedia NPTL\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNc79ly1g1x9mjuahnj31400u0doi.jpg\" alt=\"Linux 架构\"\u003e\u003c/p\u003e\n\u003ch2\u003eThread Model\u003c/h2\u003e\n\u003cp\u003e最后，聊聊线程模型。相信各位不管懂或不懂，至少都听说过 1:1, N:1, M:N 线程模型。至于究竟这些模型是怎么回事呢？且看：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNc79ly1g1xhulou5bj30go08zglv.jpg\" alt=\"Thread Model\"\u003e\u003c/p\u003e\n\u003ch3\u003e1:1 Model\u003c/h3\u003e\n\u003cp\u003e最简单的线程模型，也是内核通过NPTL最容易实现的一种模型。每个通过 \u003ccode\u003eclone\u003c/code\u003e 产生的新任务（当然，至少要符合共享内存等线程定义）对应用程序来说就是一个新线程。所谓的用户级线程和内核级线程，在 1:1 模型中就是同一个任务，只是新任务在被内核 \u003ccode\u003eclone\u003c/code\u003e 之后，又由NPTL做了进一步的管理，因此在形式上看似有用户级/内核级之分。\u003c/p\u003e\n\u003ch3\u003eN:1 Model\u003c/h3\u003e\n\u003cp\u003eN:1 线程模型又称为“用户级线程模型”。在这种模型下，线程的概念由用户态代码进行支持，包括用来管理线程的用户空间调度器以及以非阻塞模式捕捉和处理I/O机制。使用N:1模型的好处在于其上下文切换的代价几乎为零，毕竟这是纯用户态的。当然，缺点也比较明显：由于对内核来说，认为这只是单个任务，也就无法充分利用多核CPU的特性。\u003c/p\u003e\n\u003ch3\u003eM:N Model\u003c/h3\u003e\n\u003cp\u003e有没有方式整合1:1模型和N:1模型，让内核意识到有几个任务，但又存在更多的线程在用户级执行呢？当然也是可行，但如何协调调度又是费事费力的实现了。\u003c/p\u003e\n\u003ch2\u003eThreads vs Events\u003c/h2\u003e\n\u003cp\u003e线程怎么又和事件扯上关系了呢？先来回顾下任务调度的几种模式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e串行，每个任务依次执行，不存在任务调度\u003c/li\u003e\n\u003cli\u003e抢占式，通过时钟中断决定是否切换任务\u003c/li\u003e\n\u003cli\u003e协作式，只有当任务主动放弃对CPU的占用，才能轮到下一个任务。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e对于用户级线程来说，内核无法意识到这些线程的存在，硬件发起的所有中断又都被内核捕获。因此，想要实现抢占式是不可能完成的任务（至少以本人目前所知是不可能的）。故协作式线程调度是用户级线程的唯一选择。而协作式就意味着是由线程硬编码主动放弃任务执行（\u003ccode\u003eyield\u003c/code\u003e / \u003ccode\u003eschedule\u003c/code\u003e / etc.）。如此这般，与事件驱动下，不同代码片之间的调度又是何其相似。当然，只是开个玩笑，如果都一样了，直接用事件驱动不就OK了。线程之所以是线程，有其独特的定义在。不过不再细说，可以参考 \u003ca href=\"http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/Threads-VS-Events.pdf\"\u003eThreads vs Events\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e[1]. Mauerer W. Professional Linux kernel architecture[M]. John Wiley \u0026#x26; Sons, 2010.\n[2]. \u003ca href=\"http://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html\"\u003eLinus Torvalds. Re: proc fs and shared pids\u003c/a\u003e[EL/OL]. Aug 6th, 1996.\n[3]. \u003ca href=\"https://randu.org/tutorials/threads/\"\u003eMultithreaded Programming (POSIX pthreads Tutorial)\u003c/a\u003e[EL/OL].\n[4]. \u003ca href=\"https://blog.csdn.net/u012432778/article/details/47378321\"\u003e线程模型\u003c/a\u003e[EL/OL].\n[5]. \u003ca href=\"https://www.evanjones.ca/software/threading.html\"\u003eImplementing a Thread Library on Linux\u003c/a\u003e[EL/OL]. Dec 10th, 2003.\u003c/p\u003e\n\u003ch2\u003e用户级线程资料参考\u003c/h2\u003e\n\u003cp\u003e[1]. \u003ccode\u003eman makecontext\u003c/code\u003e \u0026#x26; \u003ccode\u003eman swapcontext\u003c/code\u003e\n[2]. \u003ca href=\"https://github.com/brianwatling/libfiber\"\u003eLibfiber\u003c/a\u003e\n[3]. \u003ca href=\"https://github.com/dramesh/GTThreads\"\u003e\u003cstrong\u003e所谓的\u003c/strong\u003e抢占式用户线程实现\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e在进行\u003ca href=\"https://www.ffutop.com/2018-10-12-understand-Kernel-4/\"\u003e第四篇(任务调度)\u003c/a\u003e行文描述时，就一直闹不清内核所谓的\u003ccode\u003etask\u003c/code\u003e的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：\u003cstrong\u003e我们错误地将理论和实践不加区分地混淆了\u003c/strong\u003e。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，\u003ccode\u003etask\u003c/code\u003e 也就是 \u003ccode\u003eContext of Execution\u003c/code\u003e 概念在实现上的表征。\u003c/p\u003e"},{"url":"2019-03-25-mem-dump","fileName":"2019-03-25-mem-dump.md","title":"如何获取运行时进程堆栈","author":"fangfeng","date":"2019-03-25T00:00:00.000Z","tags":["Kernel","Linux","dump"],"content":"\u003cp\u003e前些天看了关于在密码学应用中使用\u003ccode\u003ejava.lang.String\u003c/code\u003e与\u003ccode\u003ebyte[]\u003c/code\u003e的相关讨论，不推荐使用\u003ccode\u003ejava.lang.String\u003c/code\u003e的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。\u003c/p\u003e\n\u003ch2\u003e/proc/${pid}/maps\u003c/h2\u003e\n\u003cp\u003e首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从\u003ccode\u003e/proc\u003c/code\u003e虚拟文件系统中，提供了进程虚拟地址映射。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaddress                   perm offset   dev   inode                      pathname\n556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run\n556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run\n556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run\n55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]\n7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0\n7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0\n7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0\n7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]\n7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]\n7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]\nffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e/proc/${pid}/maps\u003c/code\u003e 记录了当前进程虚拟内存区域的分配以及其访问控制。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e前三行表述的是当前进程ELF文件在虚拟内存中的地址（这里使用的ELF文件名为 \u003ccode\u003erun\u003c/code\u003e ）\u003cul\u003e\n\u003cli\u003e第一行 \u003ccode\u003er-xp\u003c/code\u003e 表示其将配合\u003ccode\u003eCode Segment Register (CS)\u003c/code\u003e 作为CPU执行指令的直接依据。\u003c/li\u003e\n\u003cli\u003e第二三行分别用作可读、可写数据区，将配合 \u003ccode\u003eData Segment Register (DS), ES, FS, GS\u003c/code\u003e 等使用\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e第四行直截了当，就是分配给堆的地址空间。当然，如果不够，可以不断地向上扩张。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003exxx.so\u003c/code\u003e 文件描述的是C共享库在虚拟内存中的地址。\u003c/li\u003e\n\u003cli\u003e最后才是栈内存，将以倒序的方式下内存低地址扩张。\u003c/li\u003e\n\u003cli\u003e至于之后的内容，不了解，不表。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eptrace\u003c/h2\u003e\n\u003cp\u003e拿到了进程虚拟内存分布，又如何获取其中的内容。\u003ccode\u003eptrace\u003c/code\u003e 总算是派上用场了。之前在阅读内核源码的时候，任务数据结构 \u003ccode\u003estruct task\u003c/code\u003e 专门为此预留了一些字段来加以描述，但始终找不到其用途。现在总算对其有了初步的了解。\u003c/p\u003e\n\u003cp\u003e一般来说，进程彼此之间应该相互独立，虽然运行在同一台机器上，但应该是相互间不知道其他进程的存在。那又如何能够通过一个进程的代码来获取另一个进程的堆栈数据呢？\u003ccode\u003eptrace\u003c/code\u003e 提供的就是这么一种可能性。通过 \u003ccode\u003ePTRACE_ATTACH\u003c/code\u003e 和 \u003ccode\u003ePTRACE_DETACH\u003c/code\u003e，A进程会使得目标进程B陷入Sleeping状态，而等待A继续通过其他命令来获取其数据。至于为什么会是陷入Sleeping呢？一旦B进程的在运行，数据等随时可能改变，显然不适合读取数据啊。\u003c/p\u003e\n\u003cp\u003e如何读取？\u003ccode\u003ePTRACE_PEEKTEXT\u003c/code\u003e 就是这样一个实现进程间交互的好工具。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid attach()\n{\n    if (ptrace(PTRACE_ATTACH, options.pid, NULL, NULL) == -1)\n    {\n        fprintf(stderr, \"ptract attach failed. %s(errno: %d)\\n\", strerror(errno), errno);\n        exit(0);\n    }\n    fprintf(stderr, \"attach to %d success!\\n\", options.pid);\n    wait(NULL);\n}\n\nvoid peek()\n{\n    char maps[17];\n    sprintf(maps, \"/proc/%d/maps\", options.pid);\n    FILE *fd = fopen(maps, \"r\");\n    if (fd == NULL)\n    {\n        fprintf(stderr, \"open /proc/%d/maps failed. %s(errno: %d)\\n\", strerror(errno), errno);\n        exit(0);\n    }\n\n    struct map *map = (struct map *) malloc(sizeof(struct map *));\n\n    long word;\n    while (fscanf(fd, \"%llx-%llx %s %lx %*s %*s%*[^\\n]\", \u0026#x26;map-\u003estart_addr, \u0026#x26;map-\u003eend_addr, map-\u003eop_flag, \u0026#x26;map-\u003eoffset) != EOF)\n    {\n        if (map-\u003eop_flag[0] == '-')\n            continue;\n        fprintf(stderr, \"peek from [%llx-%llx]\\n\", map-\u003estart_addr, map-\u003eend_addr);\n        long mem_len = map-\u003eend_addr - map-\u003estart_addr;\n        char *data = malloc(mem_len + 1);\n        for (long cursor = map-\u003estart_addr;cursor \u0026#x3C; map-\u003eend_addr;cursor += sizeof(long))\n        {\n            if ((word = ptrace(PTRACE_PEEKTEXT, options.pid, cursor, NULL)) == -1 \u0026#x26;\u0026#x26; errno)\n            {\n                fprintf(stderr, \"peek failed. %s(errno: %d)\\n\", strerror(errno), errno);\n                free(data);\n                exit(0);\n            }\n            memcpy(data+cursor-map-\u003estart_addr, \u0026#x26;word, sizeof(word));\n        }\n        dump(data, mem_len);\n\n        free(data);\n    }\n\n    free(map);\n}\n\nvoid detach()\n{\n    if (ptrace(PTRACE_DETACH, options.pid, NULL, NULL) == -1)\n    {\n        fprintf(\"ptract detach failed. %s(errno: %d)\\n\", strerror(errno), errno);\n        exit(0);\n    }\n    fprintf(stderr, \"detach from %d success!\", options.pid);\n}\n\nint main(int argc, char **argv)\n{\n    // ...\n\n    attach();\n    peek();\n    detach();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e此处的代码片段就能完成dump堆栈的工作了（当然，由于没有对其它内容进行处理，同时会dump下ELF数据等）。\u003ca href=\"https://github.com/DorMOUSE-None/ffDump\"\u003e完整代码\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e小结\u003c/h2\u003e\n\u003cp\u003e当然，之后才发现 GDB 的实现借用的也正是这样一套机制。同时也意味着上面这段代码的实现在 GDB 中有现成的工具了:\u0026#x3C;\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e前些天看了关于在密码学应用中使用\u003ccode\u003ejava.lang.String\u003c/code\u003e与\u003ccode\u003ebyte[]\u003c/code\u003e的相关讨论，不推荐使用\u003ccode\u003ejava.lang.String\u003c/code\u003e的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。\u003c/p\u003e\n\u003ch2\u003e/proc/${pid}/maps\u003c/h2\u003e\n\u003cp\u003e首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从\u003ccode\u003e/proc\u003c/code\u003e虚拟文件系统中，提供了进程虚拟地址映射。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaddress                   perm offset   dev   inode                      pathname\n556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run\n556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run\n556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run\n55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]\n7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0\n7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0\n7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0\n7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]\n7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]\n7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]\nffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\n\u003c/code\u003e\u003c/pre\u003e"},{"url":"2019-03-19-JANUS","fileName":"2019-03-19-JANUS.md","title":"认证与授权·简述","author":"fangfeng","date":"2019-03-19T00:00:00.000Z","tags":["Authenticate","Authorize"],"content":"\u003ch2\u003e概述\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在大多数系统中，都或多或少需要认证授权模型/系统的支持。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e认证/授权是什么？最简单的，我们的系统要求用户必须在“登录”之后才允许进行一些操作。“登录”的过程就是认证；而区别与未登录状态，只允许登录用户进行一些操作，这就是授权。认证与授权相互独立，有协同配合，共同支撑起系统对安全的基本要求。\u003c/p\u003e\n\u003ch2\u003e认证与授权\u003c/h2\u003e\n\u003cp\u003e认证的目的在于认出用户。日常生活中，我们通过视觉、声音等因素认出一个人。但是就网络应用而言，应用最多只能够认识到发起请求的浏览器、手机APP、物联网设备等用户代理(User Agent)，也无法直接地将用户与用户代理进行绑定。因此，向应用证明操作这些用户代理的实体就成了至关重要的步骤。你需要通过密码、手机验证码、人脸识别或其它形式凭证来完成“登录”操作，即认证。\u003c/p\u003e\n\u003cp\u003e当然了，我们也认识到，不是所有的操作都需要一个这般复制“登录”流程的，即使这些操作逻辑上也需要认出背后的用户是谁。这部分所使用到的技术就是“会话管理”了。在一定的有效期范围内，用户无需重复证明自己的身份，而用户-应用间保持最基本的信任。当然，一般来说，修改密码等危险操作还是需要再次进行认证。\u003c/p\u003e\n\u003cp\u003e总而言之，无论是“登录”认证抑或是“会话”认证，其目的都是为了认出用户。\u003c/p\u003e\n\u003cp\u003e完成认证之后，就要启用授权了。授权负责的是控制用户能干什么。管理员和普通员工所能进行的操作肯定是有所差别的。借助于前置认证提供用户身份信息，授权将对用户的操作进行决断。\u003c/p\u003e\n\u003ch2\u003e访问控制（权限控制）\u003c/h2\u003e\n\u003cp\u003e授权旨在界定用户能够进行哪些操作，而访问控制正是进行授权界定的措施、手段。该如何实施访问控制呢？看人下菜是最简单、最容易被接受的方式——为每个用户独立地分配权限。但是，就Web应用而言，如此行事的代价将是及其巨大的。动辄几十万、上百万...的用户量，又如何维护得起这般细致的控制呢。而且，每个用户独立设置权限，同时也意味着每个权限需要直接对接百十万的用户。\u003c/p\u003e\n\u003cp\u003e撇开可行性，访问控制做的就是这种活计——控制主体（用户）对客体（系统、API等）的操作。\u003c/p\u003e\n\u003cp\u003e主要的访问控制技术分为三类：自主访问控制、强制访问控制、基于角色的访问控制\u003c/p\u003e\n\u003ch3\u003e自主访问控制(Discretionary Access Control，DAC)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e每个客体都独立维护一张访问控制表(Access Control List, ACL)\u003c/li\u003e\n\u003cli\u003e每个客体都有一个所有者\u003c/li\u003e\n\u003cli\u003e所有者可以将其负责的客体访问权限分配给其它用户\u003c/li\u003e\n\u003cli\u003e每次主体对客体的访问都面向ACL做确认后执行\u003c/li\u003e\n\u003cli\u003e强依赖于所有者对安全要求的认知\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e强制访问控制(Mandatory Access Control, MAC)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e预置相应的密级，例如绝密级、机密级和普通级。密级有强弱关系\u003c/li\u003e\n\u003cli\u003e每个主体/客体都分配一个密级\u003c/li\u003e\n\u003cli\u003e每次主体对客体的操作，判定主体密级 \u003e= 客体密级即允许访问\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e基于角色的访问控制(Role-Based Access Control, RBAC)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e角色作为一系列有较强相关性权限的持有者\u003c/li\u003e\n\u003cli\u003e用户通过被分配一系列角色，从而间接地拥有权限集\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003e一般来说，DAC、MAC都不太适合于Web应用的访问控制。因此，后续的讨论都将基于RBAC进行。\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003e控制粒度\u003c/h2\u003e\n\u003cp\u003e如何定义一个客体，就涉及到控制粒度了。就Web应用而言，比较粗略的有数据粒度、方法粒度、URL粒度、系统粒度等等。任意粒度，都可以作为访问控制的组成部分，作为授权的一部分。但是，粒度的控制也会导致一些相当致命的问题。\u003c/p\u003e\n\u003cp\u003e越权问题就是一种粒度控制下的问题。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e纵向访问控制\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e顾名思义，纵向访问控制所控制的权限拥有一定的优先级概念，例如管理员操作与普通用户操作。特别适合于使用强制访问控制的解决方案，使用RBAC也并不困难，基本上只要定义两类角色也能解决。业内对于这类问题的解决方案相当成熟，需要的只是根据不同的业务场景进行适配。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e横向访问控制\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e对于横向访问控制，问题就不再那么的简单。在方法粒度下的RBAC模型，很容易就会导致A用户事实上访问了B用户数据的问题发生，也就是横向越权。而想要实现数据粒度的通用模型，却又不可避免地将对业务代码进行侵入。\u003c/p\u003e\n\u003cp\u003e控制粒度的取舍，就很大程度上取决于Web应用的实际需求。\u003c/p\u003e\n\u003ch2\u003e小结\u003c/h2\u003e\n\u003cp\u003e认证、授权的基本目的在于满足对安全的基本要求，其涉及的知识相当广泛。本篇的目的，仅仅在于阐释认证、授权两个术语的基本定义，并对访问控制技术做概要式的介绍。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e概述\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在大多数系统中，都或多或少需要认证授权模型/系统的支持。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e认证/授权是什么？最简单的，我们的系统要求用户必须在“登录”之后才允许进行一些操作。“登录”的过程就是认证；而区别与未登录状态，只允许登录用户进行一些操作，这就是授权。认证与授权相互独立，有协同配合，共同支撑起系统对安全的基本要求。\u003c/p\u003e"},{"url":"2019-03-05-understand-Kernel-9","fileName":"2019-03-05-understand-Kernel-9.md","title":"理解 Linux Kernel (9) - IO Multiplexing","author":"fangfeng","date":"2019-03-05T00:00:00.000Z","tags":["Linux","Kernel","IO Model"],"content":"\u003cp\u003e\u003ca href=\"./2019-01-15-understand-Kernel-8/\"\u003e前一篇\u003c/a\u003e已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 \u003ccode\u003estruct sock\u003c/code\u003e 对象，将其逐级从网络接口层逐级提升到网络层、传输层...最终添加到接收队列 \u003ccode\u003esk_receive_queue\u003c/code\u003e 中；用户进程通过 \u003ccode\u003eread\u003c/code\u003e、\u003ccode\u003erecv\u003c/code\u003e、\u003ccode\u003erecvfrom\u003c/code\u003e 等命令检查并获取 \u003ccode\u003esk_receive_queue\u003c/code\u003e 中的数据。\u003c/p\u003e\n\u003cp\u003e整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。\u003c/p\u003e\n\u003cp\u003e那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（\u003ccode\u003eselect\u003c/code\u003e, \u003ccode\u003epoll\u003c/code\u003e, \u003ccode\u003eepoll\u003c/code\u003e）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 \u003ccode\u003eselect\u003c/code\u003e 和 \u003ccode\u003eepoll\u003c/code\u003e 两类系统调用的实现进行探究。\u003c/p\u003e\n\u003ch2\u003eSELECT\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eselect\u003c/code\u003e 是一种比较古老的系统调用方式，存在着许多的调用限制。当然，相对的也就比较容易理解。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eselect\u003c/code\u003e 系统调用最初的逻辑就是对超时时间的相关操作，完成从用户数据段到内核数据段的数据拷贝工作，而使用 \u003ccode\u003ecopy_from_user\u003c/code\u003e 的目的，虽然看似比较晦涩，不如大家在用户程序中普通调用的memcpy，但究其原因，是为了处理MMU相关的问题。将内核复制的数据timeval做一定的取整操作（因为硬件中断的精度可能达不到timeval所描述的粒度，故根据HZ做取整，恰好为时钟中断周期的整数倍）。调用 \u003ccode\u003ecore_sys_select\u003c/code\u003e 进行真正的轮询操作（当然，好像也算不上真正的逻辑，还有一层核心的调用呢）。结束后的操作当然是准备更新timeval。因为进行轮询的结果有两种，一种是因为超时而结束 \u003ccode\u003ecore_sys_select\u003c/code\u003e 函数调用；另一种是得到了一个或多个准备就绪的数据，才结束调用并返回。显然，因为第二种结果而更新timeval有着一定的实际意义——到底等待了多久。不过这里需要注意的是，不是所有的Linux系统都支持对timeval做更新。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage long sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n            fd_set __user *exp, struct timeval __user *tvp)\n{\n    s64 timeout = -1;\n    struct timeval tv;\n    int ret;\n\n    /* 如果设置了超时时间 */\n    if (tvp) {\n        if (copy_from_user(\u0026#x26;tv, tvp, sizeof(tv)))\n            return -EFAULT;\n\n        /* 计时器不能设置为负数 */\n        if (tv.tv_sec \u0026#x3C; 0 || tv.tv_usec \u0026#x3C; 0)\n            return -EINVAL;\n\n        /* Cast to u64 to make GCC stop complaining */\n        /* 对 timeout 做一定的处理，根据时钟周期对 usec 进行取整 */\n        if ((u64)tv.tv_sec \u003e= (u64)MAX_INT64_SECONDS)\n            timeout = -1;   /* 无限等待 */\n        else {\n            timeout = DIV_ROUND_UP(tv.tv_usec, USEC_PER_SEC/HZ);\n            timeout += tv.tv_sec * HZ;\n        }\n    }\n\n    /* 核心的 select 实现逻辑 */\n    ret = core_sys_select(n, inp, outp, exp, \u0026#x26;timeout);\n\n    /* 如果设置了超时时间 */\n    if (tvp) {\n        struct timeval rtv;\n\n        if (current-\u003epersonality \u0026#x26; STICKY_TIMEOUTS)\n            goto sticky;\n        rtv.tv_usec = jiffies_to_usecs(do_div((*(u64*)\u0026#x26;timeout), HZ));\n        rtv.tv_sec = timeout;\n        if (timeval_compare(\u0026#x26;rtv, \u0026#x26;tv) \u003e= 0)\n            rtv = tv;\n        /* 内核数据-\u003e用户数据的拷贝，更新距离超时剩余的时间间隔 */\n        if (copy_to_user(tvp, \u0026#x26;rtv, sizeof(rtv))) {\nsticky:\n            /*\n             * 如果应用程序把timeval放在只读内存中，内核就无需特别的更新它\n             * If an application puts its timeval in read-only\n             * memory, we don't want the Linux-specific update to\n             * the timeval to cause a fault after the select has\n             * completed successfully. However, because we're not\n             * updating the timeval, we can't restart the system\n             * call.\n             */\n            if (ret == -ERESTARTNOHAND)\n                ret = -EINTR;\n        }\n    }\n\n    return ret;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecore_sys_select\u003c/code\u003e 也没有太多核心操作，完全是在为三个位图——输入、输出、错误从用户数据段到内核数据段的拷贝工作，以及在结束 \u003ccode\u003edo_select\u003c/code\u003e 调用后的反向拷贝操作。不过，无论是 \u003ccode\u003esys_select\u003c/code\u003e 还是 \u003ccode\u003ecore_sys_select\u003c/code\u003e 都将各自需要完成的工作分割得非常清晰，一个完成timeval的处理工作，另一个完成位图的处理。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/*\n * 内核数据-位图的准备，调用do_select完成核心的逻辑\n */\nstatic int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n               fd_set __user *exp, s64 *timeout)\n{\n    fd_set_bits fds;\n    void *bits;\n    int ret, max_fds;\n    unsigned int size;\n    struct fdtable *fdt;\n    /*\n     * 在栈中定义较小的数组，减少堆内存的占用，同时可以更快；\n     * SELECT_STACK_ALLOC = 256\n     */\n    long stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n    ret = -EINVAL;\n    if (n \u0026#x3C; 0)\n        goto out_nofds;\n\n    /* max_fds can increase, so grab it once to avoid race */\n    /* max_fds 可能同时在增加，所以提前获取一份固定的拷贝避免竞争 */\n    rcu_read_lock();\n    /* 获取当前任务的文件描述符表 */\n    fdt = files_fdtable(current-\u003efiles);\n    max_fds = fdt-\u003emax_fds;\n    rcu_read_unlock();\n    if (n \u003e max_fds)\n        n = max_fds;\n\n    /*\n     * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n     * since we used fdset we need to allocate memory in units of\n     * long-words.\n     */\n    size = FDS_BYTES(n);\n    bits = stack_fds;\n    if (size \u003e sizeof(stack_fds) / 6) {\n        /* Not enough space in on-stack array; must use kmalloc */\n        /* 栈数组大小不足；使用 kmalloc 获取新的空间 */\n        ret = -ENOMEM;\n        bits = kmalloc(6 * size, GFP_KERNEL);\n        if (!bits)\n            goto out_nofds;\n    }\n    fds.in      = bits;\n    fds.out     = bits +   size;\n    fds.ex      = bits + 2*size;\n    fds.res_in  = bits + 3*size;\n    fds.res_out = bits + 4*size;\n    fds.res_ex  = bits + 5*size;\n\n    /* 用户数据段的数据 inp、outp、exp 往内核数据段 fds.xxx 拷贝 */\n    if ((ret = get_fd_set(n, inp, fds.in)) ||\n        (ret = get_fd_set(n, outp, fds.out)) ||\n        (ret = get_fd_set(n, exp, fds.ex)))\n        goto out;\n    /* fds.res_xxx 作为 do_select 的执行结果，预置为0，表示每一位相应的fd都未准备就绪 */\n    zero_fd_set(n, fds.res_in);\n    zero_fd_set(n, fds.res_out);\n    zero_fd_set(n, fds.res_ex);\n\n    /* 交由 do_select 完成真正核心的操作 */\n    ret = do_select(n, \u0026#x26;fds, timeout);\n\n    if (ret \u0026#x3C; 0)\n        goto out;\n    if (!ret) {\n        ret = -ERESTARTNOHAND;\n        if (signal_pending(current))\n            goto out;\n        ret = 0;\n    }\n\n    /* 将结果集拷贝回用户数据段的 inp、outp、exp 中 */\n    if (set_fd_set(n, inp, fds.res_in) ||\n        set_fd_set(n, outp, fds.res_out) ||\n        set_fd_set(n, exp, fds.res_ex))\n        ret = -EFAULT;\n\nout:\n    if (bits != stack_fds)\n        kfree(bits);\nout_nofds:\n    return ret;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e终于是核心的逻辑了，逐一地将当前任务挂到相应文件的等待队列上，并等待调用 \u003ccode\u003epoll\u003c/code\u003e 函数被唤醒\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint do_select(int n, fd_set_bits *fds, s64 *timeout)\n{\n    struct poll_wqueues table;\n    poll_table *wait;\n    int retval, i;\n\n    rcu_read_lock();\n    /* 确认fds.xxx所需轮询的fd全部全部处于打开状态，同时返回最大的fd */\n    retval = max_select_fd(n, fds);\n    rcu_read_unlock();\n\n    if (retval \u0026#x3C; 0)\n        return retval;\n    n = retval;\n\n    /* 把当前任务放入自己的等待队列中 */\n    poll_initwait(\u0026#x26;table);\n    wait = \u0026#x26;table.pt;\n    /* 如果超时时间为0，即无需等待 */\n    if (!*timeout)\n        wait = NULL;\n    retval = 0;\n    /* 无限循环 */\n    for (;;) {\n        unsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n        long __timeout;\n\n        set_current_state(TASK_INTERRUPTIBLE);\n\n        inp = fds-\u003ein; outp = fds-\u003eout; exp = fds-\u003eex;\n        rinp = fds-\u003eres_in; routp = fds-\u003eres_out; rexp = fds-\u003eres_ex;\n\n        for (i = 0; i \u0026#x3C; n; ++rinp, ++routp, ++rexp) {\n            unsigned long in, out, ex, all_bits, bit = 1, mask, j;\n            unsigned long res_in = 0, res_out = 0, res_ex = 0;\n            const struct file_operations *f_op = NULL;\n            struct file *file = NULL;\n\n            in = *inp++; out = *outp++; ex = *exp++;\n            all_bits = in | out | ex;\n            if (all_bits == 0) {\n                i += __NFDBITS;\n                continue;\n            }\n\n            /* 对 unsigned long 的每一位进行确认 */\n            for (j = 0; j \u0026#x3C; __NFDBITS; ++j, ++i, bit \u0026#x3C;\u0026#x3C;= 1) {\n                int fput_needed;\n                /* 超过需检测的最大的文件描述符 */\n                if (i \u003e= n)\n                    break;\n                /* 该 fd 无需检测，直接下一个 */\n                if (!(bit \u0026#x26; all_bits))\n                    continue;\n                /* 获取相应的文件实例 */\n                file = fget_light(i, \u0026#x26;fput_needed);\n                if (file) {\n                    f_op = file-\u003ef_op;\n                    mask = DEFAULT_POLLMASK;\n                    /* 对于套接字，调用的是sock_poll，在poll成功时将唤醒wait队列的任务（即把当前任务唤醒）*/\n                    if (f_op \u0026#x26;\u0026#x26; f_op-\u003epoll)\n                        mask = (*f_op-\u003epoll)(file, retval ? NULL : wait);\n                    fput_light(file, fput_needed);\n                    if ((mask \u0026#x26; POLLIN_SET) \u0026#x26;\u0026#x26; (in \u0026#x26; bit)) {\n                        res_in |= bit;\n                        retval++;\n                    }\n                    if ((mask \u0026#x26; POLLOUT_SET) \u0026#x26;\u0026#x26; (out \u0026#x26; bit)) {\n                        res_out |= bit;\n                        retval++;\n                    }\n                    if ((mask \u0026#x26; POLLEX_SET) \u0026#x26;\u0026#x26; (ex \u0026#x26; bit)) {\n                        res_ex |= bit;\n                        retval++;\n                    }\n                }\n                /* 主动让出CPU片，等待重新调度（提前设置了最高优先级PREEMPT_ACTIVE）*/\n                cond_resched();\n            }\n            if (res_in)\n                *rinp = res_in;\n            if (res_out)\n                *routp = res_out;\n            if (res_ex)\n                *rexp = res_ex;\n        }\n        wait = NULL;\n        if (retval || !*timeout || signal_pending(current))\n            break;\n        if(table.error) {\n            retval = table.error;\n            break;\n        }\n\n        if (*timeout \u0026#x3C; 0) {\n            /* Wait indefinitely */\n            __timeout = MAX_SCHEDULE_TIMEOUT;\n        } else if (unlikely(*timeout \u003e= (s64)MAX_SCHEDULE_TIMEOUT - 1)) {\n            /* Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in a loop */\n            __timeout = MAX_SCHEDULE_TIMEOUT - 1;\n            *timeout -= __timeout;\n        } else {\n            __timeout = *timeout;\n            *timeout = 0;\n        }\n        /* 进入延时唤醒状态，待定预定的超时时间 */\n        __timeout = schedule_timeout(__timeout);\n        if (*timeout \u003e= 0)\n            *timeout += __timeout;\n    }\n    __set_current_state(TASK_RUNNING);\n\n    poll_freewait(\u0026#x26;table);\n\n    return retval;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e总结来看，\u003ccode\u003eselect\u003c/code\u003e 完全能够支持IO多路复用。至少比用户程序自行实现轮询优秀得多。但是，也存在着一些明显的缺陷：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e支持的文件描述符存在上限，默认是1024。\u003c/li\u003e\n\u003cli\u003e每次陷入内核态 \u003ccode\u003eselect\u003c/code\u003e 函数之后，都需要按位遍历所有的文件描述符（无论该fd是否存在），max(fd)越大，开销越大。\u003c/li\u003e\n\u003cli\u003e每次调用 \u003ccode\u003eselect\u003c/code\u003e 都需要将fd集合从用户态复制到内核态，max(fd)越大，开销越大。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eEPOLL\u003c/h2\u003e\n\u003cp\u003e简单地描述过 \u003ccode\u003eselect\u003c/code\u003e 系统调用之后，我们着重来聊一聊 \u003ccode\u003eepoll\u003c/code\u003e 的实现。毕竟 \u003ccode\u003eselect\u003c/code\u003e 和 \u003ccode\u003epoll\u003c/code\u003e 的复杂度是 \u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eO\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003eN\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eO(N)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003eO\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e，而 \u003ccode\u003eepoll\u003c/code\u003e 只是 \u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eO\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003elog\u003c/mi\u003e\u003cmo\u003e⁡\u003c/mo\u003e\u003cmi\u003eN\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eO(\\log{N})\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003eO\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mop\"\u003elo\u003cspan style=\"margin-right:0.01389em;\"\u003eg\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e （当然，这里对时间复杂度的比较维度不同，稍候细讲）。\u003ccode\u003eepoll\u003c/code\u003e 区别于传统I/O复用模型的最大特色在于：它将创建并维护一个 \u003ccode\u003eeventpoll\u003c/code\u003e 实例，并通过注册请 \u003ccode\u003eepoll\u003c/code\u003e 对新的文件描述符进行监听，这意味着数据从用户数据区到内核数据区的拷贝只有一次；相对的，传统方式在每次轮询时，都需要全量地将数据从用户数据区拷贝到内核数据区。 \u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eepoll_create\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eepoll_create\u003c/code\u003e 负责创建一个新的 \u003ccode\u003eeventpoll\u003c/code\u003e 实例。这里的size并没有实际意义（由于历史原因而存在），传入的参数将被忽略。看源码总是件有意思的事，这个size被描述成了检查精神健全的标志...\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage long sys_epoll_create(int size)\n{\n    int error, fd = -1;\n    struct eventpoll *ep;\n    struct inode *inode;\n    struct file *file;\n\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_create(%d)\\n\",\n             current, size));\n\n    /*\n     * 精神健全检测(size)；同时建立内部数据结构 struct eventpoll\n     */\n    error = -EINVAL;\n    if (size \u0026#x3C;= 0 || (error = ep_alloc(\u0026#x26;ep)) != 0)\n        goto error_return;\n\n    /*\n     * 创建一个新的文件描述符，文件数据结构和i节点\n     */\n    error = anon_inode_getfd(\u0026#x26;fd, \u0026#x26;inode, \u0026#x26;file, \"[eventpoll]\",\n                 \u0026#x26;eventpoll_fops, ep);\n    if (error)\n        goto error_free;\n\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_create(%d) = %d\\n\",\n             current, size, fd));\n\n    return fd;\n\nerror_free:\n    ep_free(ep);\nerror_return:\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_create(%d) = %d\\n\",\n             current, size, error));\n    return error;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcly1g0qi7lrtgzj31eu0u075i.jpg\" alt=\"Epoll Create | Model\"\u003e\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eepoll_ctl\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eepoll_ctl\u003c/code\u003e 顾名思义——\u003ccode\u003eepoll\u003c/code\u003e控制器，用于增加、修改、删除监听的事件。这里 \u003ccode\u003eepfd\u003c/code\u003e 用于找到 \u003ccode\u003eeventpoll\u003c/code\u003e 实例，\u003ccode\u003efd\u003c/code\u003e 表示需要监听的文件描述符，\u003ccode\u003eop\u003c/code\u003e 区分增删改，\u003ccode\u003eevent\u003c/code\u003e 表示监听的具体事件描述。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage long sys_epoll_ctl(int epfd, int op, int fd,\n                  struct epoll_event __user *event)\n{\n    int error;\n    struct file *file, *tfile;\n    struct eventpoll *ep;\n    struct epitem *epi;\n    struct epoll_event epds;\n\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)\\n\",\n             current, epfd, op, fd, event));\n\n    error = -EFAULT;\n    /* 如果是增改操作，需要把事件描述拷贝到内核数据区; 删除操作不需要 */\n    if (ep_op_has_event(op) \u0026#x26;\u0026#x26;\n        copy_from_user(\u0026#x26;epds, event, sizeof(struct epoll_event)))\n        goto error_return;\n\n    /* Get the \"struct file *\" for the eventpoll file */\n    error = -EBADF;\n    file = fget(epfd);\n    if (!file)\n        goto error_return;\n\n    /* Get the \"struct file *\" for the target file */\n    tfile = fget(fd);\n    if (!tfile)\n        goto error_fput;\n\n    /* 需要监听的文件描述符必须支持文件操作 poll */\n    error = -EPERM;\n    if (!tfile-\u003ef_op || !tfile-\u003ef_op-\u003epoll)\n        goto error_tgt_fput;\n\n    /* 需要确保不能把epfd作为被监听的fd加入 */\n    error = -EINVAL;\n    if (file == tfile || !is_file_epoll(file))\n        goto error_tgt_fput;\n\n    /* \n     * 这里的文件描述符一定是指eventpoll实例对应的文件描述符\n     * 因此直接从中拿私有数据--预定义的*eventpoll\n     */\n    ep = file-\u003eprivate_data;\n\n    mutex_lock(\u0026#x26;ep-\u003emtx);\n\n    /*\n     * 从RB树中查找已经维护起来的监听事件\n     * 当然，必须先把这个RB树结构锁定，防止查找时结构改变\n     */\n    epi = ep_find(ep, tfile, fd);\n\n    error = -EINVAL;\n    switch (op) {\n    case EPOLL_CTL_ADD:     // 新增监听\n        if (!epi) {\n            epds.events |= POLLERR | POLLHUP;\n\n            error = ep_insert(ep, \u0026#x26;epds, tfile, fd);\n        } else\n            error = -EEXIST;\n        break;\n    case EPOLL_CTL_DEL:     // 删除监听\n        if (epi)\n            error = ep_remove(ep, epi);\n        else\n            error = -ENOENT;\n        break;\n    case EPOLL_CTL_MOD:     // 修改监听\n        if (epi) {\n            epds.events |= POLLERR | POLLHUP;\n            error = ep_modify(ep, epi, \u0026#x26;epds);\n        } else\n            error = -ENOENT;\n        break;\n    }\n    mutex_unlock(\u0026#x26;ep-\u003emtx);\n\nerror_tgt_fput:\n    fput(tfile);\nerror_fput:\n    fput(file);\nerror_return:\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d\\n\",\n             current, epfd, op, fd, event, error));\n\n    return error;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的核心操作，就是往 \u003ccode\u003eeventpoll\u003c/code\u003e 实例中增删改监听的事件。以 \u003ccode\u003eep_insert\u003c/code\u003e 为例，先看看怎么新增监听。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* 实例化 epitem */\nif (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))\n    goto error_return;\n/* 对 epitem 实例进行初始化数据 */\nep_rb_initnode(\u0026#x26;epi-\u003erbn);\nINIT_LIST_HEAD(\u0026#x26;epi-\u003erdllink);\nINIT_LIST_HEAD(\u0026#x26;epi-\u003efllink);\nINIT_LIST_HEAD(\u0026#x26;epi-\u003epwqlist);\nepi-\u003eep = ep;\n/* 构建struct epoll_filefd，作为rb_tree比较不同的key */\nep_set_ffd(\u0026#x26;epi-\u003effd, tfile, fd);\nepi-\u003eevent = *event;\nepi-\u003enwait = 0;\nepi-\u003enext = EP_UNACTIVE_PTR;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来要接触的就是一段比较烧脑的逻辑。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epoll_table\u003c/code\u003e 是在 VFS 实现中相当重要的一个数据结构，用来与\u003ccode\u003epoll\u003c/code\u003e配合（这里的\u003ccode\u003epoll\u003c/code\u003e是指文件操作中的，而不是\u003ccode\u003epoll()\u003c/code\u003e系统调用）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct poll_table_struct {\n    poll_queue_proc _qproc;\n} poll_table;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中\u003ccode\u003epoll_queue_proc\u003c/code\u003e是一个函数指针\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e为了让 \u003ccode\u003eepitem\u003c/code\u003e 更方便地追踪 \u003ccode\u003epoll_queue_proc\u003c/code\u003e，\u003ccode\u003eepoll_ctl\u003c/code\u003e 中使用了一个 \u003ccode\u003eep_pqueue\u003c/code\u003e 的数据结构来包装 \u003ccode\u003epoll_table\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* 使用 queue 回调函数初始化 poll table */\nepq.epi = epi;\ninit_poll_funcptr(\u0026#x26;epq.pt, ep_ptable_queue_proc);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcly1g0qwphhnz0j30xa0o6aan.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e之后就是把这个 \u003ccode\u003epoll_table\u003c/code\u003e 作为钩子方法挂载到被监控的文件上\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003erevents = tfile-\u003ef_op-\u003epoll(tfile, \u0026#x26;epq.pt);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里以 \u003ccode\u003etcp_poll\u003c/code\u003e 为例，先看看这段逻辑怎么实现的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic unsigned int sock_poll(struct file *file, poll_table *wait)\n{\n    struct socket *sock;\n    /* 获取 struct sock 内核套接字数据结构 */\n    sock = file-\u003eprivate_data;\n    return sock-\u003eops-\u003epoll(file, sock, wait);\n}\n\nunsigned int tcp_poll(struct file *file, struct socket *sock, poll_table *wait)\n{\n    unsigned int mask;\n    struct sock *sk = sock-\u003esk;\n    struct tcp_sock *tp = tcp_sk(sk);\n\n    /*\n     * 这里将调用 poll_table *wait 维护的回调函数\n     * 将持有 eventpoll 实例的进程注册到 sk 的等待队列中\n     */\n    poll_wait(file, sk-\u003esk_sleep, wait);\n    if (sk-\u003esk_state == TCP_LISTEN)\n        return inet_csk_listen_poll(sk);\n\n    /*\n     * 这里省略了部分逻辑，主要是负责处理 struct sock 接收到的事件\n     * 处理成 mask 并返回\n     */\n    ...\n\n    return mask;\n}\n\nstatic inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)\n{\n    if (p \u0026#x26;\u0026#x26; wait_address)\n        p-\u003eqproc(filp, wait_address, p);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再来看看epoll定义的回调函数的实现。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n                 poll_table *pt)\n{\n    struct epitem *epi = ep_item_from_epqueue(pt);\n    struct eppoll_entry *pwq;\n\n    if (epi-\u003enwait \u003e= 0 \u0026#x26;\u0026#x26; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n        init_waitqueue_func_entry(\u0026#x26;pwq-\u003ewait, ep_poll_callback);\n        pwq-\u003ewhead = whead;\n        pwq-\u003ebase = epi;\n        /* 添加到 struct sock 等待队列队首 */\n        add_wait_queue(whead, \u0026#x26;pwq-\u003ewait);\n        list_add_tail(\u0026#x26;pwq-\u003ellink, \u0026#x26;epi-\u003epwqlist);\n        epi-\u003enwait++;\n    } else {\n        /* We have to signal that an error occurred */\n        epi-\u003enwait = -1;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到此为止，\u003ccode\u003eep_insert\u003c/code\u003e 核心的逻辑已经介绍完毕。主要就是将当前的 \u003ccode\u003eeventpoll\u003c/code\u003e 实例注册到监听目标（文件描述符）的等待队列上，并注册\u003ccode\u003eep_poll_callback\u003c/code\u003e作为回调函数。回调函数实现是怎样呢？\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n    int pwake = 0;\n    unsigned long flags;\n    /* 获取 wait 结构维护的 epitem 实例 */\n    struct epitem *epi = ep_item_from_wait(wait);\n    struct eventpoll *ep = epi-\u003eep;\n\n    // ... code omitted...\n    /* \n     * 把当前的 epitem 实例添加到 eventpoll 实例的就绪队列中 \n     * 这是显然的，毕竟此回调函数只有在fd准备就绪后被回调\n     */\n    list_add_tail(\u0026#x26;epi-\u003erdllink, \u0026#x26;ep-\u003erdllist);\n\nis_linked:\n    /* 如果 wait 结构维护的进程处于Sleeping状态，则将其唤醒并加入任务就绪队列 */\n    if (waitqueue_active(\u0026#x26;ep-\u003ewq))\n        __wake_up_locked(\u0026#x26;ep-\u003ewq, TASK_UNINTERRUPTIBLE |\n                 TASK_INTERRUPTIBLE);\n    if (waitqueue_active(\u0026#x26;ep-\u003epoll_wait))\n        pwake++;\n\nout_unlock:\n    spin_unlock_irqrestore(\u0026#x26;ep-\u003elock, flags);\n\n    /* We have to call this outside the lock */\n    if (pwake)\n        ep_poll_safewake(\u0026#x26;psw, \u0026#x26;ep-\u003epoll_wait);\n\n    return 1;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003ccode\u003eepoll_wait\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e处理完所有的监听事件的维护，用户程序需要通过 \u003ccode\u003eepoll_wait\u003c/code\u003e 与 \u003ccode\u003eeventpoll\u003c/code\u003e 实例进行交互，并被告知所有正在监听中的事件是否发生。由于 \u003ccode\u003eepoll_wait\u003c/code\u003e 的整个逻辑基本上都是在进行错误检测，此处不表。我们只关注其中的核心逻辑，即调用的 \u003ccode\u003eep_poll\u003c/code\u003e 函数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,\n           int maxevents, long timeout)\n{\n    int res, eavail;\n    unsigned long flags;\n    long jtimeout;\n    wait_queue_t wait;\n\n    /*\n     * Calculate the timeout by checking for the \"infinite\" value ( -1 )\n     * and the overflow condition. The passed timeout is in milliseconds,\n     * that why (t * HZ) / 1000.\n     */\n    jtimeout = (timeout \u0026#x3C; 0 || timeout \u003e= EP_MAX_MSTIMEO) ?\n        MAX_SCHEDULE_TIMEOUT : (timeout * HZ + 999) / 1000;\n\nretry:\n    spin_lock_irqsave(\u0026#x26;ep-\u003elock, flags);\n\n    res = 0;\n    /* \n     * 如果 eventpoll 实例的就绪队列为空，表明有没任何监听的事件发生。\n     * 主动让进程陷入Sleeping状态，知道被 ep_poll_callback() 唤醒\n     */\n    if (list_empty(\u0026#x26;ep-\u003erdllist)) {\n        init_waitqueue_entry(\u0026#x26;wait, current);\n        wait.flags |= WQ_FLAG_EXCLUSIVE;\n        __add_wait_queue(\u0026#x26;ep-\u003ewq, \u0026#x26;wait);\n\n        for (;;) {\n            /*\n             * We don't want to sleep if the ep_poll_callback() sends us\n             * a wakeup in between. That's why we set the task state\n             * to TASK_INTERRUPTIBLE before doing the checks.\n             */\n            set_current_state(TASK_INTERRUPTIBLE);\n            if (!list_empty(\u0026#x26;ep-\u003erdllist) || !jtimeout)\n                break;\n            if (signal_pending(current)) {\n                res = -EINTR;\n                break;\n            }\n\n            spin_unlock_irqrestore(\u0026#x26;ep-\u003elock, flags);\n            /* 主动陷入Sleeping状态 */\n            jtimeout = schedule_timeout(jtimeout);\n            spin_lock_irqsave(\u0026#x26;ep-\u003elock, flags);\n        }\n        __remove_wait_queue(\u0026#x26;ep-\u003ewq, \u0026#x26;wait);\n\n        set_current_state(TASK_RUNNING);\n    }\n\n    /* Is it worth to try to dig for events ? */\n    eavail = !list_empty(\u0026#x26;ep-\u003erdllist);\n\n    spin_unlock_irqrestore(\u0026#x26;ep-\u003elock, flags);\n\n    /*\n     * 将监听到的事件拷贝到用户空间。如果没有事件就绪且还没超时，就再抱着\n     * 希望试一次。\n     */\n    if (!res \u0026#x26;\u0026#x26; eavail \u0026#x26;\u0026#x26;\n        !(res = ep_send_events(ep, events, maxevents)) \u0026#x26;\u0026#x26; jtimeout)\n        goto retry;\n\n    return res;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eExtra\u003c/h3\u003e\n\u003cp\u003e这部分的数据结构配合着一些胶水代码比较难以理解，最好配合着类图看看（个人使用，不一定适合各位）\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1g0rmx65dzhj324y0t8di4.jpg\"\u003e\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eLinux Kernel 2.6.24\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://idndx.com/2014/09/01/the-implementation-of-epoll-1/\"\u003eThe Implementation of epoll(1)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://idndx.com/2014/09/02/the-implementation-of-epoll-2/\"\u003eThe Implementation of epoll(2)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://idndx.com/2014/09/22/the-implementation-of-epoll-3/\"\u003eThe Implementation of epoll(3)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://idndx.com/2015/07/08/the-implementation-of-epoll-4/\"\u003eThe Implementation of epoll(4)\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e\u003ca href=\"./2019-01-15-understand-Kernel-8/\"\u003e前一篇\u003c/a\u003e已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 \u003ccode\u003estruct sock\u003c/code\u003e 对象，将其逐级从网络接口层逐级提升到网络层、传输层...最终添加到接收队列 \u003ccode\u003esk_receive_queue\u003c/code\u003e 中；用户进程通过 \u003ccode\u003eread\u003c/code\u003e、\u003ccode\u003erecv\u003c/code\u003e、\u003ccode\u003erecvfrom\u003c/code\u003e 等命令检查并获取 \u003ccode\u003esk_receive_queue\u003c/code\u003e 中的数据。\u003c/p\u003e\n\u003cp\u003e整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。\u003c/p\u003e\n\u003cp\u003e那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（\u003ccode\u003eselect\u003c/code\u003e, \u003ccode\u003epoll\u003c/code\u003e, \u003ccode\u003eepoll\u003c/code\u003e）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 \u003ccode\u003eselect\u003c/code\u003e 和 \u003ccode\u003eepoll\u003c/code\u003e 两类系统调用的实现进行探究。\u003c/p\u003e"},{"url":"2019-02-27-Java-Fatal-API","fileName":"2019-02-27-Java-Fatal-API.md","title":"【Java】API 参数误定义的后果","author":"fangfeng","date":"2019-02-27T00:00:00.000Z","tags":["Java","API"],"content":"\u003cp\u003e工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。\u003c/p\u003e\n\u003cp\u003e想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！\u003c/p\u003e\n\u003cp\u003e想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把\u003ccode\u003evoid add(int)\u003c/code\u003e API 改写成 \u003ccode\u003eint add(int)\u003c/code\u003e，可能得到的大多数回答都是可以。\u003c/p\u003e\n\u003ch2\u003e看山是山\u003c/h2\u003e\n\u003cp\u003e首先举一个具体点的例子来描述（为了方便，就不定义\u003ccode\u003eCountService\u003c/code\u003e的接口类了）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.ffutop.signature;\n\n/**\n * 主类\n * @author fangfeng\n * @since 2019-02-26\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        CountService countService = new CountService();\n        countService.add(1);\n        System.out.println(String.format(\"currentValue = %d\", countService.getCurrentValue()));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.ffutop.signature;\n\n/**\n * @author fangfeng\n * @since 2019-02-26\n */\npublic class CountService {\n\n    private int currentValue = 0;\n\n    /**\n     * 请把 add(int) 理解成 API\n     * 虽然已经做了实现\n     */\n    public void add(int addend) {\n        currentValue += addend;\n    }\n\n    public int getCurrentValue() {\n        return currentValue;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在已经有 \u003ccode\u003evoid add(int)\u003c/code\u003e 方法，完成的工作是累加。现在要把 API 改成 \u003ccode\u003eint add(int)\u003c/code\u003e，是否可以呢？看似本来没有返回值，现在只是加上一个返回值，对于原来的代码没有任何问题，而新代码又能拿到int类型的返回值，皆大欢喜啊。\u003c/p\u003e\n\u003ch2\u003e看山不是山\u003c/h2\u003e\n\u003cp\u003e先给大家执行下代码吧！（请严格按照顺序，且避免使用IDE，否则将得不到预想的结果）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ # 准备好两个类的代码（CountService的API是 `void add(int)`）\n$ # 编译Main类\n$ javac com/ffutop/signature/Main.java\n$  \n$ # 修改CountService的API为`int add(int)`\n$ # 编译 CountService 类\n$ javac com/ffutop/signature/CountService.java\n$ \n$ # 执行主程序\n$ java com.ffutop.signature.Main\nException in thread \"main\" java.lang.NoSuchMethodError: com.ffutop.signature.CountService.add(I)V\n    at com.ffutop.signature.Main.main(Main.java:11)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e很遗憾，执行失败了，报了个Error（没有这样的方法）。方法写的是 \u003ccode\u003ecom.ffutop.signature.CountService.add(I)V\u003c/code\u003e 。简单的翻译一下就是需要\u003ccode\u003e类名+方法名=x.y.CountService.add\u003c/code\u003e，且入参为int，出参为void的方法（想了解更多请优先学习\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4\"\u003eJava ClassFile Format\u003c/a\u003e）。\u003c/p\u003e\n\u003cp\u003e那么，现在得到的结论是不行。\u003c/p\u003e\n\u003ch2\u003e看山还是山\u003c/h2\u003e\n\u003cp\u003e那么，就一定不行吗？都是同名方法，不同参数。凭什么改个入参是可以的，改个出参就不行了。\u003c/p\u003e\n\u003cp\u003e从 Java 的角度来说，一定不行。“同一类中不能存在两个名字及描述符完全相同的方法”\u003c/p\u003e\n\u003cp\u003e但是，如果从 JVM 的角度来说，完全是可行的。“在class文件中，两个方法可以拥有完全相同的特征签名，前提是返回值不能相同”\u003c/p\u003e\n\u003cp\u003e什么意思呢？我们都知道建立在 JVM 之上的语言不只有 Java。像 Groovy、Kotlin 等语言都实现了各自的区别于 Java 独有的特征。这些特征的实现都是依赖于 JVM，但为什么 Java 没有呢？只能说 Java 语言的规范是 JVM 的子集（好像这话有点不严谨啊）\u003c/p\u003e\n\u003cp\u003e通过直接操作字节码，就能够达到在同一个类中建立两个同名、相同入参，但返回值不同的方法。\n先通过\u003ccode\u003ejavap\u003c/code\u003e命令看看最终提供的\u003ccode\u003eCountService.class\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ javap com.ffutop.signature.CountService\npublic class com.ffutop.signature.CountService {\n  public int add(int);\n  public com.ffutop.signature.CountService();\n  public void add(int);\n  public int getCurrentValue();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e有两个同名的方法\u003ccode\u003eadd(int)\u003c/code\u003e，至于执行，也会相当顺利。\u003c/p\u003e\n\u003cp\u003e还是写个程序来说明，在原有 \u003ccode\u003eMain.java\u003c/code\u003e 的基础上，再创建一个全限定名为 \u003ccode\u003ecom.ffutop.signature.other.Main2\u003c/code\u003e 的类\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.ffutop.signature.other;\nimport com.ffutop.signature.CountService;\n\n/**\n * @author fangfeng\n * @since 2019-02-27\n */\npublic class Main2 {\n\n    public static void main(String[] args) {\n        CountService countService = new CountService();\n        System.out.println(String.format(\"currentValue = %d\", countService.add(1)));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e与 Main.java 比较，很明显的就是一个调用了 \u003ccode\u003eCountService\u003c/code\u003e 的 \u003ccode\u003eint add(int)\u003c/code\u003e 方法，而另一个调用 \u003ccode\u003evoid add(int)\u003c/code\u003e 方法。\u003c/p\u003e\n\u003cp\u003e那么是否有效呢？先来验证一下（这里要模拟的一个场景是，CountService 类(只有 \u003ccode\u003evoid add(int)\u003c/code\u003e 方法)作为二方库C.jar version 1.0 的主要服务类。CountService 类(同时有 \u003ccode\u003evoid add(int)\u003c/code\u003e 和 \u003ccode\u003eint add(int)\u003c/code\u003e 方法)作为二方库C.jar version 2.0 的主要服务类。Main 类根据 C.jar version 1.0 做的编译，而 Main2 类根据 C.jar version 2.0 做的编译。在 Main 和 Main2 类运行时只提供 C.jar version 2.0）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ # 编译 Main 类和 CountService 类\n$ javac com/ffutop/signature/Main.java\n$\n$ # 操作 CountService.class 字节码，增加方法 `int add(int)` \n$ # 通过 ASM 实现，详见附录源码 com/ffutop/signature/support/Generator.java\n$ \n$ # 编译 Main2 类 (提供 classpath，即根据 CountService.class 编译)\n$ javac com/ffutop/signature/other/Main2.java -classpath .\n$\n$ # 验证\n$ java com.ffutop.signature.Main\ncurrentValue = 1\n$ java com.ffutop.signature.other.Main2\ncurrentValue = 1\n$ # OK，验证通过\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e一旦 API 定义错误，并已经作为二方库提供给调用方。后果必然是灾难性的。至少，只能重新定义 API 。如果对于入参定义错误，Java 语言级别也能够支持。但如果是返回值，如果非要保持方法名一致，那就不得不下沉到 JVM 级别来进行处理了。当然，在工程项目中是否应该直接操作字节码？至少个人还没直接接触过。\u003c/p\u003e\n\u003cp\u003e做个记录，未来可以翻一翻，至少是一种可行的解决方案。\u003c/p\u003e\n\u003cp\u003eUpdate: 如果直接操作字节码为添加了不同返回值的同名同参数方法，可能引起调用方静态编译失败。此操作需慎之又慎。也许提供类加载器加载时的字节码操作能更加完美地解决这个问题。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/signature.zip\"\u003e源码.zip\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。\u003c/p\u003e\n\u003cp\u003e想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！\u003c/p\u003e\n\u003cp\u003e想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把\u003ccode\u003evoid add(int)\u003c/code\u003e API 改写成 \u003ccode\u003eint add(int)\u003c/code\u003e，可能得到的大多数回答都是可以。\u003c/p\u003e"},{"url":"2019-02-02-unicode","fileName":"2019-02-02-unicode.md","content":"\u003cp\u003etitle: 字符集与字符编码\nauthor: fangfeng\ndate: 2019-02-02\ntags:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUnicode\u003c/li\u003e\n\u003cli\u003eCharacter Encoding\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e{% pdf \u003ca href=\"https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview\"\u003ehttps://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview\u003c/a\u003e %}\u003c/p\u003e","digest":"\u003cp\u003etitle: 字符集与字符编码\nauthor: fangfeng\ndate: 2019-02-02\ntags:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUnicode\u003c/li\u003e\n\u003cli\u003eCharacter Encoding\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e{% pdf \u003ca href=\"https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview\"\u003ehttps://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview\u003c/a\u003e %}\u003c/p\u003e"},{"url":"2019-01-15-understand-Kernel-8","fileName":"2019-01-15-understand-Kernel-8.md","content":"\u003cp\u003etitle: 理解 Linux Kernel (8) - 网络\nauthor: fangfeng\ndate: 2019-01-15\ntags:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinux\u003c/li\u003e\n\u003cli\u003eKernel\u003c/li\u003e\n\u003cli\u003eNetwork\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e{% pdf \u003ca href=\"https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview\"\u003ehttps://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview\u003c/a\u003e %}\u003c/p\u003e","digest":"\u003cp\u003etitle: 理解 Linux Kernel (8) - 网络\nauthor: fangfeng\ndate: 2019-01-15\ntags:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinux\u003c/li\u003e\n\u003cli\u003eKernel\u003c/li\u003e\n\u003cli\u003eNetwork\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e{% pdf \u003ca href=\"https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview\"\u003ehttps://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview\u003c/a\u003e %}\u003c/p\u003e"},{"url":"2018-12-28-understand-Kernel-7","fileName":"2018-12-28-understand-Kernel-7.md","title":"理解 Linux Kernel (7) - 字符设备","author":"fangfeng","date":"2018-12-28T00:00:00.000Z","tags":["Linux","Kernel","Char Dev"],"content":"\u003cp\u003e相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。\u003c/p\u003e\n\u003cp\u003e回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。\u003c/p\u003e\n\u003cp\u003e那么，常见的字符设备有什么？显示器、键盘、鼠标。\u003c/p\u003e\n\u003ch2\u003e宏观概览\u003c/h2\u003e\n\u003cp\u003e通常在我们的认识中，命令行终端就被认为是与一套字符设备相配合来使用的。很正常嘛。我们打开一个 Shell ，通过键盘输入一些字符，配合显示器把这些经过加工的字符展示出来。\u003c/p\u003e\n\u003cp\u003e那么，是不是就意味着 Shell 作为一个任务(进程)，以键盘设备作为标准输入，以显示设备作为标准输出?\u003c/p\u003e\n\u003cp\u003e看看一个 1 号任务 \u003ccode\u003e/bin/bash\u003c/code\u003e 的文件描述符说明吧。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ ls -al\ntotal 0\ndr-x------ 2 root root  0 Dec 13 23:20 .\ndr-xr-xr-x 9 root root  0 Dec 13 23:20 ..\nlrwx------ 1 root root 64 Dec 13 23:20 0 -\u003e /dev/pts/0\nlrwx------ 1 root root 64 Dec 13 23:20 1 -\u003e /dev/pts/0\nlrwx------ 1 root root 64 Dec 13 23:20 2 -\u003e /dev/pts/0\nlrwx------ 1 root root 64 Dec 25 01:09 255 -\u003e /dev/pts/0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里文件描述符 0, 1, 2 分别表示任务的标准输入、标准输出、标准错误。这些内容在表现形式上做了一个链接。\u003c/p\u003e\n\u003cp\u003e那么，\u003ccode\u003e/dev/pts/0\u003c/code\u003e 是什么? \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003ecrw--w---- 1 root tty 136, 0 Dec 13 23:20 /dev/pts/0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e一个字符设备。到此为止，似乎和最初预想的有比较大的区别。至少在假象中，至少是一个输入(键盘)，一个输出(显示器)。怎么就混成了一个呢？\u003c/p\u003e\n\u003cp\u003e本来是怎么都想不通的，但后来配合\"Unix一切皆文件\"的信条，总算是有点明白了。\u003c/p\u003e\n\u003cp\u003e相信大家都有这这样的经历，某个程序是以键盘输入作为标准输入的。其实就和上面👆展示的一样 \u003ccode\u003e0 -\u003e /dev/pts/0\u003c/code\u003e 。那么，有没有考虑过这整套流程是怎么协作的呢？\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyjvtjiu0zj31980oqmxe.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e对于程序来说，我们还是普通的调用 \u003ccode\u003eread\u003c/code\u003e, \u003ccode\u003ewrite\u003c/code\u003e 等经过封装的函数，来读取一个所谓的文件。\u003c/p\u003e\n\u003cp\u003e但对于文件是字符设备时，最终调用的就是 \u003ccode\u003etty_read\u003c/code\u003e, \u003ccode\u003etty_write\u003c/code\u003e 了。通俗的讲，大概率的就是键盘作为输入，显示器作为输出了。\u003c/p\u003e\n\u003ch2\u003e源码剖析\u003c/h2\u003e\n\u003ch3\u003e文件读写\u003c/h3\u003e\n\u003cp\u003e这部分上一篇已经介绍过了，不做过多说明。\u003c/p\u003e\n\u003cp\u003e简单回顾下 \u003ccode\u003esys_read\u003c/code\u003e 函数\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_read(unsigned int fd,char * buf,int count)\n{\n    struct file * file;\n    struct m_inode * inode;\n\n    if (fd\u003e=NR_OPEN || count\u0026#x3C;0 || !(file=current-\u003efilp[fd]))\n        return -EINVAL;\n    if (!count)\n        return 0;\n    verify_area(buf,count);\n    inode = file-\u003ef_inode;\n    if (inode-\u003ei_pipe)\n        return (file-\u003ef_mode\u0026#x26;1)?read_pipe(inode,buf,count):-EIO;\n    /* 确认到i节点描述的是字符设备 */\n    if (S_ISCHR(inode-\u003ei_mode)) \n        return rw_char(READ,inode-\u003ei_zone[0],buf,count,\u0026#x26;file-\u003ef_pos);\n    if (S_ISBLK(inode-\u003ei_mode))\n        return block_read(inode-\u003ei_zone[0],\u0026#x26;file-\u003ef_pos,buf,count);\n    if (S_ISDIR(inode-\u003ei_mode) || S_ISREG(inode-\u003ei_mode)) {\n        if (count+file-\u003ef_pos \u003e inode-\u003ei_size)\n            count = inode-\u003ei_size - file-\u003ef_pos;\n        if (count\u0026#x3C;=0)\n            return 0;\n        return file_read(inode,file,buf,count);\n    }\n    printk(\"(Read)inode-\u003ei_mode=%06o\\n\\r\",inode-\u003ei_mode);\n    return -EINVAL;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003eS_ISCHR()\u003c/code\u003e 就是在对i节点的类型进行判别，从而进行不同的分发。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic crw_ptr crw_table[]={\n    NULL,       /* nodev */\n    rw_memory,  /* /dev/mem etc */\n    NULL,       /* /dev/fd */\n    NULL,       /* /dev/hd */\n    rw_ttyx,    /* /dev/ttyx */\n    rw_tty,     /* /dev/tty */\n    NULL,       /* /dev/lp */\n    NULL};      /* unnamed pipes */\n/**\n * 这段还是涉及到分发，由不同的设备号(dev) 来确定执行函数 (ttyx, 串口终端; tty, 控制台终端; mem, /dev/mem 等)\n * crw_ptr 是 C 语言中常见的函数指针。由dev号来确定调用哪个函数\n */\nint rw_char(int rw,int dev, char * buf, int count, off_t * pos)\n{\n    crw_ptr call_addr;\n\n    if (MAJOR(dev)\u003e=NRDEVS)\n        return -ENODEV;\n    if (!(call_addr=crw_table[MAJOR(dev)]))\n        return -ENODEV;\n    return call_addr(rw,MINOR(dev),buf,count,pos);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e执行到 \u003ccode\u003erw_tty\u003c/code\u003e, \u003ccode\u003erw_ttyx\u003c/code\u003e 两个函数，就将对读/写进行区分，并由特定的函数进行处理。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic int rw_ttyx(int rw,unsigned minor,char * buf,int count,off_t * pos)\n{\n    return ((rw==READ)?tty_read(minor,buf,count):\n        tty_write(minor,buf,count));\n}\n\nstatic int rw_tty(int rw,unsigned minor,char * buf,int count, off_t * pos)\n{\n    if (current-\u003etty\u0026#x3C;0)\n        return -EPERM;\n    return rw_ttyx(rw,current-\u003etty,buf,count,pos);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到此为止，应该能够基本了解了字符设备，作为 Linux 的文件，所应该有的读写的相关支持。\u003c/p\u003e\n\u003cp\u003e但是，究竟读、写的内容在哪呢？比如正规文件，都很容易地可以理解到，就是从磁盘中取出某个/某几个盘块的内容即可。字符设备的IO要从哪里取(往哪里送)数据呢?\u003c/p\u003e\n\u003ch3\u003e字符设备驱动\u003c/h3\u003e\n\u003cp\u003e对于设备驱动这个概念，至今没有搞清楚。不过，这不妨碍对代码的理解。反正对于字符设备驱动来说，也就是 Linux 内核中的一些软件层面的代码，与普通代码的唯一区别，就是对外设硬件做了相应的交互支持。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fykyc6lo9pj31i40u0ac8.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e承接操作系统的字符设备接口，\u003ccode\u003etty_read\u003c/code\u003e、\u003ccode\u003etty_write\u003c/code\u003e 负责读入和写出。\u003c/p\u003e\n\u003cp\u003e从哪里读？\u003ccode\u003esecondary\u003c/code\u003e 数据队列；往哪里写？\u003ccode\u003ewrite_q\u003c/code\u003e 数据队列。\u003c/p\u003e\n\u003cp\u003e同时，也可以看到，与这些队列直接相关的，就是我们熟知的键盘和显示器了。是不是有了点豁然开朗的感觉。\u003c/p\u003e\n\u003cp\u003e好，我们先来看看这里描述的三个队列究竟是怎么工作的。这里就不得不先看看内存中抽象出来的描述终端的数据结构 \u003ccode\u003etty_struct\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/**\n * copied from include/linux/tty.h\n */\nstruct tty_struct {\n    struct termios termios;     /* terminal IO conf */\n    int pgrp;                   /* 所属进程组 */\n    int stopped;                /* 停止标志 */\n    void (*write)(struct tty_struct * tty); /* 终端写函数指针 */\n    struct tty_queue read_q;    /* 终端读队列 */\n    struct tty_queue write_q;   /* 终端写队列 */\n    struct tty_queue secondary; /* 终端辅助队列 */\n};\n\n/**\n * copied from include/termios.h\n */\nstruct termios {                /* terminal IO 属性 */\n    unsigned long c_iflag;      /* input mode flags */\n    unsigned long c_oflag;      /* output mode flags */\n    unsigned long c_cflag;      /* control mode flags */\n    unsigned long c_lflag;      /* local mode flags */\n    unsigned char c_line;       /* line discipline */\n    unsigned char c_cc[NCCS];   /* control characters */\n};\n\n/**\n * copied from include/linux/tty.h\n */\nstruct tty_queue {\n    unsigned long data;         /* 字符行数量 | 串口终端则存储端口号 */\n    unsigned long head;         /* 头指针 */\n    unsigned long tail;         /* 尾指针 */\n    struct task_struct * proc_list; /* 等待该终端的任务队列 */\n    char buf[TTY_BUF_SIZE];     /* 队列的缓冲区 */\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于任何任务需要读写字符设备(这里指终端设备)，最终直接读取/写入到的就是 \u003ccode\u003esecondary\u003c/code\u003e 和 \u003ccode\u003ewrite_q\u003c/code\u003e。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e这里可能有个小小的疑问? 为什么读终端设备不是读 \u003ccode\u003eread_q\u003c/code\u003e 呢？\u003c/p\u003e\n\u003cp\u003e其实也比较好解释，相信日常在操作命令行的时候，我们在键盘上敲击的键位与显示器上实际展示的内容是不相匹配的。最普通的，我们键入了 \u003cstrong\u003edelete(删除键)\u003c/strong\u003e，为什么不是一个 \u003cstrong\u003edelete\u003c/strong\u003e 对应的 ascii (当然，这里请先忽视非打印字符的问题)，而是删除了最后一个字符呢？完全可以想象，反正任何键位与驱动交互的时候都是传入一串二进制码嘛。\u003c/p\u003e\n\u003cp\u003e这里的 \u003ccode\u003esecondary\u003c/code\u003e 完成的就是怎么一个工作，\u003ccode\u003eread_q\u003c/code\u003e 存储的是所有的外设(这里是键盘)的输入，并原样存储。而到了 \u003ccode\u003esecondary\u003c/code\u003e 就是经过相应的加工，诸如控制字符之类的都展现了各自的意义，并完成一些加工工作，而不再仅仅只是普通地展示了。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e另外，可能还有一个问题。虽然我们已经习惯了在命令行交互时，所有的输入都将直接在显示器上进行展示，好像我们在直接往显示器上写内容。但是，前面我们描述的内容都是，键盘设备作为输入，是要写到 \u003ccode\u003eread_q\u003c/code\u003e 乃至 \u003ccode\u003esecondary\u003c/code\u003e 并最终作为进程的输入的。在显示器上显示并不是它本来应该干的事情 (比较显示器上展示的应该是 \u003ccode\u003ewrite_q\u003c/code\u003e 的内容，也就是进程的标准输出)\u003c/p\u003e\n\u003cp\u003e事实上，这仅仅只是一个回显，将 \u003ccode\u003esecondary\u003c/code\u003e 队列的内容复制了一份到写队列，也就呈现出让显示器打印相应键盘输入的效果了。\u003c/p\u003e\n\u003cp\u003e同时，这也就能够直接解释为什么我们在使用 \u003ccode\u003epasswd\u003c/code\u003e, \u003ccode\u003esu\u003c/code\u003e, \u003ccode\u003esudo\u003c/code\u003e 等命令时，要求输入密码都是不在显示器上回显的。实现也相当简单了嘛。把 tty_struct.termios 的相应控制属性 (ECHO) 重置，就可以实现不回显的效果了。\u003c/p\u003e\n\u003ch3\u003e终端设备交互\u003c/h3\u003e\n\u003cp\u003e最后一部分，应该也是最关心的了。外设如何与操作系统完成交互。其实也能够想得到了——中断。\u003c/p\u003e\n\u003cp\u003e在操作系统初始化时，就把中断描述符表的中断表项配置得当。之后的事情就是等待键盘等外设输入的中断信号了。\u003c/p\u003e\n\u003cp\u003e又看回到了 \u003ccode\u003einit/main.c\u003c/code\u003e 程序\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid main(void)\n{\n    ...\n    trap_init();\n    blk_dev_init();\n    chr_dev_init(); /* 块设备相关初始化, 方法体是空的，没有实现 */\n    tty_init();     /* tty 终端设备初始化 */\n    time_init();\n    sched_init();\n    buffer_init(buffer_memory_end);\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e/**\n * Copied from kernel/chr_drv/tty_io.c\n * 终端设备初识化\n */\nvoid tty_init(void)\n{\n    /** 串口设备初始化 */\n    rs_init();\n    /** 控制台设备初始化 */\n    con_init();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至于为什么有两种初始化方式。这来源于终端又区分为控制台终端与串口终端，区别就是一个是直接建立在主机上，串口终端是通过串行接口连接到主机的。当然，这都是古老的方式了，细节就不太清楚了。\u003c/p\u003e\n\u003cp\u003e下面来看看 \u003ccode\u003econ_init()\u003c/code\u003e 做了哪些工作(\u003ccode\u003ers_init()\u003c/code\u003e 的内容请自行了解)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid con_init(void)\n{\n    register unsigned char a;\n    char *display_desc = \"????\";\n    char *display_ptr;\n\n    /**\n     * 读取 setup.s 程序预处理的内容\n     * 包括显示器的各种配置参数\n     */\n    video_num_columns = ORIG_VIDEO_COLS;\n    video_size_row = video_num_columns * 2;\n    video_num_lines = ORIG_VIDEO_LINES;\n    video_page = ORIG_VIDEO_PAGE;\n    video_erase_char = 0x0720;\n\n    /**\n     * 读取显示器的配置并进行相关设置 (省略代码)\n     */\n    ...\n\n    origin  = video_mem_start;\n    scr_end = video_mem_start + video_num_lines * video_size_row;\n    top = 0;\n    bottom  = video_num_lines;\n\n    gotoxy(ORIG_X,ORIG_Y);\n    /** 设置陷阱门 */\n    set_trap_gate(0x21,\u0026#x26;keyboard_interrupt);\n    outb_p(inb_p(0x21)\u0026#x26;0xfd,0x21);\n    a=inb_p(0x61);\n    outb_p(a|0x80,0x61);\n    outb(a,0x61);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e应该能够看到最重要的内容就是\u003cstrong\u003e设置键盘中断陷阱门\u003c/strong\u003e了。\u003c/p\u003e\n\u003cp\u003e之后只有静静地等待键位敲击，也就能够产生硬件中断，从而让 \u003ccode\u003eread_q\u003c/code\u003e 获得到相应的字符输入。\u003c/p\u003e\n\u003cp\u003e至于键盘中断的相应处理流程，这里不再详述。简述一些步骤:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e产生硬中断 \u003ccode\u003ekeyboard_interrupt\u003c/code\u003e，由程序 \u003ccode\u003eKeyboard.s\u003c/code\u003e 的汇编代码进行处理\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e根据不同的键盘(US 键盘、德式键盘等等)将获得的键位信号进行相应的字符转换(查转换表)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e调用 \u003ccode\u003edo_tty_interrupt\u003c/code\u003e 处理函数 (确认是给哪个终端的信号)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e调用 \u003ccode\u003ecopy_to_cooked(tty)\u003c/code\u003e ，即完成 \u003ccode\u003eread_q\u003c/code\u003e 到 \u003ccode\u003esecondary\u003c/code\u003e 的相关加工。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。\u003c/p\u003e\n\u003cp\u003e回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。\u003c/p\u003e\n\u003cp\u003e那么，常见的字符设备有什么？显示器、键盘、鼠标。\u003c/p\u003e"},{"url":"2018-12-15-sql-injection","fileName":"2018-12-15-sql-injection.md","title":"SQL 注入","author":"fangfeng","date":"2018-12-15T00:00:00.000Z","tags":["Security","SQL"],"content":"\u003cp\u003e说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。\u003c/p\u003e\n\u003cp\u003e最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。\u003c/p\u003e\n\u003cp\u003e更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: \"我用不用现成的工具只是取决于我想不想自己再写一套\"\u003c/p\u003e\n\u003cp\u003e当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。\u003c/p\u003e\n\u003ch2\u003e概要\u003c/h2\u003e\n\u003cp\u003eSQL 注入漏洞究竟会产生怎么样的危害性，仅仅只是绕过某些登录账号密码的验证? 只是绕过某些访问限制实现特权内容的访问?\u003c/p\u003e\n\u003cp\u003e此前我的认识也仅仅只是停留在这里。可谁曾想，SQL SELECT 语句真的是功能强大啊。通过各种各样的字符串拼接，最终能达到的目的，可以说把整个数据库的内容拖下来也不为过。当然，这也是限定在没有实现分库分表，数据库查询账号的权限过大的前提下。\u003c/p\u003e\n\u003cp\u003e不过，这也就够了。只有真正认识到问题的严重性，最终才会想着去做出一些改善。\u003c/p\u003e\n\u003ch2\u003eSQL 注入技术\u003c/h2\u003e\n\u003ch3\u003e基于布尔的注入\u003c/h3\u003e\n\u003cp\u003e最早接触到 SQL 注入问题，还是两个月前。操作的内容也相当简单，猜解某账号的密码。\u003c/p\u003e\n\u003cp\u003e某接口提供了查询账号的功能，后台的拼接 SQL 可以简单理解成 \u003ccode\u003eSELECT * FROM users WHERE username = '${}'\u003c/code\u003e 。其中 \u003ccode\u003e${}\u003c/code\u003e 就是直接使用的接口请求参数。\u003c/p\u003e\n\u003cp\u003e而接口的请求结果会根据 SQL 查询的结果，有或没有记录呈现两个不同的页面。\u003c/p\u003e\n\u003cp\u003e这算是最简单容易的 SQL 注入了，也是凭借个人能力直接能够想到注入点的问题了。\u003c/p\u003e\n\u003cp\u003e最先做的就是猜解存储密码字段的字段名究竟是什么? 很好，符合常理的设计，直接就是 \u003ccode\u003epasswd\u003c/code\u003e 。\u003c/p\u003e\n\u003cp\u003e下面就是苦力工作，利用 SQL LIKE 操作符，逐一去猜每一位。\u003ccode\u003e${}\u003c/code\u003e 的注入内容就类似 \u003ccode\u003eadmin' AND passwd LIKE '?%\u003c/code\u003e 这里的问号就是逐一猜解的内容(1-9a-zA-Z + 特殊符号)\u003c/p\u003e\n\u003cp\u003e至于为什么利用 LIKE 操作符，很明确，减少猜解的次数。否则，在密码未知的情况下，即使六位密码也有猜解百万次。而 LIKE 操作符能将猜解次数降为线性，\u003ccode\u003e密码长度 * 字符集数\u003c/code\u003e 次\u003c/p\u003e\n\u003cp\u003e这里仅仅用了 \u003ccode\u003eAND\u003c/code\u003e，但熟悉了一个，其它就基本类似了。\u003c/p\u003e\n\u003cp\u003e如果登录也能够注入，认证 SQL 类似 \u003ccode\u003eSELECT * FROM users WHERE username = '${}' AND passwd = '${}'\u003c/code\u003e，那么直接在第一个 \u003ccode\u003e${}\u003c/code\u003e 处注入 \u003ccode\u003eadmin' OR 1=1; --\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003e基于时间的注入\u003c/h3\u003e\n\u003cp\u003e绝大多数时候，注入绝对没有这么简单。也许注入点背后的拼接 SQL 并不对返回值产生影响。例如仅仅只是为了从 DB 查询用户信息，并打一条日志，返回的永远是静态日志（当然，我知道这个例子不恰当，无奈目前只能想到这个）。\u003c/p\u003e\n\u003cp\u003e既然拼接 SQL 总是存在，但没法给我们一个直观的注入成功 OR 失败的提示。那么，时间就成了一个最好的判断。毕竟是阻塞式的执行。\u003c/p\u003e\n\u003cp\u003e还是以 \u003ccode\u003eSELECT * FROM users WHERE username = '${}'\u003c/code\u003e 为例，使用类似 \u003ccode\u003eadmin' AND IF(passwd LIKE '5%', SLEEP(5), 1);--\u003c/code\u003e 的 PAYLOAD ，当满足 \u003ccode\u003epasswd\u003c/code\u003e 以 5 开始时，则 IF 判断进入 \u003ccode\u003eSLEEP(5)\u003c/code\u003e ，根据网页的响应时长就可以进行相应的判断。\u003c/p\u003e\n\u003ch3\u003e基于报错的注入\u003c/h3\u003e\n\u003cp\u003e这应该也算一种比较容易自动化的注入方式了。其实在猜解存储密码字段的字段名时，前面也是这样用的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e\u003e SELECT * FROM users WHERE password ='1';\nERROR 1054 (42S22): Unknown column 'password' in 'where clause'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果程序不做任何处理，对 SQL 错误直接抛出，那么，通过这个就能获得相当多的信息。\u003c/p\u003e\n\u003cp\u003e由于这部分接触不深，仅仅给出 sqlmap 提的 PAYLOAD\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAND (SELECT [RANDNUM] FROM(SELECT COUNT(*),CONCAT('[DELIMITER_START]',([QUERY]),'[DELIMITER_STOP]',FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e很标准的 PAYLOAD，而且完全可以。\u003ccode\u003eINFORMATION_SCHEMA\u003c/code\u003e 库的表对所有用户都可查，因此不存在授权的问题。而且表中数据至少大于等于 3 条。\u003c/p\u003e\n\u003cp\u003e这个 PAYLOAD 一定导致报错的主因，就是对 \u003ccode\u003eRAND()\u003c/code\u003e 与 \u003ccode\u003eGROUP BY\u003c/code\u003e 的配合应用。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUse of a column with RAND() values in an ORDER BY or GROUP BY clause may yield unexpected results because for either clause a RAND() expression can be evaluated multiple times for the same row, each time returning a different result. If the goal is to retrieve rows in random order, you can use a statement like this:\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e而真正想要得到的内容，通过 \u003ccode\u003eCONCAT('[DELIMITER_START]',([QUERY]),'[DELIMITER_STOP]',FLOOR(RAND(0)*2))x\u003c/code\u003e 得到，\u003ccode\u003e[QUERY]\u003c/code\u003e 就是真正想要注入的完整SQL串。\u003c/p\u003e\n\u003cp\u003e而这里的 \u003ccode\u003eDELIMITER_START\u003c/code\u003e \u003ccode\u003eDELIMITER_STOP\u003c/code\u003e 作为界定符，帮助程序提取 \u003ccode\u003e[QUERY]\u003c/code\u003e 得到的结果。否则，直接对请求返回的结果进行过滤可真是太困难了。\u003c/p\u003e\n\u003ch3\u003e联合查询注入\u003c/h3\u003e\n\u003cp\u003e联合查询，应该算是最顾名思义的注入方式。使用 \u003ccode\u003eUNION\u003c/code\u003e 在原 SQL 已经限定了查询表的前提下，获得数据库其它库表的信息。\u003c/p\u003e\n\u003cp\u003eLIKE: \u003ccode\u003e1' UNION SELECT * FROM users;--\u003c/code\u003e 这样的 PAYLOAD。\u003c/p\u003e\n\u003ch3\u003e堆查询注入\u003c/h3\u003e\n\u003cp\u003e我想这应该是最让人摸不着头脑的命名方式了。\u003c/p\u003e\n\u003cp\u003e形象化的，我们利用 PAYLOAD 来进行说明。\u003ccode\u003e1'; INSERT INTO users (user, passwd) VALUES ('aaa', 'aaa');--\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e看起来和 UNION 挺像的哈，都是补充上一个 OR 多个 SQL 。当然，也是有区别的，否则为什么会出现这样一种技术呢。\u003c/p\u003e\n\u003cp\u003e最大的区别，就是堆查询注入能够完成 \u003ccode\u003eUPDATE\u003c/code\u003e, \u003ccode\u003eINSERT\u003c/code\u003e, \u003ccode\u003eDELETE\u003c/code\u003e 等操作，毕竟，UNION 联合的只能是作为查询了（可能说法不太恰当，但姑且这样吧）\u003c/p\u003e\n\u003ch3\u003e另类注入\u003c/h3\u003e\n\u003cp\u003e之前的几种，我们都是利用了 \u003ccode\u003eSELECT\u003c/code\u003e 完成的注入，那么对于 \u003ccode\u003eINSERT\u003c/code\u003e, \u003ccode\u003eUPDATE\u003c/code\u003e 之类的语句是否有注入的可能呢。当然也是存在可能的。\u003c/p\u003e\n\u003cp\u003e不过，精力有限，而且目前看来也不需要做到这一步。暂时挖个坑吧。不填\u003c/p\u003e\n\u003ch2\u003eSQLMAP\u003c/h2\u003e\n\u003cp\u003e简单的了解了几种注入原理之后，还是要看看 SQL 注入神器的——\u003ccode\u003eSQLMAP\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e也算是尝试了好久才真正了解它的强大之处。此处强烈推荐 DVWA，\u003ccode\u003eDamn Vulnerable Web Application\u003c/code\u003e，一个用来合法攻击的工具。\u003c/p\u003e\n\u003cp\u003e部署方式也是开箱可用，只要有 docker，直接 \u003ccode\u003edocker run --rm -it -p 80:80 vulnerables/web-dvwa\u003c/code\u003e 即可完成部署。\u003c/p\u003e\n\u003cp\u003e对于将 DVWA 安全级别设置为 low 时，仅仅只需要执行下列命令就可以获取到 DB 里几乎完整的信息。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ sqlmap -u http://127.0.0.1/vulnerabilities/sqli/\\?id\\=1\\\u0026#x26;Submit\\=Submit\\# --cookie=\"PHPSESSID=jhton35qahj78l3unjea9k2lf7;security=low\" -v 3 --banner\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当然，换一下相关获取的内容，例如把 \u003ccode\u003e--banner\u003c/code\u003e 换成 \u003ccode\u003e--dump\u003c/code\u003e ，我们借此来简单看看 SQL 注入漏洞的可怕之处\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e[10:41:39] [INFO] using default dictionary\ndo you want to use common password suffixes? (slow!) [y/N]\n[10:41:40] [INFO] starting dictionary-based cracking (md5_generic_passwd)\n[10:41:40] [INFO] starting 8 processes\n[10:41:42] [INFO] cracked password 'abc123' for hash 'e99a18c428cb38d5f260853678922e03'\n[10:41:44] [INFO] cracked password 'charley' for hash '8d3533d75ae2c3966d7e0d4fcc69216b'\n[10:41:47] [INFO] cracked password 'letmein' for hash '0d107d09f5bbe40cade3de5c71e9e9b7'\n[10:41:49] [INFO] cracked password 'password' for hash '5f4dcc3b5aa765d61d8327deb882cf99'\n[10:41:53] [DEBUG] post-processing table dump\nDatabase: dvwa\nTable: users\n[5 entries]\n+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+\n| user_id | avatar                      | user    | password                                    | last_name | first_name | last_login          | failed_login |\n+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+\n| 1       | /hackable/users/admin.jpg   | admin   | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin     | admin      | 2018-12-15 00:42:31 | 0            |\n| 2       | /hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123)   | Brown     | Gordon     | 2018-12-15 00:42:31 | 0            |\n| 3       | /hackable/users/1337.jpg    | 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b (charley)  | Me        | Hack       | 2018-12-15 00:42:31 | 0            |\n| 4       | /hackable/users/pablo.jpg   | pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein)  | Picasso   | Pablo      | 2018-12-15 00:42:31 | 0            |\n| 5       | /hackable/users/smithy.jpg  | smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith     | Bob        | 2018-12-15 00:42:31 | 0            |\n+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里就可以看到 \u003ccode\u003edvwa.users\u003c/code\u003e 表的全部内容，甚至连简单密码都帮你完成了爆破。\u003c/p\u003e\n\u003cp\u003e更多内容可以自行尝试，说真的，这个工具相当强大。如果仅仅说我针对某型数据库(例如 MySQL)完成诸如基于报错的注入，在不考虑鲁棒性的情况下，完全可以做到。但是支持超10余种数据库，且自动完成注入的全过程...\u003c/p\u003e\n\u003ch2\u003e预编译 SQL\u003c/h2\u003e\n\u003cp\u003e提了这么多，究竟 SQL 注入就不能够预防吗? 当然可以，不然整个网络环境下的WEB应用不得都完蛋了。有釜底抽薪的处理方式吗，也有。\u003c/p\u003e\n\u003cp\u003e预编译 SQL 就是一个超级 OK 的解决方案。同时在使用上也能够明显提升 DB 查询效率\u003c/p\u003e\n\u003cp\u003e我相信预编译 SQL 很多人写过，毕竟借助例如 MyBatis 框架，能够快速实现 SQL 预编译语句的编写。同时在求学过程中估计也都用过 Java 原生 JDBC 的 \u003ccode\u003ePreparedStatement\u003c/code\u003e 。\u003c/p\u003e\n\u003cp\u003e那么，与 MySQL 交互时的预编译 SQL 是怎么样地填上了占位符呢? 先来看看再说\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003emysql\u003e prepare {name} from 'SELECT * FROM users WHERE user=? AND passwd=?'; # 这里的 {name} 可以自定义命名，无需 {}\n\nmysql\u003e set @a='admin', @b='password';     # 声明变量，并赋值\n\nmysql\u003e execute {name} using @a, @b;     # 提供变量并执行预编译 SQL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我想看到这里应该就应该能够明白了吧，MySQL 对于预编译 SQL 的每一个占位符，都已经认定了是单一的元素，也就不可能存在允许打破已有预编译结果的内容了。\u003c/p\u003e\n\u003cp\u003e即使真的注入了 \u003ccode\u003eadmin OR 1=1\u003c/code\u003e 之类的内容，也是会被认为这是一个完整的字符串，用来替代 \u003ccode\u003euser\u003c/code\u003e 字段或 \u003ccode\u003epasswd\u003c/code\u003e 字段，根本不可能重新拆解。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e __                    __                  \n/ _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。\u003c/p\u003e\n\u003cp\u003e最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。\u003c/p\u003e\n\u003cp\u003e更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: \"我用不用现成的工具只是取决于我想不想自己再写一套\"\u003c/p\u003e\n\u003cp\u003e当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。\u003c/p\u003e"}],"items":32,"pages":4,"currentPage":0},"buildId":"YsOqVyLvFnUbWFBFmGa7N","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/" src="https://www.ffutop.com/blog/_next/static/YsOqVyLvFnUbWFBFmGa7N/pages/index.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/YsOqVyLvFnUbWFBFmGa7N/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.74c43a0e96cfe845a889.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>