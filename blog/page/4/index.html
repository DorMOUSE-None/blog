<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/ujZVwdt9FYQDcwzYKNDVs/pages/index.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/ujZVwdt9FYQDcwzYKNDVs/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.74c43a0e96cfe845a889.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.a1d4ae30.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.42fbd406.chunk.css"/></head><body><div id="__next"><header class="component-header"><h1 class="title">ffutop</h1><ul class="nav-items"><li><a href="/blog/index">博客</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/about">关于</a></li></ul></header><div><main class="main"><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-03-01-区块链简单介绍">区块链技术概述</a></h1><div><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg" alt="区块链简单结构"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg" alt="Merkle tree"></p></div><p><a href="/blog/2018-03-01-区块链简单介绍">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-01-15-Spring-JDBC-Code-Reading">Spring JDBC 源码学习</a></h1><div><h2>概览</h2>
<p>在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。</p></div><p><a href="/blog/2018-01-15-Spring-JDBC-Code-Reading">阅读更多</a></p><hr/></div></div><div><a href="/blog/page/3">上一页</a></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/","query":{"mdDatasParts":[{"url":"2018-03-01-区块链简单介绍","fileName":"2018-03-01-区块链简单介绍.md","title":"区块链技术概述","author":"fangfeng","date":"2018-03-01T00:00:00.000Z","tags":["BlockChain","Smart Contract"],"content":"\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg\" alt=\"区块链简单结构\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg\" alt=\"Merkle tree\"\u003e\u003c/p\u003e\n\u003ch2\u003e基本工作流程\u003c/h2\u003e\n\u003ch3\u003e新交易发起流程\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e用户通过公/私钥与区块链网络进行交互\u003c/li\u003e\n\u003cli\u003e处理用户交易的节点向网络邻节点广播用户交易\u003c/li\u003e\n\u003cli\u003e邻节点验证交易的有效性；可信，继续向其它邻节点广播；不可信，丢弃。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e新区块产生流程\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e矿工尝试将一个时间区间内的交易进行打包形成新区块（怎么打包，看下文）\u003c/li\u003e\n\u003cli\u003e生产出新区块的矿工节点向网络广播新区块\u003c/li\u003e\n\u003cli\u003e收到新区块的网络节点验证该区块的有效性\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca href=\"https://blockchain.info/zh-cn\"\u003e比特币区块浏览器\u003c/a\u003e      更多\u003ca href=\"https://en.wikipedia.org/wiki/Metric_prefix\"\u003e国际单位制前缀\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e网络共识\u003c/h2\u003e\n\u003cp\u003e所有区块链网络节点需要对交易以及其在新区块里面的顺序达成一致（交易的有效性以及交易的打包顺序）。\u003c/p\u003e\n\u003cp\u003e可能出现：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e女巫攻击——单一实体以多重身份重复对新区块结果进行表决（少数人抓住了网络的投票权）\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98\"\u003e拜占庭将军问题\u003c/a\u003e——分布式对等网络的通信容错问题\u003cul\u003e\n\u003cli\u003e不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动\u003cul\u003e\n\u003cli\u003e成员计算机可能出错而发送错误信息\u003c/li\u003e\n\u003cli\u003e网络的不可靠性\u003c/li\u003e\n\u003cli\u003e从而影响网络共识的达成，破坏一致性。\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e不解决的话可能导致——区块链分叉\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e解决方案：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e工作量证明（proof-of-work, PoW），权益证明(proof-of-stake, PoS)，白名单机制（仅适用于私有网络）等\u003c/li\u003e\n\u003cli\u003e实用拜占庭容错算法\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e局限\u003c/h3\u003e\n\u003cp\u003e网络共识机制的实现导致了：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e交易吞吐量\u003c/li\u003e\n\u003cli\u003e更高的交易时延。交易确认时间（只有打包的新区块中才交易才会被承认）。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e共识机制的伸缩可以一定程度上解决上述问题\u003c/p\u003e\n\u003ch2\u003e资产交易\u003c/h2\u003e\n\u003cp\u003e简单交易状态描述，以集中式数据库为例\u003c/p\u003e\n\u003cp\u003e假设初始状态为\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e-------------------------\n| 资产类型 | 所有者 | 数量 |\n-------------------------\n|   CNY   |  防风  |  10 |\n-------------------------\n|   CNY   |  红薯  |  0  |\n-------------------------\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e防风 向 红薯 转账 2 CNY \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e-------------------------\n| 资产类型 | 所有者 | 数量 |\n-------------------------\n|   CNY   |  防风  |  8  |\n-------------------------\n|   CNY   |  红薯  |  2  |\n-------------------------\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e数据库中相应记录的更改完成了资产的交易过程。\u003c/p\u003e\n\u003cp\u003e在区块链中，仍然将分布式链看作是一个达成共识的集中式数据库\u003c/p\u003e\n\u003cp\u003e那么现在的初始状态可以表示成\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e---------------------------------\n| 资产类型 |     所有者     | 数量 |\n---------------------------------\n|   IOTA  |  防风 pub_key  | 10  |\n---------------------------------\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在的所有者由公钥表示，想要修改记录必须提供对应的密钥。\u003c/p\u003e\n\u003cp\u003e例如，防风 向 红薯 转账 2 IOTA ，需要提供防风的私钥和红薯的公钥。交易记录修改结果：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e---------------------------------\n| 资产类型 |     所有者     | 数量 |\n---------------------------------\n                                 被删除了         |   IOTA  |  防风 pub_key  | 10  |\n---------------------------------\n|   IOTA  |  红薯 pub_key  |  2  |\n---------------------------------\n|   IOTA  |  防风 pub_key  |  8  |\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e交易的概念流程：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e定位防风所有的资产记录行\u003c/li\u003e\n\u003cli\u003e删除该行前验证密钥\u003c/li\u003e\n\u003cli\u003e确认该记录没有被别的交易使用（双花问题，双重交易）\u003c/li\u003e\n\u003cli\u003e写入新的正确的记录（红薯获得的资产 \u0026#x26; 防风剩余的资产），确保交易前与交易后资产总额不变\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e上面的模型 —— 基于比特币的交易模型(UTXO \u003cem\u003emodel\u003c/em\u003e)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e适合于数字标记资产的传输与追踪\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e概念：UTXO (unspent transaction outputs) 未花费的交易输出：数据库现有的记录\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e---------------------------------\u003c/p\u003e\n\u003cp\u003e另一种模型常用于智能合约 —— 基于账号的模型(account-based \u003cem\u003emodel\u003c/em\u003e)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e提供了建立多步骤执行的基本机制\u003c/strong\u003e \u003c/p\u003e\n\u003ch3\u003e资产如何产生\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e比特币：\u003cul\u003e\n\u003cli\u003e矿工节点允许在挖出的新节点中加入一种 coinbase 类型的交易（不存在交易输入，新资产数额有比特币链提前定义）\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e在创始新代币的时候全额发行\u003c/li\u003e\n\u003cli\u003e其它机制\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e区块链特性\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e一种健壮的、真正的分布式对等系统，它能容忍节点故障。\u003c/li\u003e\n\u003cli\u003e能够识别冲突和分叉并自动解决的网络，以便收敛到单一的、公认的唯一状态。（区块链永远选择最长的分支来达成网络上的共识）\u003c/li\u003e\n\u003cli\u003e网络活动的透明性、可验证性、可审计性。我们能获取可验证的过程，无论它们是否交换和跟踪数字资产，还是数据驱动的交互。每一个行为，都存有公开的与网络交互的记录，并以此来消除人为的矛盾。\u003c/li\u003e\n\u003cli\u003e这是一种可以标记不同信息的触发者的方法，并且能够在没有中央权威的情况下强制执行。\u003c/li\u003e\n\u003cli\u003e这是一个使得不信任双方根据可预测的、确定性的方式交互的系统。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e智能合约\u003c/h2\u003e\n\u003cp\u003e自动化地执行一系列合约条款的交易协议\u003c/p\u003e\n\u003cp\u003e智能合约是存储在区块链中的脚本（认识上可以与关系型数据库的存储过程类似）。\u003c/p\u003e\n\u003cp\u003e以基于账号的模型为例对合约执行进行描述：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e假设定义一个合约，包括三个方法\n\n(1) “存储”——合约的“存款”功能允许 防风（通过防风的密钥验证）将若干单位的X存入合约中；\n(2) “交易”——“交易”功能允许任何人向合约发送5单位Y，并从合约持有的X中返回1单位给交易方；\n(3) “撤销”——“撤销”功能允许 防风 取出合约中存有的所有资产。\n\n    请注意，上述“存款”和“撤销”功能被限制为只允许被 防风（实际上是防风的私钥）调用。当然，这只有由于上述合约由防风制定。若人为的制定一个所有人都能调用任何功能的合约也是允许的（虽然这在事实上没有意义）。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e那么在基于账户的模型下，可以认为 拥有“存储”、“交易”、“撤销”方法的合约持有一个单独的账户（与用户所持有的账户等价）。\u003c/p\u003e\n\u003cp\u003e在上述合约下，这个账户将可能持有一定数量的资产。除了只能按照预定的合约步骤对资产进行处置之外，其它与用户持有的账户别无二致。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e  __                    __\n / _| __ _ _ __   __ _ / _| ___ _ __   __ _\n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/\n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg\" alt=\"区块链简单结构\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg\" alt=\"Merkle tree\"\u003e\u003c/p\u003e"},{"url":"2018-01-15-Spring-JDBC-Code-Reading","fileName":"2018-01-15-Spring-JDBC-Code-Reading.md","title":"Spring JDBC 源码学习","author":"fangfeng","date":"2018-01-15T00:00:00.000Z","tags":["Spring","JDBC"],"content":"\u003ch2\u003e概览\u003c/h2\u003e\n\u003cp\u003e在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e/**\n * copied from https://www.tutorialspoint.com/jdbc/jdbc-sample-code.htm\n * updated by DorMOUSENone\n */\n\n//STEP 1. 引入必须的包\nimport java.sql.*;\n\npublic class Example {\n    // JDBC 驱动名 与 DB URL \n    static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\";  \n    static final String DB_URL = \"jdbc:mysql://\u0026#x3C;host\u003e:\u0026#x3C;port\u003e/\u0026#x3C;dbName\u003e\";\n\n    // 数据库登录验证 (用户名、密码等)\n    static final String USER = \"username\";\n    static final String PASS = \"password\";\n   \n    public static void main(String[] args) {\n        Connection conn = null;\n        Statement stmt = null;\n        try{\n            //STEP 2: 注册驱动(注册到驱动管理器 DriverManager 类中)\n            Class.forName(\"com.mysql.jdbc.Driver\");\n\n            //STEP 3: 创建一个连接\n            System.out.println(\"Connecting to database...\");\n            conn = DriverManager.getConnection(DB_URL,USER,PASS);\n\n            //STEP 4: 执行一个查询\n            System.out.println(\"Creating statement...\");\n            stmt = conn.createStatement();\n            String sql;\n            sql = \"SELECT id, first, last, age FROM Employees\";\n            ResultSet rs = stmt.executeQuery(sql);\n\n            //STEP 5: 将结果从结果集(ResultSet)中取出\n            while(rs.next()){\n                //根据列名逐一取出数据\n                int id  = rs.getInt(\"id\");\n                int age = rs.getInt(\"age\");\n                String first = rs.getString(\"first\");\n                String last = rs.getString(\"last\");\n\n                //展示结果\n                System.out.print(\"ID: \" + id);\n                System.out.print(\", Age: \" + age);\n                System.out.print(\", First: \" + first);\n                System.out.println(\", Last: \" + last);\n            }\n            //STEP 6: 清理环境\n            rs.close();\n            stmt.close();\n            conn.close();\n        }catch(SQLException se){\n            //处理 JDBC 错误\n            se.printStackTrace();\n        }catch(Exception e){\n            //处理 Class.forName() 引起的错误\n            e.printStackTrace();\n        }finally{\n            // finally 代码库来关闭资源\n            try{\n                if(stmt!=null)\n                    stmt.close();\n            }catch(SQLException se2){\n            }// 不做任何处理\n            try{\n                if(conn!=null)\n                    conn.close();\n            }catch(SQLException se){\n                se.printStackTrace();\n            }\n        }\n        System.out.println(\"Goodbye!\");\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从上面的通用 JDBC 代码可以看到，利用 Java 原生提供的 java.sql.* 包可以完成注册驱动，创建连接，执行查询，处理结果等一系列一整套操作。\u003c/p\u003e\n\u003cp\u003e而 Spring-JDBC 对于 Java 原生提供的 JDBC ，对一系列数据及操作进行了整合：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e实现了 DataSource 接口，用于整合数据源配置，将各种零散的属性值（诸如 URL、用户名、 密码等）整合成完整的一个对象，便于重用；也实现了 getConnection(…) 接口，便于直接通过 DataSource 获取连接。\u003c/li\u003e\n\u003cli\u003e对执行查询的流程进行了封装。\u003c/li\u003e\n\u003cli\u003e对结果集的处理提供了多种接口，针对不同的应用场景可自由选择所必须的实现类。例如直接通过 JDBC 获得 Bean ，而无需如上例 39-42 行所示，逐一编码进行提取。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e本节提供对《Spring-JDBC 源码学习》完整学习过程的一个梳理：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"http://blog.csdn.net/dormousenone/article/details/79035440\"\u003eJdbcTemplate\u003c/a\u003e 一节作为学习 Spring-jdbc 的切入点，是 org.springframework.jdbc.core 包中的核心类，是一个提供不同场景下数据库操作的模板类。主要描述其持有的属性 DataSource 等以及其实现的方法。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://blog.csdn.net/dormousenone/article/details/79037012\"\u003eDataSource\u003c/a\u003e 一节承接 JdbcTemplate 一节，提供 Spring-jdbc 对数据源的一个包装与应用。同时描述其核心方法 getConnection(…) 的实现。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://blog.csdn.net/dormousenone/article/details/79042212\"\u003eDriverManager\u003c/a\u003e 描述其对不同数据库供应商提供的驱动的管理与使用方法。同时简单描述通过具体驱动获得一个连接的实现。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://blog.csdn.net/dormousenone/article/details/79046865\"\u003ePreparedStatement \u0026#x26; CallableStatement\u003c/a\u003e 一节主要表述 Spring-jdbc 如何对执行查询的流程进行了封装。特别是对于 PreparedStatement 与 CallableStatement 这类预置可变 SQL 语句，在执行前必须对其中可变参数进行补全的 Statement 。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://blog.csdn.net/dormousenone/article/details/79062275\"\u003eResultSet\u003c/a\u003e 描述 Spring-jdbc 如何对结果集进行处理，提供了多种不同的接口实现不同的处理逻辑。这种封装后的操作可以极大地简化直接使用 Java 原生 JDBC 所必须的硬编码提取数据的问题。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eJdbcTemplate\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fn90ghu9ufj30ki0jm75t.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eJdbcTemplate 类作为 org.springframework.core 包下的核心类，对 Java 实现的 JDBC 进行了一定程度的封装，可以简化 JDBC 的使用，同时避免许多常见的错误。由该类来执行 JDBC 工作流，应用程序只需要提供 SQL 语句就可以获得 DB 执行结果（😀，当然实际操作上没有描述的这么简单）。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e使用 JdbcTemplate 类只需要实现两个回调接口 PreparedStatementCreator (创建一个 PreparedStatement，给定连接，提供 SQL 语句以及必要的参数), ResultSetExtractor (用于花式获取结果集)。当然，不实现上述两个接口也可以进行简单的数据库操作，比如只通过 JdbcTemplate 获取一个连接(Connection) 或者执行一个静态 SQL Update。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e看不懂无所谓，先继续向下看，会做更详细的讲解。\u003c/em\u003e\u003c/p\u003e\n\u003ch3\u003eJdbcAccessor\u003c/h3\u003e\n\u003cp\u003e首先了解 JdbcTemplate 的实现，JdbcTemplate 继承了 JdbcAccessor 抽象类，该抽象类有两个主要属性—— \u003cstrong\u003eDataSource dataSource\u003c/strong\u003e \u0026#x26; \u003cstrong\u003eSQLExceptionTranslator exceptionTranslator\u003c/strong\u003e ，以及一个懒加载标识符 \u003cstrong\u003elazyInit\u003c/strong\u003e 。\u003c/p\u003e\n\u003cp\u003e其中，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDataSource 可以认为是一个存储有与数据库相关的属性实例，主要方法包括 \u003ccode\u003eConnection getConnection()\u003c/code\u003e \u0026#x26; \u003ccode\u003eConnection getConnection(String username, String password)\u003c/code\u003e 。\u003c/li\u003e\n\u003cli\u003eSQLExceptionTranslator 利用策略模式将 Java 定义的 SQLException 转换成 Spring 声明的 DataAccessException。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eJdbcAccessor 实现的 InitializingBean 接口，InitializingBean 接口为 Bean 提供了一个初始化实例的方法 —— afterPropertiesSet() 方法，凡是继承该接口的类，一般都在类构造方法中执行该方法。同样的，声明初始化实例调用的方法还可采用 \u003ccode\u003e\u0026#x3C;bean id=\"\" class=\"\" init-method=\"myInitMethod\"/\u003e\u003c/code\u003e 在初始化 bean 时执行 myInitMethod() 方法。具体执行顺序为 ：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ebean 的属性注入\u003c/li\u003e\n\u003cli\u003e调用 afterPropertiesSet() 方法\u003c/li\u003e\n\u003cli\u003e执行 myInitMethod() 方法\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e此处继承该接口是为了实现 DataSource 验证以及 SQLExceptionTranslator 的懒加载 OR NOT 的选择。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic void afterPropertiesSet() {\n    if (getDataSource() == null) {  // 判断是否注入了 DataSource\n        throw new IllegalArgumentException(\"Property 'dataSource' is required\");\n    }\n    if (!isLazyInit()) {    // 根据懒加载标识符选择执行与否\n        getExceptionTranslator();   // 获取一个 SQLExceptionTranslator 实例\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e该方法在 BeanFactory 完成该 bean 的依赖注入后执行，将首先判断 DataSource 是否已经被注入，再根据懒加载标识符来决定是否实例化一个 SQLExceptionTranslator 。\u003c/p\u003e\n\u003ch3\u003eJdbcOperations\u003c/h3\u003e\n\u003cp\u003e同时，JdbcTemplate 类实现了 JdbcOperations 接口，该接口定义了基本的 JDBC 操作。基本方法如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(ConnectionCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(StatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(PreparedStatementCreator psc, PreparedStatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(CallableStatementCreator csc, CallableStatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fncp2ncqd6j31j00au0uv.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e其它的 execute(…) , query(…), update(…) 等最终都将调用上述 4 种方法其一来完成目的。\u003c/p\u003e\n\u003cp\u003e详细观察上述方法的入参， ConnectionCallback, StatementCallback, PreparedStatementCallback 和 CallableStatementCallback 四个 Callback 接口，分别都是函数式接口，其中的唯一方法 doInXXX() 将在 execute() 中被调用，以此实现获得 ResultSet 并返回 Result 。execute 中调用 doInXXX() 的通用代码如下 （以 Statement 为例）：\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e对于不理解\u003cstrong\u003e回调\u003c/strong\u003e的同学，请自行了解概念\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic \u0026#x3C;T\u003e T execute(StatementCallback\u0026#x3C;T\u003e action) throws DataAccessException {\n    // 通过工具类 DataSourceUtils 获取一个连接\n    Connection con = DataSourceUtils.getConnection(obtainDataSource());\n    // 一个 Statement 空实例，PreparedStatement, CallableStatement 类似\n    Statement stmt = null;\n    try {\n        stmt = con.createStatement();   // 通过连接(Connection)获取一个 Statement\n        applyStatementSettings(stmt);   // 配置 Statement 参数\n        // 回调执行 doInXXX() 方法, 并获得 result\n        T result = action.doInStatement(stmt);  \n        handleWarnings(stmt);\n        return result;\n    }\n    catch (SQLException ex) {\n        // Release Connection early, to avoid potential connection pool deadlock\n        // in the case when the exception translator hasn't been initialized yet.\n        String sql = getSql(action);\n        JdbcUtils.closeStatement(stmt);\n        stmt = null;\n        DataSourceUtils.releaseConnection(con, getDataSource());\n        con = null;\n        throw translateException(\"StatementCallback\", sql, ex);\n    }\n    finally {\n        JdbcUtils.closeStatement(stmt);\n        DataSourceUtils.releaseConnection(con, getDataSource());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于 Statement, PreparedStatement, CallableStatement 的区别，首先下图表现了三个接口的继承关系。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStatement 可以支持静态 SQL 语句\u003c/li\u003e\n\u003cli\u003ePreparedStatement 支持可变参数的 SQL 语句\u003c/li\u003e\n\u003cli\u003eCallableStatement 支持可变参数的 SQL 语句，并且支持定制 DB 的输出结果\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fncpaec17yj30ew0hcdh7.jpg\"\u003e\u003c/p\u003e\n\u003ch2\u003eDataSource\u003c/h2\u003e\n\u003cp\u003e上一节在粗略地了解了 JdbcTemplate 提供的方法之后，下面先来对 DataSource 做一点了解。\u003c/p\u003e\n\u003ch3\u003eJava 提供的 DataSource 定义\u003c/h3\u003e\n\u003cp\u003eDataSource 是 Java 核心库提供的接口。位于 javax.sql package 下。\u003c/p\u003e\n\u003cp\u003eDataSource 接口可以被视作是一个提供物理 DB 实例连接(Connection) 的工厂，通过 DataSource 持有的各种属性（包括 DB Url, Username, Password 等）来获取一个连接(Connection) 。DataSource 接口有三种不同的实现方案：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e最基本的实现——生产一个标准连接(Connection) 对象\u003c/li\u003e\n\u003cli\u003e连接池方案——生产会被自动添加到连接池的对象\u003c/li\u003e\n\u003cli\u003e分布式事物实现——生产一个可以支持分布式事物，并默认被添加到连接池的连接对象\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e包括两个对外提供连接(Connection) 对象的方法，\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eConnection getConnection() throws SQLException;\nConnection getConnection(String username, String password) throws SQLException;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其父接口 CommonDataSource 提供设置/获取 LogWriter，登录 DB 超时时间和获取父 Logger 的方法。\u003c/p\u003e\n\u003ch3\u003eSpring-JDBC 扩展的 DataSource 定义\u003c/h3\u003e\n\u003cp\u003e在 Spring-jdbc 下，DataSources 最顶级的类是 AbstractDataSource ，对 DataSource 的所有父接口方法做了实现。但保留 getConnection() 方法由子类实现。\u003c/p\u003e\n\u003cp\u003e在 AbstractDriverBasedDataSource 中，定义了大量的参数，诸如 url, username 等，这些都被用来定位并定义与数据库实例的连接。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic abstract class AbstractDriverBasedDataSource extends AbstractDataSource {\n\n   @Nullable\n   private String url;\n\n   @Nullable\n   private String username;\n\n   @Nullable\n   private String password;\n\n   @Nullable\n   private String catalog;\n\n   @Nullable\n   private String schema;\n\n   @Nullable\n   // 可以看到此处有一个 Properties 类\n   private Properties connectionProperties;\n   \n   // 省略若干方法\n  \n\n    @Override\n    public Connection getConnection() throws SQLException {\n        // 调用内部方法 getConnectionFromDriver()\n        return getConnectionFromDriver(getUsername(), getPassword());\n    }\n\n    @Override\n    public Connection getConnection(String username, String password) throws SQLException {\n        // 调用内部方法 getConnectionFromDriver()\n        return getConnectionFromDriver(username, password);\n    }\n  \n   // 定义了一个获取 Connection 的方法，由 getConnection() 方法调用，\n   // 此方法主要是将属性做了一个整合\n   // 具体获取 Connection 的逻辑仍然下放到子类实现 见 40 行\n   protected Connection getConnectionFromDriver(@Nullable String username, @Nullable String password) throws SQLException {\n        Properties mergedProps = new Properties();\n        Properties connProps = getConnectionProperties();\n        if (connProps != null) {\n            mergedProps.putAll(connProps);\n        }\n        if (username != null) {\n            mergedProps.setProperty(\"user\", username);\n        }\n        if (password != null) {\n            mergedProps.setProperty(\"password\", password);\n        }\n        \n        // 获取 Connection 逻辑下放\n        Connection con = getConnectionFromDriver(mergedProps);\n        if (this.catalog != null) {\n            con.setCatalog(this.catalog);\n        }\n        if (this.schema != null) {\n            con.setSchema(this.schema);\n        }\n        return con;\n    }\n  \n    // 该类中获取 Connection 的方法是抽象方法\n    protected abstract Connection getConnectionFromDriver(Properties props) throws SQLException;\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e整合方案为将除 url 外的所有参数整合在同一个 Properties 对象中 (其中，Properties 可以被认为是一个线程安全的 Hash Map) 。最终调用 \u003ccode\u003eConnection getConnectionFromDriver(Properties props)\u003c/code\u003e 获取连接。\u003c/p\u003e\n\u003cp\u003eAbstractDriverBasedDataSource 抽象类的两个子类 DriverManagerDataSource 和 SimpleDriverDataSource 都以不同方式获得了连接(Connection)，但总结而言，获取连接(Connection) 的任务被委托给了 Driver 来实现（其中，Driver 有 Java 定义接口，并由各数据库提供商提供，例如 MySQL 提供了 mysql-connector-java-XXX.jar 来完成针对相应数据库的具体实现）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ----------------------------\n// SimpleDriverDataSource 的实现\n// ----------------------------\n@Override\nprotected Connection getConnectionFromDriver(Properties props) throws SQLException {\n    Driver driver = getDriver();\n    String url = getUrl();\n    Assert.notNull(driver, \"Driver must not be null\");\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Creating new JDBC Driver Connection to [\" + url + \"]\");\n    }\n    // 哈哈，重点在这... driver 在该类中被预先注入\n    return driver.connect(url, props);\n}\n\n// -----------------------------\n// DriverManagerDataSource 的实现\n// -----------------------------\n@Override\nprotected Connection getConnectionFromDriver(Properties props) throws SQLException {\n    String url = getUrl();\n    Assert.state(url != null, \"'url' not set\");\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Creating new JDBC DriverManager Connection to [\" + url + \"]\");\n    }\n    // 调了个内部函数\n    return getConnectionFromDriverManager(url, props);\n}\n\nprotected Connection getConnectionFromDriverManager(String url, Properties props) throws SQLException {\n    // 委托给 DriverManager 类来获取连接\n    // DriverManager 的主要操作是遍历在该管理类中注册的 Driver\n    // 每个 Driver 实例都去尝试一下，能不能获得一个连接\n    // 第一次在某个 Driver 中拿到一个连接即返回连接 (Connection)\n    return DriverManager.getConnection(url, props);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e简要的类图如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fncrgqcjqoj31es15ajxj.jpg\"\u003e\u003c/p\u003e\n\u003ch2\u003eDriverManager\u003c/h2\u003e\n\u003cp\u003e上面提到 DataSource 获取连接(Connection) 的操作实质上将委托具体的 Driver 来提供 Connection 。有两种不同的方式，包括经由 DriverManager 遍历所有处于管理下的 Driver 尝试获取连接，或者在 DataSource 实例中直接声明一个特定的 Driver 来获取连接。\u003c/p\u003e\n\u003cp\u003e对于获取连接的具体操作，挖坑-待填。只描述简单的数据库供应商提供的 Driver 如何与 java 相联系。\u003c/p\u003e\n\u003cp\u003e###在 DriverManager 中注册 Driver 实例\u003c/p\u003e\n\u003cp\u003e通常在与数据库交互逻辑的 Java 代码中，都会有 \u003ccode\u003eClass.forName(\"com.mysql.jdbc.Driver\")\u003c/code\u003e (此处以 MySQL 提供的 mysql-connector-java-XXX.jar 为例，下同）的代码块，加载指定的 com.mysql.jdbc.Driver 为 java.lang.Class 类。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e当然，在 JDBC 4.0 标准下，可以不必再显示声明 \u003ccode\u003eClass.forName(\"\")\u003c/code\u003e 语句，Driver 也同样会在 DriverManager 初始化时自动注册。\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Class 类中对于 forName(String className) 的方法\n// 作用为返回一个 java.lang.Class 实例。\npublic static Class\u0026#x3C;?\u003e forName(String className) throws ClassNotFoundException {...}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e同时， JVM 在加载类的过程中会执行类中的 static 代码块。下述 row 10 ~ 16 的代码片段将被执行。唯一的逻辑就是 new 一个 com.mysql.jdbc.Driver 实例，并将实例注册(registerDriver) 到 \u003cstrong\u003ejava.sql.DriverManager\u003c/strong\u003e 中。 \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.mysql.jdbc;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n    // ~ Static fields/initializers\n    // ---------------------------------------------\n\n    //\n    // Register ourselves with the DriverManager\n    //\n    static {\n        try {\n            java.sql.DriverManager.registerDriver(new Driver());\n        } catch (SQLException E) {\n            throw new RuntimeException(\"Can't register driver!\");\n        }\n    }\n\n    // ~ Constructors\n    // -----------------------------------------------------------\n\n    /**\n     * Construct a new driver and register it with DriverManager\n     * \n     * @throws SQLException\n     *             if a database error occurs.\n     */\n    public Driver() throws SQLException {\n        // Required for Class.forName().newInstance()\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e下面再来看一下 DriverManager 中的 registerDriver() 方法。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DriverManager {\n\n    // DriverManager 维护一个线程安全的 Driver 列表\n    // 此处的 DriverInfo 里面即包装了 Driver \n    private final static CopyOnWriteArrayList\u0026#x3C;DriverInfo\u003e registeredDrivers = \n        new CopyOnWriteArrayList\u0026#x3C;\u003e();\n\n    // 在 DriverManager 中注册 Driver\n    public static synchronized void registerDriver(java.sql.Driver driver)\n        throws SQLException {\n        registerDriver(driver, null);\n    }\n  \n    public static synchronized void registerDriver(java.sql.Driver driver,\n            DriverAction da)\n        throws SQLException {\n\n        /* 如果当前 Driver 不在列表中，即添加到列表。 */\n        if(driver != null) {\n            registeredDrivers.addIfAbsent(new DriverInfo(driver, da));\n        } else {\n            // This is for compatibility with the original DriverManager\n            throw new NullPointerException();\n        }\n\n        println(\"registerDriver: \" + driver);\n\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e通过 DriverManager 获取连接(Connection)\u003c/h3\u003e\n\u003cp\u003e上一节有提到过可以通过 DriverManager 来遍历获取连接，也可以直接声明具体 Driver 并获取连接。下面代码展示的是通过 DriverManager 获取连接的操作。 \u003cdel\u003e哈哈哈，反正最后都是由具体驱动实现获取连接。\u003c/del\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DriverManager {\n    // 获取连接的 public 接口 (1)\n    public static Connection getConnection(String url,\n        java.util.Properties info) throws SQLException {\n        return (getConnection(url, info, Reflection.getCallerClass()));\n    }\n    // 获取连接的 public 接口 (2)\n    public static Connection getConnection(String url,\n        String user, String password) throws SQLException {\n        java.util.Properties info = new java.util.Properties();\n\n        if (user != null) {\n            info.put(\"user\", user);\n        }\n        if (password != null) {\n            info.put(\"password\", password);\n        }\n\n        return (getConnection(url, info, Reflection.getCallerClass()));\n    }\n    // 获取连接的 public 接口 (3)\n    public static Connection getConnection(String url)\n        throws SQLException {\n        java.util.Properties info = new java.util.Properties();\n        return (getConnection(url, info, Reflection.getCallerClass()));\n    }\n \n    // 获取连接的内部逻辑实现\n    private static Connection getConnection(\n        String url, java.util.Properties info, Class\u0026#x3C;?\u003e caller) \n        throws SQLException {\n        /*\n         * When callerCl is null, we should check the application's\n         * (which is invoking this class indirectly)\n         * classloader, so that the JDBC driver class outside rt.jar\n         * can be loaded from here.\n         */\n        ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;\n        synchronized(DriverManager.class) {\n            // synchronize loading of the correct classloader.\n            if (callerCL == null) {\n                callerCL = Thread.currentThread().getContextClassLoader();\n            }\n        }\n        // url 是定位 DBMS 最重要的参数，不能为空\n        if(url == null) {\n            throw new SQLException(\"The url cannot be null\", \"08001\");\n        }\n\n        println(\"DriverManager.getConnection(\\\"\" + url + \"\\\")\");\n\n        // 遍历所有注册的 Driver ，并都尝试获取连接(Connection)\n        SQLException reason = null;\n\n        for(DriverInfo aDriver : registeredDrivers) {\n            // 判断注册的 Driver 是否由 ClassLoader callerCL 加载，不是则跳过\n            if(isDriverAllowed(aDriver.driver, callerCL)) {\n                try {\n                    println(\"    trying \" + aDriver.driver.getClass().getName());\n                    // 获取连接，:) 还是由 driver 实例自行提供\n                    Connection con = aDriver.driver.connect(url, info);\n                    if (con != null) {\n                        // Success!\n                        println(\"getConnection returning \" + \n                                aDriver.driver.getClass().getName());\n                        return (con);\n                    }\n                } catch (SQLException ex) {\n                    if (reason == null) {\n                        reason = ex;\n                    }\n                }\n\n            } else {\n                println(\"    skipping: \" + aDriver.getClass().getName());\n            }\n\n        }\n\n        // 如果运行到下列代码，则表明获取连接失败，抛出错误\n        if (reason != null)    {\n            println(\"getConnection failed: \" + reason);\n            throw reason;\n        }\n\n        println(\"getConnection: no suitable driver found for \"+ url);\n        throw new SQLException(\"No suitable driver found for \"+ url, \"08001\");\n    }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003e简单的提一嘴，Connection 仍然只是一个针对 Java -\u003e DB Server 的上层接口，如果想要更深层次地了解 Connection 与 DB Server 的交互，可以尝试去看一下 com.mysql.jdbc.MysqlIO 类，MySQL 实现的 JDBC4Connection 类也是在使用该类来实现对 DB Server 交互。（哈哈，只看过 MySQL 提供的 Driver 包）。\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003ePreparedStatement \u0026#x26; CallableStatement\u003c/h2\u003e\n\u003cp\u003e在了解了 DataSource 获取连接(Connection) 的实质以及 JdbcTemplate 的通用接口之后，使用 Spring-jdbc 进行数据库相关的操作可以直截了当的利用如下代码进行实现（此处仅展示通过 Java 硬编码的形式进行实现，XML 配置方法类似）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String... args) {\n    // 定义数据源\n    DriverManagerDataSource dataSource = new DriverManagerDataSource();\n    // 配置参数\n    dataSource.setUrl(\"jdbc:mysql://\u0026#x3C;host\u003e:\u0026#x3C;port\u003e/\u0026#x3C;dbName\u003e?\u0026#x3C;props\u003e\");\n    dataSource.setUsername(\"\u0026#x3C;username\u003e\");\n    dataSource.setPassword(\"\u0026#x3C;passwd\u003e\");\n    \n    // 实例化一个 JDBC 工具类\n    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n    // 执行相关 CRUD 操作 \n    jdbcTemplate.execute();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e回顾第一节所讲的 JdbcTemplate 的 4 个基础方法：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(ConnectionCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(StatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(PreparedStatementCreator psc, PreparedStatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;T\u003e T execute(CallableStatementCreator csc, CallableStatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fndsm5tl7aj30zg0byq47.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e四个基础方法都有一个特定的回调函数将通过预配置的 DataSource 得到的 Connection 或 更进一步的 Statement or PreparedStatement or CallableStatement 作为入参来执行定义的唯一方法。\u003c/p\u003e\n\u003cp\u003e以 \u003ccode\u003e\u0026#x3C;T\u003e T execute(StatementCallback\u0026#x3C;T\u003e action);\u003c/code\u003e 为例来了解一下方法的核心逻辑。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic \u0026#x3C;T\u003e T execute(StatementCallback\u0026#x3C;T\u003e action) throws DataAccessException {\n    // 通过工具类 DataSourceUtils 获取一个连接\n    Connection con = DataSourceUtils.getConnection(obtainDataSource());\n    // 一个 Statement 空实例，PreparedStatement, CallableStatement 类似\n    Statement stmt = null;\n    try {\n        stmt = con.createStatement();   // 通过连接(Connection)获取一个 Statement\n        applyStatementSettings(stmt);   // 配置 Statement 参数\n        // 回调执行 doInXXX() 方法, 并获得 result\n        T result = action.doInStatement(stmt);  \n        handleWarnings(stmt);\n        return result;\n    } catch() {\n      \n    } finally {\n      \n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是，对于 PreparedStatement 和 CallableStatement 而言，获取一个 \u003cem\u003eXXX\u003c/em\u003eStatement 的方式就有所不同了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 获取 Statement 实例\nStatement stmt = con.createStatement();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 获取 PreparedStatement 实例\n// psc 是一个 PreparedStatementCreator 接口实现的实例\nPreparedStatement ps = psc.createPreparedStatement(con);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 获取 CallableStatement 实例\n// csc 是一个 CallableStatementCreator 接口实现的实例\nCallableStatement cs = csc.createCallableStatement(con);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 Statement 直接通过 Connection 获取实例，但是 PreparedStatement 和 CallableStatement 就有所不同，其区别就在于 PreparedStatement 和 CallableStatement 两个 Statement 都是可以定制入参的，更甚者， CallableStatement 可以定制 DB 执行结果的出参。当然，核心还是 \u003ccode\u003econ.prepareStatement() OR con.prepareCall()\u003c/code\u003e 方法，只不过是将获取 XXXStatement 的操作下放给 XXXStatementCreator 实例类实现，给予使用者重复的自主权，同时也是逻辑解耦的一种操作。\u003c/p\u003e\n\u003cp\u003e例如：\u003c/p\u003e\n\u003cp\u003eSimplePreparedStatementCreator 这个 PreparedStatementCreator 接口的实现类，只是简单的调用了 \u003ccode\u003econ.prepareStatement(sql)\u003c/code\u003e 方法。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static class SimplePreparedStatementCreator \n    implements PreparedStatementCreator, SqlProvider {\n\n    private final String sql;\n\n    @Override\n    public PreparedStatement createPreparedStatement(Connection con) \n        throws SQLException {\n        return con.prepareStatement(this.sql);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e而对于 PreparedStatementCreatorImpl ，在 createPreparedStatement(Connection con) 的实现上，又添加了更多的操作。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate class PreparedStatementCreatorImpl\n        implements PreparedStatementCreator, PreparedStatementSetter, SqlProvider, ParameterDisposer {\n\n    private final String actualSql;\n\n    private final List\u0026#x3C;?\u003e parameters;\n\n    @Override\n    public PreparedStatement createPreparedStatement(Connection con) throws SQLException {\n        PreparedStatement ps;\n        if (generatedKeysColumnNames != null || returnGeneratedKeys) {\n            if (generatedKeysColumnNames != null) {\n                // 获取一个 PreparedStatement 实例，下同\n                ps = con.prepareStatement(this.actualSql, \n                                          generatedKeysColumnNames);\n            }\n            else {\n                ps = con.prepareStatement(this.actualSql, \n                                         PreparedStatement.RETURN_GENERATED_KEYS);\n            }\n        }\n        else if (resultSetType == ResultSet.TYPE_FORWARD_ONLY \n                 \u0026#x26;\u0026#x26; !updatableResults) {\n            ps = con.prepareStatement(this.actualSql);\n        }\n        else {\n            ps = con.prepareStatement(this.actualSql, resultSetType,\n                updatableResults ? ResultSet.CONCUR_UPDATABLE : \n                                      ResultSet.CONCUR_READ_ONLY);\n        }\n        // 将可变 SQL (例如 SELECT * FROM msg WHERE id = ?) 的 ? 用实际参数替换\n        setValues(ps);\n        return ps;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从上述两种 PreparedStatementCreator 接口的不同实现，也可以从另一种角度理解到，函数式接口将获取目标出参的具体逻辑交给使用者定义，给予了使用者充分的自主权，同时也是一种业务逻辑的解耦。\u003c/p\u003e\n\u003cp\u003e在上面代码 PreparedStatementCreatorImpl 类的实现中，我们看到第 32 行代码 \u003ccode\u003esetValue(ps)\u003c/code\u003e 。此处的方法是由接口 PreparedStatementSetter 定义的。主要目的是将可变 SQL 中的 ? 参数用实际参数进行一个替换。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 以 SQL (SELECT * FROM msg WHERE id = ? AND day = ?) 为例\n/** 纯 Java 核心库的实现 PreparedStatement 参数注入 */\nps.setInt(1, 1763);\nps.setString(2, \"2018-01-01\");\nps.executeQuery();\n\n/** 以 Spring-jdbc 实现 PreparedStatement 参数注入 */\n// setValues() 由接口 PreparedStatementSetter 定义，封装了注入参数的具体实现逻辑\n// 可以由使用者自行定义\nsetValues(ps);  \nps.executeQuery();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fndyybh4q1j31kw0u3afx.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e上面类图表示了 PreparedStatementSetter 及其实现类的相关依赖。\u003c/p\u003e\n\u003cp\u003eSetter 的主要目标即为对 SQL 中的 ? 参数进行注入。\u003c/p\u003e\n\u003cp\u003e\u003cdel\u003e个人精力有限，对Spring-jdbc在Statement上对参数注入的回调理解有限。\u003c/del\u003e\u003c/p\u003e\n\u003ch2\u003eResultSet\u003c/h2\u003e\n\u003cp\u003e在前几节已经提到讲了数据源、驱动管理器以及 Statement 之后，利用 JDBC 的最重要的目的就是对 DB 进行操作，并获得预期结果。对于查询语句而言，结果应该是若干记录行；就更新语句而言，结果可能是影响的行数。而 Spring-jdbc 对 ResultSet 额外进行的封装，即是将原本散乱的结果进行一个整合，例如整合成一个(一组)完整的 Bean 来进行展示。\u003c/p\u003e\n\u003cp\u003e在 JdbcTemplate 中，四个基本方法入参都包括一个回调接口，而在执行回调获得 ResultSet 之后，方法并不是直接返回，而是进行了一定的操作。\u003c/p\u003e\n\u003cp\u003e以一个 PreparedStatementCallback 的实例类为例，在 doInPreparedStatement() 方法中，获得了 ResultSet ，但是仍通过 rse.extractData(rs) 语句进行了处理后再返回结果\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic T doInPreparedStatement(PreparedStatement ps) throws SQLException {\n    // 声明一个 ResultSet \n    ResultSet rs = null;\n    try {\n        if (pss != null) {  // setValues() 方法填充 PreparedStatement 中的可变参数 ? \n            pss.setValues(ps);\n        }\n        rs = ps.executeQuery(); // 执行查询 sql ，获取结果\n        return rse.extractData(rs); // 重点... 该语句一定是对结果进行了一些操作.\n    }\n    finally {\n        JdbcUtils.closeResultSet(rs);\n        if (pss instanceof ParameterDisposer) {\n            ((ParameterDisposer) pss).cleanupParameters();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在来看一下究竟在返回结果前进行了什么操作。\u003c/p\u003e\n\u003cp\u003e由于是一个回调接口的实现类，rse 应该在外部方法中。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic \u0026#x3C;T\u003e T query(\n        PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, \n        final ResultSetExtractor\u0026#x3C;T\u003e rse)\n        throws DataAccessException {\n\n    return execute(psc, new PreparedStatementCallback\u0026#x3C;T\u003e() {\n        @Override\n        public T doInPreparedStatement(PreparedStatement ps) throws SQLException {\n            ... \n        }\n    });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 rse 是一个 ResultSetExtractor 的实例。从名称上可以看出 Extractor 即为提取器，结果集提取器。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e/** 函数式接口，提供的唯一方法为 extractData(...) */\n@FunctionalInterface\npublic interface ResultSetExtractor\u0026#x3C;T\u003e {\n\n    @Nullable\n    T extractData(ResultSet rs) throws SQLException, DataAccessException;\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fndzz0pqnrj31a60i676v.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eSpring-jdbc 中现有的实现有三个类，其中 RowCallbackHandlerResultSetExtractor 和 RowMapperResultSetExtractor 两个类从上面类图及命名即可看出，两个是作为一个适配器而存在的，将 extractData() 进行转换，分别由 RowCallbackHandler 和 RowMapper 实例进行具体操作。而 AbstractLobStreamingResultSetExtractor 类从名称上看，也是一个类似流操作的实现类(其中的 Lob 指的是 DB 中的 BLOB 与 CLOB 类型，在 Spring-jdbc 中也加入了额外的支持) 。\u003c/p\u003e\n\u003ch3\u003eRowCallbackHandler\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fnh2uw3a0aj30h20jeta4.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e从名称上看，这是一个与 ResultSet 结果集行相关的回调接口。processRow(ResultSet rs) 方法将处理行相关的逻辑。\u003c/p\u003e\n\u003cp\u003e从它的一个实现类 RowCountCallbackHandler 来说，其最主要的私有属性 rowCount 即是统计 ResultSet 的结果行数。下面是一个具体使用的该类的案例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String[] args) throws ClassNotFoundException {\n\n    DriverManagerDataSource dataSource = new DriverManagerDataSource();\n    dataSource.setUrl(\"jdbc:mysql://\u0026#x3C;host\u003e:\u0026#x3C;port\u003e/\u0026#x3C;dbName\u003e\");\n    dataSource.setUsername(\"\u0026#x3C;username\u003e\");\n    dataSource.setPassword(\"\u0026#x3C;password\u003e\");\n\n    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n    RowCountCallbackHandler rcch = new RowCountCallbackHandler();\n\n    jdbcTemplate.query(\"SELECT * FROM info WHERE id='2018'\", (RowCallbackHandler) rcch);\n    \n    System.out.println(rcch.getRowCount()); //获取结果集行数\n    System.out.println(rcch.getColumnCount());  // 获取结果集列数\n    for (String arg : rcch.getColumnNames()) {  // 打印结果集每一列名称\n        System.out.println(\"ColumnNames : \" + arg);\n    }\n    for (int i : rcch.getColumnTypes()) {   // 打印结果集每一列类型(Types 为枚举类)\n        System.out.println(\"ColumnTypes : \" + i);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e具体查看 RowCountCallbackHandler 类的 processRow() 方法可以看到，其获取列相关信息都来自于 ResultSetMetaData 。而结果行数来源于 Iterator 迭代。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic final void processRow(ResultSet rs) throws SQLException {\n    if (this.rowCount == 0) {\n        ResultSetMetaData rsmd = rs.getMetaData();\n        this.columnCount = rsmd.getColumnCount();\n        this.columnTypes = new int[this.columnCount];\n        this.columnNames = new String[this.columnCount];\n        for (int i = 0; i \u0026#x3C; this.columnCount; i++) {\n            this.columnTypes[i] = rsmd.getColumnType(i + 1);\n            this.columnNames[i] = JdbcUtils.lookupColumnName(rsmd, i + 1);\n        }\n        // could also get column names\n    }\n    processRow(rs, this.rowCount++);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eRowMapper\u003c/h3\u003e\n\u003cp\u003e上面 RowCallbackHandler 接口从逻辑上划分是用于处理 ResultSet 元数据信息的。而 RowMapper 较上一个接口而言，有更高的实用性。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fnh3h739kaj30z60nago4.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e特别是其实现类 BeanPropertyRowMapper 可以将散乱的 ResultSet 的结果数据整理成一个个 Object Bean 作为返回结果。而省去了对逐一读取 ResultSet 行记录并填充 Bean 属性的麻烦。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n\nBeanPropertyRowMapper\u0026#x3C;Model\u003e rowMapper = new BeanPropertyRowMapper\u0026#x3C;\u003e(Model.class);\nList\u0026#x3C;Model\u003e list = jdbcTemplate.query(\"SELECT * FROM info WHERE id = '2018'\", rowMapper);\n/** 获得的 Model list 的对应属性将通过 Java 的反射机制进行填充\n *  List\u0026#x3C;Model\u003e list 即结果\n */\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当然，要求是 Model 类中的属性与 DB table 中的列名保持一致（大小写无要求）。\u003c/p\u003e\n\u003cp\u003e而其它两个类的实现也是基于反射机制，实现其相应的业务逻辑。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e概览\u003c/h2\u003e\n\u003cp\u003e在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。\u003c/p\u003e"}],"items":32,"pages":4,"currentPage":3},"buildId":"ujZVwdt9FYQDcwzYKNDVs","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/" src="https://www.ffutop.com/blog/_next/static/ujZVwdt9FYQDcwzYKNDVs/pages/index.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/ujZVwdt9FYQDcwzYKNDVs/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.74c43a0e96cfe845a889.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>