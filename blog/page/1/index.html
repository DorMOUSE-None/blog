<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><meta charSet="utf-8" class="next-head"/><title class="next-head">Utop&#x27;s Blog</title><link rel="preload" href="https://www.ffutop.com/blog/_next/static/KZWxx6ur1oSf8xr-9UZXm/pages/index.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/KZWxx6ur1oSf8xr-9UZXm/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.7e5e68e72610ac3a4255.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.f3603d0a56c82c4f5e78.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-fd73dbd6f398b7b886ec.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.736184b0.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.55a7521e.chunk.css"/></head><body><div id="__next"><header class="component-header"><h1 class="title">ffutop</h1><ul class="nav-items"><li><a href="/blog/index">博客</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/about">关于</a></li></ul></header><div><main class="main"><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2019-05-20-CLOSE_WAIT_PROBLEM">pipe 导致的 CLOSE_WAIT</a></h1><div><p>历时一周总算把导致服务大量 <code>CLOSE_WAIT</code> 的原因给找到了。打印任务调用栈果然的必备手段啊！</p>
<h2>问题描述</h2>
<p>Python 服务 A，用于接收心跳包确认其他服务是否存活。其他服务每 5 分钟向 A 发送一次心跳包；总计 &#x3C; 100 个其他服务。</p>
<ul>
<li>05-11 19:30 ，首次出现 Python 服务大量 <code>CLOSE_WAIT</code>，至 13 日发现，总计 10k 左右 <code>CLOSE_WAIT</code> 的 TCP 连接。05-13 15:30 通过运维平台重新部署...</li>
<li>05-14 16:30 ，再次出现。19:30 手动重启。</li>
<li>其间给 Python 服务 A 添加了打印调用栈的模块 <a href="https://pypi.org/project/pdbx/">pdbx</a>，通过运维平台重新部署</li>
<li>05-17 19:00 ，再次出现。等待打印调用栈，不小心杀掉了服务...</li>
<li>05-19 14:30 ，重现。</li>
<li>05-20 08:30 ，查找原因，解决问题。</li>
</ul>
<p>由于不是本人负责的服务，于 16 日凭兴趣开始有限介入，协助排查。现将排查流程一一记述，给自己和大家未来排查问题提供一个借鉴。</p></div><p><a href="/blog/2019-05-20-CLOSE_WAIT_PROBLEM">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2019-05-10-png-structure">PNG 文件格式</a></h1><div><p>PNG (Portable Network Graphics) 文件格式(第二版)。PNG 文件格式由两类结构——<code>PNG 签名(PNG Signature)</code>和若干<code>数据块(chunk)</code>组成。</p>
<p>PNG 签名相当于其他文件格式中的魔数，用于声明二进制数据所代表的格式。类似的有 <code>JAVA</code> class 文件的 <code>ca fe ba be</code>、<code>ELF</code> 文件的 <code>7f 45 4c 46</code> (.ELF) 。PNG 签名使用 <code>89 50 4e 47 0d 0a 1a 0a</code> (.PNG....) 作为魔数。</p>
<blockquote>
<p>HINT 上述的 <code>.</code> 仅仅是为了指代非打印字符，并非真的是 <code>点号</code>。</p>
</blockquote>
<p>在 <code>PNG 签名</code> 数据之后，紧接着就是 <code>数据块(chunk)</code> 的数据。虽然统称<code>数据块</code>，但存在不同类型的数据块（例如 IHDR, PLTE, IDAT, IEND 等）。每个 PNG 文件可以有若干连续的数据块（至少 3 个数据块），其中第一个数据块和最后一个数据块类型分别是 IHDR、IEND 。</p></div><p><a href="/blog/2019-05-10-png-structure">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2019-04-26-time-accuracy">MySQL TIMESTAMP 时间精度问题</a></h1><div><p>最近一段单元测试代码总是不定时地爆炸。test pass 与 failed 的比例大约 10:1 。伪代码如下:</p>
<pre><code class="language-java">/**
  * 表结构
  * CREATE TABLE `time_0` (
  *     `timeout` timestamp NOT NULL
  * )
  */

// part 1
jdbcTemplate.execute("UPDATE `time_0` SET `timeout`=now() WHERE `id` = xxx;");

// part 2
Date timeout = jdbcTemplate.queryForObject("SELECT `timeout` FROM `time_0` WHERE `id` = xxx;", Date.class);
Assert.assertTrue(timeout.getTime() &#x3C; System.currentTimeMillis());
</code></pre>
<p>在绝大多数模拟中，先执行 <code>part 1</code>，紧跟着执行 <code>part 2</code> 都能通过测试。但偶尔还是挂掉了。</p></div><p><a href="/blog/2019-04-26-time-accuracy">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2019-04-25-lex-and-yacc">Lex &amp; Yacc 学习笔记</a></h1><div><p>高级语言相较于机器语言、汇编语言，更加符合人的思考习惯。换句话说，更偏向于自然语言的风格而更偏离指令化的描述。用高级语言编写的一行代码，最终可能需要处理器执行若干条指令。如何让机器意识到高级语言代码对应的机器指令是哪些呢？当然就需要一个优秀的翻译。</p>
<p>无论是编译型语言还是解释型语言，总逃脱不了这样一个流程：高级语言 ➜ 目标平台的指令。所谓编译型/解释型的区别，在于其转换流程是在线的(online)还是离线的(offline)。在线的方式无法意识到后续的代码，但胜在即时反应；离线的方式可以统揽全局，进行更多的优化，但代码文本必须完整。</p>
<p>高级语言 ➜ 目标平台的指令，这样的流程如何实现。一般来说，划分为四个阶段：词法分析、语法分析、语义分析、目标代码生成。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2b583io0ej30wq094aa5.jpg"></p>
<p>本篇的主要目的，是展示“语言翻译”的几个阶段工作，以及通过 Lex &#x26; Yacc 工具演示一门自定义语言的“翻译”。</p></div><p><a href="/blog/2019-04-25-lex-and-yacc">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2019-04-10-understand-Kernel-10">理解 Linux Kernel(10) - Context of Execution</a></h1><div><p>在进行<a href="https://www.ffutop.com/2018-10-12-understand-Kernel-4/">第四篇(任务调度)</a>行文描述时，就一直闹不清内核所谓的<code>task</code>的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：<strong>我们错误地将理论和实践不加区分地混淆了</strong>。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，<code>task</code> 也就是 <code>Context of Execution</code> 概念在实现上的表征。</p></div><p><a href="/blog/2019-04-10-understand-Kernel-10">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2019-03-25-mem-dump">如何获取运行时进程堆栈</a></h1><div><p>前些天看了关于在密码学应用中使用<code>java.lang.String</code>与<code>byte[]</code>的相关讨论，不推荐使用<code>java.lang.String</code>的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。</p>
<h2>/proc/${pid}/maps</h2>
<p>首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从<code>/proc</code>虚拟文件系统中，提供了进程虚拟地址映射。</p>
<pre><code>address                   perm offset   dev   inode                      pathname
556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run
556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run
556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run
55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]
7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so
7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so
7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so
7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so
7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0
7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so
7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0
7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so
7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so
7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0
7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]
7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]
7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
</code></pre></div><p><a href="/blog/2019-03-25-mem-dump">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2019-03-19-JANUS">认证与授权·简述</a></h1><div><h2>概述</h2>
<blockquote>
<p>在大多数系统中，都或多或少需要认证授权模型/系统的支持。</p>
</blockquote>
<p>认证/授权是什么？最简单的，我们的系统要求用户必须在“登录”之后才允许进行一些操作。“登录”的过程就是认证；而区别与未登录状态，只允许登录用户进行一些操作，这就是授权。认证与授权相互独立，有协同配合，共同支撑起系统对安全的基本要求。</p></div><p><a href="/blog/2019-03-19-JANUS">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2019-03-05-understand-Kernel-9">理解 Linux Kernel (9) - IO Multiplexing</a></h1><div><p><a href="./2019-01-15-understand-Kernel-8/">前一篇</a>已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 <code>struct sock</code> 对象，将其逐级从网络接口层逐级提升到网络层、传输层...最终添加到接收队列 <code>sk_receive_queue</code> 中；用户进程通过 <code>read</code>、<code>recv</code>、<code>recvfrom</code> 等命令检查并获取 <code>sk_receive_queue</code> 中的数据。</p>
<p>整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。</p>
<p>那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（<code>select</code>, <code>poll</code>, <code>epoll</code>）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 <code>select</code> 和 <code>epoll</code> 两类系统调用的实现进行探究。</p></div><p><a href="/blog/2019-03-05-understand-Kernel-9">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2019-02-27-Java-Fatal-API">【Java】API 参数误定义的后果</a></h1><div><p>工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。</p>
<p>想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！</p>
<p>想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把<code>void add(int)</code> API 改写成 <code>int add(int)</code>，可能得到的大多数回答都是可以。</p></div><p><a href="/blog/2019-02-27-Java-Fatal-API">阅读更多</a></p><hr/></div></div><div class="component-page-turner"><a href="/blog/page/0"></a><a href="/blog/page/2">下一页</a></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Powered by <a href="https://reactjs.org/">React</a> and <a href="https://nextjs.org/">Next.js</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/","query":{"mdDatasParts":[{"url":"2019-05-20-CLOSE_WAIT_PROBLEM","fileName":"2019-05-20-CLOSE_WAIT_PROBLEM.md","title":"pipe 导致的 CLOSE_WAIT","author":"fangfeng","date":"2019-05-20T00:00:00.000Z","tags":["pipe","CLOSE_WAIT"],"content":"\u003cp\u003e历时一周总算把导致服务大量 \u003ccode\u003eCLOSE_WAIT\u003c/code\u003e 的原因给找到了。打印任务调用栈果然的必备手段啊！\u003c/p\u003e\n\u003ch2\u003e问题描述\u003c/h2\u003e\n\u003cp\u003ePython 服务 A，用于接收心跳包确认其他服务是否存活。其他服务每 5 分钟向 A 发送一次心跳包；总计 \u0026#x3C; 100 个其他服务。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e05-11 19:30 ，首次出现 Python 服务大量 \u003ccode\u003eCLOSE_WAIT\u003c/code\u003e，至 13 日发现，总计 10k 左右 \u003ccode\u003eCLOSE_WAIT\u003c/code\u003e 的 TCP 连接。05-13 15:30 通过运维平台重新部署...\u003c/li\u003e\n\u003cli\u003e05-14 16:30 ，再次出现。19:30 手动重启。\u003c/li\u003e\n\u003cli\u003e其间给 Python 服务 A 添加了打印调用栈的模块 \u003ca href=\"https://pypi.org/project/pdbx/\"\u003epdbx\u003c/a\u003e，通过运维平台重新部署\u003c/li\u003e\n\u003cli\u003e05-17 19:00 ，再次出现。等待打印调用栈，不小心杀掉了服务...\u003c/li\u003e\n\u003cli\u003e05-19 14:30 ，重现。\u003c/li\u003e\n\u003cli\u003e05-20 08:30 ，查找原因，解决问题。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e由于不是本人负责的服务，于 16 日凭兴趣开始有限介入，协助排查。现将排查流程一一记述，给自己和大家未来排查问题提供一个借鉴。\u003c/p\u003e\n\u003ch2\u003e问题探究\u003c/h2\u003e\n\u003ch3\u003eCLOSE_WAIT 现象梳理\u003c/h3\u003e\n\u003cp\u003e16 日拿到的信息只有前两次问题记录。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"http://img.ffutop.com/82B074FB-68FF-4A21-B664-A557FECBB2DF.png\"\u003e\u003c/p\u003e\n\u003cp\u003e大量 \u003ccode\u003eCLOSE_WAIT\u003c/code\u003e 状态的 TCP 连接，\u003ccode\u003eRecv-Q\u003c/code\u003e 数据大小平均在 300 Bytes 左右。对比实际的 HTTP 包大小，恰好是一次 HTTP Request 请求大小。同时参考 Nginx 打印的日志，确定是一次 HTTP 请求的数据包大小，同时都以 Timeout 为结束。\u003c/p\u003e\n\u003cp\u003eOK，简单地建立起了第一个印象，TCP 断开连接的 FIN 包由 Nginx 请求超时后发起(\u003ccode\u003eproxy_read_timeout 300s\u003c/code\u003e) 。A 服务所在的 Linux 机器接收到 FIN 包，并由内核线程直接将套接字状态置位为 \u003ccode\u003eCLOSE_WAIT\u003c/code\u003e 。\u003c/p\u003e\n\u003cp\u003eA 服务没意识到 FIN 包？当然，接收了 FIN 包之后，再回应 ACK 包，这“四次挥手”的第二个数据包并不会被 A 服务所认知，而是由内核的 \u003ccode\u003e[ksoftirqd]\u003c/code\u003e 内核线程直接处理。看下内核处理 FIN 包的代码 (from \u003ccode\u003enet/ipv4/tcp_input.c\u003c/code\u003e)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/*\n * 处理 FIN 包\n *\n * 如果当前套接字是 ESTABLISHED 状态，则接收 FIN 包，进入 CLOSE-WAIT\n * 状态 \n * ...\n */\nvoid tcp_fin(struct sock *sk)\n{\n    struct tcp_sock *tp = tcp_sk(sk);\n\n    inet_csk_schedule_ack(sk);\n\n    sk-\u003esk_shutdown |= RCV_SHUTDOWN;\n    sock_set_flag(sk, SOCK_DONE);\n\n    switch (sk-\u003esk_state) {\n    case TCP_SYN_RECV:\n    case TCP_ESTABLISHED:\n        /* 当前为 ESTABLISHED 状态，进入 CLOSE_WAIT */\n        tcp_set_state(sk, TCP_CLOSE_WAIT);\n        inet_csk(sk)-\u003eicsk_ack.pingpong = 1;\n        break;\n\n    // ... more omitted \n\n    }\n\n    // ... more omitted \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e更多关于网络相关的内核实现请参考 \u003ca href=\"https://www.ffutop.com/2019-01-15-understand-Kernel-8/\"\u003e理解 Linux Kernel (8) - 网络\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e再结合 \u003ccode\u003eRecv-Q\u003c/code\u003e 恰好等于一次完整 HTTP 请求的条件，可以认识到 Python 线程根本没有 \u003ccode\u003erecv\u003c/code\u003e 请求数据。更别提意识到远端发出来 FIN 包。\u003c/p\u003e\n\u003cp\u003e到此为止，由前两次的问题得到的线索，只能认为 Python 服务 A 的所有工作线程都在哪段代码阻塞了。而我所能认知的唯一条件就是事务死锁（当然，我犯了比较大的错误）。事实上看代码根本就没有任何死锁代码。暂时无果。\u003c/p\u003e\n\u003ch3\u003e打印线程调用栈 (一次失败的尝试)\u003c/h3\u003e\n\u003cp\u003e集成了调用栈打印工具 \u003ccode\u003epdbx\u003c/code\u003e （强烈安利，我们老大写的，很好用的工具）之后，按理说 18 日解决问题是非常容易的。\u003c/p\u003e\n\u003cp\u003e结果按照文档的描述，使用 \u003ccode\u003ekill -30 \u0026#x3C;PID\u003e\u003c/code\u003e ，Python 服务进程莫名挂掉。功亏一篑啊。后来查看源码发现 \u003ccode\u003epdbx\u003c/code\u003e 重定义了 \u003ccode\u003eUSR1\u003c/code\u003e 信号的处理函数。T_T Linux x86 平台下，对应的信号值为 10. \u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e额外地穿插一点信号相关的内容。\u003ccode\u003esignal\u003c/code\u003e 是一种异步处理机制，一般由执行流在退出内核态回到用户态之前 Check 当前任务的信号队列（为什么会主动 check 呢？当然是内核代码提前写好的流程），并主动针对获得的信号调用对应的信号处理函数。\u003c/p\u003e\n\u003cp\u003e可怕的是，之前竟然一直没有意识到信号值在不同的 CPU 架构下是不同的。USR1 在 x86 平台下是 10，在 平台下是 30 。而 BSD 又与 Linux 的编号方案不同。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eLinux  supports  the standard signals listed below.  Several signal numbers are architecture-dependent, as indicated in the \"Value\" column.  (Where three values are given, the first one is usually valid for alpha and sparc, the middle one for x86, arm, and most other architectures, and the last one for mips.  (Values for parisc are not shown; see the Linux kernel source for signal numbering on that architecture.)  A dash (-) denotes that a signal is absent on the corresponding architecture.\nLinux 支持的标准信号如下。一些信号值是平台相关的（Value 列，第一个值用于 alpha 和 sparc 平台，中间的值用于 x86、arm 和大量其他架构，最后一个值用于 mips 平台）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003eSignal     Value     Action   Comment\n----------------------------------------------------------------------\nSIGHUP        1       Term    Hangup detected on controlling terminal or death of controlling process\nSIGINT        2       Term    Interrupt from keyboard\nSIGQUIT       3       Core    Quit from keyboard\nSIGKILL       9       Term    Kill signal\nSIGUSR1   30,10,16    Term    User-defined signal 1\nSIGUSR2   31,12,17    Term    User-defined signal 2\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e总结下，最靠谱的写法就是直接用信号的字符描述啦。\u003ccode\u003ekill -s USR1 \u0026#x3C;PID\u003e\u003c/code\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e打印线程调用栈\u003c/h3\u003e\n\u003cp\u003e19 日下午再次重现，等到 20 日周一上班，总是成功地拿到了线程的调用栈。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\"CP Server Thread-10\" tid=139694658537216\n    at self.__bootstrap_inner()(threading.py:785)\n    at self.run()(threading.py:812)\n    at conn.communicate()(wsgiserver2.py:1532)\n    ... more omitted\n    at instances = list(db.select('instance', vars, where='app_name=$app_name and host=$host and port=$port'))(xxx.py:233)\n    at return self.query(qout, processed=True)(db.py:720)\n    at self._db_execute(db_cursor, sql_query)(db.py:680)\n    at print('%s (%s): %s' % (round(b-a, 2), self.ctx.dbq_count, str(sql_query)), file=debug)(db.py:623)\n    at out.write(x)(webapi.py:512)\n\n\"CP Server Thread-9\" tid=139694666929920\n    at self.__bootstrap_inner()(threading.py:785)\n    at self.run()(threading.py:812)\n    at conn.communicate()(wsgiserver2.py:1532)\n    ... more omitted \n    at apps = list(db.select('application', vars, where='name=$name'))(xxx.py:149)\n    at return self.query(qout, processed=True)(db.py:720)\n    at self._db_execute(db_cursor, sql_query)(db.py:680)\n    at print('%s (%s): %s' % (round(b-a, 2), self.ctx.dbq_count, str(sql_query)), file=debug)(db.py:623)\n    at out.write(x)(webapi.py:512)\n\n\"MainThread\" tid=139695478638400\n    at app.run()(xxx.py:326)\n    at return wsgi.runwsgi(self.wsgifunc(*middleware))(application.py:341)\n    at return httpserver.runsimple(func, server_addr)(wsgi.py:59)\n    at server.start()(httpserver.py:177)\n    at self.tick()(wsgiserver2.py:1956)\n    at s, addr = self.socket.accept()(wsgiserver2.py:2008)\n    at sock, addr = self._sock.accept()(socket.py:202)\n    at pystack()(pdbx.py:181)\n    at for filename, lineno, _, line in traceback.extract_stack(stack):(pdbx.py:169)\n\n... omit CP Server Thread-1 / Thread-2 / Thread-6 / Thread-7 / Thread-8\n... same as other thread\n\n\"CP Server Thread-4\" tid=139695180908288\n    at self.__bootstrap_inner()(threading.py:785)\n    at self.run()(threading.py:812)\n    at conn.communicate()(wsgiserver2.py:1532)\n    ... more omitted \n    at instances = list(db.select('instance', vars, where='app_name=$app_name and host=$host and port=$port'))(xxx.py:233)\n    at return self.query(qout, processed=True)(db.py:720)\n    at self._db_execute(db_cursor, sql_query)(db.py:680)\n    at print('%s (%s): %s' % (round(b-a, 2), self.ctx.dbq_count, str(sql_query)), file=debug)(db.py:623)\n    at out.write(x)(webapi.py:512)\n\n\"APScheduler\" tid=139695219828480\n    at self.__bootstrap_inner()(threading.py:785)\n    at self.run()(threading.py:812)\n    at self.__target(*self.__args, **self.__kwargs)(threading.py:765)\n    at self._event.wait(wait_seconds)(blocking.py:28)\n    at self.__cond.wait(timeout, balancing)(threading.py:622)\n    at waiter.acquire()(threading.py:339)\n\n\"CP Server Thread-3\" tid=139695189300992\n    at self.__bootstrap_inner()(threading.py:785)\n    at self.run()(threading.py:812)\n    at conn.communicate()(wsgiserver2.py:1532)\n    ... more omitted \n    at instances = list(db.select('instance', vars, where='app_name=$app_name and host=$host and port=$port'))(xxx.py:233)\n    at return self.query(qout, processed=True)(db.py:720)\n    at self._db_execute(db_cursor, sql_query)(db.py:680)\n    at print('%s (%s): %s' % (round(b-a, 2), self.ctx.dbq_count, str(sql_query)), file=debug)(db.py:623)\n    at out.write(x)(webapi.py:512)\n\n\"CP Server Thread-5\" tid=139695172515584\n    at self.__bootstrap_inner()(threading.py:785)\n    at self.run()(threading.py:812)\n    at conn.communicate()(wsgiserver2.py:1532)\n    ... more omitted \n    at instances = list(db.select('instance', vars, where='app_name=$app_name and host=$host and port=$port'))(xxx.py:233)\n    at return self.query(qout, processed=True)(db.py:720)\n    at self._db_execute(db_cursor, sql_query)(db.py:680)\n    at print('%s (%s): %s' % (round(b-a, 2), self.ctx.dbq_count, str(sql_query)), file=debug)(db.py:623)\n    at out.write(x)(webapi.py:512)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOK，总计 10 个工作线程，全都阻塞在 \u003ccode\u003eout.write(x)\u003c/code\u003e ，多次打印调用栈结果相同。基本可以断定是 \u003ccode\u003ewrite\u003c/code\u003e 方法出了问题了。不过直到这个时候，都还是深陷在死锁原因中无法自拔（还是接触得太少了）。\u003c/p\u003e\n\u003cp\u003e虚度半个多钟... 后看代码了解到，其准备将 SQL 执行结果打印到标准错误。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef _debugwrite(x):\n    try:\n        out = ctx.environ['wsgi.errors']\n    except:\n        out = sys.stderr\n    out.write(x)\ndebug.write = _debugwrite\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e果断去查看 Python 服务的文件描述符 \u003ccode\u003elsof -p \u0026#x3C;PID\u003e\u003c/code\u003e / \u003ccode\u003els -al /proc/\u0026#x3C;PID\u003e/fd\u003c/code\u003e 。总算见着可信的证据了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003e lsof -p \u0026#x3C;PID\u003e\npython  139756 sysop    0r  FIFO     0,9       0t0 5210639 pipe\npython  139756 sysop    1w   REG   253,1      5187 1188500 /home/www/wwwroot/logs/eswitch-console.9999.log\npython  139756 sysop    2w  FIFO     0,9       0t0 5210641 pipe\npython  139756 sysop    3u  IPv4 5210787       0t0     TCP 10.1.5.60:65442-\u003e10.1.6.104:mysql (ESTABLISHED)\npython  139756 sysop    4r  FIFO     0,9       0t0 5210774 pipe\npython  139756 sysop    5w  FIFO     0,9       0t0 5210774 pipe\npython  139756 sysop    6r  FIFO     0,9       0t0 5210778 pipe\npython  139756 sysop    7w  FIFO     0,9       0t0 5210778 pipe\npython  139756 sysop    8u  IPv4 5210788       0t0     TCP *:distinct (LISTEN)\npython  139756 sysop    9u  IPv4 5226722       0t0     TCP localhost:distinct-\u003elocalhost:26032 (CLOSE_WAIT)\npython  139756 sysop   10u  IPv4 5226858       0t0     TCP localhost:distinct-\u003elocalhost:26052 (CLOSE_WAIT)\n... more omitted\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e\u003e ls -al /proc/\u0026#x3C;PID\u003e/fd\nlr-x------ 1 sysop sysop 64 May 20 13:47 0 -\u003e pipe:[5210639]\nl-wx------ 1 sysop sysop 64 May 20 13:47 1 -\u003e /home/path/to/logs/xxx.log\nl-wx------ 1 sysop sysop 64 May 20 13:47 2 -\u003e pipe:[5210641]\nlrwx------ 1 sysop sysop 64 May 20 13:47 3 -\u003e socket:[5210787]\nlr-x------ 1 sysop sysop 64 May 20 13:47 4 -\u003e pipe:[5210774]\nl-wx------ 1 sysop sysop 64 May 20 13:47 5 -\u003e pipe:[5210774]\nlr-x------ 1 sysop sysop 64 May 20 13:47 6 -\u003e pipe:[5210778]\nl-wx------ 1 sysop sysop 64 May 20 13:47 7 -\u003e pipe:[5210778]\n... more omitted\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e标准错误(fd = 2)指向了一个匿名管道（inode = 5210641）。但是找遍整个系统都没有这个匿名管道的读取方，只有写入方\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e\u003e sudo lsof | grep 5210641\nbash      139747          sysop    2w     FIFO                0,9       0t0    5210641 pipe\npython    139756          sysop    2w     FIFO                0,9       0t0    5210641 pipe\npython    139756 139764   sysop    2w     FIFO                0,9       0t0    5210641 pipe\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOK，合理的解释出现了。管道的缓冲区大小有限(经过测试是 64KB)，Python 服务在不断地向标准错误打印日志，从而导致匿名管道(inode = 5210641)的缓冲区数据不断积累，最终达到满的状态。这个过程大概需要一天多的心跳包才能积累得到。而系统调用 \u003ccode\u003ewrite\u003c/code\u003e 发现标准错误对应的文件已满，为等待 IO 就绪而陷入睡眠状态。同时，Main 线程在不断地 Accept 新的套接字的建立，而没有更多工作线程来处理新的请求，Nginx 因为连接超时直接发出来 FIN 包。最后，积累了几千/上万请求的 Python 服务也没法主动 close 已有的套接字（即 FIN,ACK 包因为没法发送而在本机不断积累 \u003ccode\u003eCLOSE_WAIT\u003c/code\u003e 状态的连接）\u003c/p\u003e\n\u003ch3\u003e重定向标准错误的原因\u003c/h3\u003e\n\u003cp\u003e至于为何会将标准错误重定向到一个匿名管道呢？百思不得其解，不过最后还是从应用负责人那儿得到了提示。新的发布方式采用了全新的启动命令:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003essh -fn xx.xx.x.60 'cd /home/path/to/xxx ; python -u xxx.py 8080 \u003e\u003e /home/path/to/logs/xxx.log'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e一看就能和前面的原因衔接，使用 ssh 直接调用命名，不会建立一个终端，由 ssh 远程命令启动的任务，其标准输入/输出/错误默认将会通过管道重定向的 ssh server 端，并通过网络传回发起的 ssh client 端。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e以发起 \u003ccode\u003essh -fn ...\u003c/code\u003e 的机器为 xx.192，目标机器为 xx.60\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  xx.192                       |           xx.60\n  -----------------------------+-------------------------------\n                               | \n    ssh client                 |          ssh serve           python serve\n  +------------+               |        +------------+       +-------------+\n  | 0 | stdin  |               |        | y | pipe[a]| \u0026#x3C;---\u003e | 0 | pipe[a] |\n  | 1 | stdout |               |        | z | pipe[b]| \u0026#x3C;-+   | 1 | xxx.log |\n  | 2 | stderr |               |        |   |        |   +-\u003e | 2 | pipe[b] |\n  | ...        |               |        | ...        |       | ...         |\n  | x | sock   | \u0026#x3C;--------------------\u003e | w | sock   |       | ...         |\n  +------------+               |        +------------+       +-------------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython 服务通过管道与 ssh serve 进行进程间交互，最终会将标准错误打印到 192 机器的标准输出/错误上（一般是终端，也就是我们将在终端上看到 Python 服务的错误日志）。而问题在于 ssh serve 任务被杀掉了，从而 \u003ccode\u003epipe[b]\u003c/code\u003e 只能不断地向匿名管道写入数据，而没有任务读取数据，一天多时间也就将缓冲区写满了。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e到此为止，问题总算得到了圆满的解释，历时 5 天。最重要的就是通过调用栈定位代码阻塞的原因，否则就真是瞎找。对于匿名管道问题的发现、write 系统调用导致的线程睡眠，都是建立在调用栈信息之上的定向探究的过程。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e历时一周总算把导致服务大量 \u003ccode\u003eCLOSE_WAIT\u003c/code\u003e 的原因给找到了。打印任务调用栈果然的必备手段啊！\u003c/p\u003e\n\u003ch2\u003e问题描述\u003c/h2\u003e\n\u003cp\u003ePython 服务 A，用于接收心跳包确认其他服务是否存活。其他服务每 5 分钟向 A 发送一次心跳包；总计 \u0026#x3C; 100 个其他服务。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e05-11 19:30 ，首次出现 Python 服务大量 \u003ccode\u003eCLOSE_WAIT\u003c/code\u003e，至 13 日发现，总计 10k 左右 \u003ccode\u003eCLOSE_WAIT\u003c/code\u003e 的 TCP 连接。05-13 15:30 通过运维平台重新部署...\u003c/li\u003e\n\u003cli\u003e05-14 16:30 ，再次出现。19:30 手动重启。\u003c/li\u003e\n\u003cli\u003e其间给 Python 服务 A 添加了打印调用栈的模块 \u003ca href=\"https://pypi.org/project/pdbx/\"\u003epdbx\u003c/a\u003e，通过运维平台重新部署\u003c/li\u003e\n\u003cli\u003e05-17 19:00 ，再次出现。等待打印调用栈，不小心杀掉了服务...\u003c/li\u003e\n\u003cli\u003e05-19 14:30 ，重现。\u003c/li\u003e\n\u003cli\u003e05-20 08:30 ，查找原因，解决问题。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e由于不是本人负责的服务，于 16 日凭兴趣开始有限介入，协助排查。现将排查流程一一记述，给自己和大家未来排查问题提供一个借鉴。\u003c/p\u003e"},{"url":"2019-05-10-png-structure","fileName":"2019-05-10-png-structure.md","title":"PNG 文件格式","author":"fangfeng","date":"2019-05-10T00:00:00.000Z","tags":["File Format","PNG"],"content":"\u003cp\u003ePNG (Portable Network Graphics) 文件格式(第二版)。PNG 文件格式由两类结构——\u003ccode\u003ePNG 签名(PNG Signature)\u003c/code\u003e和若干\u003ccode\u003e数据块(chunk)\u003c/code\u003e组成。\u003c/p\u003e\n\u003cp\u003ePNG 签名相当于其他文件格式中的魔数，用于声明二进制数据所代表的格式。类似的有 \u003ccode\u003eJAVA\u003c/code\u003e class 文件的 \u003ccode\u003eca fe ba be\u003c/code\u003e、\u003ccode\u003eELF\u003c/code\u003e 文件的 \u003ccode\u003e7f 45 4c 46\u003c/code\u003e (.ELF) 。PNG 签名使用 \u003ccode\u003e89 50 4e 47 0d 0a 1a 0a\u003c/code\u003e (.PNG....) 作为魔数。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHINT 上述的 \u003ccode\u003e.\u003c/code\u003e 仅仅是为了指代非打印字符，并非真的是 \u003ccode\u003e点号\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e在 \u003ccode\u003ePNG 签名\u003c/code\u003e 数据之后，紧接着就是 \u003ccode\u003e数据块(chunk)\u003c/code\u003e 的数据。虽然统称\u003ccode\u003e数据块\u003c/code\u003e，但存在不同类型的数据块（例如 IHDR, PLTE, IDAT, IEND 等）。每个 PNG 文件可以有若干连续的数据块（至少 3 个数据块），其中第一个数据块和最后一个数据块类型分别是 IHDR、IEND 。\u003c/p\u003e\n\u003ch2\u003eChunk Layout\u003c/h2\u003e\n\u003cp\u003e数据块由三/四部分组成：长度、数据块类型、数据（可选）、CRC 校验码\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e+ ------ + ---------- + ---------- + --- +\n| LENGTH | CHUNK TYPE | CHUNK DATA | CRC |\n+ ------ + ---------- + ---------- + --- +\nOR\n+ --------- + ---------- + --- +\n| LENGTH(0) | CHUNK TYPE | CRC |\n+ --------- + ---------- + --- +\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e长度 (4 bytes, unsigned integer): 只负责记录数据(CHUNK DATA)的长度\u003c/li\u003e\n\u003cli\u003e数据块类型 (4 bytes, char sequence): 由 4 个大小写字母组成\u003c/li\u003e\n\u003cli\u003e数据: 一系列数据字符\u003c/li\u003e\n\u003cli\u003eCRC (4 bytes): 循环冗余校验码。对数据块类型和数据两块二进制信息进行校验，不包括长度部分。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e数据类型\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e有趣的是：由4个大小写字母组成的数据块类型还额外的携带了一些配置信息。通过大写代表0，小写代表1。这里提供了4 bits信息。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第一个字母: \u003cul\u003e\n\u003cli\u003e0 (critical, 决定性的数据块)\u003c/li\u003e\n\u003cli\u003e1 (ancillary, 辅助性的数据块)\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e第二个字母:\u003cul\u003e\n\u003cli\u003e0 (public, 由本协议预定义的数据块类型)\u003c/li\u003e\n\u003cli\u003e1 (private, 自定义的数据块类型)\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e第三个字母:\u003cul\u003e\n\u003cli\u003e0 (遵循当前版本规范的数据块)\u003c/li\u003e\n\u003cli\u003e1 (为未来版本预留的位)\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e第四个字母:\u003cul\u003e\n\u003cli\u003e0 (unsafe to copy)\u003c/li\u003e\n\u003cli\u003e1 (safe to copy)\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e例如数据类型 \u003ccode\u003ecHNk\u003c/code\u003e \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003ecHNk  \u0026#x3C;-- 32 bit chunk type represented in text form\n||||\n|||+- Safe-to-copy bit is 1 (lower case letter; bit 5 is 1)\n||+-- Reserved bit is 0     (upper case letter; bit 5 is 0)\n|+--- Private bit is 0      (upper case letter; bit 5 is 0)\n+---- Ancillary bit is 1    (lower case letter; bit 5 is 1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e决定性的数据块类型\u003c/th\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e类型\u003c/td\u003e\n\u003ctd\u003e是否允许出现多次\u003c/td\u003e\n\u003ctd\u003e顺序限制\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11IHDR\"\u003e\u003cstrong\u003eIHDR\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e必须出现在开始处\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11PLTE\"\u003e\u003cstrong\u003ePLTE\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e必须早于第一个 \u003cstrong\u003eIDAT\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11IDAT\"\u003e\u003cstrong\u003eIDAT\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eYes\u003c/td\u003e\n\u003ctd\u003e可选；多个 \u003cstrong\u003eIDAT\u003c/strong\u003e 必须连续，不允许间断\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11IEND\"\u003e\u003cstrong\u003eIEND\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e必须出现在结束处\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e辅助性的数据块类型\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e类型\u003c/td\u003e\n\u003ctd\u003e是否允许出现多次\u003c/td\u003e\n\u003ctd\u003e顺序限制\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11cHRM\"\u003e\u003cstrong\u003ecHRM\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e可选；需早于 \u003cstrong\u003ePLTE\u003c/strong\u003e 和 \u003cstrong\u003eIDAT\u003c/strong\u003e 出现\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11gAMA\"\u003e\u003cstrong\u003egAMA\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e可选；需早于 \u003cstrong\u003ePLTE\u003c/strong\u003e 和 \u003cstrong\u003eIDAT\u003c/strong\u003e 出现\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11iCCP\"\u003e\u003cstrong\u003eiCCP\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e可选；需早于 \u003cstrong\u003ePLTE\u003c/strong\u003e 和 \u003cstrong\u003eIDAT\u003c/strong\u003e 出现；与 \u003cstrong\u003esBIT\u003c/strong\u003e 不能同时出现\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11sBIT\"\u003e\u003cstrong\u003esBIT\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e可选；需早于 \u003cstrong\u003ePLTE\u003c/strong\u003e 和 \u003cstrong\u003eIDAT\u003c/strong\u003e 出现\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11sRGB\"\u003e\u003cstrong\u003esRGB\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e可选；需早于 \u003cstrong\u003ePLTE\u003c/strong\u003e 和 \u003cstrong\u003eIDAT\u003c/strong\u003e 出现；与 \u003cstrong\u003eiCCP\u003c/strong\u003e 不能同时出现\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11bKGD\"\u003e\u003cstrong\u003ebKGD\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e可选；在 \u003cstrong\u003ePLTE\u003c/strong\u003e 之后，\u003cstrong\u003eIDAT\u003c/strong\u003e 之前出现\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11hIST\"\u003e\u003cstrong\u003ehIST\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e可选；在 \u003cstrong\u003ePLTE\u003c/strong\u003e 之后，\u003cstrong\u003eIDAT\u003c/strong\u003e 之前出现\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11tRNS\"\u003e\u003cstrong\u003etRNS\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e可选；在 \u003cstrong\u003ePLTE\u003c/strong\u003e 之后，\u003cstrong\u003eIDAT\u003c/strong\u003e 之前出现\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11pHYs\"\u003e\u003cstrong\u003epHYs\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e可选；在 \u003cstrong\u003eIDAT\u003c/strong\u003e 之前出现\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11sPLT\"\u003e\u003cstrong\u003esPLT\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eYes\u003c/td\u003e\n\u003ctd\u003e可选；在 \u003cstrong\u003eIDAT\u003c/strong\u003e 之前出现\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11tIME\"\u003e\u003cstrong\u003etIME\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNo\u003c/td\u003e\n\u003ctd\u003e可选\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11iTXt\"\u003e\u003cstrong\u003eiTXt\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eYes\u003c/td\u003e\n\u003ctd\u003e可选\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11tEXt\"\u003e\u003cstrong\u003etEXt\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eYes\u003c/td\u003e\n\u003ctd\u003e可选\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#11zTXt\"\u003e\u003cstrong\u003ezTXt\u003c/strong\u003e\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eYes\u003c/td\u003e\n\u003ctd\u003e可选\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e如果想要可视化直观的了解，详见 \u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#figure52\"\u003eW3C PNG Specification (Figure 5.2/5.3)\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003eColor Type\u003c/h2\u003e\n\u003cp\u003e根据图像的颜色类型划分，PNG 总计支持五类图像。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003ePNG image type\u003c/th\u003e\n\u003cth\u003eColour type\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e灰度\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e真彩色\u003c/td\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e索引颜色\u003c/td\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e有透明通道的灰度\u003c/td\u003e\n\u003ctd\u003e4\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e有透明通道的真彩色\u003c/td\u003e\n\u003ctd\u003e6\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e针对这五种类型，其实都支持透明度配置，只是各有区分罢了。灰度(0)、真彩色(2)、索引颜色(3) 通过 \u003cstrong\u003etRNS\u003c/strong\u003e 数据块来维护透明度设置。其中灰度(0)、真彩色(2)支持由配置一个统一的透明度(2字节)，无法为每个像素单独配置透明度；索引颜色(3)支持为每个索引颜色设置透明度，但每个索引颜色的透明度设置最大只有 8 bits 的选择空间。\u003c/p\u003e\n\u003cp\u003e对于有透明通道的真彩色(6)、灰度(4)，它们不能拥有 \u003cstrong\u003etRNS\u003c/strong\u003e 数据块，因为它们本身的就有透明通道来记录每个像素点的透明度。\u003c/p\u003e\n\u003ch2\u003eInterlacing and pass extraction\u003c/h2\u003e\n\u003cp\u003e交错渲染，中文资料中更多看到“隔行渲染”的翻译。PNG 提供 Interlace 选项: 0(不交错渲染)、1(Adam7 算法交错渲染)。\u003c/p\u003e\n\u003cp\u003eAdam7 交错渲染可以简单的理解为将图像像素点矩阵划分为7级，如下表，逐级分别提取 1~7 级都能构成一个矩阵，每个级别与更高级别只是相近的像素点缺失了。但随着 1~7 级获得的像素点信息越多，图像就会越细腻。从而达到网络加载图片逐渐从模糊到清晰的效果。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1 6 4 6 2 6 4 6\n7 7 7 7 7 7 7 7\n5 6 5 6 5 6 5 6\n7 7 7 7 7 7 7 7\n3 6 4 6 3 6 4 6\n7 7 7 7 7 7 7 7\n5 6 5 6 5 6 5 6\n7 7 7 7 7 7 7 7\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eChunk specifications\u003c/h2\u003e\n\u003cp\u003e下列的各个数据块的内容，将以一套比较实际的二进制数据来辅助解析。\u003c/p\u003e\n\u003ch3\u003eIHDR\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eWidth\u003c/td\u003e\n\u003ctd\u003e4 bytes\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eHeight\u003c/td\u003e\n\u003ctd\u003e4 bytes\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eBit depth\u003c/td\u003e\n\u003ctd\u003e1 byte\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eColour type\u003c/td\u003e\n\u003ctd\u003e1 byte\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCompression method\u003c/td\u003e\n\u003ctd\u003e1 byte\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eFilter method\u003c/td\u003e\n\u003ctd\u003e1 byte\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eInterlace method\u003c/td\u003e\n\u003ctd\u003e1 byte\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e0000 000d 4948 4452 0000 004c 0000 0019 \n0806 0000 009b d4c8 6f\n\nLENGTH: 0x0000000d\nTYPE: 0x49484452 (IHDR)\nWidth: 0x0000004c (76)\nHeight: 0x00000019 (25)\nBit depth: 08 (每样本点取值区间 0 ~ 2^8-1)\nColour type: 06 (有透明通道的真彩色)\nCompression method: 00 (默认)\nFilter method: 00 (五种过滤算法自适应)\nInterlace method: 00 (无交错渲染)\nCRC: 0x9bd4c86f\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003ePLTE\u003c/h3\u003e\n\u003cp\u003e索引颜色(3)所使用的数据块，用于描述每个索引对应的 RGB 值（每个 RBG 值总计占 3 字节）\u003c/p\u003e\n\u003cp\u003e索引颜色主要见于使用较少颜色的图像中，对出现的颜色建立索引，每个像素点直接指向索引即可。\u003c/p\u003e\n\u003ch3\u003eIDAT\u003c/h3\u003e\n\u003cp\u003eIDAT 数据块用于存储各像素点的数据，具体数据由 \u003cstrong\u003eIHDR\u003c/strong\u003e 中声明的 \u003ccode\u003eFilter method\u003c/code\u003e 和 \u003ccode\u003eCompression method\u003c/code\u003e 共同决定。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e0000 0020 4944 4154 081d 63e8 64fd f9bf \n9de3 bb02 0308 8038 400a 8419 9840 0410 \n3082 0800 dcfc 07b5 4c0c 837a \n\nLENGTH: 0x00000020 (32 bytes)\nTYPE: 0x49444154 (IDAT)\nDATA: 稍后解析\nCRC: 0x4c0c837a\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDATA 部分的数据由于已经被压缩过了，因此看不出任何与原图相关的内容 \u003ca href=\"https://github.com/DorMOUSE-None/Repo/blob/master/z.png\"\u003e原图\u003c/a\u003e 大小为 3×3 像素\u003c/p\u003e\n\u003cp\u003eOK，在 \u003cstrong\u003eIHDR\u003c/strong\u003e 有个数据描述的是使用的压缩算法 (Compression)，0 代表默认，即 PNG 规范所指出的 Zlib 。在 MacOS 下，抽取出 DATA 数据，用 \u003ccode\u003ezlib_decompress\u003c/code\u003e 解压，得到如下数据：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e00000000: 0089 05f9 ff87 08f7 2000 0000 00  \n0000000d: 0089 05f9 ff00 0000 ff00 0000 00  \n0000001a: 0200 0000 0000 0000 0100 0000 00  \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOK，现在应该能看出点内容来了。\u003cstrong\u003eColour Type\u003c/strong\u003e 描述过图像是带透明通道的真彩色，每个样本点用 8 bits 来描述。3×3 的图像也就意味着需要 4 字节/像素 (RGBA) × 3 像素/行 × 3 行 = 36 字节。好吧，莫名其妙多了 3 字节？这当然与 \u003ccode\u003eFilter method\u003c/code\u003e 有关。用于描述图像每行的像素点将被如何描述。0 代表直接通过 RGBA 描述，而 2 代表需要借助上一行数据与当前行做累加。还有更多详见 \u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters\"\u003eFilters\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e每行像素点描述的最开始一个字节就是对 \u003ccode\u003eFilter method\u003c/code\u003e 所使用的类型的描述。\u003c/p\u003e\n\u003cp\u003e简单解析一下，9 个像素点的数据如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e00000000: 8905f9ff 8708f720 00000000  \n0000000d: 8905f9ff 000000ff 00000000  \n0000001a: 8905f9ff 00000000 00000000  \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e去看看\u003ca href=\"https://github.com/DorMOUSE-None/Repo/blob/master/z.png\"\u003e实际的图像\u003c/a\u003e，恰如解析出的结果，完全匹配。\u003c/p\u003e\n\u003ch3\u003eIEND\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eIEND\u003c/strong\u003e 的内容最为简单，只是为了标识 chunks 的结束。其内容就是 \u003ccode\u003e00000000 49454e44 ae426082\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003eMore\u003c/h2\u003e\n\u003cp\u003ePNG 规范的文档很长，对规范的描述也相当详细，除了对初次接触图像的非专业人士存在很大的障碍。有太多的新名词的出现。\u003c/p\u003e\n\u003cp\u003e本篇仅仅只是摘录及翻译了一部分内容，只是为了能够对 PNG 的文件格式建立初步的印象，以及能够简单解析一些图像信息。更多的内容请移步 \u003ca href=\"https://www.w3.org/TR/2003/REC-PNG-20031110/\"\u003ePNG 规范\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003ePNG (Portable Network Graphics) 文件格式(第二版)。PNG 文件格式由两类结构——\u003ccode\u003ePNG 签名(PNG Signature)\u003c/code\u003e和若干\u003ccode\u003e数据块(chunk)\u003c/code\u003e组成。\u003c/p\u003e\n\u003cp\u003ePNG 签名相当于其他文件格式中的魔数，用于声明二进制数据所代表的格式。类似的有 \u003ccode\u003eJAVA\u003c/code\u003e class 文件的 \u003ccode\u003eca fe ba be\u003c/code\u003e、\u003ccode\u003eELF\u003c/code\u003e 文件的 \u003ccode\u003e7f 45 4c 46\u003c/code\u003e (.ELF) 。PNG 签名使用 \u003ccode\u003e89 50 4e 47 0d 0a 1a 0a\u003c/code\u003e (.PNG....) 作为魔数。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHINT 上述的 \u003ccode\u003e.\u003c/code\u003e 仅仅是为了指代非打印字符，并非真的是 \u003ccode\u003e点号\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e在 \u003ccode\u003ePNG 签名\u003c/code\u003e 数据之后，紧接着就是 \u003ccode\u003e数据块(chunk)\u003c/code\u003e 的数据。虽然统称\u003ccode\u003e数据块\u003c/code\u003e，但存在不同类型的数据块（例如 IHDR, PLTE, IDAT, IEND 等）。每个 PNG 文件可以有若干连续的数据块（至少 3 个数据块），其中第一个数据块和最后一个数据块类型分别是 IHDR、IEND 。\u003c/p\u003e"},{"url":"2019-04-26-time-accuracy","fileName":"2019-04-26-time-accuracy.md","title":"MySQL TIMESTAMP 时间精度问题","author":"fangfeng","date":"2019-04-26T00:00:00.000Z","tags":["MySQL","DateTime","TimeStamp","time accuracy"],"content":"\u003cp\u003e最近一段单元测试代码总是不定时地爆炸。test pass 与 failed 的比例大约 10:1 。伪代码如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e/**\n  * 表结构\n  * CREATE TABLE `time_0` (\n  *     `timeout` timestamp NOT NULL\n  * )\n  */\n\n// part 1\njdbcTemplate.execute(\"UPDATE `time_0` SET `timeout`=now() WHERE `id` = xxx;\");\n\n// part 2\nDate timeout = jdbcTemplate.queryForObject(\"SELECT `timeout` FROM `time_0` WHERE `id` = xxx;\", Date.class);\nAssert.assertTrue(timeout.getTime() \u0026#x3C; System.currentTimeMillis());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在绝大多数模拟中，先执行 \u003ccode\u003epart 1\u003c/code\u003e，紧跟着执行 \u003ccode\u003epart 2\u003c/code\u003e 都能通过测试。但偶尔还是挂掉了。\u003c/p\u003e\n\u003ch2\u003eMySQL 时间表示\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003cstrong\u003eType\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eStorage before MySQL 5.6.4\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eStorage as of MySQL 5.6.4\u003c/strong\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eYEAR\u003c/td\u003e\n\u003ctd\u003e1 byte, little endian\u003c/td\u003e\n\u003ctd\u003eUnchanged\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDATE\u003c/td\u003e\n\u003ctd\u003e3 bytes, little endian\u003c/td\u003e\n\u003ctd\u003eUnchanged\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eTIME\u003c/td\u003e\n\u003ctd\u003e3 bytes, little endian\u003c/td\u003e\n\u003ctd\u003e3 bytes + fractional-seconds storage, big endian\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eTIMESTAMP\u003c/td\u003e\n\u003ctd\u003e4 bytes, little endian\u003c/td\u003e\n\u003ctd\u003e4 bytes + fractional-seconds storage, big endian\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDATETIME\u003c/td\u003e\n\u003ctd\u003e8 bytes, little endian\u003c/td\u003e\n\u003ctd\u003e5 bytes + fractional-seconds storage, big endian\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003eTimeStamp\u003c/code\u003e 由四字节描述，可以存储 \u003ccode\u003e1970-01-01 00:00:00\u003c/code\u003e 到 \u003ccode\u003e2038-01-19 03:14:07\u003c/code\u003e。4 字节存储正好是精确到秒为止。根据表中所描述的毫秒存储，是依赖于额外的存储空间。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003emysql\u003e show variables like 'version';\n+---------------+--------+\n| Variable_name | Value  |\n+---------------+--------+\n| version       | 5.7.20 |\n+---------------+--------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOK，版本大于 5.6.4，能够支持毫秒级精度。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e# mysql-cli 直接插入新的数据\nmysql\u003e INSERT INTO `time_0` (timeout) VALUES ('2019-04-26 08:00:00.500');\n\n# Check 结果\nmysql\u003e SELECT * FROM `time_0`;\n+---------------------+\n| timeout             |\n+---------------------+\n| 2019-04-26 08:00:01 |\n+---------------------+\n1 row in set (0.00 sec)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e被向上取整了？没有存储毫秒级数据？还是说 \u003ccode\u003eSELECT\u003c/code\u003e 展示结果的时候被加工了？直接去检查数据文件 \u003ccode\u003e/path/to/time_0.ibd\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e# 2019-04-26 08:00:00 -\u003e 1556236800 second -\u003e 0x5cc24a00 \n# 2019-04-26 08:00:00 -\u003e 1556236801 second -\u003e 0x5cc24a01\n$ xxd time_0.ibd | grep 5cc2\n0000c090: 5cc2 4a01 0000 0000 0000 0000 0000 0000  \\.J.............\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e存储时已经被四舍五入了，存了 \u003ccode\u003e5cc24a01\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e:\u0026#x3C; 如果需要存储毫秒级精度，需要在声明类型 \u003ccode\u003etimestamp\u003c/code\u003e 时添加毫秒精度的声明。Like \u003ccode\u003etimestamp(1)\u003c/code\u003e：最小精度 0.1 秒。不同的毫秒精度还将决定所需的存储空间大小。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e毫秒精度\u003c/th\u003e\n\u003cth\u003e存储空间\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0 bytes\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1,2\u003c/td\u003e\n\u003ctd\u003e1 byte\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e3,4\u003c/td\u003e\n\u003ctd\u003e2 bytes\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e4,5\u003c/td\u003e\n\u003ctd\u003e3 bytes\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e新建表 \u003ccode\u003etime_1\u003c/code\u003e (timestamp(3))\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003emysql\u003e insert into time_1 (timeout) values ('2019-04-26 08:00:00.500');\nmysql\u003e select * from time_1;\n+----+-------------------------+\n| id | timeout                 |\n+----+-------------------------+\n|  1 | 2019-04-26 08:00:00.500 |\n+----+-------------------------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从 \u003ccode\u003e/path/to/time_1.ibd\u003c/code\u003e 检查数据\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e# 2019-04-26 08:00:00.500 -\u003e 2019-04-26 08:00:00.5000  3,4 位毫秒级精度存储方式相同\n# -\u003e 1556236800.5000 second -\u003e 0x5cc24a00 0x1388\n$ xxd time_1.ibd | grep -A 1 5cc2\n0000c080: 0100 0000 008c 87ce 0000 01e4 0110 5cc2  ..............\\.\n0000c090: 4a00 1388 0000 0000 0000 0000 0000 0000  J...............\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOK，看来确实如此。\u003c/p\u003e\n\u003ch2\u003eNOW()\u003c/h2\u003e\n\u003cp\u003e确认了 MySQL 对 \u003ccode\u003eTIMESTAMP\u003c/code\u003e 的存储方式。还有 \u003ccode\u003enow()\u003c/code\u003e 函数的表现亟待确认。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-mysql\"\u003emysql\u003e SELECT now();\n+---------------------+\n| now()               |\n+---------------------+\n| 2019-04-26 09:03:27 |\n+---------------------+\n1 row in set (0.00 sec)\n\nmysql\u003e SELECT now(3);\n+-------------------------+\n| now(3)                  |\n+-------------------------+\n| 2019-04-26 09:03:31.491 |\n+-------------------------+\n1 row in set (0.00 sec)\n\n# 加入 `sleep(1)` 是为了体现两个 now() 是同时产生效果的。\n# 但并没有出现四舍五入的现象。从网上的源码看到 now(3) 对于毫秒级数据是额外附加的。\nmysql\u003e SELECT now(), sleep(1), now(3);\n+---------------------+----------+-------------------------+\n| now()               | sleep(1) | now(3)                  |\n+---------------------+----------+-------------------------+\n| 2019-04-26 09:04:58 |        0 | 2019-04-26 09:04:58.946 |\n+---------------------+----------+-------------------------+\n1 row in set (1.00 sec)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e结论\u003c/h2\u003e\n\u003cp\u003e综合 \u003ccode\u003enow()\u003c/code\u003e 和 \u003ccode\u003etimestamp\u003c/code\u003e 的表现，结论就是默认是按向下取整的方式进行的。因为 \u003ccode\u003eUPDATE\u003c/code\u003e 语句用了 \u003ccode\u003enow()\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e既然如此，还能够出现已经设置 \u003ccode\u003etimeout = now()\u003c/code\u003e 而 SELECT 得到的 \u003ccode\u003etimeout \u003e System.currentTimeMillis()\u003c/code\u003e。只能推断为数据库服务器和本机的系统时间不一致，而且数据库服务器的时间更快，但快的有限，不超过 1 秒。\u003c/p\u003e\n\u003cp\u003e至于如何比较两台机器的时间差，\u003ccode\u003eclockdiff\u003c/code\u003e 是个好工具，但没找到 MacOS 下的替代品。具体计算时间差，只能暂时放弃了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e最近一段单元测试代码总是不定时地爆炸。test pass 与 failed 的比例大约 10:1 。伪代码如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e/**\n  * 表结构\n  * CREATE TABLE `time_0` (\n  *     `timeout` timestamp NOT NULL\n  * )\n  */\n\n// part 1\njdbcTemplate.execute(\"UPDATE `time_0` SET `timeout`=now() WHERE `id` = xxx;\");\n\n// part 2\nDate timeout = jdbcTemplate.queryForObject(\"SELECT `timeout` FROM `time_0` WHERE `id` = xxx;\", Date.class);\nAssert.assertTrue(timeout.getTime() \u0026#x3C; System.currentTimeMillis());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在绝大多数模拟中，先执行 \u003ccode\u003epart 1\u003c/code\u003e，紧跟着执行 \u003ccode\u003epart 2\u003c/code\u003e 都能通过测试。但偶尔还是挂掉了。\u003c/p\u003e"},{"url":"2019-04-25-lex-and-yacc","fileName":"2019-04-25-lex-and-yacc.md","title":"Lex \u0026 Yacc 学习笔记","author":"fangfeng","date":"2019-04-25T00:00:00.000Z","tags":["Lex","Yacc"],"content":"\u003cp\u003e高级语言相较于机器语言、汇编语言，更加符合人的思考习惯。换句话说，更偏向于自然语言的风格而更偏离指令化的描述。用高级语言编写的一行代码，最终可能需要处理器执行若干条指令。如何让机器意识到高级语言代码对应的机器指令是哪些呢？当然就需要一个优秀的翻译。\u003c/p\u003e\n\u003cp\u003e无论是编译型语言还是解释型语言，总逃脱不了这样一个流程：高级语言 ➜ 目标平台的指令。所谓编译型/解释型的区别，在于其转换流程是在线的(online)还是离线的(offline)。在线的方式无法意识到后续的代码，但胜在即时反应；离线的方式可以统揽全局，进行更多的优化，但代码文本必须完整。\u003c/p\u003e\n\u003cp\u003e高级语言 ➜ 目标平台的指令，这样的流程如何实现。一般来说，划分为四个阶段：词法分析、语法分析、语义分析、目标代码生成。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNc79ly1g2b583io0ej30wq094aa5.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e本篇的主要目的，是展示“语言翻译”的几个阶段工作，以及通过 Lex \u0026#x26; Yacc 工具演示一门自定义语言的“翻译”。\u003c/p\u003e\n\u003ch2\u003e词法分析 \u0026#x3C;- Lex\u003c/h2\u003e\n\u003cp\u003e词法分析的核心就是识别源代码，并将它按照特定的规则划分成一系列的标记(Token)。\u003c/p\u003e\n\u003cp\u003e比如 \u003ccode\u003eint value = 12 + 23 * 323\u003c/code\u003e 以 C 语言的划分方式可以分成 \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003evalue\u003c/code\u003e, \u003ccode\u003e=\u003c/code\u003e, \u003ccode\u003e12\u003c/code\u003e, \u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e23\u003c/code\u003e, \u003ccode\u003e*\u003c/code\u003e, \u003ccode\u003e323\u003c/code\u003e 这些标记。\u003c/p\u003e\n\u003cp\u003e如何将源代码划分为标记呢？再不济不过是逐一扫描每种标记罢了。但是，规则是变化的，其它实现字符匹配的代码都是一致的。有没有一套框架，用户提供规则表就能实现词法分析呢？当然有，Lex 以及 Flex 就是这方面的好手。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNc79ly1g2boqbqx3oj31pi0q0q44.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLex 语法规范\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e整个 \u003ccode\u003e\u0026#x3C;name\u003e.lex\u003c/code\u003e 规则文件分为三部分，由 \u003ccode\u003e%%\u003c/code\u003e 进行分隔\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edefinitions\n%%\nrules\n%%\nuser code\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003edefinitions\u003c/code\u003e，定义区的所有声明可以类比 C 语言中的宏，只不过无需 \u003ccode\u003e#define\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e例如 \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDIGIT [0-9]+\nNZDIGIT [1-9]{DIGIT}\n%%\n{NZDIGIT}   {   printf(\"nzdigit = %s\\n\", yytext);   }\n{DIGIT}     {   printf(\"digit = %s\\n\", yytext); }\n%%\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e等效于\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e%%\n[1-9][0-9]+ {   printf(\"nzdigit = %s\\n\", yytext);   }\n[0-9]+      {   printf(\"digit = %s\\n\", yytext); }\n%%\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003erule\u003c/code\u003e，规则区就是定义标记识别规则的核心块。lex 将按最长匹配原则确定最终匹配上的标记(Token)，如果都没匹配上，则按原样输出。如果多个匹配上，则按最先声明的规则为准。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003euser code\u003c/code\u003e 用户代码区的所有代码将原样拷贝到生成的 \u003ccode\u003e\u0026#x3C;name\u003e.c\u003c/code\u003e 文件中。\u003c/p\u003e\n\u003ch2\u003e语法分析 \u0026#x3C;- Yacc\u003c/h2\u003e\n\u003cp\u003e仅仅是词法分析还做不了太多的事情。之后的工作都将交给语法分析器来完成。Yacc、Bison 就是两个优秀的语法分析器。当然，它们也有着一些局限（由于只是学习使用，未对其中原理展开深入了解）。Yacc / Bison 只能解决能被 BNF(Backus-Naur Form, 巴科斯范式) 描述的语法规则，而且只支持符合 LALR(1) 规则的。\u003c/p\u003e\n\u003cp\u003e不过，这也已经足够了。在 \u003ca href=\"https://www.rfc-editor.org/\"\u003eRFC\u003c/a\u003e 上看到大量的规范性文档都通过 BNF 描述其语法规则，通过 Yacc/Bison 其实也能解决对这些规则的解析。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBison 语法规范\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e%{\nC declarations\n%}\n\nBison declarations\n\n%%\nGrammar rules\n%%\nAdditional C code\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eC 声明区将定义后面需要用到的类型和变量。当然，在这个区域使用 C 语言宏也是被允许的。比如 \u003ccode\u003e#define\u003c/code\u003e, \u003ccode\u003e#include\u003c/code\u003e 等\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBison 声明区被用来定义\u003ccode\u003e终止符号(terminal symbols)\u003c/code\u003e和\u003ccode\u003e非终止符号(nonterminal symbols)\u003c/code\u003e，当然也可以用来定义符号操作优先级和\u003ccode\u003e语义值\u003c/code\u003e的数据类型。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e语法规则区将\u003ccode\u003e非终止符号\u003c/code\u003e是如何被组成的（在这个区域声明 BNF）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eC 代码区与 lex 的规范一致，该区所有代码将被原样拷贝到生成的解析器源文件中。 \u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e示例\u003c/h2\u003e\n\u003cp\u003e简单计算器语言的实现（改编自 \u003ca href=\"http://dinosaur.compilertools.net/bison/bison_5.html#SEC29\"\u003emfcalc\u003c/a\u003e）：\n1. 支持简单四则运算\n2. 支持乘方、平方根\n3. 支持三角函数\n4. 支持变量声明\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ ./calc\n3*10+2*(3-1)\n    34\nalpha=beta=5*3+4\n    19\nsin(PI/2)\n    1\ncos(PI)\n    -1\nln(alpha)\n    2.944438979\nbeta=ln(alpha)\n    2.944438979\nsqrt(25)\n    5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e%{\n#include \u0026#x3C;math.h\u003e\n#include \u0026#x3C;stdio.h\u003e\n#include \u0026#x3C;ctype.h\u003e\n#include \"calc.h\"\n%}\n%union {\ndouble val;\nsymrec *tptr;\n}\n\n%token \u0026#x3C;val\u003e NUM\n%token \u0026#x3C;tptr\u003e VAR FNCT\n%type \u0026#x3C;val\u003e expr\n\n%right '='\n%left '+' '-'\n%left '*' '/'\n%left NEG\n%right '^'\n\n%%\ninput:\n        | input line\n;\n\nline: '\\n'\n        | expr '\\n' {   printf(\"\\t%.10g\\n\", $1);    }\n;\n\nexpr: NUM   { $$ = $1;  }\n        | VAR   { $$ = $1-\u003evalue.var;   }\n        | VAR '=' expr  { $$ = $3;  $1-\u003evalue.var = $3; }\n        | FNCT '(' expr ')' { $$ = (*($1-\u003evalue.fnctptr))($3);  }\n        | expr '+' expr { $$ = $1 + $3; }\n        | expr '-' expr { $$ = $1 - $3; }\n        | expr '*' expr { $$ = $1 * $3; }\n        | expr '/' expr { $$ = $1 / $3; }\n        | expr '^' expr { $$ = pow($1, $3); }\n        | '-' expr %prec NEG    { $$ = -$2; }\n        | '(' expr ')'  { $$ = $2;  }\n%%\n\nint main(int argc, char **argv)\n{\n    init_table();\n    yyparse();\n    return 0;\n}\n\nint yyerror (char *s)\n{\n    printf(\"%s\\n\", s);\n}\n\nstruct init_fnct\n{\n    char *fname;\n    double (*fnct)();\n};\n\nstruct init_fnct arith_fncts[] = {\n    \"sin\", sin,\n    \"cos\", cos,\n    \"atan\", atan,\n    \"ln\", log,\n    \"exp\", exp,\n    \"sqrt\", sqrt,\n    \"floor\", floor,\n    \"ceil\", ceil,\n    \"abs\", fabs,\n    0, 0\n};\n\nstruct init_var {\n    char *vname;\n    double value;\n};\n\nstruct init_var constant_var[] = {\n    \"PI\", M_PI,\n    \"E\", M_E,\n    0, 0\n};\n\nsymrec *sym_table = (symrec *) 0;\n\nint init_table()\n{\n    int i;\n    symrec *ptr;\n    for (int i=0;constant_var[i].vname != 0;i++)\n    {\n        ptr = putsym(constant_var[i].vname, VAR);\n        ptr-\u003evalue.var = constant_var[i].value; \n    }\n    for (int i=0;arith_fncts[i].fname != 0;i++)\n    {\n        ptr = putsym(arith_fncts[i].fname, FNCT);\n        ptr-\u003evalue.fnctptr = arith_fncts[i].fnct;\n    }\n}\n\nsymrec * putsym(char *sym_name, int sym_type)\n{\n    symrec *ptr;\n    ptr = (symrec *) malloc(sizeof(symrec));\n    ptr-\u003ename = (char *) malloc(strlen(sym_name) + 1);\n    strcpy(ptr-\u003ename, sym_name);\n    ptr-\u003etype = sym_type;\n    ptr-\u003evalue.var = 0;\n    ptr-\u003enext = (struct symrec *) sym_table;\n    sym_table = ptr;\n    return ptr;\n}\n\nsymrec * getsym(char *sym_name)\n{\n    symrec *ptr;\n    for (ptr = sym_table; ptr != (symrec *) 0;ptr = (symrec *) ptr-\u003enext)\n        if (strcmp(ptr-\u003ename, sym_name) == 0)\n            return ptr;\n    return 0;\n}\n\nint yylex()\n{\n    int c;\n    while ((c = getchar()) == ' ' || c == '\\t');\n\n    if (c == EOF)\n        return 0;\n    \n    if (c == '.' || isdigit(c))\n    {\n        ungetc(c, stdin);\n        scanf(\"%lf\", \u0026#x26;yylval.val);\n        return NUM;\n    }\n\n    if (isalpha(c))\n    {\n        symrec *s;\n        static char *symbuf = 0;\n        static int length = 0;\n        int i;\n        if (length == 0)\n            length = 40, symbuf = (char *) malloc(length + 1);\n        i = 0;\n        do {\n            if (i == length)\n            {\n                length *= 2;\n                symbuf = realloc(symbuf, length + 1);\n            }\n            symbuf[i++] = c;\n            c = getchar();\n        } while (c != EOF \u0026#x26;\u0026#x26; isalnum(c));\n\n        ungetc(c, stdin);\n        symbuf[i] = '\\0';\n        s = getsym(symbuf);\n        if (s == 0)\n            s = putsym(symbuf, VAR);\n        yylval.tptr = s;\n        return s-\u003etype;\n    }\n\n    return c;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* Data type for links in the chain of symbols.      */\nstruct symrec\n{\n    char *name;  /* name of symbol                     */\n    int type;    /* type of symbol: either VAR or FNCT */\n    union {\n        double var;           /* value of a VAR          */\n        double (*fnctptr)();  /* value of a FNCT         */\n    } value;\n    struct symrec *next;    /* link field              */\n};\n\ntypedef struct symrec symrec;\n\n/* The symbol table: a chain of `struct symrec'.     */\nextern symrec *sym_table;\n\nsymrec *putsym ();\nsymrec *getsym ();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-make\"\u003ecalc: calc.y calc.h\n    bison -o calc.c calc.y \n    gcc -o calc calc.c -w\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e高级语言相较于机器语言、汇编语言，更加符合人的思考习惯。换句话说，更偏向于自然语言的风格而更偏离指令化的描述。用高级语言编写的一行代码，最终可能需要处理器执行若干条指令。如何让机器意识到高级语言代码对应的机器指令是哪些呢？当然就需要一个优秀的翻译。\u003c/p\u003e\n\u003cp\u003e无论是编译型语言还是解释型语言，总逃脱不了这样一个流程：高级语言 ➜ 目标平台的指令。所谓编译型/解释型的区别，在于其转换流程是在线的(online)还是离线的(offline)。在线的方式无法意识到后续的代码，但胜在即时反应；离线的方式可以统揽全局，进行更多的优化，但代码文本必须完整。\u003c/p\u003e\n\u003cp\u003e高级语言 ➜ 目标平台的指令，这样的流程如何实现。一般来说，划分为四个阶段：词法分析、语法分析、语义分析、目标代码生成。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNc79ly1g2b583io0ej30wq094aa5.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e本篇的主要目的，是展示“语言翻译”的几个阶段工作，以及通过 Lex \u0026#x26; Yacc 工具演示一门自定义语言的“翻译”。\u003c/p\u003e"},{"url":"2019-04-10-understand-Kernel-10","fileName":"2019-04-10-understand-Kernel-10.md","title":"理解 Linux Kernel(10) - Context of Execution","author":"fangfeng","date":"2019-04-10T00:00:00.000Z","tags":["Linux","Kernel","COE"],"content":"\u003cp\u003e在进行\u003ca href=\"https://www.ffutop.com/2018-10-12-understand-Kernel-4/\"\u003e第四篇(任务调度)\u003c/a\u003e行文描述时，就一直闹不清内核所谓的\u003ccode\u003etask\u003c/code\u003e的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：\u003cstrong\u003e我们错误地将理论和实践不加区分地混淆了\u003c/strong\u003e。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，\u003ccode\u003etask\u003c/code\u003e 也就是 \u003ccode\u003eContext of Execution\u003c/code\u003e 概念在实现上的表征。\u003c/p\u003e\n\u003cp\u003e执行的上下文(Context of Execution, COE)，记录了所有程序执行中的状态，包括：CPU状态（寄存器信息等）、MMU状态（页映射）、权限状态（uid、gid等）和一些公共属性（打开的文件、信号处理函数等）。对比理论上的进程/线程概念，粗略地讲就是同一线程组的线程各自持有CPU状态而共享其它状态，而认为两进程不共享任何状态。当然，在内核的概念里，进程/线程只是COE共享部分状态中的一个特例。\u003c/p\u003e\n\u003ch2\u003efork, clone\u003c/h2\u003e\n\u003cp\u003e如果用进程/线程的概念来看，内核提供了 \u003ccode\u003efork\u003c/code\u003e 来完成进程的复制，提供了 \u003ccode\u003eclone\u003c/code\u003e 来处理线程的拷贝，另外还有 \u003ccode\u003evfork\u003c/code\u003e , \u003ccode\u003ekernel_thread\u003c/code\u003e 等。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003esyscall fork\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage int sys_fork(struct pt_regs regs)\n{\n    return do_fork(SIGCHLD, regs.esp, \u0026#x26;regs, 0, NULL, NULL);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003esyscall clone\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage int sys_clone(struct pt_regs regs)\n{\n    unsigned long clone_flags;\n    unsigned long newsp;\n    int __user *parent_tidptr, *child_tidptr;\n    \n    clone_flags = regs.ebx;\n    newsp = regs.ecx;\n    parent_tidptr = (int __user *)regs.edx;\n    child_tidptr = (int __user *)regs.edi;\n    if (!newsp)\n        newsp = regs.esp;\n    return do_fork(clone_flags, newsp, \u0026#x26;regs, 0, parent_tidptr, child_tidptr);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003esyscall vfork\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage int sys_vfork(struct pt_regs regs)\n{\n    return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.esp, \u0026#x26;regs, 0, NULL, NULL);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ekernel function: kernel_thread\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)\n{\n    // ...\n    return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, \u0026#x26;regs, 0, NULL, NULL);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efork\u003c/code\u003e, \u003ccode\u003eclone\u003c/code\u003e, \u003ccode\u003evfork\u003c/code\u003e 的入参怎么和日常使用的系统调用入参不同？且看：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e    .macro PTREGSCALL label, func, arg\n    .globl \\label\n\\label:\n    leaq \\func(%rip),%rax\n    leaq -ARGOFFSET+8(%rsp),\\arg    /* 8 for return address */\n    jmp  ia32_ptregs_common\n    .endm\n\n    CFI_STARTPROC32\n\n    PTREGSCALL stub32_rt_sigreturn, sys32_rt_sigreturn, %rdi\n    PTREGSCALL stub32_sigreturn, sys32_sigreturn, %rdi\n    PTREGSCALL stub32_sigaltstack, sys32_sigaltstack, %rdx\n    PTREGSCALL stub32_sigsuspend, sys32_sigsuspend, %rcx\n    PTREGSCALL stub32_execve, sys32_execve, %rcx\n    PTREGSCALL stub32_fork, sys_fork, %rdi\n    PTREGSCALL stub32_clone, sys32_clone, %rdx\n    PTREGSCALL stub32_vfork, sys_vfork, %rdi\n    PTREGSCALL stub32_iopl, sys_iopl, %rsi\n    PTREGSCALL stub32_rt_sigsuspend, sys_rt_sigsuspend, %rdx\n\nENTRY(ia32_ptregs_common)\n    popq %r11\n    CFI_ENDPROC\n    CFI_STARTPROC32 simple\n    CFI_SIGNAL_FRAME\n    CFI_DEF_CFA rsp,SS+8-ARGOFFSET\n    CFI_REL_OFFSET  rax,RAX-ARGOFFSET\n    CFI_REL_OFFSET  rcx,RCX-ARGOFFSET\n    CFI_REL_OFFSET  rdx,RDX-ARGOFFSET\n    CFI_REL_OFFSET  rsi,RSI-ARGOFFSET\n    CFI_REL_OFFSET  rdi,RDI-ARGOFFSET\n    CFI_REL_OFFSET  rip,RIP-ARGOFFSET\n/*  CFI_REL_OFFSET  cs,CS-ARGOFFSET*/\n/*  CFI_REL_OFFSET  rflags,EFLAGS-ARGOFFSET*/\n    CFI_REL_OFFSET  rsp,RSP-ARGOFFSET\n/*  CFI_REL_OFFSET  ss,SS-ARGOFFSET*/\n    SAVE_REST\n    call *%rax\n    RESTORE_REST\n    jmp  ia32_sysret    /* misbalances the return cache */\n    CFI_ENDPROC\nEND(ia32_ptregs_common)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e进行系统调用时的处理逻辑统一地将这些内容进行了整合，并将CPU状态（所有通用寄存器状态）维护到 \u003ccode\u003estruct pt_regs\u003c/code\u003e 数据块中。总结起来，三种系统调用最终都委托给 \u003ccode\u003edo_fork\u003c/code\u003e 进行实现，只是在参数的选择方面做了不同的预处理。这在用户层的函数原型上就更为明显，\u003ccode\u003efork\u003c/code\u003e 和 \u003ccode\u003evfork\u003c/code\u003e 都不允许参数的调用。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003epid_t fork(void);\n\n/* for x86-32 */\nlong clone(unsigned long flags, void *child_stack,\n        int *ptid, unsigned long newtls,\n        int *ctid);\n\npid_t vfork(void);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再看看 \u003ccode\u003eflags\u003c/code\u003e 有哪些值可选。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/*\n * cloning flags:\n */\n#define CSIGNAL     0x000000ff  /* signal mask to be sent at exit */\n#define CLONE_VM    0x00000100  /* set if VM shared between processes */\n#define CLONE_FS    0x00000200  /* set if fs info shared between processes */\n#define CLONE_FILES 0x00000400  /* set if open files shared between processes */\n#define CLONE_SIGHAND   0x00000800  /* set if signal handlers and blocked signals shared */\n#define CLONE_PTRACE    0x00002000  /* set if we want to let tracing continue on the child too */\n#define CLONE_VFORK 0x00004000  /* set if the parent wants the child to wake it up on mm_release */\n#define CLONE_PARENT    0x00008000  /* set if we want to have the same parent as the cloner */\n#define CLONE_THREAD    0x00010000  /* Same thread group? */\n#define CLONE_NEWNS 0x00020000  /* New namespace group? */\n#define CLONE_SYSVSEM   0x00040000  /* share system V SEM_UNDO semantics */\n#define CLONE_SETTLS    0x00080000  /* create a new TLS for the child */\n#define CLONE_PARENT_SETTID 0x00100000  /* set the TID in the parent */\n#define CLONE_CHILD_CLEARTID    0x00200000  /* clear the TID in the child */\n#define CLONE_DETACHED      0x00400000  /* Unused, ignored */\n#define CLONE_UNTRACED      0x00800000  /* set if the tracing process can't force CLONE_PTRACE on this clone */\n#define CLONE_CHILD_SETTID  0x01000000  /* set the TID in the child */\n#define CLONE_STOPPED       0x02000000  /* Start in stopped state */\n#define CLONE_NEWUTS        0x04000000  /* New utsname group? */\n#define CLONE_NEWIPC        0x08000000  /* New ipcs */\n#define CLONE_NEWUSER       0x10000000  /* New user namespace */\n#define CLONE_NEWPID        0x20000000  /* New pid namespace */\n#define CLONE_NEWNET        0x40000000  /* New network namespace */\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003exxx shared between processes\u003c/code\u003e ，描述即将被创建的新任务将进行哪些状态/资源的共享，而哪些状态需要进行拷贝。\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003edo_fork\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e先看看核心的 \u003ccode\u003edo_fork\u003c/code\u003e 的逻辑。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eHint: 下列代码经过大量的删减\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003elong do_fork(unsigned long clone_flags,\n        unsigned long stack_start,\n        struct pt_regs *regs,\n        unsigned long stack_size,\n        int __user *parent_tidptr,\n        int __user *child_tidptr)\n{\n    p = copy_process(clone_flags, stack_start, regs, stack_size, child_tidptr, NULL);\n    if (!IS_ERR(p)) {\n        nr = (clone_flags \u0026#x26; CLONE_NEWPID) ?\n            task_pid_nr_ns(p, current-\u003ensproxy-\u003epid_ns) :\n                task_pid_vnr(p);\n        if (!(clone_flags \u0026#x26; CLONE_STOPPED))\n            wake_up_new_task(p, clone_flags);\n        else\n            p-\u003estate = TASK_STOPPED;\n    } else {\n        nr = PTR_ERR(p);\n    }\n    return nr;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic struct task_struct *copy_process(unsigned long clone_flags,\n                    unsigned long stack_start,\n                    struct pt_regs *regs,\n                    unsigned long stack_size,\n                    int __user *child_tidptr,\n                    struct pid *pid)\n{\n    /* 预分配 task_struct 数据结构空间 */\n    retval = security_task_create(clone_flags);\n    /* 复制 current 的 task_struct 数据结构 */\n    p = dup_task_struct(current);\n\n    if (nr_threads \u003e= max_threads)\n        goto bad_fork_cleanup_count;\n\n    /* 针对多核CPU，为新任务分配CPU */\n    sched_fork(p, clone_flags);\n    /* 复制 thread_info 数据结构及线程栈 */\n    retval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);\n\n    /* 分配新的 pid */\n    p-\u003epid = pid_nr(pid);\n    /* thread group id = new pid */\n    p-\u003etgid = p-\u003epid;\n    /* 如果标志是 CLONE_THREAD，tgid = 父任务id */\n    if (clone_flags \u0026#x26; CLONE_THREAD)\n        p-\u003etgid = current-\u003etgid;\n\n    p-\u003eset_child_tid = (clone_flags \u0026#x26; CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n    p-\u003eclear_child_tid = (clone_flags \u0026#x26; CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;\n    /*\n     * sigaltstack should be cleared when sharing the same VM\n     */\n    if ((clone_flags \u0026#x26; (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n        p-\u003esas_ss_sp = p-\u003esas_ss_size = 0;\n\n    /* ok, now we should be set up.. */\n    p-\u003eexit_signal = (clone_flags \u0026#x26; CLONE_THREAD) ? -1 : (clone_flags \u0026#x26; CSIGNAL);\n    p-\u003epdeath_signal = 0;\n    p-\u003eexit_state = 0;\n\n    /*\n     * Ok, make it visible to the rest of the system.\n     * We dont wake it up yet.\n     */\n    p-\u003egroup_leader = p;\n    INIT_LIST_HEAD(\u0026#x26;p-\u003ethread_group);\n    INIT_LIST_HEAD(\u0026#x26;p-\u003eptrace_children);\n    INIT_LIST_HEAD(\u0026#x26;p-\u003eptrace_list);\n\n    p-\u003ecpus_allowed = current-\u003ecpus_allowed;\n    if (unlikely(!cpu_isset(task_cpu(p), p-\u003ecpus_allowed) ||\n            !cpu_online(task_cpu(p))))\n        set_task_cpu(p, smp_processor_id());\n\n    /* CLONE_PARENT re-uses the old parent */\n    if (clone_flags \u0026#x26; (CLONE_PARENT|CLONE_THREAD))\n        p-\u003ereal_parent = current-\u003ereal_parent;\n    else\n        p-\u003ereal_parent = current;\n    p-\u003eparent = p-\u003ereal_parent;\n\n    spin_lock(\u0026#x26;current-\u003esighand-\u003esiglock);\n\n    if (clone_flags \u0026#x26; CLONE_THREAD) {\n        p-\u003egroup_leader = current-\u003egroup_leader;\n        list_add_tail_rcu(\u0026#x26;p-\u003ethread_group, \u0026#x26;p-\u003egroup_leader-\u003ethread_group);\n\n        if (!cputime_eq(current-\u003esignal-\u003eit_virt_expires,\n                cputime_zero) ||\n            !cputime_eq(current-\u003esignal-\u003eit_prof_expires,\n                cputime_zero) ||\n            current-\u003esignal-\u003erlim[RLIMIT_CPU].rlim_cur != RLIM_INFINITY ||\n            !list_empty(\u0026#x26;current-\u003esignal-\u003ecpu_timers[0]) ||\n            !list_empty(\u0026#x26;current-\u003esignal-\u003ecpu_timers[1]) ||\n            !list_empty(\u0026#x26;current-\u003esignal-\u003ecpu_timers[2])) {\n            /*\n             * Have child wake up on its first tick to check\n             * for process CPU timers.\n             */\n            p-\u003eit_prof_expires = jiffies_to_cputime(1);\n        }\n    }\n\n    if (likely(p-\u003epid)) {\n        add_parent(p);\n        if (unlikely(p-\u003eptrace \u0026#x26; PT_PTRACED))\n            __ptrace_link(p, current-\u003eparent);\n\n        if (thread_group_leader(p)) {\n            if (clone_flags \u0026#x26; CLONE_NEWPID)\n                p-\u003ensproxy-\u003epid_ns-\u003echild_reaper = p;\n\n            p-\u003esignal-\u003etty = current-\u003esignal-\u003etty;\n            set_task_pgrp(p, task_pgrp_nr(current));\n            set_task_session(p, task_session_nr(current));\n            attach_pid(p, PIDTYPE_PGID, task_pgrp(current));\n            attach_pid(p, PIDTYPE_SID, task_session(current));\n            list_add_tail_rcu(\u0026#x26;p-\u003etasks, \u0026#x26;init_task.tasks);\n            __get_cpu_var(process_counts)++;\n        }\n        attach_pid(p, PIDTYPE_PID, pid);\n        nr_threads++;\n    }\n\n    total_forks++;\n    spin_unlock(\u0026#x26;current-\u003esighand-\u003esiglock);\n    write_unlock_irq(\u0026#x26;tasklist_lock);\n    proc_fork_connector(p);\n    cgroup_post_fork(p);\n    return p;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e根据入参配置的 \u003ccode\u003eflags\u003c/code\u003e ，\u003ccode\u003ecopy_process\u003c/code\u003e 确定了新任务与父任务共享的状态，以及一些需要拷贝的状态。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efork\u003c/code\u003e 产生一个新的任务，与父任务不存在任何资源共享的情况。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eclone\u003c/code\u003e 可高度定制化的系统调用，几乎可以自由组合定制新的任务\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evfork\u003c/code\u003e 历史原因而存在的系统调用，设计目的在于一般 \u003ccode\u003efork\u003c/code\u003e 之后都将调用 \u003ccode\u003eexecve\u003c/code\u003e 来执行全新的任务，也就导致了 \u003ccode\u003efork\u003c/code\u003e 所做的拷贝全部白费，因此搞了个轻量级的 \u003ccode\u003evfork\u003c/code\u003e 来避免做内存的拷贝。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eVFORK\u003c/strong\u003e\nHistoric description\nUnder Linux, fork(2) is implemented using copy-on-write pages, so the only penalty incurred by fork(2) is the time and memory required to duplicate the  parent's page tables, and to create a unique task structure for the child.  However, in the bad old days a fork(2) would require making a complete copy of the caller's data space, often needlessly, since usually immediately afterward an exec(3) is done.  Thus, for greater efficiency, BSD introduced  the  vfork() system call, which did not fully copy the address space of the parent process, but borrowed the parent's memory and thread of control until a call to execve(2) or an exit occurred.  The parent process was suspended while the child was using its resources.   The  use  of vfork() was tricky: for example, not modifying data in the parent process depended on knowing which variables were held in a register.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003epid, tgid\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* 分配新的 pid */\np-\u003epid = pid_nr(pid);\n/* thread group id = new pid */\np-\u003etgid = p-\u003epid;\n/* 如果标志是 CLONE_THREAD，tgid = 父任务id */\nif (clone_flags \u0026#x26; CLONE_THREAD)\n    p-\u003etgid = current-\u003etgid;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epid\u003c/code\u003e 作为每个 \u003ccode\u003etask\u003c/code\u003e 的唯一标识符存在。\u003ccode\u003etgid\u003c/code\u003e 用于指代线程组id，从代码上看也就是进程主线程id。（请原谅我又用了进程/线程的表述）\u003c/p\u003e\n\u003cp\u003e看着没有问题？当然不可能。这段代码可是意味着 \u003ccode\u003epid\u003c/code\u003e 唯一啊，这可不符合日常表述啊。对于系统的终端用户来讲，一个进程可以有一个或多个线程。\u003ccode\u003epid\u003c/code\u003e 可是一直被翻译成进程ID(process id)。难道？\u003c/p\u003e\n\u003cp\u003e这就是本质实现与表面功夫的差别啦。\u003ccode\u003epid_t getpid(void);\u003c/code\u003e, \u003ccode\u003epid_t gettid(void);\u003c/code\u003e 两个系统调用分别被用来提供进程ID和线程ID（请仔细思考下代码实现和对外展示的差距）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/**\n * sys_getpid - return the thread group id of the current process\n *\n * Note, despite the name, this returns the tgid not the pid.  The tgid and\n * the pid are identical unless CLONE_THREAD was specified on clone() in\n * which case the tgid is the same in all threads of the same group.\n *\n * This is SMP safe as current-\u003etgid does not change.\n */\nasmlinkage long sys_getpid(void)\n{\n    return task_tgid_vnr(current);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* Thread ID - the internal kernel \"pid\" */\nasmlinkage long sys_gettid(void)\n{\n    return task_pid_vnr(current);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样就好懂多了吧。用户态通过系统调用取到的 \u003ccode\u003epid\u003c/code\u003e, \u003ccode\u003etid\u003c/code\u003e 已经经过了一层加工，分别映射着内核实现的 \u003ccode\u003etgid\u003c/code\u003e, \u003ccode\u003epid\u003c/code\u003e 。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e额外地：想通过 \u003ccode\u003eps\u003c/code\u003e 查看进程/线程可以使用 \u003ccode\u003eps -eLf\u003c/code\u003e\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003eschedule\u003c/h2\u003e\n\u003cp\u003e再来回顾下任务调度是如何实现的。与\u003ca href=\"https://www.ffutop.com/2018-10-12-understand-Kernel-4/\"\u003e第四篇 任务调度\u003c/a\u003e描述的并无太大不同。要说最大的区分，就是早期版本与时下版本顺时的演进。当然，还有就是多核CPU下的SMP调度。\u003c/p\u003e\n\u003cp\u003e至于多核下的所谓进程/线程如何调度。内核根本认识不到进程/线程的概念，唯一的只有任务(task, or COE)。而每个用户所认为的线程在内核的认识下也是一个任务。因此，所谓用户认识到的多线程并发执行在多核CPU下也就完全是可行的。\u003c/p\u003e\n\u003ch2\u003econcept of Thread\u003c/h2\u003e\n\u003cp\u003e且不论Linux内核没有线程概念的前提，线程的定义总是存在的，而满足其定义的实现，也就可以被称为“线程”。哪些要素组成了线程呢？\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e线程是与其它代码共享进程地址空间的最小执行流\u003c/li\u003e\n\u003cli\u003e诸如栈、寄存器信息、本地线程数据需要保持独立\u003c/li\u003e\n\u003cli\u003e互斥锁(Mutex)、条件变量(Condition Variable)、线程间同步管理的支持\u003c/li\u003e\n\u003cli\u003e...\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e既然都说了Linux内核没有线程概念，现在却又开始提，这不是打脸嘛？OK，具体情况是：内核本身不支持线程，甚至没有线程概念。但其通过GLIBC的NPTL(Native POSIX Thread Library)支持了线程。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在Linux内核2.6出现之前任务是(最小)可调度的对象，当时的Linux不真正支持线程。但是Linux内核有一个系统调用指令\u003ccode\u003eclone()\u003c/code\u003e，这个指令将产生一个调用方任务的拷贝，而且这个拷贝可以与原任务使用同一地址空间。LinuxThreads计划使用这个系统调用来提供一个内核级别的线程支持。但是这个解决方法与真正的POSIX标准有一些不兼容的地方，尤其是在信号处理、进程调度和进程间同步原语方面。\n\u003cem\u003eCopied From \u003ca href=\"https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library\"\u003eWikipedia NPTL\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNc79ly1g1x9mjuahnj31400u0doi.jpg\" alt=\"Linux 架构\"\u003e\u003c/p\u003e\n\u003ch2\u003eThread Model\u003c/h2\u003e\n\u003cp\u003e最后，聊聊线程模型。相信各位不管懂或不懂，至少都听说过 1:1, N:1, M:N 线程模型。至于究竟这些模型是怎么回事呢？且看：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNc79ly1g1xhulou5bj30go08zglv.jpg\" alt=\"Thread Model\"\u003e\u003c/p\u003e\n\u003ch3\u003e1:1 Model\u003c/h3\u003e\n\u003cp\u003e最简单的线程模型，也是内核通过NPTL最容易实现的一种模型。每个通过 \u003ccode\u003eclone\u003c/code\u003e 产生的新任务（当然，至少要符合共享内存等线程定义）对应用程序来说就是一个新线程。所谓的用户级线程和内核级线程，在 1:1 模型中就是同一个任务，只是新任务在被内核 \u003ccode\u003eclone\u003c/code\u003e 之后，又由NPTL做了进一步的管理，因此在形式上看似有用户级/内核级之分。\u003c/p\u003e\n\u003ch3\u003eN:1 Model\u003c/h3\u003e\n\u003cp\u003eN:1 线程模型又称为“用户级线程模型”。在这种模型下，线程的概念由用户态代码进行支持，包括用来管理线程的用户空间调度器以及以非阻塞模式捕捉和处理I/O机制。使用N:1模型的好处在于其上下文切换的代价几乎为零，毕竟这是纯用户态的。当然，缺点也比较明显：由于对内核来说，认为这只是单个任务，也就无法充分利用多核CPU的特性。\u003c/p\u003e\n\u003ch3\u003eM:N Model\u003c/h3\u003e\n\u003cp\u003e有没有方式整合1:1模型和N:1模型，让内核意识到有几个任务，但又存在更多的线程在用户级执行呢？当然也是可行，但如何协调调度又是费事费力的实现了。\u003c/p\u003e\n\u003ch2\u003eThreads vs Events\u003c/h2\u003e\n\u003cp\u003e线程怎么又和事件扯上关系了呢？先来回顾下任务调度的几种模式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e串行，每个任务依次执行，不存在任务调度\u003c/li\u003e\n\u003cli\u003e抢占式，通过时钟中断决定是否切换任务\u003c/li\u003e\n\u003cli\u003e协作式，只有当任务主动放弃对CPU的占用，才能轮到下一个任务。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e对于用户级线程来说，内核无法意识到这些线程的存在，硬件发起的所有中断又都被内核捕获。因此，想要实现抢占式是不可能完成的任务（至少以本人目前所知是不可能的）。故协作式线程调度是用户级线程的唯一选择。而协作式就意味着是由线程硬编码主动放弃任务执行（\u003ccode\u003eyield\u003c/code\u003e / \u003ccode\u003eschedule\u003c/code\u003e / etc.）。如此这般，与事件驱动下，不同代码片之间的调度又是何其相似。当然，只是开个玩笑，如果都一样了，直接用事件驱动不就OK了。线程之所以是线程，有其独特的定义在。不过不再细说，可以参考 \u003ca href=\"http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/Threads-VS-Events.pdf\"\u003eThreads vs Events\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e[1]. Mauerer W. Professional Linux kernel architecture[M]. John Wiley \u0026#x26; Sons, 2010.\n[2]. \u003ca href=\"http://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html\"\u003eLinus Torvalds. Re: proc fs and shared pids\u003c/a\u003e[EL/OL]. Aug 6th, 1996.\n[3]. \u003ca href=\"https://randu.org/tutorials/threads/\"\u003eMultithreaded Programming (POSIX pthreads Tutorial)\u003c/a\u003e[EL/OL].\n[4]. \u003ca href=\"https://blog.csdn.net/u012432778/article/details/47378321\"\u003e线程模型\u003c/a\u003e[EL/OL].\n[5]. \u003ca href=\"https://www.evanjones.ca/software/threading.html\"\u003eImplementing a Thread Library on Linux\u003c/a\u003e[EL/OL]. Dec 10th, 2003.\u003c/p\u003e\n\u003ch2\u003e用户级线程资料参考\u003c/h2\u003e\n\u003cp\u003e[1]. \u003ccode\u003eman makecontext\u003c/code\u003e \u0026#x26; \u003ccode\u003eman swapcontext\u003c/code\u003e\n[2]. \u003ca href=\"https://github.com/brianwatling/libfiber\"\u003eLibfiber\u003c/a\u003e\n[3]. \u003ca href=\"https://github.com/dramesh/GTThreads\"\u003e\u003cstrong\u003e所谓的\u003c/strong\u003e抢占式用户线程实现\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e在进行\u003ca href=\"https://www.ffutop.com/2018-10-12-understand-Kernel-4/\"\u003e第四篇(任务调度)\u003c/a\u003e行文描述时，就一直闹不清内核所谓的\u003ccode\u003etask\u003c/code\u003e的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：\u003cstrong\u003e我们错误地将理论和实践不加区分地混淆了\u003c/strong\u003e。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，\u003ccode\u003etask\u003c/code\u003e 也就是 \u003ccode\u003eContext of Execution\u003c/code\u003e 概念在实现上的表征。\u003c/p\u003e"},{"url":"2019-03-25-mem-dump","fileName":"2019-03-25-mem-dump.md","title":"如何获取运行时进程堆栈","author":"fangfeng","date":"2019-03-25T00:00:00.000Z","tags":["Kernel","Linux","dump"],"content":"\u003cp\u003e前些天看了关于在密码学应用中使用\u003ccode\u003ejava.lang.String\u003c/code\u003e与\u003ccode\u003ebyte[]\u003c/code\u003e的相关讨论，不推荐使用\u003ccode\u003ejava.lang.String\u003c/code\u003e的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。\u003c/p\u003e\n\u003ch2\u003e/proc/${pid}/maps\u003c/h2\u003e\n\u003cp\u003e首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从\u003ccode\u003e/proc\u003c/code\u003e虚拟文件系统中，提供了进程虚拟地址映射。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaddress                   perm offset   dev   inode                      pathname\n556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run\n556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run\n556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run\n55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]\n7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0\n7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0\n7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0\n7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]\n7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]\n7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]\nffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e/proc/${pid}/maps\u003c/code\u003e 记录了当前进程虚拟内存区域的分配以及其访问控制。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e前三行表述的是当前进程ELF文件在虚拟内存中的地址（这里使用的ELF文件名为 \u003ccode\u003erun\u003c/code\u003e ）\u003cul\u003e\n\u003cli\u003e第一行 \u003ccode\u003er-xp\u003c/code\u003e 表示其将配合\u003ccode\u003eCode Segment Register (CS)\u003c/code\u003e 作为CPU执行指令的直接依据。\u003c/li\u003e\n\u003cli\u003e第二三行分别用作可读、可写数据区，将配合 \u003ccode\u003eData Segment Register (DS), ES, FS, GS\u003c/code\u003e 等使用\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e第四行直截了当，就是分配给堆的地址空间。当然，如果不够，可以不断地向上扩张。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003exxx.so\u003c/code\u003e 文件描述的是C共享库在虚拟内存中的地址。\u003c/li\u003e\n\u003cli\u003e最后才是栈内存，将以倒序的方式下内存低地址扩张。\u003c/li\u003e\n\u003cli\u003e至于之后的内容，不了解，不表。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eptrace\u003c/h2\u003e\n\u003cp\u003e拿到了进程虚拟内存分布，又如何获取其中的内容。\u003ccode\u003eptrace\u003c/code\u003e 总算是派上用场了。之前在阅读内核源码的时候，任务数据结构 \u003ccode\u003estruct task\u003c/code\u003e 专门为此预留了一些字段来加以描述，但始终找不到其用途。现在总算对其有了初步的了解。\u003c/p\u003e\n\u003cp\u003e一般来说，进程彼此之间应该相互独立，虽然运行在同一台机器上，但应该是相互间不知道其他进程的存在。那又如何能够通过一个进程的代码来获取另一个进程的堆栈数据呢？\u003ccode\u003eptrace\u003c/code\u003e 提供的就是这么一种可能性。通过 \u003ccode\u003ePTRACE_ATTACH\u003c/code\u003e 和 \u003ccode\u003ePTRACE_DETACH\u003c/code\u003e，A进程会使得目标进程B陷入Sleeping状态，而等待A继续通过其他命令来获取其数据。至于为什么会是陷入Sleeping呢？一旦B进程的在运行，数据等随时可能改变，显然不适合读取数据啊。\u003c/p\u003e\n\u003cp\u003e如何读取？\u003ccode\u003ePTRACE_PEEKTEXT\u003c/code\u003e 就是这样一个实现进程间交互的好工具。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid attach()\n{\n    if (ptrace(PTRACE_ATTACH, options.pid, NULL, NULL) == -1)\n    {\n        fprintf(stderr, \"ptract attach failed. %s(errno: %d)\\n\", strerror(errno), errno);\n        exit(0);\n    }\n    fprintf(stderr, \"attach to %d success!\\n\", options.pid);\n    wait(NULL);\n}\n\nvoid peek()\n{\n    char maps[17];\n    sprintf(maps, \"/proc/%d/maps\", options.pid);\n    FILE *fd = fopen(maps, \"r\");\n    if (fd == NULL)\n    {\n        fprintf(stderr, \"open /proc/%d/maps failed. %s(errno: %d)\\n\", strerror(errno), errno);\n        exit(0);\n    }\n\n    struct map *map = (struct map *) malloc(sizeof(struct map *));\n\n    long word;\n    while (fscanf(fd, \"%llx-%llx %s %lx %*s %*s%*[^\\n]\", \u0026#x26;map-\u003estart_addr, \u0026#x26;map-\u003eend_addr, map-\u003eop_flag, \u0026#x26;map-\u003eoffset) != EOF)\n    {\n        if (map-\u003eop_flag[0] == '-')\n            continue;\n        fprintf(stderr, \"peek from [%llx-%llx]\\n\", map-\u003estart_addr, map-\u003eend_addr);\n        long mem_len = map-\u003eend_addr - map-\u003estart_addr;\n        char *data = malloc(mem_len + 1);\n        for (long cursor = map-\u003estart_addr;cursor \u0026#x3C; map-\u003eend_addr;cursor += sizeof(long))\n        {\n            if ((word = ptrace(PTRACE_PEEKTEXT, options.pid, cursor, NULL)) == -1 \u0026#x26;\u0026#x26; errno)\n            {\n                fprintf(stderr, \"peek failed. %s(errno: %d)\\n\", strerror(errno), errno);\n                free(data);\n                exit(0);\n            }\n            memcpy(data+cursor-map-\u003estart_addr, \u0026#x26;word, sizeof(word));\n        }\n        dump(data, mem_len);\n\n        free(data);\n    }\n\n    free(map);\n}\n\nvoid detach()\n{\n    if (ptrace(PTRACE_DETACH, options.pid, NULL, NULL) == -1)\n    {\n        fprintf(\"ptract detach failed. %s(errno: %d)\\n\", strerror(errno), errno);\n        exit(0);\n    }\n    fprintf(stderr, \"detach from %d success!\", options.pid);\n}\n\nint main(int argc, char **argv)\n{\n    // ...\n\n    attach();\n    peek();\n    detach();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e此处的代码片段就能完成dump堆栈的工作了（当然，由于没有对其它内容进行处理，同时会dump下ELF数据等）。\u003ca href=\"https://github.com/DorMOUSE-None/ffDump\"\u003e完整代码\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e小结\u003c/h2\u003e\n\u003cp\u003e当然，之后才发现 GDB 的实现借用的也正是这样一套机制。同时也意味着上面这段代码的实现在 GDB 中有现成的工具了:\u0026#x3C;\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e前些天看了关于在密码学应用中使用\u003ccode\u003ejava.lang.String\u003c/code\u003e与\u003ccode\u003ebyte[]\u003c/code\u003e的相关讨论，不推荐使用\u003ccode\u003ejava.lang.String\u003c/code\u003e的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。\u003c/p\u003e\n\u003ch2\u003e/proc/${pid}/maps\u003c/h2\u003e\n\u003cp\u003e首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从\u003ccode\u003e/proc\u003c/code\u003e虚拟文件系统中，提供了进程虚拟地址映射。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaddress                   perm offset   dev   inode                      pathname\n556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run\n556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run\n556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run\n55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]\n7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so\n7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0\n7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0\n7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so\n7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0\n7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]\n7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]\n7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]\nffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\n\u003c/code\u003e\u003c/pre\u003e"},{"url":"2019-03-19-JANUS","fileName":"2019-03-19-JANUS.md","title":"认证与授权·简述","author":"fangfeng","date":"2019-03-19T00:00:00.000Z","tags":["Authenticate","Authorize"],"content":"\u003ch2\u003e概述\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在大多数系统中，都或多或少需要认证授权模型/系统的支持。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e认证/授权是什么？最简单的，我们的系统要求用户必须在“登录”之后才允许进行一些操作。“登录”的过程就是认证；而区别与未登录状态，只允许登录用户进行一些操作，这就是授权。认证与授权相互独立，有协同配合，共同支撑起系统对安全的基本要求。\u003c/p\u003e\n\u003ch2\u003e认证与授权\u003c/h2\u003e\n\u003cp\u003e认证的目的在于认出用户。日常生活中，我们通过视觉、声音等因素认出一个人。但是就网络应用而言，应用最多只能够认识到发起请求的浏览器、手机APP、物联网设备等用户代理(User Agent)，也无法直接地将用户与用户代理进行绑定。因此，向应用证明操作这些用户代理的实体就成了至关重要的步骤。你需要通过密码、手机验证码、人脸识别或其它形式凭证来完成“登录”操作，即认证。\u003c/p\u003e\n\u003cp\u003e当然了，我们也认识到，不是所有的操作都需要一个这般复制“登录”流程的，即使这些操作逻辑上也需要认出背后的用户是谁。这部分所使用到的技术就是“会话管理”了。在一定的有效期范围内，用户无需重复证明自己的身份，而用户-应用间保持最基本的信任。当然，一般来说，修改密码等危险操作还是需要再次进行认证。\u003c/p\u003e\n\u003cp\u003e总而言之，无论是“登录”认证抑或是“会话”认证，其目的都是为了认出用户。\u003c/p\u003e\n\u003cp\u003e完成认证之后，就要启用授权了。授权负责的是控制用户能干什么。管理员和普通员工所能进行的操作肯定是有所差别的。借助于前置认证提供用户身份信息，授权将对用户的操作进行决断。\u003c/p\u003e\n\u003ch2\u003e访问控制（权限控制）\u003c/h2\u003e\n\u003cp\u003e授权旨在界定用户能够进行哪些操作，而访问控制正是进行授权界定的措施、手段。该如何实施访问控制呢？看人下菜是最简单、最容易被接受的方式——为每个用户独立地分配权限。但是，就Web应用而言，如此行事的代价将是及其巨大的。动辄几十万、上百万...的用户量，又如何维护得起这般细致的控制呢。而且，每个用户独立设置权限，同时也意味着每个权限需要直接对接百十万的用户。\u003c/p\u003e\n\u003cp\u003e撇开可行性，访问控制做的就是这种活计——控制主体（用户）对客体（系统、API等）的操作。\u003c/p\u003e\n\u003cp\u003e主要的访问控制技术分为三类：自主访问控制、强制访问控制、基于角色的访问控制\u003c/p\u003e\n\u003ch3\u003e自主访问控制(Discretionary Access Control，DAC)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e每个客体都独立维护一张访问控制表(Access Control List, ACL)\u003c/li\u003e\n\u003cli\u003e每个客体都有一个所有者\u003c/li\u003e\n\u003cli\u003e所有者可以将其负责的客体访问权限分配给其它用户\u003c/li\u003e\n\u003cli\u003e每次主体对客体的访问都面向ACL做确认后执行\u003c/li\u003e\n\u003cli\u003e强依赖于所有者对安全要求的认知\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e强制访问控制(Mandatory Access Control, MAC)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e预置相应的密级，例如绝密级、机密级和普通级。密级有强弱关系\u003c/li\u003e\n\u003cli\u003e每个主体/客体都分配一个密级\u003c/li\u003e\n\u003cli\u003e每次主体对客体的操作，判定主体密级 \u003e= 客体密级即允许访问\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e基于角色的访问控制(Role-Based Access Control, RBAC)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e角色作为一系列有较强相关性权限的持有者\u003c/li\u003e\n\u003cli\u003e用户通过被分配一系列角色，从而间接地拥有权限集\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003e一般来说，DAC、MAC都不太适合于Web应用的访问控制。因此，后续的讨论都将基于RBAC进行。\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003e控制粒度\u003c/h2\u003e\n\u003cp\u003e如何定义一个客体，就涉及到控制粒度了。就Web应用而言，比较粗略的有数据粒度、方法粒度、URL粒度、系统粒度等等。任意粒度，都可以作为访问控制的组成部分，作为授权的一部分。但是，粒度的控制也会导致一些相当致命的问题。\u003c/p\u003e\n\u003cp\u003e越权问题就是一种粒度控制下的问题。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e纵向访问控制\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e顾名思义，纵向访问控制所控制的权限拥有一定的优先级概念，例如管理员操作与普通用户操作。特别适合于使用强制访问控制的解决方案，使用RBAC也并不困难，基本上只要定义两类角色也能解决。业内对于这类问题的解决方案相当成熟，需要的只是根据不同的业务场景进行适配。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e横向访问控制\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e对于横向访问控制，问题就不再那么的简单。在方法粒度下的RBAC模型，很容易就会导致A用户事实上访问了B用户数据的问题发生，也就是横向越权。而想要实现数据粒度的通用模型，却又不可避免地将对业务代码进行侵入。\u003c/p\u003e\n\u003cp\u003e控制粒度的取舍，就很大程度上取决于Web应用的实际需求。\u003c/p\u003e\n\u003ch2\u003e小结\u003c/h2\u003e\n\u003cp\u003e认证、授权的基本目的在于满足对安全的基本要求，其涉及的知识相当广泛。本篇的目的，仅仅在于阐释认证、授权两个术语的基本定义，并对访问控制技术做概要式的介绍。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e概述\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在大多数系统中，都或多或少需要认证授权模型/系统的支持。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e认证/授权是什么？最简单的，我们的系统要求用户必须在“登录”之后才允许进行一些操作。“登录”的过程就是认证；而区别与未登录状态，只允许登录用户进行一些操作，这就是授权。认证与授权相互独立，有协同配合，共同支撑起系统对安全的基本要求。\u003c/p\u003e"},{"url":"2019-03-05-understand-Kernel-9","fileName":"2019-03-05-understand-Kernel-9.md","title":"理解 Linux Kernel (9) - IO Multiplexing","author":"fangfeng","date":"2019-03-05T00:00:00.000Z","tags":["Linux","Kernel","IO Model"],"content":"\u003cp\u003e\u003ca href=\"./2019-01-15-understand-Kernel-8/\"\u003e前一篇\u003c/a\u003e已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 \u003ccode\u003estruct sock\u003c/code\u003e 对象，将其逐级从网络接口层逐级提升到网络层、传输层...最终添加到接收队列 \u003ccode\u003esk_receive_queue\u003c/code\u003e 中；用户进程通过 \u003ccode\u003eread\u003c/code\u003e、\u003ccode\u003erecv\u003c/code\u003e、\u003ccode\u003erecvfrom\u003c/code\u003e 等命令检查并获取 \u003ccode\u003esk_receive_queue\u003c/code\u003e 中的数据。\u003c/p\u003e\n\u003cp\u003e整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。\u003c/p\u003e\n\u003cp\u003e那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（\u003ccode\u003eselect\u003c/code\u003e, \u003ccode\u003epoll\u003c/code\u003e, \u003ccode\u003eepoll\u003c/code\u003e）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 \u003ccode\u003eselect\u003c/code\u003e 和 \u003ccode\u003eepoll\u003c/code\u003e 两类系统调用的实现进行探究。\u003c/p\u003e\n\u003ch2\u003eSELECT\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eselect\u003c/code\u003e 是一种比较古老的系统调用方式，存在着许多的调用限制。当然，相对的也就比较容易理解。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eselect\u003c/code\u003e 系统调用最初的逻辑就是对超时时间的相关操作，完成从用户数据段到内核数据段的数据拷贝工作，而使用 \u003ccode\u003ecopy_from_user\u003c/code\u003e 的目的，虽然看似比较晦涩，不如大家在用户程序中普通调用的memcpy，但究其原因，是为了处理MMU相关的问题。将内核复制的数据timeval做一定的取整操作（因为硬件中断的精度可能达不到timeval所描述的粒度，故根据HZ做取整，恰好为时钟中断周期的整数倍）。调用 \u003ccode\u003ecore_sys_select\u003c/code\u003e 进行真正的轮询操作（当然，好像也算不上真正的逻辑，还有一层核心的调用呢）。结束后的操作当然是准备更新timeval。因为进行轮询的结果有两种，一种是因为超时而结束 \u003ccode\u003ecore_sys_select\u003c/code\u003e 函数调用；另一种是得到了一个或多个准备就绪的数据，才结束调用并返回。显然，因为第二种结果而更新timeval有着一定的实际意义——到底等待了多久。不过这里需要注意的是，不是所有的Linux系统都支持对timeval做更新。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage long sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n            fd_set __user *exp, struct timeval __user *tvp)\n{\n    s64 timeout = -1;\n    struct timeval tv;\n    int ret;\n\n    /* 如果设置了超时时间 */\n    if (tvp) {\n        if (copy_from_user(\u0026#x26;tv, tvp, sizeof(tv)))\n            return -EFAULT;\n\n        /* 计时器不能设置为负数 */\n        if (tv.tv_sec \u0026#x3C; 0 || tv.tv_usec \u0026#x3C; 0)\n            return -EINVAL;\n\n        /* Cast to u64 to make GCC stop complaining */\n        /* 对 timeout 做一定的处理，根据时钟周期对 usec 进行取整 */\n        if ((u64)tv.tv_sec \u003e= (u64)MAX_INT64_SECONDS)\n            timeout = -1;   /* 无限等待 */\n        else {\n            timeout = DIV_ROUND_UP(tv.tv_usec, USEC_PER_SEC/HZ);\n            timeout += tv.tv_sec * HZ;\n        }\n    }\n\n    /* 核心的 select 实现逻辑 */\n    ret = core_sys_select(n, inp, outp, exp, \u0026#x26;timeout);\n\n    /* 如果设置了超时时间 */\n    if (tvp) {\n        struct timeval rtv;\n\n        if (current-\u003epersonality \u0026#x26; STICKY_TIMEOUTS)\n            goto sticky;\n        rtv.tv_usec = jiffies_to_usecs(do_div((*(u64*)\u0026#x26;timeout), HZ));\n        rtv.tv_sec = timeout;\n        if (timeval_compare(\u0026#x26;rtv, \u0026#x26;tv) \u003e= 0)\n            rtv = tv;\n        /* 内核数据-\u003e用户数据的拷贝，更新距离超时剩余的时间间隔 */\n        if (copy_to_user(tvp, \u0026#x26;rtv, sizeof(rtv))) {\nsticky:\n            /*\n             * 如果应用程序把timeval放在只读内存中，内核就无需特别的更新它\n             * If an application puts its timeval in read-only\n             * memory, we don't want the Linux-specific update to\n             * the timeval to cause a fault after the select has\n             * completed successfully. However, because we're not\n             * updating the timeval, we can't restart the system\n             * call.\n             */\n            if (ret == -ERESTARTNOHAND)\n                ret = -EINTR;\n        }\n    }\n\n    return ret;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecore_sys_select\u003c/code\u003e 也没有太多核心操作，完全是在为三个位图——输入、输出、错误从用户数据段到内核数据段的拷贝工作，以及在结束 \u003ccode\u003edo_select\u003c/code\u003e 调用后的反向拷贝操作。不过，无论是 \u003ccode\u003esys_select\u003c/code\u003e 还是 \u003ccode\u003ecore_sys_select\u003c/code\u003e 都将各自需要完成的工作分割得非常清晰，一个完成timeval的处理工作，另一个完成位图的处理。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/*\n * 内核数据-位图的准备，调用do_select完成核心的逻辑\n */\nstatic int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n               fd_set __user *exp, s64 *timeout)\n{\n    fd_set_bits fds;\n    void *bits;\n    int ret, max_fds;\n    unsigned int size;\n    struct fdtable *fdt;\n    /*\n     * 在栈中定义较小的数组，减少堆内存的占用，同时可以更快；\n     * SELECT_STACK_ALLOC = 256\n     */\n    long stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n    ret = -EINVAL;\n    if (n \u0026#x3C; 0)\n        goto out_nofds;\n\n    /* max_fds can increase, so grab it once to avoid race */\n    /* max_fds 可能同时在增加，所以提前获取一份固定的拷贝避免竞争 */\n    rcu_read_lock();\n    /* 获取当前任务的文件描述符表 */\n    fdt = files_fdtable(current-\u003efiles);\n    max_fds = fdt-\u003emax_fds;\n    rcu_read_unlock();\n    if (n \u003e max_fds)\n        n = max_fds;\n\n    /*\n     * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n     * since we used fdset we need to allocate memory in units of\n     * long-words.\n     */\n    size = FDS_BYTES(n);\n    bits = stack_fds;\n    if (size \u003e sizeof(stack_fds) / 6) {\n        /* Not enough space in on-stack array; must use kmalloc */\n        /* 栈数组大小不足；使用 kmalloc 获取新的空间 */\n        ret = -ENOMEM;\n        bits = kmalloc(6 * size, GFP_KERNEL);\n        if (!bits)\n            goto out_nofds;\n    }\n    fds.in      = bits;\n    fds.out     = bits +   size;\n    fds.ex      = bits + 2*size;\n    fds.res_in  = bits + 3*size;\n    fds.res_out = bits + 4*size;\n    fds.res_ex  = bits + 5*size;\n\n    /* 用户数据段的数据 inp、outp、exp 往内核数据段 fds.xxx 拷贝 */\n    if ((ret = get_fd_set(n, inp, fds.in)) ||\n        (ret = get_fd_set(n, outp, fds.out)) ||\n        (ret = get_fd_set(n, exp, fds.ex)))\n        goto out;\n    /* fds.res_xxx 作为 do_select 的执行结果，预置为0，表示每一位相应的fd都未准备就绪 */\n    zero_fd_set(n, fds.res_in);\n    zero_fd_set(n, fds.res_out);\n    zero_fd_set(n, fds.res_ex);\n\n    /* 交由 do_select 完成真正核心的操作 */\n    ret = do_select(n, \u0026#x26;fds, timeout);\n\n    if (ret \u0026#x3C; 0)\n        goto out;\n    if (!ret) {\n        ret = -ERESTARTNOHAND;\n        if (signal_pending(current))\n            goto out;\n        ret = 0;\n    }\n\n    /* 将结果集拷贝回用户数据段的 inp、outp、exp 中 */\n    if (set_fd_set(n, inp, fds.res_in) ||\n        set_fd_set(n, outp, fds.res_out) ||\n        set_fd_set(n, exp, fds.res_ex))\n        ret = -EFAULT;\n\nout:\n    if (bits != stack_fds)\n        kfree(bits);\nout_nofds:\n    return ret;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e终于是核心的逻辑了，逐一地将当前任务挂到相应文件的等待队列上，并等待调用 \u003ccode\u003epoll\u003c/code\u003e 函数被唤醒\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint do_select(int n, fd_set_bits *fds, s64 *timeout)\n{\n    struct poll_wqueues table;\n    poll_table *wait;\n    int retval, i;\n\n    rcu_read_lock();\n    /* 确认fds.xxx所需轮询的fd全部全部处于打开状态，同时返回最大的fd */\n    retval = max_select_fd(n, fds);\n    rcu_read_unlock();\n\n    if (retval \u0026#x3C; 0)\n        return retval;\n    n = retval;\n\n    /* 把当前任务放入自己的等待队列中 */\n    poll_initwait(\u0026#x26;table);\n    wait = \u0026#x26;table.pt;\n    /* 如果超时时间为0，即无需等待 */\n    if (!*timeout)\n        wait = NULL;\n    retval = 0;\n    /* 无限循环 */\n    for (;;) {\n        unsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n        long __timeout;\n\n        set_current_state(TASK_INTERRUPTIBLE);\n\n        inp = fds-\u003ein; outp = fds-\u003eout; exp = fds-\u003eex;\n        rinp = fds-\u003eres_in; routp = fds-\u003eres_out; rexp = fds-\u003eres_ex;\n\n        for (i = 0; i \u0026#x3C; n; ++rinp, ++routp, ++rexp) {\n            unsigned long in, out, ex, all_bits, bit = 1, mask, j;\n            unsigned long res_in = 0, res_out = 0, res_ex = 0;\n            const struct file_operations *f_op = NULL;\n            struct file *file = NULL;\n\n            in = *inp++; out = *outp++; ex = *exp++;\n            all_bits = in | out | ex;\n            if (all_bits == 0) {\n                i += __NFDBITS;\n                continue;\n            }\n\n            /* 对 unsigned long 的每一位进行确认 */\n            for (j = 0; j \u0026#x3C; __NFDBITS; ++j, ++i, bit \u0026#x3C;\u0026#x3C;= 1) {\n                int fput_needed;\n                /* 超过需检测的最大的文件描述符 */\n                if (i \u003e= n)\n                    break;\n                /* 该 fd 无需检测，直接下一个 */\n                if (!(bit \u0026#x26; all_bits))\n                    continue;\n                /* 获取相应的文件实例 */\n                file = fget_light(i, \u0026#x26;fput_needed);\n                if (file) {\n                    f_op = file-\u003ef_op;\n                    mask = DEFAULT_POLLMASK;\n                    /* 对于套接字，调用的是sock_poll，在poll成功时将唤醒wait队列的任务（即把当前任务唤醒）*/\n                    if (f_op \u0026#x26;\u0026#x26; f_op-\u003epoll)\n                        mask = (*f_op-\u003epoll)(file, retval ? NULL : wait);\n                    fput_light(file, fput_needed);\n                    if ((mask \u0026#x26; POLLIN_SET) \u0026#x26;\u0026#x26; (in \u0026#x26; bit)) {\n                        res_in |= bit;\n                        retval++;\n                    }\n                    if ((mask \u0026#x26; POLLOUT_SET) \u0026#x26;\u0026#x26; (out \u0026#x26; bit)) {\n                        res_out |= bit;\n                        retval++;\n                    }\n                    if ((mask \u0026#x26; POLLEX_SET) \u0026#x26;\u0026#x26; (ex \u0026#x26; bit)) {\n                        res_ex |= bit;\n                        retval++;\n                    }\n                }\n                /* 主动让出CPU片，等待重新调度（提前设置了最高优先级PREEMPT_ACTIVE）*/\n                cond_resched();\n            }\n            if (res_in)\n                *rinp = res_in;\n            if (res_out)\n                *routp = res_out;\n            if (res_ex)\n                *rexp = res_ex;\n        }\n        wait = NULL;\n        if (retval || !*timeout || signal_pending(current))\n            break;\n        if(table.error) {\n            retval = table.error;\n            break;\n        }\n\n        if (*timeout \u0026#x3C; 0) {\n            /* Wait indefinitely */\n            __timeout = MAX_SCHEDULE_TIMEOUT;\n        } else if (unlikely(*timeout \u003e= (s64)MAX_SCHEDULE_TIMEOUT - 1)) {\n            /* Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in a loop */\n            __timeout = MAX_SCHEDULE_TIMEOUT - 1;\n            *timeout -= __timeout;\n        } else {\n            __timeout = *timeout;\n            *timeout = 0;\n        }\n        /* 进入延时唤醒状态，待定预定的超时时间 */\n        __timeout = schedule_timeout(__timeout);\n        if (*timeout \u003e= 0)\n            *timeout += __timeout;\n    }\n    __set_current_state(TASK_RUNNING);\n\n    poll_freewait(\u0026#x26;table);\n\n    return retval;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e总结来看，\u003ccode\u003eselect\u003c/code\u003e 完全能够支持IO多路复用。至少比用户程序自行实现轮询优秀得多。但是，也存在着一些明显的缺陷：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e支持的文件描述符存在上限，默认是1024。\u003c/li\u003e\n\u003cli\u003e每次陷入内核态 \u003ccode\u003eselect\u003c/code\u003e 函数之后，都需要按位遍历所有的文件描述符（无论该fd是否存在），max(fd)越大，开销越大。\u003c/li\u003e\n\u003cli\u003e每次调用 \u003ccode\u003eselect\u003c/code\u003e 都需要将fd集合从用户态复制到内核态，max(fd)越大，开销越大。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eEPOLL\u003c/h2\u003e\n\u003cp\u003e简单地描述过 \u003ccode\u003eselect\u003c/code\u003e 系统调用之后，我们着重来聊一聊 \u003ccode\u003eepoll\u003c/code\u003e 的实现。毕竟 \u003ccode\u003eselect\u003c/code\u003e 和 \u003ccode\u003epoll\u003c/code\u003e 的复杂度是 \u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eO\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003eN\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eO(N)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003eO\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e，而 \u003ccode\u003eepoll\u003c/code\u003e 只是 \u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eO\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003elog\u003c/mi\u003e\u003cmo\u003e⁡\u003c/mo\u003e\u003cmi\u003eN\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eO(\\log{N})\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003eO\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mop\"\u003elo\u003cspan style=\"margin-right:0.01389em;\"\u003eg\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e （当然，这里对时间复杂度的比较维度不同，稍候细讲）。\u003ccode\u003eepoll\u003c/code\u003e 区别于传统I/O复用模型的最大特色在于：它将创建并维护一个 \u003ccode\u003eeventpoll\u003c/code\u003e 实例，并通过注册请 \u003ccode\u003eepoll\u003c/code\u003e 对新的文件描述符进行监听，这意味着数据从用户数据区到内核数据区的拷贝只有一次；相对的，传统方式在每次轮询时，都需要全量地将数据从用户数据区拷贝到内核数据区。 \u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eepoll_create\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eepoll_create\u003c/code\u003e 负责创建一个新的 \u003ccode\u003eeventpoll\u003c/code\u003e 实例。这里的size并没有实际意义（由于历史原因而存在），传入的参数将被忽略。看源码总是件有意思的事，这个size被描述成了检查精神健全的标志...\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage long sys_epoll_create(int size)\n{\n    int error, fd = -1;\n    struct eventpoll *ep;\n    struct inode *inode;\n    struct file *file;\n\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_create(%d)\\n\",\n             current, size));\n\n    /*\n     * 精神健全检测(size)；同时建立内部数据结构 struct eventpoll\n     */\n    error = -EINVAL;\n    if (size \u0026#x3C;= 0 || (error = ep_alloc(\u0026#x26;ep)) != 0)\n        goto error_return;\n\n    /*\n     * 创建一个新的文件描述符，文件数据结构和i节点\n     */\n    error = anon_inode_getfd(\u0026#x26;fd, \u0026#x26;inode, \u0026#x26;file, \"[eventpoll]\",\n                 \u0026#x26;eventpoll_fops, ep);\n    if (error)\n        goto error_free;\n\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_create(%d) = %d\\n\",\n             current, size, fd));\n\n    return fd;\n\nerror_free:\n    ep_free(ep);\nerror_return:\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_create(%d) = %d\\n\",\n             current, size, error));\n    return error;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcly1g0qi7lrtgzj31eu0u075i.jpg\" alt=\"Epoll Create | Model\"\u003e\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eepoll_ctl\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eepoll_ctl\u003c/code\u003e 顾名思义——\u003ccode\u003eepoll\u003c/code\u003e控制器，用于增加、修改、删除监听的事件。这里 \u003ccode\u003eepfd\u003c/code\u003e 用于找到 \u003ccode\u003eeventpoll\u003c/code\u003e 实例，\u003ccode\u003efd\u003c/code\u003e 表示需要监听的文件描述符，\u003ccode\u003eop\u003c/code\u003e 区分增删改，\u003ccode\u003eevent\u003c/code\u003e 表示监听的具体事件描述。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003easmlinkage long sys_epoll_ctl(int epfd, int op, int fd,\n                  struct epoll_event __user *event)\n{\n    int error;\n    struct file *file, *tfile;\n    struct eventpoll *ep;\n    struct epitem *epi;\n    struct epoll_event epds;\n\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)\\n\",\n             current, epfd, op, fd, event));\n\n    error = -EFAULT;\n    /* 如果是增改操作，需要把事件描述拷贝到内核数据区; 删除操作不需要 */\n    if (ep_op_has_event(op) \u0026#x26;\u0026#x26;\n        copy_from_user(\u0026#x26;epds, event, sizeof(struct epoll_event)))\n        goto error_return;\n\n    /* Get the \"struct file *\" for the eventpoll file */\n    error = -EBADF;\n    file = fget(epfd);\n    if (!file)\n        goto error_return;\n\n    /* Get the \"struct file *\" for the target file */\n    tfile = fget(fd);\n    if (!tfile)\n        goto error_fput;\n\n    /* 需要监听的文件描述符必须支持文件操作 poll */\n    error = -EPERM;\n    if (!tfile-\u003ef_op || !tfile-\u003ef_op-\u003epoll)\n        goto error_tgt_fput;\n\n    /* 需要确保不能把epfd作为被监听的fd加入 */\n    error = -EINVAL;\n    if (file == tfile || !is_file_epoll(file))\n        goto error_tgt_fput;\n\n    /* \n     * 这里的文件描述符一定是指eventpoll实例对应的文件描述符\n     * 因此直接从中拿私有数据--预定义的*eventpoll\n     */\n    ep = file-\u003eprivate_data;\n\n    mutex_lock(\u0026#x26;ep-\u003emtx);\n\n    /*\n     * 从RB树中查找已经维护起来的监听事件\n     * 当然，必须先把这个RB树结构锁定，防止查找时结构改变\n     */\n    epi = ep_find(ep, tfile, fd);\n\n    error = -EINVAL;\n    switch (op) {\n    case EPOLL_CTL_ADD:     // 新增监听\n        if (!epi) {\n            epds.events |= POLLERR | POLLHUP;\n\n            error = ep_insert(ep, \u0026#x26;epds, tfile, fd);\n        } else\n            error = -EEXIST;\n        break;\n    case EPOLL_CTL_DEL:     // 删除监听\n        if (epi)\n            error = ep_remove(ep, epi);\n        else\n            error = -ENOENT;\n        break;\n    case EPOLL_CTL_MOD:     // 修改监听\n        if (epi) {\n            epds.events |= POLLERR | POLLHUP;\n            error = ep_modify(ep, epi, \u0026#x26;epds);\n        } else\n            error = -ENOENT;\n        break;\n    }\n    mutex_unlock(\u0026#x26;ep-\u003emtx);\n\nerror_tgt_fput:\n    fput(tfile);\nerror_fput:\n    fput(file);\nerror_return:\n    DNPRINTK(3, (KERN_INFO \"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d\\n\",\n             current, epfd, op, fd, event, error));\n\n    return error;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的核心操作，就是往 \u003ccode\u003eeventpoll\u003c/code\u003e 实例中增删改监听的事件。以 \u003ccode\u003eep_insert\u003c/code\u003e 为例，先看看怎么新增监听。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* 实例化 epitem */\nif (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))\n    goto error_return;\n/* 对 epitem 实例进行初始化数据 */\nep_rb_initnode(\u0026#x26;epi-\u003erbn);\nINIT_LIST_HEAD(\u0026#x26;epi-\u003erdllink);\nINIT_LIST_HEAD(\u0026#x26;epi-\u003efllink);\nINIT_LIST_HEAD(\u0026#x26;epi-\u003epwqlist);\nepi-\u003eep = ep;\n/* 构建struct epoll_filefd，作为rb_tree比较不同的key */\nep_set_ffd(\u0026#x26;epi-\u003effd, tfile, fd);\nepi-\u003eevent = *event;\nepi-\u003enwait = 0;\nepi-\u003enext = EP_UNACTIVE_PTR;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来要接触的就是一段比较烧脑的逻辑。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epoll_table\u003c/code\u003e 是在 VFS 实现中相当重要的一个数据结构，用来与\u003ccode\u003epoll\u003c/code\u003e配合（这里的\u003ccode\u003epoll\u003c/code\u003e是指文件操作中的，而不是\u003ccode\u003epoll()\u003c/code\u003e系统调用）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct poll_table_struct {\n    poll_queue_proc _qproc;\n} poll_table;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中\u003ccode\u003epoll_queue_proc\u003c/code\u003e是一个函数指针\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e为了让 \u003ccode\u003eepitem\u003c/code\u003e 更方便地追踪 \u003ccode\u003epoll_queue_proc\u003c/code\u003e，\u003ccode\u003eepoll_ctl\u003c/code\u003e 中使用了一个 \u003ccode\u003eep_pqueue\u003c/code\u003e 的数据结构来包装 \u003ccode\u003epoll_table\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* 使用 queue 回调函数初始化 poll table */\nepq.epi = epi;\ninit_poll_funcptr(\u0026#x26;epq.pt, ep_ptable_queue_proc);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcly1g0qwphhnz0j30xa0o6aan.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e之后就是把这个 \u003ccode\u003epoll_table\u003c/code\u003e 作为钩子方法挂载到被监控的文件上\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003erevents = tfile-\u003ef_op-\u003epoll(tfile, \u0026#x26;epq.pt);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里以 \u003ccode\u003etcp_poll\u003c/code\u003e 为例，先看看这段逻辑怎么实现的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic unsigned int sock_poll(struct file *file, poll_table *wait)\n{\n    struct socket *sock;\n    /* 获取 struct sock 内核套接字数据结构 */\n    sock = file-\u003eprivate_data;\n    return sock-\u003eops-\u003epoll(file, sock, wait);\n}\n\nunsigned int tcp_poll(struct file *file, struct socket *sock, poll_table *wait)\n{\n    unsigned int mask;\n    struct sock *sk = sock-\u003esk;\n    struct tcp_sock *tp = tcp_sk(sk);\n\n    /*\n     * 这里将调用 poll_table *wait 维护的回调函数\n     * 将持有 eventpoll 实例的进程注册到 sk 的等待队列中\n     */\n    poll_wait(file, sk-\u003esk_sleep, wait);\n    if (sk-\u003esk_state == TCP_LISTEN)\n        return inet_csk_listen_poll(sk);\n\n    /*\n     * 这里省略了部分逻辑，主要是负责处理 struct sock 接收到的事件\n     * 处理成 mask 并返回\n     */\n    ...\n\n    return mask;\n}\n\nstatic inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)\n{\n    if (p \u0026#x26;\u0026#x26; wait_address)\n        p-\u003eqproc(filp, wait_address, p);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再来看看epoll定义的回调函数的实现。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n                 poll_table *pt)\n{\n    struct epitem *epi = ep_item_from_epqueue(pt);\n    struct eppoll_entry *pwq;\n\n    if (epi-\u003enwait \u003e= 0 \u0026#x26;\u0026#x26; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n        init_waitqueue_func_entry(\u0026#x26;pwq-\u003ewait, ep_poll_callback);\n        pwq-\u003ewhead = whead;\n        pwq-\u003ebase = epi;\n        /* 添加到 struct sock 等待队列队首 */\n        add_wait_queue(whead, \u0026#x26;pwq-\u003ewait);\n        list_add_tail(\u0026#x26;pwq-\u003ellink, \u0026#x26;epi-\u003epwqlist);\n        epi-\u003enwait++;\n    } else {\n        /* We have to signal that an error occurred */\n        epi-\u003enwait = -1;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到此为止，\u003ccode\u003eep_insert\u003c/code\u003e 核心的逻辑已经介绍完毕。主要就是将当前的 \u003ccode\u003eeventpoll\u003c/code\u003e 实例注册到监听目标（文件描述符）的等待队列上，并注册\u003ccode\u003eep_poll_callback\u003c/code\u003e作为回调函数。回调函数实现是怎样呢？\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n    int pwake = 0;\n    unsigned long flags;\n    /* 获取 wait 结构维护的 epitem 实例 */\n    struct epitem *epi = ep_item_from_wait(wait);\n    struct eventpoll *ep = epi-\u003eep;\n\n    // ... code omitted...\n    /* \n     * 把当前的 epitem 实例添加到 eventpoll 实例的就绪队列中 \n     * 这是显然的，毕竟此回调函数只有在fd准备就绪后被回调\n     */\n    list_add_tail(\u0026#x26;epi-\u003erdllink, \u0026#x26;ep-\u003erdllist);\n\nis_linked:\n    /* 如果 wait 结构维护的进程处于Sleeping状态，则将其唤醒并加入任务就绪队列 */\n    if (waitqueue_active(\u0026#x26;ep-\u003ewq))\n        __wake_up_locked(\u0026#x26;ep-\u003ewq, TASK_UNINTERRUPTIBLE |\n                 TASK_INTERRUPTIBLE);\n    if (waitqueue_active(\u0026#x26;ep-\u003epoll_wait))\n        pwake++;\n\nout_unlock:\n    spin_unlock_irqrestore(\u0026#x26;ep-\u003elock, flags);\n\n    /* We have to call this outside the lock */\n    if (pwake)\n        ep_poll_safewake(\u0026#x26;psw, \u0026#x26;ep-\u003epoll_wait);\n\n    return 1;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003ccode\u003eepoll_wait\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e处理完所有的监听事件的维护，用户程序需要通过 \u003ccode\u003eepoll_wait\u003c/code\u003e 与 \u003ccode\u003eeventpoll\u003c/code\u003e 实例进行交互，并被告知所有正在监听中的事件是否发生。由于 \u003ccode\u003eepoll_wait\u003c/code\u003e 的整个逻辑基本上都是在进行错误检测，此处不表。我们只关注其中的核心逻辑，即调用的 \u003ccode\u003eep_poll\u003c/code\u003e 函数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,\n           int maxevents, long timeout)\n{\n    int res, eavail;\n    unsigned long flags;\n    long jtimeout;\n    wait_queue_t wait;\n\n    /*\n     * Calculate the timeout by checking for the \"infinite\" value ( -1 )\n     * and the overflow condition. The passed timeout is in milliseconds,\n     * that why (t * HZ) / 1000.\n     */\n    jtimeout = (timeout \u0026#x3C; 0 || timeout \u003e= EP_MAX_MSTIMEO) ?\n        MAX_SCHEDULE_TIMEOUT : (timeout * HZ + 999) / 1000;\n\nretry:\n    spin_lock_irqsave(\u0026#x26;ep-\u003elock, flags);\n\n    res = 0;\n    /* \n     * 如果 eventpoll 实例的就绪队列为空，表明有没任何监听的事件发生。\n     * 主动让进程陷入Sleeping状态，知道被 ep_poll_callback() 唤醒\n     */\n    if (list_empty(\u0026#x26;ep-\u003erdllist)) {\n        init_waitqueue_entry(\u0026#x26;wait, current);\n        wait.flags |= WQ_FLAG_EXCLUSIVE;\n        __add_wait_queue(\u0026#x26;ep-\u003ewq, \u0026#x26;wait);\n\n        for (;;) {\n            /*\n             * We don't want to sleep if the ep_poll_callback() sends us\n             * a wakeup in between. That's why we set the task state\n             * to TASK_INTERRUPTIBLE before doing the checks.\n             */\n            set_current_state(TASK_INTERRUPTIBLE);\n            if (!list_empty(\u0026#x26;ep-\u003erdllist) || !jtimeout)\n                break;\n            if (signal_pending(current)) {\n                res = -EINTR;\n                break;\n            }\n\n            spin_unlock_irqrestore(\u0026#x26;ep-\u003elock, flags);\n            /* 主动陷入Sleeping状态 */\n            jtimeout = schedule_timeout(jtimeout);\n            spin_lock_irqsave(\u0026#x26;ep-\u003elock, flags);\n        }\n        __remove_wait_queue(\u0026#x26;ep-\u003ewq, \u0026#x26;wait);\n\n        set_current_state(TASK_RUNNING);\n    }\n\n    /* Is it worth to try to dig for events ? */\n    eavail = !list_empty(\u0026#x26;ep-\u003erdllist);\n\n    spin_unlock_irqrestore(\u0026#x26;ep-\u003elock, flags);\n\n    /*\n     * 将监听到的事件拷贝到用户空间。如果没有事件就绪且还没超时，就再抱着\n     * 希望试一次。\n     */\n    if (!res \u0026#x26;\u0026#x26; eavail \u0026#x26;\u0026#x26;\n        !(res = ep_send_events(ep, events, maxevents)) \u0026#x26;\u0026#x26; jtimeout)\n        goto retry;\n\n    return res;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eExtra\u003c/h3\u003e\n\u003cp\u003e这部分的数据结构配合着一些胶水代码比较难以理解，最好配合着类图看看（个人使用，不一定适合各位）\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1g0rmx65dzhj324y0t8di4.jpg\"\u003e\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eLinux Kernel 2.6.24\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://idndx.com/2014/09/01/the-implementation-of-epoll-1/\"\u003eThe Implementation of epoll(1)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://idndx.com/2014/09/02/the-implementation-of-epoll-2/\"\u003eThe Implementation of epoll(2)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://idndx.com/2014/09/22/the-implementation-of-epoll-3/\"\u003eThe Implementation of epoll(3)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://idndx.com/2015/07/08/the-implementation-of-epoll-4/\"\u003eThe Implementation of epoll(4)\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e\u003ca href=\"./2019-01-15-understand-Kernel-8/\"\u003e前一篇\u003c/a\u003e已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 \u003ccode\u003estruct sock\u003c/code\u003e 对象，将其逐级从网络接口层逐级提升到网络层、传输层...最终添加到接收队列 \u003ccode\u003esk_receive_queue\u003c/code\u003e 中；用户进程通过 \u003ccode\u003eread\u003c/code\u003e、\u003ccode\u003erecv\u003c/code\u003e、\u003ccode\u003erecvfrom\u003c/code\u003e 等命令检查并获取 \u003ccode\u003esk_receive_queue\u003c/code\u003e 中的数据。\u003c/p\u003e\n\u003cp\u003e整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。\u003c/p\u003e\n\u003cp\u003e那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（\u003ccode\u003eselect\u003c/code\u003e, \u003ccode\u003epoll\u003c/code\u003e, \u003ccode\u003eepoll\u003c/code\u003e）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 \u003ccode\u003eselect\u003c/code\u003e 和 \u003ccode\u003eepoll\u003c/code\u003e 两类系统调用的实现进行探究。\u003c/p\u003e"},{"url":"2019-02-27-Java-Fatal-API","fileName":"2019-02-27-Java-Fatal-API.md","title":"【Java】API 参数误定义的后果","author":"fangfeng","date":"2019-02-27T00:00:00.000Z","tags":["Java","API"],"content":"\u003cp\u003e工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。\u003c/p\u003e\n\u003cp\u003e想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！\u003c/p\u003e\n\u003cp\u003e想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把\u003ccode\u003evoid add(int)\u003c/code\u003e API 改写成 \u003ccode\u003eint add(int)\u003c/code\u003e，可能得到的大多数回答都是可以。\u003c/p\u003e\n\u003ch2\u003e看山是山\u003c/h2\u003e\n\u003cp\u003e首先举一个具体点的例子来描述（为了方便，就不定义\u003ccode\u003eCountService\u003c/code\u003e的接口类了）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.ffutop.signature;\n\n/**\n * 主类\n * @author fangfeng\n * @since 2019-02-26\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        CountService countService = new CountService();\n        countService.add(1);\n        System.out.println(String.format(\"currentValue = %d\", countService.getCurrentValue()));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.ffutop.signature;\n\n/**\n * @author fangfeng\n * @since 2019-02-26\n */\npublic class CountService {\n\n    private int currentValue = 0;\n\n    /**\n     * 请把 add(int) 理解成 API\n     * 虽然已经做了实现\n     */\n    public void add(int addend) {\n        currentValue += addend;\n    }\n\n    public int getCurrentValue() {\n        return currentValue;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在已经有 \u003ccode\u003evoid add(int)\u003c/code\u003e 方法，完成的工作是累加。现在要把 API 改成 \u003ccode\u003eint add(int)\u003c/code\u003e，是否可以呢？看似本来没有返回值，现在只是加上一个返回值，对于原来的代码没有任何问题，而新代码又能拿到int类型的返回值，皆大欢喜啊。\u003c/p\u003e\n\u003ch2\u003e看山不是山\u003c/h2\u003e\n\u003cp\u003e先给大家执行下代码吧！（请严格按照顺序，且避免使用IDE，否则将得不到预想的结果）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ # 准备好两个类的代码（CountService的API是 `void add(int)`）\n$ # 编译Main类\n$ javac com/ffutop/signature/Main.java\n$  \n$ # 修改CountService的API为`int add(int)`\n$ # 编译 CountService 类\n$ javac com/ffutop/signature/CountService.java\n$ \n$ # 执行主程序\n$ java com.ffutop.signature.Main\nException in thread \"main\" java.lang.NoSuchMethodError: com.ffutop.signature.CountService.add(I)V\n    at com.ffutop.signature.Main.main(Main.java:11)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e很遗憾，执行失败了，报了个Error（没有这样的方法）。方法写的是 \u003ccode\u003ecom.ffutop.signature.CountService.add(I)V\u003c/code\u003e 。简单的翻译一下就是需要\u003ccode\u003e类名+方法名=x.y.CountService.add\u003c/code\u003e，且入参为int，出参为void的方法（想了解更多请优先学习\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4\"\u003eJava ClassFile Format\u003c/a\u003e）。\u003c/p\u003e\n\u003cp\u003e那么，现在得到的结论是不行。\u003c/p\u003e\n\u003ch2\u003e看山还是山\u003c/h2\u003e\n\u003cp\u003e那么，就一定不行吗？都是同名方法，不同参数。凭什么改个入参是可以的，改个出参就不行了。\u003c/p\u003e\n\u003cp\u003e从 Java 的角度来说，一定不行。“同一类中不能存在两个名字及描述符完全相同的方法”\u003c/p\u003e\n\u003cp\u003e但是，如果从 JVM 的角度来说，完全是可行的。“在class文件中，两个方法可以拥有完全相同的特征签名，前提是返回值不能相同”\u003c/p\u003e\n\u003cp\u003e什么意思呢？我们都知道建立在 JVM 之上的语言不只有 Java。像 Groovy、Kotlin 等语言都实现了各自的区别于 Java 独有的特征。这些特征的实现都是依赖于 JVM，但为什么 Java 没有呢？只能说 Java 语言的规范是 JVM 的子集（好像这话有点不严谨啊）\u003c/p\u003e\n\u003cp\u003e通过直接操作字节码，就能够达到在同一个类中建立两个同名、相同入参，但返回值不同的方法。\n先通过\u003ccode\u003ejavap\u003c/code\u003e命令看看最终提供的\u003ccode\u003eCountService.class\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ javap com.ffutop.signature.CountService\npublic class com.ffutop.signature.CountService {\n  public int add(int);\n  public com.ffutop.signature.CountService();\n  public void add(int);\n  public int getCurrentValue();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e有两个同名的方法\u003ccode\u003eadd(int)\u003c/code\u003e，至于执行，也会相当顺利。\u003c/p\u003e\n\u003cp\u003e还是写个程序来说明，在原有 \u003ccode\u003eMain.java\u003c/code\u003e 的基础上，再创建一个全限定名为 \u003ccode\u003ecom.ffutop.signature.other.Main2\u003c/code\u003e 的类\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.ffutop.signature.other;\nimport com.ffutop.signature.CountService;\n\n/**\n * @author fangfeng\n * @since 2019-02-27\n */\npublic class Main2 {\n\n    public static void main(String[] args) {\n        CountService countService = new CountService();\n        System.out.println(String.format(\"currentValue = %d\", countService.add(1)));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e与 Main.java 比较，很明显的就是一个调用了 \u003ccode\u003eCountService\u003c/code\u003e 的 \u003ccode\u003eint add(int)\u003c/code\u003e 方法，而另一个调用 \u003ccode\u003evoid add(int)\u003c/code\u003e 方法。\u003c/p\u003e\n\u003cp\u003e那么是否有效呢？先来验证一下（这里要模拟的一个场景是，CountService 类(只有 \u003ccode\u003evoid add(int)\u003c/code\u003e 方法)作为二方库C.jar version 1.0 的主要服务类。CountService 类(同时有 \u003ccode\u003evoid add(int)\u003c/code\u003e 和 \u003ccode\u003eint add(int)\u003c/code\u003e 方法)作为二方库C.jar version 2.0 的主要服务类。Main 类根据 C.jar version 1.0 做的编译，而 Main2 类根据 C.jar version 2.0 做的编译。在 Main 和 Main2 类运行时只提供 C.jar version 2.0）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ # 编译 Main 类和 CountService 类\n$ javac com/ffutop/signature/Main.java\n$\n$ # 操作 CountService.class 字节码，增加方法 `int add(int)` \n$ # 通过 ASM 实现，详见附录源码 com/ffutop/signature/support/Generator.java\n$ \n$ # 编译 Main2 类 (提供 classpath，即根据 CountService.class 编译)\n$ javac com/ffutop/signature/other/Main2.java -classpath .\n$\n$ # 验证\n$ java com.ffutop.signature.Main\ncurrentValue = 1\n$ java com.ffutop.signature.other.Main2\ncurrentValue = 1\n$ # OK，验证通过\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e一旦 API 定义错误，并已经作为二方库提供给调用方。后果必然是灾难性的。至少，只能重新定义 API 。如果对于入参定义错误，Java 语言级别也能够支持。但如果是返回值，如果非要保持方法名一致，那就不得不下沉到 JVM 级别来进行处理了。当然，在工程项目中是否应该直接操作字节码？至少个人还没直接接触过。\u003c/p\u003e\n\u003cp\u003e做个记录，未来可以翻一翻，至少是一种可行的解决方案。\u003c/p\u003e\n\u003cp\u003eUpdate: 如果直接操作字节码为添加了不同返回值的同名同参数方法，可能引起调用方静态编译失败。此操作需慎之又慎。也许提供类加载器加载时的字节码操作能更加完美地解决这个问题。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/signature.zip\"\u003e源码.zip\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。\u003c/p\u003e\n\u003cp\u003e想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！\u003c/p\u003e\n\u003cp\u003e想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把\u003ccode\u003evoid add(int)\u003c/code\u003e API 改写成 \u003ccode\u003eint add(int)\u003c/code\u003e，可能得到的大多数回答都是可以。\u003c/p\u003e"}],"items":36,"pages":4,"currentPage":0},"buildId":"KZWxx6ur1oSf8xr-9UZXm","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/" src="https://www.ffutop.com/blog/_next/static/KZWxx6ur1oSf8xr-9UZXm/pages/index.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/KZWxx6ur1oSf8xr-9UZXm/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.7e5e68e72610ac3a4255.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.f3603d0a56c82c4f5e78.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-fd73dbd6f398b7b886ec.js" async=""></script></body></html>