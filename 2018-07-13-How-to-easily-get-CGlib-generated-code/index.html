<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/YsOqVyLvFnUbWFBFmGa7N/pages/post.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/YsOqVyLvFnUbWFBFmGa7N/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.74c43a0e96cfe845a889.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.a1d4ae30.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.d723af22.chunk.css"/></head><body><div id="__next"><header class="component-header"><h1 class="title">ffutop</h1><ul class="nav-items"><li><a href="/blog/index">博客</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/about">关于</a></li></ul></header><div><main class="main"><div class="page-post"><div><h2>配置参数</h2>
<p><strong>命令行使用</strong></p>
<p>在 java 启动命令中添加参数配置项 <code>-Dcglib.debugLocation=&#x3C;Custom Path></code></p>
<p><strong>编码实现</strong></p>
<p>在执行 CGlib 获取新生成类之前，调用 <code>System.setProperty("cglib.debugLocation", &#x3C;Custom Path>)</code></p>
<h2>如何游刃有余地 Debug 掺杂 CGlib 生成类的调用链</h2>
<p>经常会遇到，项目中不经意间就遇到了 CGlib 代理，然后对调用链的 Debug 就开始出现断层。继而，对对象或实例变量的跟踪就显得一头雾水。</p>
<p>特别是在不了解生成类到底是增强了那些内容的时候，甚至可能连调用链都跟踪不下去了 T_T 。</p>
<p>通过 <strong>配置参数</strong> 一节的内容，你就可以在你理想的目录 <code>&#x3C;Custom Path></code> 下看到<strong>所谓黑盒</strong>中生成类的完成内容了。</p>
<p>下面的内容，将简单地介绍如何配合 CGlib 生成类的内容实现: 保证 Debug 的每一步骤可见; 保证 Debug 的过程不会出现<em>黑盒</em>。</p>
<h3>确定 <code>&#x3C;Custom Path></code> 下哪个文件是原有 Java 类的生成类</h3>
<pre><code class="language-java">public String getClassName(String prefix, String source, Object key, Predicate names) {
    if (prefix == null) {
        prefix = "net.sf.cglib.empty.Object";
    } else if (prefix.startsWith("java")) {
        prefix = "$" + prefix;
    }
    String base =
        prefix + "$$" +
        source.substring(source.lastIndexOf('.') + 1) +
        getTag() + "$$" +
        Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());
    String attempt = base;
    int index = 2;
    while (names.evaluate(attempt))
        attempt = base + "_" + index++;
    return attempt;
}
</code></pre>
<p>CGlib 默认的类名生成策略下，生成类的全限定名将结合原文件的全限定名决定。</p>
<p>通常命名如下: <code>&#x3C;原 Java 类全限定名>$$&#x3C;类似 EnhancerByCGlib>$$&#x3C;生成类核心内容的 hash 值>_&#x3C;index[可能存在]></code></p>
<p>例如: 原有 Java 类全限定名为 me.fangfeng.Test ，则生成类名可能为 <code>me.fangfeng.Test$$EnhancerByCGlib$$ab1203aa</code></p>
<p>当然，通常情况下会存在一个类名形如 <code>me.fangfeng.Test$$FastClassBySpring$$...</code> 的类，这是作为生成类 <code>me.fangfeng.Test$$EnhancerByCGlib$$ab1203aa</code> 的辅助类来使用。</p>
<h3>简单了解生成类下的调用关系</h3>
<p>Java 代码触发被增强的类，将首先调用生成类。但是，这是没办法进行 Debug 的，因为这个生成类的字节码缺少 SourceFile 属性，同时缺少 LineNumberTable 属性。</p>
<p>但是，这并不影响对调用链的跟踪。</p>
<p>CGlib 的增强，所有的增强逻辑都是以 Callback 实现类的形式来提供的。同时在 CGlib 生成类中也有 Callback 的实例变量来持有这些注入的 Callback 。</p>
<p><strong>原有 Java 类</strong></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft8e7kr7qvj30sc0j0wh4.jpg" alt="LogonService.java"></p>
<p><strong>对应的生成类</strong></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8e9ww4hqj31hg0oojzv.jpg"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eanb6c9j31j00lgn1e.jpg"></p>
<p><strong>跟踪 LogonService.addLogon(String var1) 演示</strong></p>
<p>当前 LogonService 的生成类全限定名为me.fangfeng.transactionBugs.LogonService<span class="inlineMath"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>n</mi><mi>h</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi>r</mi><mi>B</mi><mi>y</mi><mi>S</mi><mi>p</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>C</mi><mi>G</mi><mi>L</mi><mi>I</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">EnhancerBySpringCGLIB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">n</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">G</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span>bfc1dc3.class; 以下简称为 LogonSerivce$$bfc1dc3 </p>
<ol>
<li>
<p>首先，配置 <code>cglib.debugLocation</code> 参数，值 = 项目生成的 .class 路径</p>
</li>
<li>
<p>无断点直接运行一次需要处理的逻辑</p>
</li>
<li>
<p>找到 LogonSerive$$bfc1dc3.class, 随意打上一个看似有效的断点</p>
</li>
<li>
<p>在各处打上必要的断点，开始进行真正的调试工作</p>
</li>
<li>
<p>代码执行到 <code>LogonService$$bfc1dc3.class</code>, 虽然没有真正进入断点位置, 但是可以看到这个 <code>LogonService$$bfc1dc3</code> 实例的实例变量信息</p>
</li>
</ol>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft8eq1be61j319w0bwtde.jpg"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8egtg1naj31ji0fmgp2.jpg"></p>
<p>比照生成类代码中 addLogon(String var1) 方法体的内容以及展示的实例变量信息。可以看到生成类调用的 Callback 实例是 <code>CGLIB$CALLBACK_0</code>
类型是 CglibAopProxy 的静态内部私有类 DynamicAdvisedInterceptor 。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eu91oscj31gq0ayju5.jpg"></p>
<p>在 intercept(...) 上打个断点，跳过生成类 addLogon(String var1) 方法的下一个调用方法就是 intercept(...) </p>
<p><strong>而且事实上，CGlib 生成类的内容基本也就是对调用方法进行的一种转发</strong></p>
<ol start="6">
<li>继续 Debug ，对于生成类的内容，人肉了解并定位到触发的 Callback 实例或者 super.Xxx() 方法。</li>
</ol>
<pre><code class="language-plain">  __                    __                  
 / _| __ _ _ __   __ _ / _| ___ _ __   __ _ 
| |_ / _` | '_ \ / _` | |_ / _ \ '_ \ / _` |
|  _| (_| | | | | (_| |  _|  __/ | | | (_| |
|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |
                 |___/                |___/ 
</code></pre></div></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/post","query":{"content":"\u003ch2\u003e配置参数\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e命令行使用\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 java 启动命令中添加参数配置项 \u003ccode\u003e-Dcglib.debugLocation=\u0026#x3C;Custom Path\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e编码实现\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在执行 CGlib 获取新生成类之前，调用 \u003ccode\u003eSystem.setProperty(\"cglib.debugLocation\", \u0026#x3C;Custom Path\u003e)\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e如何游刃有余地 Debug 掺杂 CGlib 生成类的调用链\u003c/h2\u003e\n\u003cp\u003e经常会遇到，项目中不经意间就遇到了 CGlib 代理，然后对调用链的 Debug 就开始出现断层。继而，对对象或实例变量的跟踪就显得一头雾水。\u003c/p\u003e\n\u003cp\u003e特别是在不了解生成类到底是增强了那些内容的时候，甚至可能连调用链都跟踪不下去了 T_T 。\u003c/p\u003e\n\u003cp\u003e通过 \u003cstrong\u003e配置参数\u003c/strong\u003e 一节的内容，你就可以在你理想的目录 \u003ccode\u003e\u0026#x3C;Custom Path\u003e\u003c/code\u003e 下看到\u003cstrong\u003e所谓黑盒\u003c/strong\u003e中生成类的完成内容了。\u003c/p\u003e\n\u003cp\u003e下面的内容，将简单地介绍如何配合 CGlib 生成类的内容实现: 保证 Debug 的每一步骤可见; 保证 Debug 的过程不会出现\u003cem\u003e黑盒\u003c/em\u003e。\u003c/p\u003e\n\u003ch3\u003e确定 \u003ccode\u003e\u0026#x3C;Custom Path\u003e\u003c/code\u003e 下哪个文件是原有 Java 类的生成类\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic String getClassName(String prefix, String source, Object key, Predicate names) {\n    if (prefix == null) {\n        prefix = \"net.sf.cglib.empty.Object\";\n    } else if (prefix.startsWith(\"java\")) {\n        prefix = \"$\" + prefix;\n    }\n    String base =\n        prefix + \"$$\" +\n        source.substring(source.lastIndexOf('.') + 1) +\n        getTag() + \"$$\" +\n        Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\n    String attempt = base;\n    int index = 2;\n    while (names.evaluate(attempt))\n        attempt = base + \"_\" + index++;\n    return attempt;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCGlib 默认的类名生成策略下，生成类的全限定名将结合原文件的全限定名决定。\u003c/p\u003e\n\u003cp\u003e通常命名如下: \u003ccode\u003e\u0026#x3C;原 Java 类全限定名\u003e$$\u0026#x3C;类似 EnhancerByCGlib\u003e$$\u0026#x3C;生成类核心内容的 hash 值\u003e_\u0026#x3C;index[可能存在]\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e例如: 原有 Java 类全限定名为 me.fangfeng.Test ，则生成类名可能为 \u003ccode\u003eme.fangfeng.Test$$EnhancerByCGlib$$ab1203aa\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e当然，通常情况下会存在一个类名形如 \u003ccode\u003eme.fangfeng.Test$$FastClassBySpring$$...\u003c/code\u003e 的类，这是作为生成类 \u003ccode\u003eme.fangfeng.Test$$EnhancerByCGlib$$ab1203aa\u003c/code\u003e 的辅助类来使用。\u003c/p\u003e\n\u003ch3\u003e简单了解生成类下的调用关系\u003c/h3\u003e\n\u003cp\u003eJava 代码触发被增强的类，将首先调用生成类。但是，这是没办法进行 Debug 的，因为这个生成类的字节码缺少 SourceFile 属性，同时缺少 LineNumberTable 属性。\u003c/p\u003e\n\u003cp\u003e但是，这并不影响对调用链的跟踪。\u003c/p\u003e\n\u003cp\u003eCGlib 的增强，所有的增强逻辑都是以 Callback 实现类的形式来提供的。同时在 CGlib 生成类中也有 Callback 的实例变量来持有这些注入的 Callback 。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原有 Java 类\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1ft8e7kr7qvj30sc0j0wh4.jpg\" alt=\"LogonService.java\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e对应的生成类\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8e9ww4hqj31hg0oojzv.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eanb6c9j31j00lgn1e.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e跟踪 LogonService.addLogon(String var1) 演示\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e当前 LogonService 的生成类全限定名为me.fangfeng.transactionBugs.LogonService\u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eE\u003c/mi\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmi\u003eh\u003c/mi\u003e\u003cmi\u003ea\u003c/mi\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmi\u003ec\u003c/mi\u003e\u003cmi\u003ee\u003c/mi\u003e\u003cmi\u003er\u003c/mi\u003e\u003cmi\u003eB\u003c/mi\u003e\u003cmi\u003ey\u003c/mi\u003e\u003cmi\u003eS\u003c/mi\u003e\u003cmi\u003ep\u003c/mi\u003e\u003cmi\u003er\u003c/mi\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmi\u003eg\u003c/mi\u003e\u003cmi\u003eC\u003c/mi\u003e\u003cmi\u003eG\u003c/mi\u003e\u003cmi\u003eL\u003c/mi\u003e\u003cmi\u003eI\u003c/mi\u003e\u003cmi\u003eB\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eEnhancerBySpringCGLIB\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05764em;\"\u003eE\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003en\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003eh\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ea\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003en\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ec\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ee\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003er\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05017em;\"\u003eB\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.03588em;\"\u003ey\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05764em;\"\u003eS\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ep\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003er\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ei\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003en\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.03588em;\"\u003eg\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07153em;\"\u003eC\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003eG\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003eL\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07847em;\"\u003eI\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05017em;\"\u003eB\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003ebfc1dc3.class; 以下简称为 LogonSerivce$$bfc1dc3 \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e首先，配置 \u003ccode\u003ecglib.debugLocation\u003c/code\u003e 参数，值 = 项目生成的 .class 路径\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e无断点直接运行一次需要处理的逻辑\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e找到 LogonSerive$$bfc1dc3.class, 随意打上一个看似有效的断点\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在各处打上必要的断点，开始进行真正的调试工作\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e代码执行到 \u003ccode\u003eLogonService$$bfc1dc3.class\u003c/code\u003e, 虽然没有真正进入断点位置, 但是可以看到这个 \u003ccode\u003eLogonService$$bfc1dc3\u003c/code\u003e 实例的实例变量信息\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1ft8eq1be61j319w0bwtde.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8egtg1naj31ji0fmgp2.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e比照生成类代码中 addLogon(String var1) 方法体的内容以及展示的实例变量信息。可以看到生成类调用的 Callback 实例是 \u003ccode\u003eCGLIB$CALLBACK_0\u003c/code\u003e\n类型是 CglibAopProxy 的静态内部私有类 DynamicAdvisedInterceptor 。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eu91oscj31gq0ayju5.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e在 intercept(...) 上打个断点，跳过生成类 addLogon(String var1) 方法的下一个调用方法就是 intercept(...) \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e而且事实上，CGlib 生成类的内容基本也就是对调用方法进行的一种转发\u003c/strong\u003e\u003c/p\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e继续 Debug ，对于生成类的内容，人肉了解并定位到触发的 Callback 实例或者 super.Xxx() 方法。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e"},"buildId":"YsOqVyLvFnUbWFBFmGa7N","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/post" src="https://www.ffutop.com/blog/_next/static/YsOqVyLvFnUbWFBFmGa7N/pages/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/YsOqVyLvFnUbWFBFmGa7N/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.74c43a0e96cfe845a889.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>