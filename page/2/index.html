<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/YsOqVyLvFnUbWFBFmGa7N/pages/index.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/YsOqVyLvFnUbWFBFmGa7N/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.74c43a0e96cfe845a889.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.a1d4ae30.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.d723af22.chunk.css"/></head><body><div id="__next"><header class="component-header"><h1 class="title">ffutop</h1><ul class="nav-items"><li><a href="/blog/index">博客</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/about">关于</a></li></ul></header><div><main class="main"><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-11-11-understand-Kernel-6">理解 Linux Kernel (6) - read &amp; write</a></h1><div><p><a href="https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/">前一篇</a>已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。</p>
<p>首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式</p>
<pre><code class="language-c">#include &#x3C;stdio.h>
#include &#x3C;stdlib.h>
#include &#x3C;string.h>
#include &#x3C;unistd.h>
#include &#x3C;fcntl.h>
#include &#x3C;errno.h>
#include &#x3C;sys/types.h>
#include &#x3C;sys/stat.h>

int panic()
{
    fprintf(stderr, "%s (errno=%d)\n", strerror(errno), errno);
    return -1;
}

int main(int argc, char *argv[])
{
    /* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */
    int fd = open("/root/frw.txt", O_RDWR | O_CREAT);
    if (fd == -1)
        return panic();

    /* 向文件写入 Hello World! 共计 12 个字符 */
    ssize_t wsize = write(fd, "Hello World!", 12);
    if (wsize == -1)
        return panic();

    /* 重定位文件读写指针 */
    off_t off = lseek(fd, 0, SEEK_SET);
    if (off == -1)
        return panic();

    char* buf = (char *) malloc(wsize);
    /* 读取文件内容 */
    ssize_t rsize = read(fd, buf, wsize);
    if (rsize == -1)
        return panic();

    printf("%s\n", buf);
    free(buf);
    /* 关闭文件 */
    int stat = close(fd);
    if (stat == -1)
        return panic();

    return 0;
}
</code></pre></div><p><a href="/blog2018-11-11-understand-Kernel-6">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-10-14-understand-Kernel-5">理解 Linux Kernel (5) - 文件系统(宏观描述)</a></h1><div><p>用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。</p>
<pre><code class="language-shell">$ ls
Applications Network      Users        bin          data         etc          net          sbin         usr
Library      System       Volumes      cores        dev          home         private      tmp          var
</code></pre>
<p>但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?</p></div><p><a href="/blog2018-10-14-understand-Kernel-5">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-10-12-understand-Kernel-4">理解 Linux Kernel (4) - 任务调度</a></h1><div><p>前面几节已经描述过，对于单核 CPU 来说。CPU 就处于不断地执行指令的过程(或者通过 <code>hlt</code> 指令直接停止工作)。</p>
<p>针对于每一个程序来说，这个程序执行流程是通过 CPU 中几组寄存器(通用寄存器、段寄存器、控制寄存器等) 和存储在内存中的代码和数据协作完成的。</p>
<p>如果要达到单核多任务的目的，首先要做的就是完成对几组寄存器中当前值的保存(我称之为保存现场)。而对于内存来说，多个任务的代码、数据同时存在内存是完全合理且可行的。毕竟相较于有限的寄存器，内存实在是太大了(相对而言)。</p></div><p><a href="/blog2018-10-12-understand-Kernel-4">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-10-06-understand-Kernel-3">理解 Linux Kernel (3) - 操作系统启动</a></h1><div><p>这次拖得有够久的，毕竟需要将知识串联起来并不是一件容易的事情。更何况很多内容可以说和常理(个人理解的常理)有了比较大的偏差。</p>
<p>不过确实比较有意思。从引导程序到操作系统启动，这中间究竟经历了多少流程呢？</p>
<p>由于有了前几节的内容，这里不会再对引导程序及汇编语法做过多的介绍。而着重在于整个流程的描述。</p></div><p><a href="/blog2018-10-06-understand-Kernel-3">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-09-27-mail">Understand MAIL</a></h1><div><p>在网络协议上，高层协议确实比底层协议更容易理解，也更加的人性化。
传输层的 TCP, UDP 都还停留在各种字节内容的整合和校验上，而更上层的应用层协议就已经能够直观到通过直接解读就能理解其每条消息的含义了。</p></div><p><a href="/blog2018-09-27-mail">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-09-18-TCP-SYN">TCP SYN 包模拟</a></h1><div><p>写了两天，几乎是从零开始，C 语言搞了一个发 TCP SYN 包的小程序。
从协议到程序代码的转换，确实没有花费太多的时间，但是为了字节序(byteorder)的问题简直折腾得...</p></div><p><a href="/blog2018-09-18-TCP-SYN">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-09-08-preprocessor-output">Preprocessor Output</a></h1><div><p>最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。
暂时告别一步到位的命令 <code>gcc main.c</code>，如果从 <code>.c</code> 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。
但是，仅仅从第一个流程 <strong>预编译</strong> 而言，就已经遇到了一些麻烦。</p>
<p>program.i</p>
<pre><code class="language-c"># 1 "program.c"
# 1 "&#x3C;built-in>"
# 1 "&#x3C;command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "&#x3C;command-line>" 2
# 1 "program.c"
# 1 "header.h" 1
char *test(void);
# 2 "program.c" 2

int main(void)
{
}
</code></pre>
<p>预编译后的问题出现了诸如 <code># 1 "program.c"</code> 的 <em>注释?</em> </p>
<p>这里简单记录预处理输出文件的基本格式，方便今后回顾。</p></div><p><a href="/blog2018-09-08-preprocessor-output">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-08-26-understand-Kernel-2">理解 Linux Kernel (2) - 多任务切换</a></h1><div><h2>概述</h2>
<p>《只是为了好玩》一书中，林纳斯描述过他最早的试验性程序就是让 CPU 执行两个不同的任务(一个不断输出A，另一个输出B)，同时不断地让 CPU 在两个任务间的切换。</p>
<p>结合《Linux 内核完全注释》一书，得到了多任务切换的示例程序。</p>
<p>本节所要描述的内容，正是结合一个框架式的汇编程序(多任务切换程序, 书中提供的内容比较老，无法适应目前的各种工具、环境)，在现有环境中加以处理并成功运行。</p>
<p>关于运行环境的说明，欢迎参考 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">理解 Linux Kernel (0)</a></p></div><p><a href="/blog2018-08-26-understand-Kernel-2">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog2018-08-19-understand-Kernel-1">理解 Linux Kernel (1) - BIOS</a></h1><div><h2>前言</h2>
<p>在<a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">概述</a>，我想我已经介绍过我开始这一些列博文的原因。
我不能担保我所进行的所有试验性操作都是对的，但是，至少这些在我所描述的环境下成功的运行了起来，并帮助我触及我始终敬畏而又敬而远之的<strong>硬件&#x26;OS</strong></p>
<p>在《Linux内核完全注释》一书第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，并最终通过 Bochs 仿真器在模拟开机通电后，BIOS Load
boot 程序，通过显示器输出 <em>Loading System...</em> 。</p>
<p>这些，将是这里所要描述的主要内容。</p></div><p><a href="/blog2018-08-19-understand-Kernel-1">阅读更多</a></p><hr/></div></div><div><a href="/blog/page/1">上一页</a><a href="/blog/page/3">下一页</a></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/","query":{"mdDatasParts":[{"url":"2018-11-11-understand-Kernel-6","fileName":"2018-11-11-understand-Kernel-6.md","title":"理解 Linux Kernel (6) - read \u0026 write","author":"fangfeng","date":"2018-11-11T00:00:00.000Z","tags":["Linux","Kernel","File System","read \u0026 write"],"content":"\u003cp\u003e\u003ca href=\"https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/\"\u003e前一篇\u003c/a\u003e已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。\u003c/p\u003e\n\u003cp\u003e首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \u0026#x3C;stdio.h\u003e\n#include \u0026#x3C;stdlib.h\u003e\n#include \u0026#x3C;string.h\u003e\n#include \u0026#x3C;unistd.h\u003e\n#include \u0026#x3C;fcntl.h\u003e\n#include \u0026#x3C;errno.h\u003e\n#include \u0026#x3C;sys/types.h\u003e\n#include \u0026#x3C;sys/stat.h\u003e\n\nint panic()\n{\n    fprintf(stderr, \"%s (errno=%d)\\n\", strerror(errno), errno);\n    return -1;\n}\n\nint main(int argc, char *argv[])\n{\n    /* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */\n    int fd = open(\"/root/frw.txt\", O_RDWR | O_CREAT);\n    if (fd == -1)\n        return panic();\n\n    /* 向文件写入 Hello World! 共计 12 个字符 */\n    ssize_t wsize = write(fd, \"Hello World!\", 12);\n    if (wsize == -1)\n        return panic();\n\n    /* 重定位文件读写指针 */\n    off_t off = lseek(fd, 0, SEEK_SET);\n    if (off == -1)\n        return panic();\n\n    char* buf = (char *) malloc(wsize);\n    /* 读取文件内容 */\n    ssize_t rsize = read(fd, buf, wsize);\n    if (rsize == -1)\n        return panic();\n\n    printf(\"%s\\n\", buf);\n    free(buf);\n    /* 关闭文件 */\n    int stat = close(fd);\n    if (stat == -1)\n        return panic();\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e高速缓冲区初始化\u003c/h2\u003e\n\u003cp\u003e上一篇已经描述过了，文件系统的结构、包括数据，都是持久化地存储在存储设备中的。\u003c/p\u003e\n\u003cp\u003e但是，我们应该也隐约的了解另一个事实，文件读写操作并不会直接操作存储设备上的数据，而是先经过一个称之为高速缓冲的内存区域。\u003c/p\u003e\n\u003cp\u003e那么，高速缓冲是什么? 究竟承担什么工作? 先来看看它的初始化流程吧。\u003c/p\u003e\n\u003cp\u003e首先回到 \u003ccode\u003emain.c\u003c/code\u003e (内核代码的主函数)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid main(void) \n{\n    ROOT_DEV = ORIG_ROOT_DEV;\n    drive_info = DRIVE_INFO;\n    memory_end = (1\u0026#x3C;\u0026#x3C;20) + (EXT_MEM_K\u0026#x3C;\u0026#x3C;10);\n    memory_end \u0026#x26;= 0xfffff000;\n    if (memory_end \u003e 16*1024*1024)\n        memory_end = 16*1024*1024;\n    if (memory_end \u003e 12*1024*1024)\n        buffer_memory_end = 4*1024*1024;\n    else if (memory_end \u003e 6*1024*1024)\n        buffer_memory_end = 2*1024*1024;\n    else\n        buffer_memory_end = 1*1024*1024;\n    main_memory_start = buffer_memory_end;\n#ifdef RAMDISK\n    main_memory_start += rd_init(main_memory_start, RAMDISK*1024);\n#endif\n    mem_init(main_memory_start,memory_end);\n    trap_init();\n    blk_dev_init();\n    chr_dev_init();\n    tty_init();\n    time_init();\n    sched_init();                       // 第四篇已经讲过，负责任务调度模块的初始化\n    buffer_init(buffer_memory_end);     // 本篇的起始，负责缓冲区的初始化\n    hd_init();\n    floppy_init();\n    sti();\n    move_to_user_mode();\n    if (!fork()) {      /* we count on this going ok */\n        init();\n    }\n    for(;;) pause();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebuffer_init(buffer_memory_end);\u003c/code\u003e 用来初始化缓冲区。此处有几个原因:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eCPU 读写操作如果直接操作外存，速度上是一个极大的考验。毕竟内存已经较之 CPU 速度慢，外存的读写速度就更慢了。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e解耦，其实读写操作并不仅仅发生在外存(块存储设备)，同样的，字符设备等等也都会需要读写操作，增加中间层可以封装变化。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e更多，个人了解有限...\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct buffer_head {\n char * b_data;\n unsigned long b_blocknr;\n unsigned short b_dev;\n unsigned char b_uptodate;\n unsigned char b_dirt;\n unsigned char b_count;\n unsigned char b_lock;\n struct task_struct * b_wait;\n struct buffer_head * b_prev;\n struct buffer_head * b_next;\n struct buffer_head * b_prev_free;\n struct buffer_head * b_next_free;\n};\n\n/* from fs/buffer.c */\nvoid buffer_init(long buffer_end)\n{\n    struct buffer_head * h = start_buffer;\n    void * b;\n    int i;\n\n    if (buffer_end == 1\u0026#x3C;\u0026#x3C;20)\n        b = (void *) (640*1024);\n    else\n        b = (void *) buffer_end;\n    while ( (b -= BLOCK_SIZE) \u003e= ((void *) (h+1)) ) {\n        h-\u003eb_dev = 0;\n        h-\u003eb_dirt = 0;\n        h-\u003eb_count = 0;\n        h-\u003eb_lock = 0;\n        h-\u003eb_uptodate = 0;\n        h-\u003eb_wait = NULL;\n        h-\u003eb_next = NULL;\n        h-\u003eb_prev = NULL;\n        h-\u003eb_data = (char *) b;\n        h-\u003eb_prev_free = h-1;\n        h-\u003eb_next_free = h+1;\n        h++;\n        NR_BUFFERS++;\n        /* 跳过 640K ~ 1M 的显存和 BIOS RAM 部分 */\n        if (b == (void *) 0x100000)\n            b = (void *) 0xA0000;\n    }\n    h--;\n    free_list = start_buffer;\n    free_list-\u003eb_prev_free = h;\n    h-\u003eb_next_free = free_list;\n    for (i=0;i\u0026#x3C;NR_HASH;i++)\n        hash_table[i]=NULL;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e缓冲块的所有关键信息都由 \u003ccode\u003ebuffer_head\u003c/code\u003e 数据结构进行记录, 至于有多少个 \u003ccode\u003ebuffer_head\u003c/code\u003e? 只能说能划分多少就划分多少。\u003c/p\u003e\n\u003cp\u003e比较直观的结构信息如下\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fwy2iag1exj31kw0k1dgb.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e在 \u003ccode\u003emain.c\u003c/code\u003e 中已经提前确认了内核程序占用内存的大小，缓冲区大小以及主内存大小。\u003c/p\u003e\n\u003cp\u003e在高速缓冲区的开始位置，都用来存储 \u003ccode\u003ebuffer_head\u003c/code\u003e 的信息，与每个缓冲块(从缓冲区结束位置开始分配)一一对应，直到中间某个位置不足以分配缓冲块为止。\u003c/p\u003e\n\u003cp\u003e另外的信息，就是可以看到一个 \u003ccode\u003ehash_table\u003c/code\u003e 数据结构了。\u003c/p\u003e\n\u003cp\u003e应该都能够想象，每个缓存块与外存中的数据块相对应，通过设备号 + 数据块号进行唯一定位。但是，如何快速查找需要操作的数据块是否已经存在与高速缓存中了呢? 显然直接遍历查找是不太可靠的办法。采用开放地址法的哈希表能够协助快速定位缓冲块。\u003c/p\u003e\n\u003ch2\u003e挂载文件系统\u003c/h2\u003e\n\u003cp\u003e既然高速缓冲区都准备就绪了，那么文件系统是否已经挂载了呢? 很遗憾，知道 \u003ccode\u003emain()\u003c/code\u003e 调用 \u003ccode\u003einit()\u003c/code\u003e 函数之前，文件系统依然没有挂载，也就是说，CPU 仍然只能通过基本输入输出对存储设备进行相当初级的 IO 操作。\u003c/p\u003e\n\u003cp\u003e那么，什么时候才能去挂载根目录呢?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* from init/main.c */\n/* 由 main() 触发 */\nvoid init(void)\n{\n    int pid,i;\n    /* 这是比较重要的一环了，开始挂载的起始动作 */\n    setup((void *) \u0026#x26;drive_info);\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esetup\u003c/code\u003e 函数做了什么呢？这是一个内嵌汇编，主要做的就是触发系统调用 \u003ccode\u003eint 0x80\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e__inline__ int setup(void * BIOS) { \n    long __res; \n    __asm__ volatile (\n            \"int $0x80\" \n            : \"=a\" (__res) \n            : \"0\" (0),\"b\" ((long)(BIOS))\n    ); \n    if (__res \u003e= 0) \n        return (int) __res; \n    errno = -__res; \n    return -1; \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中看到给出的 \u003ccode\u003eEAX = 0\u003c/code\u003e, 查表(表在 \u003ccode\u003einclude/linux/sys.h\u003c/code\u003e 里) 可以知道触发的是 \u003ccode\u003esys_setup\u003c/code\u003e 函数(函数位于 \u003ccode\u003ekernel/blk_drv/hd.c\u003c/code\u003e)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* This may be used only once, enforced by 'static int callable' */\nint sys_setup(void * BIOS)\n{\n    static int callable = 1;\n    int i,drive;\n    unsigned char cmos_disks;\n    struct partition *p;\n    struct buffer_head * bh;\n\n    /* setup 只允许被调用一次 */\n    if (!callable)\n        return -1;\n    callable = 0;\n    /* 可以强制在源码中指定硬盘参数, 所以加了宏定义作判断*/\n#ifndef HD_TYPE\n    for (drive=0 ; drive\u0026#x3C;2 ; drive++) {\n        hd_info[drive].cyl = *(unsigned short *) BIOS;\n        hd_info[drive].head = *(unsigned char *) (2+BIOS);\n        hd_info[drive].wpcom = *(unsigned short *) (5+BIOS);\n        hd_info[drive].ctl = *(unsigned char *) (8+BIOS);\n        hd_info[drive].lzone = *(unsigned short *) (12+BIOS);\n        hd_info[drive].sect = *(unsigned char *) (14+BIOS);\n        BIOS += 16;\n    }\n    if (hd_info[1].cyl)\n        NR_HD=2;\n    else\n        NR_HD=1;\n#endif\n    for (i=0 ; i\u0026#x3C;NR_HD ; i++) {\n        hd[i*5].start_sect = 0;\n        hd[i*5].nr_sects = hd_info[i].head*\n                hd_info[i].sect*hd_info[i].cyl;\n    }\n\n    /*\n        We querry CMOS about hard disks : it could be that\n        we have a SCSI/ESDI/etc controller that is BIOS\n        compatable with ST-506, and thus showing up in our\n        BIOS table, but not register compatable, and therefore\n        not present in CMOS.\n\n        Furthurmore, we will assume that our ST-506 drives\n        \u0026#x3C;if any\u003e are the primary drives in the system, and\n        the ones reflected as drive 1 or 2.\n\n        The first drive is stored in the high nibble of CMOS\n        byte 0x12, the second in the low nibble.  This will be\n        either a 4 bit drive type or 0xf indicating use byte 0x19\n        for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.\n\n        Needless to say, a non-zero value means we have\n        an AT controller hard disk for that drive.\n\n\n    */\n\n    if ((cmos_disks = CMOS_READ(0x12)) \u0026#x26; 0xf0)\n        if (cmos_disks \u0026#x26; 0x0f)\n            NR_HD = 2;\n        else\n            NR_HD = 1;\n    else\n        NR_HD = 0;\n    for (i = NR_HD ; i \u0026#x3C; 2 ; i++) {\n        hd[i*5].start_sect = 0;\n        hd[i*5].nr_sects = 0;\n    }\n    /* 更进一步设置每个盘的参数 */\n    for (drive=0 ; drive\u0026#x3C;NR_HD ; drive++) {\n        /* 0x300 和 0x305 分别代表两个硬盘 */\n        /* 读取每个硬盘的第一块数据 (1024B) */\n        if (!(bh = bread(0x300 + drive*5,0))) {\n            printk(\"Unable to read partition table of drive %d\\n\\r\",\n                drive);\n            panic(\"\");\n        }\n        /* 判断硬盘有效性 */\n        if (bh-\u003eb_data[510] != 0x55 || (unsigned char)\n            bh-\u003eb_data[511] != 0xAA) {\n            printk(\"Bad partition table on drive %d\\n\\r\",drive);\n            panic(\"\");\n        }\n        /* 读取分区表 (位于 引导扇区第 446 字节开始处 */\n        p = 0x1BE + (void *)bh-\u003eb_data;\n        for (i=1;i\u0026#x3C;5;i++,p++) {\n            hd[i+5*drive].start_sect = p-\u003estart_sect;\n            hd[i+5*drive].nr_sects = p-\u003enr_sects;\n        }\n        brelse(bh);\n    }\n    if (NR_HD)\n        printk(\"Partition table%s ok.\\n\\r\",(NR_HD\u003e1)?\"s\":\"\");\n    rd_load();              /* 尝试创建并加载虚拟盘 */\n    mount_root();           /* mount 根文件系统 */\n    return (0);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e终于到了挂载文件系统的时候了\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emount_root\u003c/code\u003e 用来做初级的初始化工作。同时，上一节已经描述过了，存储设备的超级块是用了记录整个文件系统最重要的结构。\u003c/p\u003e\n\u003cp\u003e那么通过将超级块的信息读取到内存，也就可以将内存与外存的文件系统相互联系起来了。\u003c/p\u003e\n\u003cp\u003e下面这段代码最重要的内容就是 \u003ccode\u003eread_super()\u003c/code\u003e 函数了 .\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid mount_root(void)\n{\n    int i,free;\n    struct super_block * p;\n    struct m_inode * mi;\n\n    if (32 != sizeof (struct d_inode))\n        panic(\"bad i-node size\");\n    /* 先初始化文件表，该版本操作系统限制最大同时打开 NR_FILE(64个) 文件 */\n    for(i=0;i\u0026#x3C;NR_FILE;i++)\n        /* f_count = 0 表明没有被引用 */\n        file_table[i].f_count=0;\n    /* 如果引导盘是软盘的话，提示插入根文件系统盘 */\n    if (MAJOR(ROOT_DEV) == 2) {\n        printk(\"Insert root floppy and press ENTER\");\n        wait_for_keypress();\n    }\n    /* 初始化内存超级块数据结构 (总共 8 个) */\n    for(p = \u0026#x26;super_block[0] ; p \u0026#x3C; \u0026#x26;super_block[NR_SUPER] ; p++) {\n        p-\u003es_dev = 0;\n        p-\u003es_lock = 0;\n        p-\u003es_wait = NULL;\n    }\n    /* Hint: 读取超级块的信息，挂载根文件系统重要的部分(代码请往下翻) */\n    if (!(p=read_super(ROOT_DEV)))\n        panic(\"Unable to mount root\");\n    /* 读取文件系统的 1 号i节点 (即该设备上文件系统的根节点) */\n    if (!(mi=iget(ROOT_DEV,ROOT_INO)))\n        panic(\"Unable to read root i-node\");\n    mi-\u003ei_count += 3 ;  /* NOTE! it is logically used 4 times, not 1 */\n    p-\u003es_isup = p-\u003es_imount = mi;\n    /* 应该还记得吧，current 指的是当前的任务(任务1)，以后所有的任务都会由任务1或任务1的子任务进行派生，也就意味着 current-\u003eroot 会一直复制过去\n     * 到这里为止，应该认为根文件系统以及被挂载了。是不是跟被耍了一样?\n     */\n    current-\u003epwd = mi;\n    current-\u003eroot = mi;\n    free=0;\n    i=p-\u003es_nzones;\n    /* 统计还有多少空闲数据块以及多少可用i节点 (附上一张启动过程中打印的信息) */\n    while (-- i \u003e= 0)\n        if (!set_bit(i\u0026#x26;8191,p-\u003es_zmap[i\u003e\u003e13]-\u003eb_data))\n            free++;\n    printk(\"%d/%d free blocks\\n\\r\",free,p-\u003es_nzones);\n    free=0;\n    i=p-\u003es_ninodes+1;\n    while (-- i \u003e= 0)\n        if (!set_bit(i\u0026#x26;8191,p-\u003es_imap[i\u003e\u003e13]-\u003eb_data))\n            free++;\n    printk(\"%d/%d free inodes\\n\\r\",free,p-\u003es_ninodes);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fwz8kvvgbpj30l006i3yb.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e重要要的部分，\u003ccode\u003eread_super(int dev)\u003c/code\u003e，用于读取超级块的数据\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic struct super_block * read_super(int dev)\n{\n    struct super_block * s;\n    struct buffer_head * bh;\n    int i,block;\n\n    if (!dev)\n        return NULL;\n    check_disk_change(dev);\n    /* 如果该超级块已经在内存中了，那么就直接使用 (和这里挂载根文件系统的流程无关) */\n    if (s = get_super(dev))\n        return s;\n    /* 设备超级块不在内存中，就先找一个空闲的内存超级块 (总共维护 8 个超级块数据结构) */\n    for (s = 0+super_block ;; s++) {\n        if (s \u003e= NR_SUPER+super_block)\n            return NULL;\n        if (!s-\u003es_dev)\n            break;\n    }\n    s-\u003es_dev = dev;\n    s-\u003es_isup = NULL;\n    s-\u003es_imount = NULL;\n    s-\u003es_time = 0;\n    s-\u003es_rd_only = 0;\n    s-\u003es_dirt = 0;\n    lock_super(s);\n    /* 通过 block read 读取设备第一个物理块 (每个物理块 1024 B) */\n    if (!(bh = bread(dev,1))) {\n        s-\u003es_dev=0;\n        free_super(s);\n        return NULL;\n    }\n    /* 复制一份超级块的数据 */\n    *((struct d_super_block *) s) =\n        *((struct d_super_block *) bh-\u003eb_data);\n    /* 释放缓冲区的数据 */\n    brelse(bh);\n    /* 验证魔数, 该版本操作系统只支持 1.0 版 Minix 文件系统，魔数 0x137F */\n    if (s-\u003es_magic != SUPER_MAGIC) {\n        s-\u003es_dev = 0;\n        free_super(s);\n        return NULL;\n    }\n    /* 先清空内存中的数据 */\n    for (i=0;i\u0026#x3C;I_MAP_SLOTS;i++)\n        s-\u003es_imap[i] = NULL;\n    for (i=0;i\u0026#x3C;Z_MAP_SLOTS;i++)\n        s-\u003es_zmap[i] = NULL;\n    block=2;\n    /* 读取 i 节点位图块 */\n    for (i=0 ; i \u0026#x3C; s-\u003es_imap_blocks ; i++)\n        if (s-\u003es_imap[i]=bread(dev,block))\n            block++;\n        else\n            break;\n    /* 读取数据块位图 */\n    for (i=0 ; i \u0026#x3C; s-\u003es_zmap_blocks ; i++)\n        if (s-\u003es_zmap[i]=bread(dev,block))\n            block++;\n        else\n            break;\n    if (block != 2+s-\u003es_imap_blocks+s-\u003es_zmap_blocks) {\n        for(i=0;i\u0026#x3C;I_MAP_SLOTS;i++)\n            brelse(s-\u003es_imap[i]);\n        for(i=0;i\u0026#x3C;Z_MAP_SLOTS;i++)\n            brelse(s-\u003es_zmap[i]);\n        s-\u003es_dev=0;\n        free_super(s);\n        return NULL;\n    }\n    s-\u003es_imap[0]-\u003eb_data[0] |= 1;\n    s-\u003es_zmap[0]-\u003eb_data[0] |= 1;\n    /* 与前面的 wait_on_super() 对应(解开lock标志) */\n    free_super(s);\n    return s;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e是不是觉得也没什么，就这样根文件系统已经挂载了? 毫无实感是吧。\u003c/p\u003e\n\u003ch2\u003eExtra: 普通挂载\u003c/h2\u003e\n\u003cp\u003e既然讲过了根文件系统的挂载。那就顺带着讲讲普通文件系统的挂载吧。\u003c/p\u003e\n\u003cp\u003e相信从命令上来讲应该比较简单也比较熟悉吧。\u003ccode\u003emount disk.img /mnt\u003c/code\u003e 也算是挂载到 /mnt 下了\u003c/p\u003e\n\u003cp\u003e但是，究竟是怎么实现的呢?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_mount(char * dev_name, char * dir_name, int rw_flag)\n{\n    struct m_inode * dev_i, * dir_i;\n    struct super_block * sb;\n    int dev;\n\n    /** \n     * 省略大部分判断逻辑, 主要就是:\n     * 1. 判断 dev_name 所属的设备号，读取该设备上的超级块\n     * 2. 读取 dir_name (需要挂载到的位置)，判定是否允许被挂载(比如根节点不允许挂其它设备)\n     */\n    ...\n\n    /* 设置超级块的 mount 标志 */\n    sb-\u003es_imount=dir_i;\n    /* 设置该 i 节点的 mount 标志 */\n    dir_i-\u003ei_mount=1;\n    dir_i-\u003ei_dirt=1;        /* NOTE! we don't iput(dir_i) */\n    return 0;           /* we do that in umount */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e文件读写\u003c/h2\u003e\n\u003cp\u003e前面讲了这么多，终于到了最关心的部分了。当然，也并不是说前面的内容不重要，事实上，相当重要，只是都隐藏在了内核引导的过程中，且调用频度低，才导致了没有存在感。但是这恰恰才是支持文件读写的基石。\u003c/p\u003e\n\u003cp\u003e不多说废话，下面就要开始文件读写的内容。\u003c/p\u003e\n\u003ch3\u003e打开文件\u003c/h3\u003e\n\u003cp\u003e打开文件的函数原型是 \u003ccode\u003eint open(const char * filename, int flag, ...);\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e当然，此类系统调用最终的实现都是 \u003ccode\u003eint 0x80\u003c/code\u003e , 明确一个调用号，然后就陷入内核态了。\u003c/p\u003e\n\u003cp\u003e内核态下调用的函数是: \u003ccode\u003eint sys_open(const char * filename,int flag,int mode)\u003c/code\u003e \u003c/p\u003e\n\u003cp\u003e来看看细节:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_open(const char * filename,int flag,int mode)\n{\n    struct m_inode * inode;\n    struct file * f;\n    int i,fd;\n\n    /*\n     * current 是由内核数据段维护的当前任务的指针\n     * umask 是指当前任务在新建文件时的默认掩码\n     *   例如 Linux 默认是 022, 即新建文件被禁止了组用户与其它用户的写权限\n     * 这里是先确定新建文件的权限\n     */\n    mode \u0026#x26;= 0777 \u0026#x26; ~current-\u003eumask;\n    /*\n     * 文件描述符，每个文件单独维护一套，以数字标记\n     * 找一个空闲的文件描述符项\n     */\n    for(fd=0 ; fd\u0026#x3C;NR_OPEN ; fd++)\n        if (!current-\u003efilp[fd])\n            break;\n    if (fd\u003e=NR_OPEN)\n        return -EINVAL;\n    /*\n     * 顾名思义，设置在调用 exec() 函数时主动关闭的文件\n     * exec() 通常与 fork() 联用，fork() 负责复制一个任务，而 exec 负责替换新任务的代码和数据段(从而产生一个新的任务)\n     * 这里的声明即是复位 fd 位置的标志，允许子任务也持有相同的文件描述符项\n     */\n    current-\u003eclose_on_exec \u0026#x26;= ~(1\u0026#x3C;\u0026#x3C;fd);\n    f=0+file_table;\n    /* 在文件表中找一项空闲的 */\n    for (i=0 ; i\u0026#x3C;NR_FILE ; i++,f++)\n        if (!f-\u003ef_count) break;\n    if (i\u003e=NR_FILE)\n        return -EINVAL;\n    /* 当前任务的文件描述符项指向文件表项, 同时文件表项的引用计数+1*/\n    (current-\u003efilp[fd]=f)-\u003ef_count++;\n    /* 调用 open_namei 打开文件，如果失败则释放刚才占用的文件结构，并返回错误码 */\n    if ((i=open_namei(filename,flag,mode,\u0026#x26;inode))\u0026#x3C;0) {\n        current-\u003efilp[fd]=NULL;\n        f-\u003ef_count=0;\n        return i;\n    }\n    /* \n     * 对不同的文件进行不同的特殊处理, 毕竟有 \"一切皆文件\" 的口号嘛\n     * 诸如字符设备等也都是文件\n     */\n/* ttys are somewhat special (ttyxx major==4, tty major==5) */\n    if (S_ISCHR(inode-\u003ei_mode))\n        if (MAJOR(inode-\u003ei_zone[0])==4) {\n            if (current-\u003eleader \u0026#x26;\u0026#x26; current-\u003etty\u0026#x3C;0) {\n                current-\u003etty = MINOR(inode-\u003ei_zone[0]);\n                tty_table[current-\u003etty].pgrp = current-\u003epgrp;\n            }\n        } else if (MAJOR(inode-\u003ei_zone[0])==5)\n            if (current-\u003etty\u0026#x3C;0) {\n                iput(inode);\n                current-\u003efilp[fd]=NULL;\n                f-\u003ef_count=0;\n                return -EPERM;\n            }\n/* Likewise with block-devices: check for floppy_change */\n    if (S_ISBLK(inode-\u003ei_mode))\n        check_disk_change(inode-\u003ei_zone[0]);\n    /* 初始化内存文件结构的各个参数 */\n    f-\u003ef_mode = inode-\u003ei_mode;\n    f-\u003ef_flags = flag;\n    f-\u003ef_count = 1;\n    f-\u003ef_inode = inode;\n    f-\u003ef_pos = 0;\n    return (fd);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在整个打开文件的过程中，除了真正去文件系统查找文件的时候用到了文件名，其它时候，都将是以文件描述符进行交互的。\u003c/p\u003e\n\u003cp\u003e再看看更细节的方面，毕竟就目前来说，我们跳过了最重要的一环 \u003ccode\u003eopen_namei\u003c/code\u003e ，从而看似整个流程都简单了很多很多。\u003c/p\u003e\n\u003cp\u003e通常我们在编码过程中都是通过绝对地址/相对地址来唯一定位一个文件。因此，就必然存在逐级寻找文件的过程\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic struct m_inode * get_dir(const char * pathname)\n{\n    char c;\n    const char * thisname;\n    struct m_inode * inode;\n    struct buffer_head * bh;\n    int namelen,inr,idev;\n    struct dir_entry * de;\n\n    /* 判定当前任务设定的根节点是否有效 */\n    if (!current-\u003eroot || !current-\u003eroot-\u003ei_count)\n        panic(\"No root inode\");\n    /* 判定当前路径i节点是否有效 */\n    if (!current-\u003epwd || !current-\u003epwd-\u003ei_count)\n        panic(\"No cwd inode\");\n    /* \n     * 这里的 get_fs_byte(..) 是宏定义，fs 指的是 FS 段寄存器\n     * Linux 内核将 DS, ES 用于内核数据段, 用 FS 指向局部描述符表的当前任务数据段\n     * 这里可以简单理解成取字符数组的第一个字节\n     */\n    if ((c=get_fs_byte(pathname))=='/') {\n        inode = current-\u003eroot;\n        pathname++;\n    } else if (c)\n        inode = current-\u003epwd;\n    else\n        return NULL;    /* empty name is bad */\n    inode-\u003ei_count++;\n    while (1) {\n        thisname = pathname;\n        if (!S_ISDIR(inode-\u003ei_mode) || !permission(inode,MAY_EXEC)) {\n            iput(inode);\n            return NULL;\n        }\n        for(namelen=0;(c=get_fs_byte(pathname++))\u0026#x26;\u0026#x26;(c!='/');namelen++)\n            /* nothing */ ;\n        if (!c)\n            return inode;\n        if (!(bh = find_entry(\u0026#x26;inode,thisname,namelen,\u0026#x26;de))) {\n            iput(inode);\n            return NULL;\n        }\n        inr = de-\u003einode;\n        idev = inode-\u003ei_dev;\n        brelse(bh);\n        iput(inode);\n        if (!(inode = iget(idev,inr)))\n            return NULL;\n    }\n}\n\n/*\n *  dir_namei()\n *\n * 处理路径 pathname, 处理成i节点表示的最终一级目录+目录下文件名(也可能pathname表示的就是目录)\n */\nstatic struct m_inode * dir_namei(const char * pathname, int * namelen, const char ** name)\n{\n    char c;\n    const char * basename;\n    struct m_inode * dir;\n\n    if (!(dir = get_dir(pathname)))\n        return NULL;\n    basename = pathname;\n    while (c=get_fs_byte(pathname++))\n        if (c=='/')\n            basename=pathname;\n    *namelen = pathname-basename-1;\n    *name = basename;\n    return dir;\n}\n\n/*\n *  open_namei()\n *\n * namei for open - this is in fact almost the whole open-routine.\n */\nint open_namei(const char * pathname, int flag, int mode,\n    struct m_inode ** res_inode)\n{\n    const char * basename;\n    int inr,dev,namelen;\n    struct m_inode * dir, *inode;\n    struct buffer_head * bh;\n    struct dir_entry * de;\n\n    if ((flag \u0026#x26; O_TRUNC) \u0026#x26;\u0026#x26; !(flag \u0026#x26; O_ACCMODE))\n        flag |= O_WRONLY;\n    mode \u0026#x26;= 0777 \u0026#x26; ~current-\u003eumask;\n    mode |= I_REGULAR;\n    if (!(dir = dir_namei(pathname,\u0026#x26;namelen,\u0026#x26;basename)))\n        return -ENOENT;\n    /* 如果给的 pathname 是一个目录 */\n    if (!namelen) {         /* special case: '/usr/' etc */\n        if (!(flag \u0026#x26; (O_ACCMODE|O_CREAT|O_TRUNC))) {\n            *res_inode=dir;\n            return 0;\n        }\n        iput(dir);\n        return -EISDIR;\n    }\n    /* 找到目录对应的i节点的数据块 */\n    bh = find_entry(\u0026#x26;dir,basename,namelen,\u0026#x26;de);\n    if (!bh) {\n        if (!(flag \u0026#x26; O_CREAT)) {\n            iput(dir);\n            return -ENOENT;\n        }\n        if (!permission(dir,MAY_WRITE)) {\n            iput(dir);\n            return -EACCES;\n        }\n        inode = new_inode(dir-\u003ei_dev);\n        if (!inode) {\n            iput(dir);\n            return -ENOSPC;\n        }\n        inode-\u003ei_uid = current-\u003eeuid;\n        inode-\u003ei_mode = mode;\n        inode-\u003ei_dirt = 1;\n        bh = add_entry(dir,basename,namelen,\u0026#x26;de);\n        if (!bh) {\n            inode-\u003ei_nlinks--;\n            iput(inode);\n            iput(dir);\n            return -ENOSPC;\n        }\n        de-\u003einode = inode-\u003ei_num;\n        bh-\u003eb_dirt = 1;\n        brelse(bh);\n        iput(dir);\n        *res_inode = inode;\n        return 0;\n    }\n    inr = de-\u003einode;\n    dev = dir-\u003ei_dev;\n    brelse(bh);\n    iput(dir);\n    if (flag \u0026#x26; O_EXCL)\n        return -EEXIST;\n    if (!(inode=iget(dev,inr)))\n        return -EACCES;\n    if ((S_ISDIR(inode-\u003ei_mode) \u0026#x26;\u0026#x26; (flag \u0026#x26; O_ACCMODE)) ||\n        !permission(inode,ACC_MODE(flag))) {\n        iput(inode);\n        return -EPERM;\n    }\n    inode-\u003ei_atime = CURRENT_TIME;\n    if (flag \u0026#x26; O_TRUNC)\n        truncate(inode);\n    *res_inode = inode;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e文件写入\u003c/h3\u003e\n\u003cp\u003e接下来就要进行文件写入的流程了\u003c/p\u003e\n\u003cp\u003e如何陷入内核态函数就不再细说了，相信看过这么多系统调用之后，也能知道基本上系统调用在内核态对应的函数都是以 sys_ 形式出现的\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_write(unsigned int fd,char * buf,int count)\n{\n    struct file * file;\n    struct m_inode * inode;\n\n    /* 非法 fd , 抛异常 */\n    if (fd\u003e=NR_OPEN || count \u0026#x3C;0 || !(file=current-\u003efilp[fd]))\n        return -EINVAL;\n    /* count = 0，无需写入数据 */\n    if (!count)\n        return 0;\n    inode=file-\u003ef_inode;\n    /* 针对不同的i节点类型，有不同的写入函数 */\n    if (inode-\u003ei_pipe)\n        return (file-\u003ef_mode\u0026#x26;2)?write_pipe(inode,buf,count):-EIO;\n    if (S_ISCHR(inode-\u003ei_mode))\n        return rw_char(WRITE,inode-\u003ei_zone[0],buf,count,\u0026#x26;file-\u003ef_pos);\n    if (S_ISBLK(inode-\u003ei_mode))\n        return block_write(inode-\u003ei_zone[0],\u0026#x26;file-\u003ef_pos,buf,count);\n    if (S_ISREG(inode-\u003ei_mode))\n        return file_write(inode,file,buf,count);\n    printk(\"(Write)inode-\u003ei_mode=%06o\\n\\r\",inode-\u003ei_mode);\n    return -EINVAL;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e看看对于常规文件是怎么操作的吧。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint file_write(struct m_inode * inode, struct file * filp, char * buf, int count)\n{\n    off_t pos;      /* 偏移量 */\n    int block,c;\n    struct buffer_head * bh;\n    char * p;\n    int i=0;\n\n    /* 如果是 Append 模式，把偏移量重置到文件末尾 */\n    if (filp-\u003ef_flags \u0026#x26; O_APPEND) \n        pos = inode-\u003ei_size;\n    /* 否则就使用当前文件数据结构持有的偏移量 */\n    /*\n        附上数据结构  file 的内容 \n        struct file {\n            unsigned short f_mode;\n            unsigned short f_flags;\n            unsigned short f_count;\n            struct m_inode * f_inode;\n            off_t f_pos;    每个打开的文件都将持有当前的偏移值\n        };\n     */\n    else\n        pos = filp-\u003ef_pos;\n    /* 逐字符向缓冲区写入数据 */\n    while (i\u0026#x3C;count) {\n        /* 最开始当然是创建在磁盘上占用一个数据块了 (如果文件对应的块不存在的话) */\n        if (!(block = create_block(inode,pos/BLOCK_SIZE)))\n            break;\n        /* 根据数据块获得相应的缓冲块 */\n        if (!(bh=bread(inode-\u003ei_dev,block)))\n            break;\n        /* 在缓冲块中的偏移量 */\n        c = pos % BLOCK_SIZE;\n        /* 定位到具体的缓冲区的内存地址 */\n        p = c + bh-\u003eb_data;\n        bh-\u003eb_dirt = 1;\n        /* 当前这个缓冲块还有多少字节可写 */\n        c = BLOCK_SIZE-c;\n        /* 如果需要写入的数据量少于 c */\n        if (c \u003e count-i) c = count-i;\n        /* 添加偏移量计数, 更新数据结构中维护的值 */\n        pos += c;\n        if (pos \u003e inode-\u003ei_size) {\n            inode-\u003ei_size = pos;\n            inode-\u003ei_dirt = 1;\n        }\n        i += c;\n        /* 向缓冲块逐字节写入数据 */\n        while (c--\u003e0)\n            *(p++) = get_fs_byte(buf++);\n        /* 释放对缓冲块的占用，当然，在释放前会完成缓冲块\u0026#x3C;-\u003e外存数据块的同步 */\n        brelse(bh);\n    }\n    inode-\u003ei_mtime = CURRENT_TIME;\n    if (!(filp-\u003ef_flags \u0026#x26; O_APPEND)) {\n        /* 非 APPEND 模式，更新文件读写指针(偏移量); APPEND 模式是使用 inode-\u003ei_size ，所有就不需要在这里更新了 */\n        filp-\u003ef_pos = pos;\n        inode-\u003ei_ctime = CURRENT_TIME;\n    }\n    return (i?i:-1);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e是不是觉得也没有什么太高大上的操作。确实如此，更多关于缓存块与文件系统数据块的同步都已经被包装到 bread(), brelse() 中了。\u003c/p\u003e\n\u003cp\u003e不过，暂时无需细究。总之到此为止，先要有一个基础的观念: 所有与外存储器(这里也包括控制台等)进行数据交互都必须经过缓冲区\u003c/p\u003e\n\u003cp\u003e缓冲区封装了对外存储器的全部操作，而提供给 CPU 更高效的 I/O 操作，当然，也更为简单快捷\u003c/p\u003e\n\u003ch3\u003e文件读取\u003c/h3\u003e\n\u003cp\u003e至于文件读取，也基本类似了，所以也就不再深入描述。\u003c/p\u003e\n\u003cp\u003e当然，要注意的就是，在本篇开始的部分提供的例程中，write \u0026#x26; read 中插入了 \u003ccode\u003eoff_t off = lseek(fd, 0, SEEK_SET);\u003c/code\u003e  这样的代码。\u003c/p\u003e\n\u003cp\u003e原因应该也能够想到，学习 \u003ccode\u003esys_write(..)\u003c/code\u003e 的时候我们已经看到，任务对同一个文件在内存中维护了一个文件读写偏移量。因此，要读取刚才写入的内容，就不得不先改动这个读写偏移量了\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint sys_read(unsigned int fd,char * buf,int count)\n{\n    struct file * file;\n    struct m_inode * inode;\n\n    if (fd\u003e=NR_OPEN || count\u0026#x3C;0 || !(file=current-\u003efilp[fd]))\n        return -EINVAL;\n    if (!count)\n        return 0;\n    verify_area(buf,count);\n    inode = file-\u003ef_inode;\n    if (inode-\u003ei_pipe)\n        return (file-\u003ef_mode\u0026#x26;1)?read_pipe(inode,buf,count):-EIO;\n    if (S_ISCHR(inode-\u003ei_mode))\n        return rw_char(READ,inode-\u003ei_zone[0],buf,count,\u0026#x26;file-\u003ef_pos);\n    if (S_ISBLK(inode-\u003ei_mode))\n        return block_read(inode-\u003ei_zone[0],\u0026#x26;file-\u003ef_pos,buf,count);\n    if (S_ISDIR(inode-\u003ei_mode) || S_ISREG(inode-\u003ei_mode)) {\n        if (count+file-\u003ef_pos \u003e inode-\u003ei_size)\n            count = inode-\u003ei_size - file-\u003ef_pos;\n        if (count\u0026#x3C;=0)\n            return 0;\n        return file_read(inode,file,buf,count);\n    }\n    printk(\"(Read)inode-\u003ei_mode=%06o\\n\\r\",inode-\u003ei_mode);\n    return -EINVAL;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e小结\u003c/h2\u003e\n\u003cp\u003e这篇对文件系统的代码层面的描述，仅仅只是捡了一个相当有限的片面 (常规文件读写)。从文件系统的挂载开始提供了一个读写的完整流程介绍(当然，很多细节是缺失的，不过不要着急)。\u003c/p\u003e\n\u003cp\u003e虽然平常都能够了解到一个比较模糊的前提，文件读写需要利用缓冲区，但是究竟什么是缓存区，如何使用都不会有太多的概念。本篇最大的重点，就是首先请读者们建立起一个基础性的对缓冲区的了解。事实上，这个中介在 I/O 中扮演了相当重要的角色。而且内存也为其提供了相当大的一份空间，差不多有 1/4 了。\u003c/p\u003e\n\u003cp\u003e跨了差不多半个多月来写，上下文的承接可能有些生硬了，甚至不一致了... 尴尬...\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e\u003ca href=\"https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/\"\u003e前一篇\u003c/a\u003e已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。\u003c/p\u003e\n\u003cp\u003e首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \u0026#x3C;stdio.h\u003e\n#include \u0026#x3C;stdlib.h\u003e\n#include \u0026#x3C;string.h\u003e\n#include \u0026#x3C;unistd.h\u003e\n#include \u0026#x3C;fcntl.h\u003e\n#include \u0026#x3C;errno.h\u003e\n#include \u0026#x3C;sys/types.h\u003e\n#include \u0026#x3C;sys/stat.h\u003e\n\nint panic()\n{\n    fprintf(stderr, \"%s (errno=%d)\\n\", strerror(errno), errno);\n    return -1;\n}\n\nint main(int argc, char *argv[])\n{\n    /* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */\n    int fd = open(\"/root/frw.txt\", O_RDWR | O_CREAT);\n    if (fd == -1)\n        return panic();\n\n    /* 向文件写入 Hello World! 共计 12 个字符 */\n    ssize_t wsize = write(fd, \"Hello World!\", 12);\n    if (wsize == -1)\n        return panic();\n\n    /* 重定位文件读写指针 */\n    off_t off = lseek(fd, 0, SEEK_SET);\n    if (off == -1)\n        return panic();\n\n    char* buf = (char *) malloc(wsize);\n    /* 读取文件内容 */\n    ssize_t rsize = read(fd, buf, wsize);\n    if (rsize == -1)\n        return panic();\n\n    printf(\"%s\\n\", buf);\n    free(buf);\n    /* 关闭文件 */\n    int stat = close(fd);\n    if (stat == -1)\n        return panic();\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e"},{"url":"2018-10-14-understand-Kernel-5","fileName":"2018-10-14-understand-Kernel-5.md","title":"理解 Linux Kernel (5) - 文件系统(宏观描述)","author":"fangfeng","date":"2018-10-14T00:00:00.000Z","tags":["Kernel","Linux","File System"],"content":"\u003cp\u003e用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ ls\nApplications Network      Users        bin          data         etc          net          sbin         usr\nLibrary      System       Volumes      cores        dev          home         private      tmp          var\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?\u003c/p\u003e\n\u003ch2\u003e文件系统的形式\u003c/h2\u003e\n\u003cp\u003e首先我们假设文件是简单地存储在存储设备(硬盘等)某一块连续区域的。\u003c/p\u003e\n\u003cp\u003e那么如何在小则几百G，大则几十T甚至更大的存储设备上找到具体的某一文件，并读取的内存中呢?\u003c/p\u003e\n\u003cp\u003e最普通的，就只能在存储设备上一字节一字节的查找，直到找到相应的目标文件。是不是可以想象，这会很慢很慢。\u003c/p\u003e\n\u003cp\u003e有没有快一点的？很容易想到，参考类似字典的形式就可以了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e目录形式\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e文件内容可能很大，但相比之下，文件名就小了很多(就算不同目录下同名文件很多，但是记录全路径名也代价不大。当然了，如果都是小文件、空文件，那就不一样了)\u003c/p\u003e\n\u003cp\u003e通过为所有文件通过文件名编一个目录，指明每个文件在存储设备上的具体位置。这样需要扫描的内容就会小很多，也能更快地定位到文件内容。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e逐级目录\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e仅仅只编制一个目录，那么层次目录又有什么实际意义吗？只是为了方便用户分类不同功能、目的的文件吗？\u003c/p\u003e\n\u003cp\u003e利用逐级目录，可以考虑对次级目录的内容编制上一级目录。通过顶级目录定位次级目录的内容，次级目录定位再次级目录，最后对应目录下的文件的内容。\u003c/p\u003e\n\u003ch2\u003e文件系统的组织\u003c/h2\u003e\n\u003cp\u003e在之前的理解里，文件系统是接管了整个存储设备。似乎文件系统和存储设备就是直接关联的，两个不可分割。没有建立文件系统的硬盘就不能使用，而没有硬盘，文件系统就没有了载体。\u003c/p\u003e\n\u003cp\u003e但是，在学习 Linux 的过程中，似乎发现也并不是这么一回事。没有直接硬盘，文件系统一样可以存在。一直都有在使用 \u003ccode\u003e.img\u003c/code\u003e 磁盘映像文件，只是没有意识到，这意识文件系统的一种载体。同样的，没有文件系统，在操作系统启动的过程中，一样是可以加载各种内容，乃至预置的文件信息。\u003c/p\u003e\n\u003cp\u003e在 Linux 中，最常见的文件系统就是 ext2, ext3, ext4 之流了。偶尔也有听过用过，比如说准备接入新的硬盘的时候。但是，真正里面是什么样的。还真不了解，ext2,3,4 的区别，也根本不知道。\u003c/p\u003e\n\u003cp\u003e当然了，本次也并不会对这些内容进行描述。由于一直在学习 Linux 0.11 版本的源码，接下来要描述的文件系统，也就是 0.11 版本直接使用的 minix 文件系统了。\u003c/p\u003e\n\u003cp\u003e最开始，当然是应该有一个感官的印象，才能更方便地来理解文件系统的组织形式啦!\u003c/p\u003e\n\u003ch3\u003e创建文件系统\u003c/h3\u003e\n\u003cp\u003e这里我们创建一个 512 KB 大小的文件系统\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emkfs\u003c/code\u003e 应该是最简单的方式了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ touch disk.img            # 磁盘映像文件 (由于没有额外的磁盘，就以此作为新创建的 minix 文件系统的载体)\n$ dd if=/dev/zero of=disk.img bs=1024 count=512     # 先将文件的大小扩展到 512 KB ，否则在创建文件系统的时候会失败\n512+0 records in\n512+0 records out\n524288 bytes (524 kB, 512 KiB) copied, 0.00216049 s, 243 MB/s\n$ mkfs.minix disk.img 512   # 创建文件系统\n192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode\n512 blocks                  # 总共 512 个磁盘块\nFirstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的\nZonesize=1024               # 每个磁盘块的大小为 1024 B\nMaxsize=268966912           # 单一文件的最大大小\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e先来看看目前 disk.img 里面的内容\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ hexdump disk.img\n0000000 0000 0000 0000 0000 0000 0000 0000 0000\n*                                                   # * 表示这段数据全为 0\n0000400 00c0 0200 0001 0001 000a 0000 1c00 1008\n0000410 138f 0001 0000 0000 0000 0000 0000 0000\n0000420 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000800 0003 0000 0000 0000 0000 0000 0000 0000\n0000810 0000 0000 0000 0000 fffe ffff ffff ffff\n0000820 ffff ffff ffff ffff ffff ffff ffff ffff\n*                                                   # * 表示这段数据全为 ff ( * 总是表示与前一段数据一致的省略)\n0000c00 0003 0000 0000 0000 0000 0000 0000 0000\n0000c10 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000c30 0000 0000 0000 0000 0000 0000 0000 ff80\n0000c40 ffff ffff ffff ffff ffff ffff ffff ffff\n*\n0001000 41ed 0000 0040 0000 cf12 5bd3 0200 000a\n0001010 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0002800 0001 002e 0000 0000 0000 0000 0000 0000\n0002810 0000 0000 0000 0000 0000 0000 0000 0000\n0002820 0001 2e2e 0000 0000 0000 0000 0000 0000\n0002830 0000 0000 0000 0000 0000 0000 0000 0000\n0002840 0000 622e 6461 6c62 636f 736b 0000 0000\n0002850 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0080000                                             # 截止字节，0x80000 = 512 KB 并不存在\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e似乎并没有太多的感觉，现在我们往 disk.img 这个磁盘映像文件中添些内容再来看看。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ mount disk.img /mnt   # 把 disk.img 挂载到 /mnt 目录下\n$ cd /mnt\n$ echo \"#include \u0026#x3C;stdio.h\u003e\" \u003e hello.c       # 创建 hello.c 文件，并写入 #include \u0026#x3C;stdio.h\u003e \n$ umount /mnt           # 解挂 disk.img\n$ hexdump -C disk.img\n00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|\n00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000420  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|\n00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|\n*\n00000c00  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000c10  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000c30  00 00 00 00 00 00 00 00  00 00 00 00 00 00 80 ff  |................|\n00000c40  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|\n*\n00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|\n00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|\n00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|\n00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include \u0026#x3C;stdio.|\n00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h\u003e..............|\n00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00080000\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e很明显，我们看到了 \u003ccode\u003e#include \u0026#x3C;stdio.h\u003e\u003c/code\u003e 字样的内容，同时也出现了 \u003ccode\u003ehello.c\u003c/code\u003e 的文件名。\u003c/p\u003e\n\u003cp\u003e需要注意，文件名和文件内容是相互割裂的，并没有直接存储在一起。\u003c/p\u003e\n\u003ch3\u003e文件系统存储结构\u003c/h3\u003e\n\u003cp\u003e那么，配合着上面的内容来看看文件系统的组织结构。\u003c/p\u003e\n\u003cp\u003e首先可以注意到的是，每一段非零的数据的开始地址，基本都是在 \u003ccode\u003e0x0000, 0x0400, 0x0800, 0x0c00, 0x1000\u003c/code\u003e 。间隔了 0x0400 = 1KB，这就是最基本的块的大小。\u003c/p\u003e\n\u003cp\u003eMinix 文件系统将 1024 B 作为基本块的大小。\u003ccode\u003edisk.img\u003c/code\u003e 这个 512 KB 的磁盘映像文件，也就恰好被分割成 512 块。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ mkfs.minix disk.img 512   # 创建文件系统\n192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode\n512 blocks                  # 总共 512 个磁盘块\nFirstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的\nZonesize=1024               # 每个磁盘块的大小为 1024 B\nMaxsize=268966912           # 单一文件的最大大小\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在回过头来看看前面创建文件系统的时候的信息，相信也就能够看懂一部分了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e块的作用划分\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e那么，每个块如何进行使用呢？\u003c/p\u003e\n\u003cp\u003e首先，最开始的一个块并不会直接使用。我们知道引导程序应该出现在引导盘最开始 512 B。但是，有些盘有引导程序，有些盘又没有，如何处理呢？\u003c/p\u003e\n\u003cp\u003e文件系统结构中，默认地不对第一个 1024 B 的块进行操作，即原本是什么数据就是什么数据，与文件系统并不相干。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fwnnc753epj31kw04tq35.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e除了引导块，之后还有超级块，inode 位图，逻辑块位图，inode 区块，数据区块\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e超级块\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e真正对 MINIX 文件系统起着统领性作用的，是超级块(第二个块)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct super_block {\n unsigned short s_ninodes;          /* i 节点的数量 */\n unsigned short s_nzones;           /* 总区块数量 */\n unsigned short s_imap_blocks;      /* i 节点位图的数量 */\n unsigned short s_zmap_blocks;      /* 区块位图的数量 */\n unsigned short s_firstdatazone;    /* 第一个数据块的编号 */\n unsigned short s_log_zone_size;    /* log2(磁盘块大小 / 逻辑块大小) */\n unsigned long s_max_size;          /* 单文件的最大长度 */\n unsigned short s_magic;            /* 文件系统的魔数 */\n\n /* 下面的内容是在内存中使用的，并不会在磁盘上进行读写 */\n struct buffer_head * s_imap[8];\n struct buffer_head * s_zmap[8];\n unsigned short s_dev;\n struct m_inode * s_isup;\n struct m_inode * s_imount;\n unsigned long s_time;\n struct task_struct * s_wait;\n unsigned char s_lock;\n unsigned char s_rd_only;\n unsigned char s_dirt;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e结合着 \u003ccode\u003edisk.img\u003c/code\u003e 的数据来看看。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|\n00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n\n0x00c0  -\u003e 192 个 i 节点\n0x0200  -\u003e 512 个逻辑块\n0x0001  -\u003e 一个i节点位图\n0x0001  -\u003e 一个逻辑块位图\n0x000a  -\u003e 第一个数据块编号为 10 \n0x0000  -\u003e log2(磁盘块大小 / 逻辑块大小) = 0 ，即磁盘块大小 = 逻辑块大小 = 1024 B\n0x10081c00 -\u003e 单文件最大 268966912 B \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003einode 位图\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003einode 位图的数据比较简单，是通过设置比特位 0、1 的方式，来直接表明相应编号的 i 节点是否存在。\n默认 i 节点从 1 号开始编号，0 号节点在 inode 位图上一定设置为 1 \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|\n00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e总共 192 个 i 节点，加上 0 号节点总计需占用 193 位 ( = 193 / 8 = 24 字节 + 1 位)\u003c/p\u003e\n\u003cp\u003e其余多余的位，全部置位为 1 。\u003c/p\u003e\n\u003cp\u003e位图存储的最初数据 0x07 (注意，小端存储法) = 0b111\u003c/p\u003e\n\u003cp\u003e由此，总共有1号和2号i节点。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e逻辑块位图\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e类似的，逻辑块位图是为了表明第n个逻辑块存储有数据，或处于空闲状态。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003einode 区块\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e参照前面讲过的字典目录的形式，inode 就是一种分级编排后的目录。\u003c/p\u003e\n\u003cp\u003e当然，说目录可能还会引发误解。这里无论是对于操作系统下的目录或是文件，每一个都对应着一个独特的 inode\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct d_inode {\n unsigned short i_mode;     /* 文件类型和属性 (rwx 位) */\n unsigned short i_uid;      /* 文件所有者 id */\n unsigned long i_size;      /* 文件大小 */\n unsigned long i_time;      /* 修改时间 */\n unsigned char i_gid;       /* 文件所在组 id */\n unsigned char i_nlinks;    /* 有多少个链接数 (有多少个文件目录项指向该 i 节点) */\n unsigned short i_zone[9];  /* 文件数据所占用数据盘的指针 */\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e每个i节点的数据分别 32 字节\u003c/p\u003e\n\u003cp\u003e同样的，结合 \u003ccode\u003edisk.img\u003c/code\u003e 的数据来看\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|\n00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|\n00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n\n0x41ed  -\u003e \n0x0000  -\u003e  文件所有者为 0 即 root\n0x00000060  -\u003e  文件大小为 96 B\n0x5bd40de5  -\u003e  文件最后修改时间为 Unix TimeStamp 1540623845 =\u003e 2018/10/27 15:4:5\n0x00    -\u003e  文件所在组 id\n0x02    -\u003e  有两个文件目录项指向1号i节点\n0x000a  -\u003e  1 号 i 节点指向的第0块数据为第10个逻辑块(即第1个数据块)\n0x0000  =\u003e  由于数据比较小，后面的 i_zone[1] ~ i_zone[8] 均为 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ei_zone 指向的是数据实际存储的数据块的位置。\u003c/p\u003e\n\u003cp\u003e但是，仅仅只有 9 个指针，每个数据块能存储 1024 B ，是远远达不到之前所描述的单文件 \u003ccode\u003e0x10081c00 = 268966912 B\u003c/code\u003e 的上限的。\u003c/p\u003e\n\u003cp\u003e事实上，minix 在实际处理的过程中，把前7个指针作为直接数据块指针，最多存储 7168 B 数据。\u003c/p\u003e\n\u003cp\u003ei_zone[7] 表示一次间接指针，指向某一个数据块，但是该数据块每2字节作为一个指针，指向真正的数据块。\u003c/p\u003e\n\u003cp\u003ei_zone[8] 表示二次间接指针。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fwnu3zrwuij310y0m6abj.jpg\"\u003e\nCopied from Linux 内核完全注释V3.0\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e数据块\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e最后，我们看看数据块的内容，也希望能够更好地来理解 Linux 目录和文件的异同。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|\n00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include \u0026#x3C;stdio.|\n00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h\u003e..............|\n00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在i节点区块上，我们看到有1号i节点和2号i节点已经被使用了。\u003c/p\u003e\n\u003cp\u003e0x2800 ~ 0x2860 的位置表示的就是 1 号i节点的数据。事实上这是一个目录(当然，怎么区分目录还是文件，在i节点区块的 i_mode 字段已经描述过了)\u003c/p\u003e\n\u003cp\u003e对于目录文件，当然是用来记载目录项的，每个目录项占用 32 字节。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这里需要进行说明，MINIX 1.0 版本的文件系统似乎是对每个目录项占用 16 字节的。\u003c/p\u003e\n\u003cp\u003e这里提供一个 Linux 0.11 版本的仿真运行结果以供证明\n\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fwnuexcwx7j30nw0c8745.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e上面描述的 \u003ccode\u003edisk.img\u003c/code\u003e 是在 Ubuntu 16.04 LTS 下跑出来的结果，所有确实出现了一些差别。\n至于具体的一个规范，目前还没有找到，所有这部分只能做模糊处理了，勿怪。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e前2个字节用来表示该目录项所对应的 i 节点编号。之后的30个字节用来描述该目录项的名字。\u003c/p\u003e\n\u003cp\u003e因此，对 0x2800 ~ 0x2860 的数据进行重建的结果就是 \u003ccode\u003e. .. hello.c\u003c/code\u003e 三个目录项了。其中，由于是根目录，\u003ccode\u003e.\u003c/code\u003e 和 \u003ccode\u003e..\u003c/code\u003e 所指向的i节点的相同的，都是1号i节点。\u003c/p\u003e\n\u003cp\u003e而 hello.c 文件指向的是 2 号i节点。\u003c/p\u003e\n\u003cp\u003e哈哈，2号i节点的数据内容就在 0x2c00 开始的位置。通过右侧的 ASCII 结果我们也可以看到。\u003c/p\u003e\n\u003cp\u003e当然，之前说过每个数据块是 1024 B ，那么数据块多余的部分，就是留空咯，而不会被其它i节点占用(除非该文件or目录被完全移除了)\u003c/p\u003e\n\u003ch2\u003e小结\u003c/h2\u003e\n\u003cp\u003e到此为止，文件系统宏观的描述就已经完结了。\u003c/p\u003e\n\u003cp\u003e下一节将对操作系统如何使用文件系统进行描述。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ ls\nApplications Network      Users        bin          data         etc          net          sbin         usr\nLibrary      System       Volumes      cores        dev          home         private      tmp          var\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?\u003c/p\u003e"},{"url":"2018-10-12-understand-Kernel-4","fileName":"2018-10-12-understand-Kernel-4.md","title":"理解 Linux Kernel (4) - 任务调度","author":"fangfeng","date":"2018-10-12T00:00:00.000Z","tags":["Kernel","Linux","time interrupt"],"content":"\u003cp\u003e前面几节已经描述过，对于单核 CPU 来说。CPU 就处于不断地执行指令的过程(或者通过 \u003ccode\u003ehlt\u003c/code\u003e 指令直接停止工作)。\u003c/p\u003e\n\u003cp\u003e针对于每一个程序来说，这个程序执行流程是通过 CPU 中几组寄存器(通用寄存器、段寄存器、控制寄存器等) 和存储在内存中的代码和数据协作完成的。\u003c/p\u003e\n\u003cp\u003e如果要达到单核多任务的目的，首先要做的就是完成对几组寄存器中当前值的保存(我称之为保存现场)。而对于内存来说，多个任务的代码、数据同时存在内存是完全合理且可行的。毕竟相较于有限的寄存器，内存实在是太大了(相对而言)。\u003c/p\u003e\n\u003ch2\u003e任务调度的宏观描述\u003c/h2\u003e\n\u003cp\u003e从宏观上来说，操作系统维护了若干个任务(假设有 0, 1, 5, 6)。\u003c/p\u003e\n\u003cp\u003e下面以一个假象的例子来对任务调度做一些形象的说明:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e假设当前任务是任务 5 ，操作系统分配给它的 CPU 使用时间是 30ms。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e每 10ms 计时器(Intel 8253, 可编程计数器/定时器) 向 CPU 发起一个时钟中断。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCPU 开始处理时钟中断(此时是\u003cstrong\u003e内核态\u003c/strong\u003e)。当前任务剩余可用时间 -10ms。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e检查当前任务的剩余时间片，有剩余 -\u003e 步骤 5 ; 否则 -\u003e 步骤 6 \u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e直接退出对时钟中断的处理函数(回到 \u003cstrong\u003e用户态\u003c/strong\u003e), 重复步骤 1 \u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e根据每个任务的优先级及其它一些因素确定把接下来的一段时间分配给哪个任务。(假设分配给任务 6 ，30ms 的 CPU 使用时间) -\u003e 重复步骤 2 。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e当然，上面的描述中忽略了很多的因素。\u003c/p\u003e\n\u003ch2\u003e任务调度准备阶段\u003c/h2\u003e\n\u003cp\u003e这里都将以 Linux 0.11 版本代码作为实例。当然，其中一些代码为了适应现在的 GCC 做了一些修改，另外还可能直接摆出 GCC 编译后的汇编代码来解释说明。\u003c/p\u003e\n\u003cp\u003e首先，内核代码在经过一系列的准备流程(包括设置一些寄存器以及在内存中暂存某些值，读取计算机的硬件配置等)。真正开始出现任务 0 始于下列这段代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* 来自 Linux0.11 init/main.c */\nvoid main(void) \n{\n    ...\n\n    sched_init();       /* schedule, 顾名思义就是时间安排咯 */\n    \n    ...\n    sti();\n    move_to_user_mode();\n    if (!fork()) {  \n        init();\n    }\n    for(;;) pause();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在操作系统的主函数中，开始对任务调度进行一定的准备工作。看看具体代码吧\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/* 这里给出的是 Linux0.11 kernel/sched.c 经过预编译的函数(里面有一些内联汇编) */\nvoid sched_init(void)\n{\n    int i;\n    struct desc_struct * p;    /* 声明一个描述符指针 */\n\n    if (sizeof(struct sigaction) != 16)\n        panic(\"Struct sigaction MUST be 16 bytes\");\n    __asm__ (                           /* 这段是为了设置全局描述符表GDT的第4项，是一个 0 号任务(当前任务)的任务调用门*/\n            \"movw $104,%1\\n\\t\" \n            \"movw %%ax,%2\\n\\t\" \n            \"rorl $16,%%eax\\n\\t\" \n            \"movb %%al,%3\\n\\t\" \n            \"movb $\" \"0x89\" \",%4\\n\\t\" \n            \"movb $0x00,%5\\n\\t\" \n            \"movb %%ah,%6\\n\\t\" \n            \"rorl $16,%%eax\" \n            ::\"a\" (\u0026#x26;(init_task.task.tss)), \"m\" (*(((char *) (gdt+4)))), \"m\" (*(((char *) (gdt+4))+2)), \"m\" (*(((char *) (gdt+4))+4)), \"m\" (*(((char *) (gdt+4))+5)), \"m\" (*(((char *) (gdt+4))+6)), \"m\" (*(((char *) (gdt+4))+7)) \n            );\n    __asm__ (                           /* 这里设置全局描述符表的第5项，0号任务的局部描述符表基址选择符 */\n            \"movw $104,%1\\n\\t\" \n            \"movw %%ax,%2\\n\\t\" \n            \"rorl $16,%%eax\\n\\t\" \n            \"movb %%al,%3\\n\\t\" \n            \"movb $\" \"0x82\" \",%4\\n\\t\" \n            \"movb $0x00,%5\\n\\t\" \n            \"movb %%ah,%6\\n\\t\" \n            \"rorl $16,%%eax\" \n            ::\"a\" (\u0026#x26;(init_task.task.ldt)), \"m\" (*(((char *) (gdt+(4 +1))))), \"m\" (*(((char *) (gdt+(4 +1)))+2)), \"m\" (*(((char *) (gdt+(4 +1)))+4)), \"m\" (*(((char *) (gdt+(4 +1)))+5)), \"m\" (*(((char *) (gdt+(4 +1)))+6)), \"m\" (*(((char *) (gdt+(4 +1)))+7)) \n            );\n    p = gdt+2+4;        /* 描述符指针指向 GDT 第6项。因为前面已经占用了第4，5项。由内核占用了 0，1，2，3。*/\n    for(i=1;i\u0026#x3C;64;i++) {         /* 循环 63 次，这是 Linux0.11 最大支持 64 个任务同时存在。当前任务已经占了一个任务了*/\n        task[i] = ((void *) 0); /* 63个任务指针全部值为 NULL */\n        p-\u003ea=p-\u003eb=0;            /* GDT 累积 126 项(126 * 8 字节)全部置为 0 。每个任务占用 GDT 两项，一为任务门，一为局部描述符表选择符*/\n        p++;\n        p-\u003ea=p-\u003eb=0;\n        p++;\n    }\n\n    __asm__(\"pushfl ; andl $0xffffbfff,(%esp) ; popfl\");\n    __asm__(\"ltr %%ax\"::\"a\" (((((unsigned long) 0)\u0026#x3C;\u0026#x3C;4)+(4\u0026#x3C;\u0026#x3C;3))));           /* load Task Register TR 记录当前任务门为 gdt 第4项 */\n    __asm__(\"lldt %%ax\"::\"a\" (((((unsigned long) 0)\u0026#x3C;\u0026#x3C;4)+((4 +1)\u0026#x3C;\u0026#x3C;3))));     /* load Local Descriptor Table Register LDTR 记录当前选择符为 gdt 第5项 */\n    /* 给8253芯片编程，每 10ms 发起一次时钟中断(下面3行的工作) */\n    __asm__ (\"outb %%al,%%dx\\n\" \"\\tjmp 1f\\n\" \"1:\\tjmp 1f\\n\" \"1:\"::\"a\" (0x36),\"d\" (0x43));   \n    __asm__ (\"outb %%al,%%dx\\n\" \"\\tjmp 1f\\n\" \"1:\\tjmp 1f\\n\" \"1:\"::\"a\" ((1193180/100) \u0026#x26; 0xff),\"d\" (0x40));\n    __asm__ (\"outb %%al,%%dx\"::\"a\" ((1193180/100) \u003e\u003e 8),\"d\" (0x40));\n    __asm__ (\"movw %%dx,%%ax\\n\\t\" \"movw %0,%%dx\\n\\t\" \"movl %%eax,%1\\n\\t\" \"movl %%edx,%2\" : : \"i\" ((short) (0x8000+(0\u0026#x3C;\u0026#x3C;13)+(14\u0026#x3C;\u0026#x3C;8))), \"o\" (*((char *) (\u0026#x26;idt[0x20]))), \"o\" (*(4+(char *) (\u0026#x26;idt[0x20]))), \"d\" ((char *) (\u0026#x26;timer_interrupt)),\"a\" (0x00080000)); /* 在 IDT 中设置时钟中断描述符项，第32项为时钟中断*/\n    __asm__ (\"outb %%al,%%dx\"::\"a\" (({ unsigned char _v; __asm__ volatile (\"inb %%dx,%%al\\n\" \"\\tjmp 1f\\n\" \"1:\\tjmp 1f\\n\" \"1:\":\"=a\" (_v):\"d\" (0x21)); _v; })\u0026#x26;~0x01),\"d\" (0x21)); /*重新设置时钟中断的可屏蔽属性，这样就可在调用 hlt 后被时钟中断唤醒 */\n    __asm__ (\"movw %%dx,%%ax\\n\\t\" \"movw %0,%%dx\\n\\t\" \"movl %%eax,%1\\n\\t\" \"movl %%edx,%2\" : : \"i\" ((short) (0x8000+(3\u0026#x3C;\u0026#x3C;13)+(15\u0026#x3C;\u0026#x3C;8))), \"o\" (*((char *) (\u0026#x26;idt[0x80]))), \"o\" (*(4+(char *) (\u0026#x26;idt[0x80]))), \"d\" ((char *) (\u0026#x26;system_call)),\"a\" (0x00080000)); /* 在 IDT 中设置系统中断，第128项为时钟中断 */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过执行 \u003ccode\u003esched_init()\u003c/code\u003e ，操作系统开始有了任务的概念。并且把当前任务作为任务 0 来加以认识。\u003c/p\u003e\n\u003cp\u003e同时，预置了 64 个任务状态数组，用来辅助任务调度器完成未来调度任务时确认目前所有任务的基础性支持。\u003c/p\u003e\n\u003cp\u003e最重要的，当然是对 8253 芯片的编程，使其每 10ms 向 CPU 发起一个硬件时钟中断。由此将把系统暂时性的带入\u003cstrong\u003e内核态\u003c/strong\u003e 来完成 CPU 下一个 10ms 需要进行的任务的决策工作。\u003c/p\u003e\n\u003cp\u003e最后的设置时钟中断描述符和系统中断描述符自不用说。不设置的话，对于接收到的中断根本就没办法确认处理中断的代码在哪(毕竟中断处理逻辑也是由 CPU 执行指令来解决的)\u003c/p\u003e\n\u003ch2\u003e任务调度实施阶段\u003c/h2\u003e\n\u003cp\u003e由于时钟中断是由硬件芯片进行控制，根本不会顾及当前 CPU 正在执行的任务已经执行到了哪个指令 (哈哈，这不得是当然的嘛，不然要任务调度做什么，所有任务流水线作业得了)。\u003c/p\u003e\n\u003cp\u003e因此，下面的描述将借着一次时钟中断，来看一下整一个任务调度操作。\u003c/p\u003e\n\u003ch3\u003e定位时钟中断处理逻辑\u003c/h3\u003e\n\u003cp\u003eIntel 8253芯片发起时钟中断之后，CPU 立即开始处理该中断\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e通过 IDTR 芯片查找中断描述符表(IDT, 最多256项，每项8字节) 的基址。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e结合中断号作为偏移量，定位表中某一项具体的中断描述符 (时钟中断是0x20，因此偏移就是 0x20 * 8 = 256)\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fw51zkvo2nj313q0mm3z3.jpg\"\u003e\nCopied from Intel® 64 and IA-32 Architectures Software Developer’s Manual\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e每一个中断描述符项都将是任务门，中断门，陷阱门三类中的一类，其所占用的 8 字节数据将按如下的形式进行存储\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fw527o8903j314614ita0.jpg\"\u003e\nCopied from Intel® 64 and IA-32 Architectures Software Developer’s Manual\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e时钟中断是一种中断门，可以看到低 0~15 位和高 48~63 位共同组成了段内偏移量，而低16~31位组成了一个段选择符(可以去 GDT 找到相应的段)。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fw52a4jbe0j31440zeq3j.jpg\"\u003e\nCopied from Intel® 64 and IA-32 Architectures Software Developer’s Manual\u003c/p\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e至此，我们就可以定位到处理时钟中断的代码究竟在呢。之后也就是普通的 CPU 继续执行指令的过程(当然，需要注意，这个时候需要注意当前段选择符所表示的 DPL=0 ，即已经进入了内核态)\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e模板式的保存现场 timer_interrupt\u003c/h3\u003e\n\u003cp\u003e在上一小节第 5 步定位时钟中断的代码时，由于发生了特权级的切换，因此中断处理流程会自动地在新的栈(这里指处理时钟中断使用的内核栈)中保存原来任务的信息，依次入新栈的数据有原任务的 SS, ESP, EFLAGS, CS, EIP, (Error Code) 。\u003c/p\u003e\n\u003cp\u003e然后将正式进入到 IDT 定位的时钟中断处理逻辑的开始位置 (当然了，到这里也还是在保存现场。毕竟还有好多寄存器的数据要保存的)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e.align 4\n_timer_interrupt:\n    push %ds        # save ds,es and put kernel data space\n    push %es        # into them. %fs is used by _system_call\n    push %fs\n    pushl %edx      # we save %eax,%ecx,%edx as gcc doesn't\n    pushl %ecx      # save those across function calls. %ebx\n    pushl %ebx      # is saved as we use that in ret_sys_call\n    pushl %eax\n    movl $0x10,%eax # 0x10 是内核数据段选择符，即 GDT 第二项\n    mov %ax,%ds\n    mov %ax,%es\n    movl $0x17,%eax # 0x17 是当前任务数据段选择符，LDT 第二项 (区分选择符是使用 GDT or LDT ，看 val \u0026#x26; 0x4 的结果，如果为 1 使用 LDT，否则 GDT\n    mov %ax,%fs\n    incl _jiffies   # 反正每次时钟中断 +1 ，想不到合适的中文翻译\n    movb $0x20,%al      # EOI to interrupt controller #1 发送指令请求硬件结束这次时钟中断的报告\n    outb %al,$0x20\n    movl CS(%esp),%eax  # 这个 CS 是个常量，取出内核栈暂存的原来正在执行的任务的代码段选择符\n    andl $3,%eax        # %eax is CPL (0 or 3, 0=supervisor)    判断一下在中断开始前代码的特权级 0 是内核态，3 是用户态\n    pushl %eax\n    call _do_timer      # 调用 do_timer(long CPL) 。真正的处理时钟中断\n    addl $4,%esp        # task switching to accounting ...\n    jmp ret_from_sys_call\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e任务调度 do_timer\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid do_timer(long cpl)     /* 这个 cpl 是上一小节获取的原任务正在执行的指令的特权级 */\n{\n    extern int beepcount;       /* 扬声器发声计数 */\n    extern void sysbeepstop(void);  /* 关闭扬声器的函数声明 */\n\n    if (beepcount)              /* 这段逻辑作用很不清晰，可能是富有年代感的产物 */\n        if (!--beepcount)\n            sysbeepstop();\n\n    if (cpl)                    /* 判断特权级 然后给当前任务的用户态/内核态用时计数 */\n        current-\u003eutime++;\n    else\n        current-\u003estime++;\n\n    /* 这段逻辑是给操作系统定时任务用的，用兴趣的欢迎自己学习 */\n    if (next_timer) {\n        next_timer-\u003ejiffies--;\n        while (next_timer \u0026#x26;\u0026#x26; next_timer-\u003ejiffies \u0026#x3C;= 0) {\n            void (*fn)(void);\n\n            fn = next_timer-\u003efn;\n            next_timer-\u003efn = ((void *) 0);\n            next_timer = next_timer-\u003enext;\n            (fn)();\n        }\n    }\n    if (current_DOR \u0026#x26; 0xf0)\n        do_floppy_timer();\n    if ((--current-\u003ecounter)\u003e0) return;     /* 分配给当前任务的时间片 -1 。如果不为0，那么直接退出时钟中断，让任务继续执行 */\n    current-\u003ecounter=0;     /* 否则，当前任务的时间片记为 0 */\n    if (!cpl) return;       /* 如果当前任务正处于内核态(比如用户程序中使用了一些系统调用)，那么先让这个任务继续执行，避免任务切换引起的麻烦 */\n    schedule();             /* 任务调用，决定下一个时间片的主人 */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e任务调度 schedule()\u003c/h3\u003e\n\u003cp\u003eschedule() 就开始对 CPU 之后要把时间片分配给哪个任务做一次决策了。\u003c/p\u003e\n\u003cp\u003e但是，在开始之前，我们有必要先了解一下结构体 task_struct \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct task_struct {\n    long state; /* -1 unrunnable, 0 runnable, \u003e0 stopped */\n    long counter;\n    long priority;\n    long signal;\n    struct sigaction sigaction[32];\n    long blocked;   /* bitmap of masked signals */\n/* various fields */\n    int exit_code;\n    unsigned long start_code,end_code,end_data,brk,start_stack;\n    long pid,father,pgrp,session,leader;\n    unsigned short uid,euid,suid;\n    unsigned short gid,egid,sgid;\n    long alarm;\n    long utime,stime,cutime,cstime,start_time;\n    unsigned short used_math;\n/* file system info */\n    int tty;        /* -1 if no tty, so it must be signed */\n    unsigned short umask;\n    struct m_inode * pwd;\n    struct m_inode * root;\n    struct m_inode * executable;\n    unsigned long close_on_exec;\n    struct file * filp[NR_OPEN];\n/* ldt for this task 0 - zero 1 - cs 2 - ds\u0026#x26;ss */\n    struct desc_struct ldt[3];\n/* tss for this task */\n    struct tss_struct tss;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e匆匆一瞥，不过是不是觉得有些变量名还是很熟悉的，比如说 priority, utime, uid, eid, gid 等等。\n但是暂时还用不上这么多。只要有个概念就好。操作系统通过上述这些值共同维护起了一个任务的方方面面的信息。\u003c/p\u003e\n\u003cp\u003e其中，需要再次注意的是，Linux0.11 版本最多只支持 64 个任务 (这是硬编码决定的上限，因为这个 task_struct 结构实例只声明了 64 个)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e/*\n *  'schedule()' is the scheduler function. This is GOOD CODE! There\n * probably won't be any reason to change this, as it should work well\n * in all circumstances (ie gives IO-bound processes good response etc).\n * The one thing you might take a look at is the signal-handler code here.\n *\n *   NOTE!!  Task 0 is the 'idle' task, which gets called when no other\n * tasks can run. It can not be killed, and it cannot sleep. The 'state'\n * information in task[0] is never used.\n */\nvoid schedule(void)\n{\n    int i,next,c;\n    struct task_struct ** p;\n\n/* check alarm, wake up any interruptible tasks that have got a signal */\n/* 检测 alarm (任务定时报警信号)，并唤醒可中断的任务来完成预定义的工作, 好像自己用得少，还不太了解 alarm(xxx) 的细节\n * 从任务 63 号开始(总共 64 个任务, 0~63) ，倒着遍历所有任务，检测 alarm \n */\n    for(p = \u0026#x26;LAST_TASK ; p \u003e \u0026#x26;FIRST_TASK ; --p)\n        if (*p) {\n            if ((*p)-\u003ealarm \u0026#x26;\u0026#x26; (*p)-\u003ealarm \u0026#x3C; jiffies) {\n                    (*p)-\u003esignal |= (1\u0026#x3C;\u0026#x3C;(SIGALRM-1));\n                    (*p)-\u003ealarm = 0;\n                }\n            if (((*p)-\u003esignal \u0026#x26; ~(_BLOCKABLE \u0026#x26; (*p)-\u003eblocked)) \u0026#x26;\u0026#x26;\n            (*p)-\u003estate==TASK_INTERRUPTIBLE)\n                (*p)-\u003estate=TASK_RUNNING;\n        }\n\n/* this is the scheduler proper: */\n\n    while (1) {\n        c = -1;\n        next = 0;\n        i = NR_TASKS;   /* 这里的宏 NR_TASKS = 64 */\n        p = \u0026#x26;task[NR_TASKS];\n        while (--i) {\n            if (!*--p)\n                continue;\n            /* 选择任务状态为 就绪态，且 counter 值最大的任务号作为下一个占用 CPU 的任务\n            if ((*p)-\u003estate == TASK_RUNNING \u0026#x26;\u0026#x26; (*p)-\u003ecounter \u003e c) \n                c = (*p)-\u003ecounter, next = i;\n        }\n        /* 如果没有其它任务，那么 next = 0 ，即接下来占用 cpu 的任务就是 0号任务(0号任务一定存在，不能被 kill ) */\n        if (c) break;\n        /* 如果 1~63 号任务(不存在或不在就绪态)至少存在一个任务，且时间片都为 0 ，那么重新计算分配给每个任务的 counter 值 */\n        for(p = \u0026#x26;LAST_TASK ; p \u003e \u0026#x26;FIRST_TASK ; --p)\n            if (*p)\n                (*p)-\u003ecounter = ((*p)-\u003ecounter \u003e\u003e 1) + (*p)-\u003epriority;\n    }\n    /* 将当前任务切换为 next ，然后就可以一切就绪，退出时钟中断，就变成新的占用cpu的任务来执行了 */\n    switch_to(next);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eswitch_to(next)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eswitch_to(next) 这个函数，是通过内嵌汇编写的。下面我们来看看细节(这里选用 GCC 编译出来的汇编指令，不直接使用内嵌汇编)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e# 这里的汇编指令紧跟在 if(c) break; 之后\n.L36:\n    movl    %ebx, %edx          # 这里 ebx 存储的是 next 变量的值，现在复制到 edx 上\n    sall    $4, %edx            # sall、addl 两行的目的是计算得到一个 TSS 选择符，TSS0 在 GDT 是第4项，TSS1 在 GDT 是第 6 项，类推...其中选择符后3位为DPL和 GDTR/LDTR 选项\n    addl    $32, %edx\n    movl    _task(,%ebx,4), %ecx    # 找到 next 号任务的 task_struct 的指针 (存储在 task[64] 的数组中)\n#APP\n# 141 \"sched.c\" 1\n    cmpl %ecx,_current          # 确认是不是原任务\n    je 1f                       # 是的话直接跳出 (跳到最近的标签 1 )\n    movw %dx,8(%esp)\n    xchgl %ecx,_current         # 交换 ecx 和 _current 存储的值\n    ljmp 4(%esp)                # 通过间接跳转完成任务切换。通用的形式是 jmp CS:IP，但是使用间接跳转，在内存中的值先读取 32 位偏移量，再读 16 位段选择符\n    cmpl %ecx,_last_task_used_math\n    jne 1f\n    clts                        # 清除 CR0 寄存器中的 TS Flag \n1:\n# 0 \"\" 2\n#NO_AP\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面这段程序有必要将它割裂成两部分来看待，以 \u003ccode\u003eljmp 4(%esp)\u003c/code\u003e 为界。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ejmp\u003c/code\u003e ，这是一个相当明显的程序跳转。这里 jmp 给出的选择符是 GDT 上某个任务的 TSS 描述符\u003c/p\u003e\n\u003cp\u003e通过 \u003ccode\u003ejmp\u003c/code\u003e CPU 将完成老的任务所有寄存器的保存现场，以及新的任务所有寄存器暂存结果的载入。\u003c/p\u003e\n\u003cp\u003eCPU 执行的下一条指令，将是新的任务 CS:EIP 所指明的指令。\u003c/p\u003e\n\u003cp\u003e相应的，\u003ccode\u003eljmp\u003c/code\u003e 之后的指令将在该任务重新获得占用 CPU 后获得执行。\u003c/p\u003e\n\u003ch2\u003e任务调度的结束阶段\u003c/h2\u003e\n\u003cp\u003e这段就比较绕了，现在假设一个前提，就是任务 A 也是在时钟中断重新进行任务调度的时候被替换掉的，现在 CPU 分配的时间片又轮到了任务 A 。\u003c/p\u003e\n\u003cp\u003e也就是紧随着上一小节 \u003ccode\u003eljmp\u003c/code\u003e 看看从任务内核态回到用户态的流程。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e    # 这段与上面一段指令是直接承接的\n    movl    12(%esp), %eax\n    xorl    %gs:20, %eax\n    je  .L40\n    call    ___stack_chk_fail\n.L40:\n    addl    $24, %esp           # 这里返还这次 call 额外申请的内核栈空间\n    .cfi_def_cfa_offset 8\n    popl    %ebx                # 恢复进入 call 的时候暂存的 ebx\n    .cfi_restore 3\n    .cfi_def_cfa_offset 4\n    ret                         # return 跳转回到当初调用的地方\n    .cfi_endproc\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e还是从汇编指令来看\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e    call    _schedule           # 原先调用 schedule() 的地方\n.L93:\n    # return 跳转回来，直接承接的指令\n    addl    $8, %esp\n    .cfi_def_cfa_offset 8\n    popl    %ebx\n    .cfi_restore 3\n    .cfi_def_cfa_offset 4\n    ret                         # 继续 return ，跳出 do_timer() \n    .cfi_endproc\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e    call _do_timer      # 'do_timer(long CPL)' does everything from\n    addl $4,%esp        # task switching to accounting ...\n    jmp ret_from_sys_call\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eret_from_sys_call\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这里就打算正式结束由于这次时钟中断所引发的内核态指令执行的流程，正式回归用户态了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003eret_from_sys_call:\n    # 这 3 行来判断是不是任务0，如果是就不进行信号量的处理了\n    movl _current,%eax      # task[0] cannot have signals\n    cmpl _task,%eax\n    je 3f\n    # 判断在发生时钟中断前，CS 表示的是不是 LDT 第 1 项 (局部变量表的代码段)\n    # 否则 CS 就应该内核态代码段了，不进行信号量处理\n    cmpw $0x0f,CS(%esp)     # was old code segment supervisor ?\n    jne 3f\n    # 判断在发生时钟中断前，SS 表示的是不是 LDT 第 2 项 (局部变量表的数据段)\n    # 否则认为程序还处在内核态，不进行信号量处理\n    cmpw $0x17,OLDSS(%esp)      # was stack segment = 0x17 ?\n    jne 3f\n    # 设置信号量 (不清楚，先挖个坑)\n    movl signal(%eax),%ebx\n    movl blocked(%eax),%ecx\n    notl %ecx\n    andl %ebx,%ecx\n    bsfl %ecx,%ecx\n    je 3f\n    btrl %ecx,%ebx\n    movl %ebx,signal(%eax)\n    incl %ecx\n    pushl %ecx\n    call _do_signal\n    popl %eax\n3:  popl %eax\n    popl %ebx\n    popl %ecx\n    popl %edx\n    pop %fs\n    pop %es\n    pop %ds\n    iret\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至此，通过 iret 将跳转回到用户态代码被中断的位置，并继续执行\u003c/p\u003e\n\u003ch2\u003e补充\u003c/h2\u003e\n\u003ch3\u003epause()\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://dormouse-none.github.io/2018-10-06-understand-Kernel-3/\"\u003eLinux Kernel(3) - 操作系统启动\u003c/a\u003e 中，描述过任务0在完成了整个操作系统的启动流程之后，唯一在做的事情，就是调用 \u003ccode\u003efor(;;) pause();\u003c/code\u003e \u003c/p\u003e\n\u003cp\u003eCPU 每次把时间片分配给它，它就开始浪费权力，直接不要了这个时间片。\u003c/p\u003e\n\u003cp\u003e之前一直以为 pause() 会选择执行 \u003ccode\u003eHLT\u003c/code\u003e 指令让 CPU 暂时地陷入停止状态。但是出乎意料，并不是这个结果(当然，最终是不是还是另一个说法。毕竟代码都是人写的，每个人都可以各自有一套实现)。\u003c/p\u003e\n\u003cp\u003e当 CPU 把执行指令的权力交个任务 0 时，选择让 CPU 停止，直到接收到硬件中断为止也不失为一种选择。当然，不论其它，Linux0.11版本的代码不是这样的。\u003c/p\u003e\n\u003cp\u003e通过 \u003ccode\u003eINT 0x80\u003c/code\u003e 配合系统调用函数查表，最后定位到的就是 sys_pause() 了\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e_sys_pause:\n.LFB13:\n    .cfi_startproc\n    subl    $12, %esp\n    .cfi_def_cfa_offset 16\n    movl    _current, %eax\n    movl    $1, (%eax)\n    call    _schedule       # 调用 schedule() 重新划分时间片\n    movl    $0, %eax\n    addl    $12, %esp\n    .cfi_def_cfa_offset 4\n    ret\n    .cfi_endproc\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003etimer 定时器\u003c/h3\u003e\n\u003cp\u003e之前在 \u003ccode\u003edo_timer()\u003c/code\u003e 函数中也看过了每次时钟中断，都会检查一遍定时器，并决定是否触发预置的定时器处理函数。\u003c/p\u003e\n\u003cp\u003e当然了，既然是触发定时器，总是要有一个前提——设置定时器\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid add_timer(long jiffies, void (*fn)(void))\n{\n    struct timer_list * p;\n\n    if (!fn)\n        return;\n    cli();\n    if (jiffies \u0026#x3C;= 0)\n        (fn)();\n    else {\n        for (p = timer_list ; p \u0026#x3C; timer_list + TIME_REQUESTS ; p++)\n            if (!p-\u003efn)\n                break;\n        if (p \u003e= timer_list + TIME_REQUESTS)\n            panic(\"No more time requests free\");\n        p-\u003efn = fn;\n        p-\u003ejiffies = jiffies;\n        p-\u003enext = next_timer;\n        next_timer = p;\n        while (p-\u003enext \u0026#x26;\u0026#x26; p-\u003enext-\u003ejiffies \u0026#x3C; p-\u003ejiffies) {\n            p-\u003ejiffies -= p-\u003enext-\u003ejiffies;\n            fn = p-\u003efn;\n            p-\u003efn = p-\u003enext-\u003efn;\n            p-\u003enext-\u003efn = fn;\n            jiffies = p-\u003ejiffies;\n            p-\u003ejiffies = p-\u003enext-\u003ejiffies;\n            p-\u003enext-\u003ejiffies = jiffies;\n            p = p-\u003enext;\n        }\n    }\n    sti();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e小结\u003c/h2\u003e\n\u003cp\u003e对于任务调度，更难的是对一个时间断层的理解。在调度过程中，旧任务被暂停，新的任务被重新启动, 直到旧的任务又被启动。这里就必须人为地将被中断的任务主动的连接起来看待。\u003c/p\u003e\n\u003cp\u003e早期版本的任务调度模块确实比较简单，累计不过百行 C 代码。哈哈。一点一点继续来吧。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e前面几节已经描述过，对于单核 CPU 来说。CPU 就处于不断地执行指令的过程(或者通过 \u003ccode\u003ehlt\u003c/code\u003e 指令直接停止工作)。\u003c/p\u003e\n\u003cp\u003e针对于每一个程序来说，这个程序执行流程是通过 CPU 中几组寄存器(通用寄存器、段寄存器、控制寄存器等) 和存储在内存中的代码和数据协作完成的。\u003c/p\u003e\n\u003cp\u003e如果要达到单核多任务的目的，首先要做的就是完成对几组寄存器中当前值的保存(我称之为保存现场)。而对于内存来说，多个任务的代码、数据同时存在内存是完全合理且可行的。毕竟相较于有限的寄存器，内存实在是太大了(相对而言)。\u003c/p\u003e"},{"url":"2018-10-06-understand-Kernel-3","fileName":"2018-10-06-understand-Kernel-3.md","title":"理解 Linux Kernel (3) - 操作系统启动","author":"fangfeng","date":"2018-10-06T00:00:00.000Z","tags":["Kernel","Linux","OS"],"content":"\u003cp\u003e这次拖得有够久的，毕竟需要将知识串联起来并不是一件容易的事情。更何况很多内容可以说和常理(个人理解的常理)有了比较大的偏差。\u003c/p\u003e\n\u003cp\u003e不过确实比较有意思。从引导程序到操作系统启动，这中间究竟经历了多少流程呢？\u003c/p\u003e\n\u003cp\u003e由于有了前几节的内容，这里不会再对引导程序及汇编语法做过多的介绍。而着重在于整个流程的描述。\u003c/p\u003e\n\u003ch2\u003e引导程序\u003c/h2\u003e\n\u003cp\u003e从 BIOS 将512字节长的引导程序加载到物理内存\u003ccode\u003e0x7c00\u003c/code\u003e开始的连续递增空间后，即将程序的执行权交给了引导程序(这里指的执行权可以简单理解成CS:IP)\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eCS:IP\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCS\u003c/strong\u003e. 代码段基址。一般用于划定一段连续代码开始的地址。是一个16位段寄存器，类似的还有 DS, ES, FS, GS, SS 等16位段寄存器，分别提供不同的段基址存储功能)\n\u003cstrong\u003eIP\u003c/strong\u003e. 代码段偏移值。配合 CS 共同为 CPU 确定下一个将要被执行的机器指令的线性地址。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eLinux 0.11 版本的引导程序实现的支持比较简单。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将引导程序代码(自身) 512 字节的内容移动到 \u003ccode\u003e0x90000\u003c/code\u003e 开始的 512B 内存空间上\u003c/li\u003e\n\u003cli\u003e跳到 \u003ccode\u003e0x90000\u003c/code\u003e 开始的段的相应位置继续执行\u003c/li\u003e\n\u003cli\u003e从磁盘中读取 4*512 字节的 setup 程序的二进制内容\u003c/li\u003e\n\u003cli\u003e读取操作系统的二进制内容到内存 \u003ccode\u003e0x10000\u003c/code\u003e 开始的连续地址空间中 (此处最大可以有 0x90000 - 0x10000 = 0x80000 = 512 KB，即当时的操作系统二进制程序+数据最大只能是 512KB, 不过也很多了)\u003c/li\u003e\n\u003cli\u003e确认将要作为文件系统的磁盘是否存在\u003c/li\u003e\n\u003cli\u003e将控制权交给 setup 程序\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eSETUP 程序\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e读取硬件配置\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003esetup 程序，顾名思义，就是在搞一些配置。那么究竟在配置什么？\u003c/p\u003e\n\u003cp\u003e就是通过 BIOS 中断读取各种硬件信息(诸如内存大小，显示器长宽比，磁盘等)，并将它们存储在内存的指定位置。\u003c/p\u003e\n\u003cp\u003e哈哈，由于引导程序已经执行完了，再也不会使用了。因此，setup 程序就是将这些信息存储到了原引导程序所在的位置，即 0x90000 ~ 0x901FF 共 512 B 的内存中。\u003c/p\u003e\n\u003cp\u003e当然，每个字节存的是什么内容都是一种约定(比如 setup 程序把内存大小的信息存到了哪，后面其它程序就到相应的位置去取)。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e移动操作系统程序\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eOK，setup 程序也不是仅仅只干这么点事情的，不然要 4*512 字节岂不是太浪费了，哪用得了这么多。\u003c/p\u003e\n\u003cp\u003esetup 还要负责将操作系统程序移动到\u003cem\u003e方便\u003c/em\u003e的位置。前面将操作系统程序加载到了内存 0x10000 处，主要是为了暂时保持 BIOS 中断向量表 (位于 0x0000 开始的连续 1024 B 内存中，由 BIOS 程序创建，用于各种中断调用) 。在 setup 决定不再使用 BIOS 中断之后，就已经可以完全废弃了。\u003c/p\u003e\n\u003cp\u003e因此，操作系统程序将从 0x10000 顺次移动到 0x00000 的位置。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e重置中断\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e软中断与硬中断，应该是在软硬件划分下唯二的两种中断形式。软中断一般通过汇编指令 \u003ccode\u003eINT {中断号}\u003c/code\u003e 的形式通过软件执行的形式产生，而硬中断是硬件由于某些错误指令而自动产生的中断。\u003c/p\u003e\n\u003cp\u003e当然，这些中断都需要 CPU 进行相应的处理。那么，在 BIOS  中断向量表被覆盖了之后，如何来处理这些中断呢？\u003c/p\u003e\n\u003cp\u003e首先，在上一步 \u003cstrong\u003e移动操作系统程序\u003c/strong\u003e 开始时，就直接通过汇编指令 \u003ccode\u003ecli\u003c/code\u003e 强制禁止除 \u003cem\u003e非可屏蔽中断\u003c/em\u003e 外的所有中断，因此也就基本不考虑中断的问题。\u003c/p\u003e\n\u003cp\u003e但是，总还得解除禁止吧。因此，setup 程序尽快地重新编制了硬件中断，进入保护模式。使用保护模式下的中断描述符表来替代 BIOS 中断向量表。\u003c/p\u003e\n\u003cp\u003e至于如何创建中断描述符表，哈哈，这都是直接在汇编编程的时候写好的。直接划出了一块区域写上了中断描述符表的表项，然后与 setup 代码一起被读取到了内存的指定位置。至于唯一要做的，就是将 IDTR (中断描述符表寄存器) 修改为中断描述符表在内存的开始地址。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e进入保护模式\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e首先，简单介绍一下实模式 \u0026#x26; 保护模式。\u003c/p\u003e\n\u003cp\u003e保护模式与实模式的主要区别，就在于两者的内存寻址方式，归根结底也就是段寄存器如何辅助完成内存地址定位的问题。\u003c/p\u003e\n\u003cp\u003e先简单的回顾下实模式下的寻址方式\u003c/p\u003e\n\u003cp\u003e段寄存器的出现，很大程度上是为了对 16 bit CPU 下可寻址地址不足所作出的补充。\n诸如 CS:IP = 0x07C0:0x0001 -\u003e 0x07C01 。通过CS:IP 的配合，物理地址 = CS \u0026#x3C;\u0026#x3C; 4 + IP ，将原本 128 KB 的可寻址空间扩展到 0xFFFF:0xFFFF -\u003e 0x10FFFE 的寻址空间\u003c/p\u003e\n\u003cp\u003e而保护模式的出现，也是由于实模式下的地址寻址仍然不能满足对内存寻址的需求。\u003c/p\u003e\n\u003cp\u003e那么保护模式究竟将如何进行寻址呢？简单来说就是通过新增了一个寄存器 GDTR (全局描述符表寄存器。当然，暂时不考虑 LDTR) 用来存储全局描述符表(全局描述符表是一些在内存中的有结构的数据) ，那么类似的，本来是段寄存器中是表示一个内存段基址，现在通过借助中间项 (GDTR) ，由全局描述符表的每一个表项来表示每一个内存段基址，从而达到在最大 4GB 的内存中进行内存地址的寻址。\u003c/p\u003e\n\u003cp\u003e而与上面的中断描述符表类似的，全局描述符表也是以同样的方式，预先写好，然后设置一下 GDTR 就 OK 了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e转入操作系统程序\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e最后的最后，当然是把控制权交给操作系统程序。即跳转到内存 0x00000 处。当然，由于现在已经处于保护模式下，因此 jmp 指令略有不同。 为 \u003ccode\u003ejmpi 0, 8\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e简单解释一下这一条指令 \u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ejmpi\u003c/code\u003e 指令表示进行段间跳转。(段间跳转与段内跳转的区别在于: 程序代码的寻址一般通过 CS:IP 配合完成，如果是段内跳转，则段基址不变，即 CS 不变，只需要给出 IP 即可；而段间跳转需要同时给出新的段基址(CS)和新的段偏移(IP)。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e0\u003c/code\u003e 这里 0 就表示的是段偏移。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e8\u003c/code\u003e 保护模式下的段寄存器以一种特殊的方式来配合 GDTR/LDTR 来完成对全局/局部描述符表项的定位。如下图所示。最后两位表示特权级，用于区分用户态(11) or 内核态(00) (Linux 只使用了两个，还有 01 和 10 不使用)\u003c/p\u003e\n\u003cp\u003e第三位表示使用 GDTR 还是 LDTR\u003c/p\u003e\n\u003cp\u003e高 13 位共同组成了对 GDTR/LDTR 表项的描述，究竟使用哪一个表项。当然，这里其实也侧面反映了，其实每个全局描述符表/局部描述符表最多只能有 \u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmsup\u003e\u003cmn\u003e2\u003c/mn\u003e\u003cmn\u003e13\u003c/mn\u003e\u003c/msup\u003e\u003cmo\u003e=\u003c/mo\u003e\u003cmn\u003e8192\u003c/mn\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003e2^{13} = 8192\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord\"\u003e2\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.8141079999999999em;\"\u003e\u003cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e\u003cspan class=\"mord mtight\"\u003e1\u003c/span\u003e\u003cspan class=\"mord mtight\"\u003e3\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e8\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003cspan class=\"mord\"\u003e9\u003c/span\u003e\u003cspan class=\"mord\"\u003e2\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e 个表项。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fulm7vumywj31220aw74f.jpg\"\u003e\u003c/p\u003e\n\u003ch2\u003e操作系统程序\u003c/h2\u003e\n\u003cp\u003e终于要到操作系统程序了。这个就比较复杂了。这里只简单描述将操作系统启动起来的最基本使用到的代码。其它以后继续。\u003c/p\u003e\n\u003cp\u003e其实整一个操作系统程序是一个比较大的量，毕竟最大能够达到 512 KB 呢。\u003c/p\u003e\n\u003cp\u003e简单的看一下文档树，见附录一，编译前的源代码文件总计 100 多个。\u003c/p\u003e\n\u003cp\u003e首先被执行的是 head.s 中的代码，这里完成的工作主要包括:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e重新编制每个中断的具体处理代码(这个应该比较好理解，说到底中断出现了，也还是要通过实现代码来完成中断逻辑。不论是 BIOS 中断向量还是保护模式下使用的中断描述符表，都不过是记录了一下中断处理代码的位置，进行了定位而已)。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e初始化分页模式(不详述，以后有机会在说)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e验证 80387 数学协处理器。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e进入 main.c 程序 (既然 Linus 都将其命名为 main 了，那么显然这是整个操作系统最核心的部分了)。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003emain.c\u003c/h3\u003e\n\u003cp\u003e下面将简单给出 main.c 程序的两段代码 \u003ccode\u003emain(...)\u003c/code\u003e 和 \u003ccode\u003einit(...)\u003c/code\u003e，并直接针对代码进行直接解释。\u003c/p\u003e\n\u003ch4\u003emain(void)\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid main(void)     \n{\n    ROOT_DEV = ORIG_ROOT_DEV;   // 读取在引导程序执行时获取到的文件系统所在的磁盘\n    drive_info = DRIVE_INFO;\n    memory_end = (1\u0026#x3C;\u0026#x3C;20) + (EXT_MEM_K\u0026#x3C;\u0026#x3C;10); // 首先先确认整个内存的大小\n    memory_end \u0026#x26;= 0xfffff000;               // 当然，这里为了分页方便 (每页 4096 B)，直接将不满一页的内存忽略掉了\n    if (memory_end \u003e 16*1024*1024)          // 最大支持 16 MB 的内存，这里是 Linus 当时的机器只有 16 MB，因此没有做更大内存的支持，但可以自己去改源码\n        memory_end = 16*1024*1024;\n    if (memory_end \u003e 12*1024*1024)          // 确认缓存区的末地址 (根据实际内存大小调整, \u003e12MB 留 4MB 缓存，\u003e6MB 留 2 MB 缓存，否则 1MB )\n        buffer_memory_end = 4*1024*1024;\n    else if (memory_end \u003e 6*1024*1024)\n        buffer_memory_end = 2*1024*1024;\n    else\n        buffer_memory_end = 1*1024*1024;\n    main_memory_start = buffer_memory_end;\n#ifdef RAMDISK\n    main_memory_start += rd_init(main_memory_start, RAMDISK*1024);      // 如果需要虚拟盘，则再留一部分作为交换区\n#endif\n    mem_init(main_memory_start,memory_end); // 内存初始化，毕竟 Linux 操作系统下的所有内存都将被统一分配，用户程序没有权限随便使用内存，只能用被分配的\n    trap_init();            // 初始化中断\n    blk_dev_init();         // 初始化块设备\n    chr_dev_init();         // 初始化字符设备\n    tty_init();             // 初始化 tty\n    time_init();            // 设置开机启动时间\n    sched_init();           // 初始化任务调度程序，由此就将可以进行多任务切换了\n    buffer_init(buffer_memory_end); // 缓存区初始化\n    hd_init();              // 硬盘初始化\n    floppy_init();          // 软盘初始化\n    sti();                  // 不再禁止中断，现在开始又允许中断了\n    move_to_user_mode();    // 进入用户态\n    if (!fork()) {          // 关于 fork 函数，下面将简单介绍。\n        init();\n    }\n\n    for(;;) pause();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003efork()\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e如果熟悉 C 语言，应该对 fork() 也比较熟悉吧。这将执行一次系统调用，最终的结果是，创建一个新的任务 (这里将原来的操作系统程序认为是 0 号进程/任务，将产生 1 号进程/任务)。新的任务与原有任务几乎一模一样，除了 fork() 调用的返回值不同。子任务将返回 0 ，原有任务将返回子任务的任务号。\u003c/p\u003e\n\u003cp\u003e因此，对于上面的代码，\u003ccode\u003eif(!fork())\u003c/code\u003e ，0号任务将不执行 \u003ccode\u003eif(){}\u003c/code\u003e 语句块内的 init ，而 1 号任务将执行 \u003ccode\u003einit()\u003c/code\u003e 函数\u003c/p\u003e\n\u003cp\u003e而 0 号进程在做什么呢? \u003c/p\u003e\n\u003cp\u003e很简单，下面 \u003ccode\u003efor(;;) pause();\u003c/code\u003e。 \u003ccode\u003epause()\u003c/code\u003e 是指让 CPU 完全停止，只有发生硬件中断， CPU 才会从停止状态中恢复 (前面已经设置了定时的/ 10ms/次的时钟中断，因此 CPU 总是能够恢复)， \u003c/p\u003e\n\u003cp\u003e具体的描述就是，如果任务调度程序把时间片分配给了 0 号进程，那么 0 号进程唯一做的，就是让 CPU 停止。而且 0 号进程的 \u003ccode\u003efor\u003c/code\u003e 是死循环，每次把时间分配给 0 号进程，它就 CPU 停止。我们在 Linux 操作系统上，通过 top 可以看到对 cpu 有如下描述\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中对 idle(id) 的统计，其实就在 0 号任务让 cpu 停止工作了而已。\u003c/p\u003e\n\u003ch4\u003einit(void)\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid init(void)\n{\n    int pid,i;\n\n    setup((void *) \u0026#x26;drive_info);\n    (void) open(\"/dev/tty0\",O_RDWR,0);\n    (void) dup(0);\n    (void) dup(0);\n    printf(\"%d buffers = %d bytes buffer space\\n\\r\",NR_BUFFERS,\n        NR_BUFFERS*BLOCK_SIZE);\n    printf(\"Free mem: %d bytes\\n\\r\",memory_end-main_memory_start);\n    if (!(pid=fork())) {\n        close(0);\n        if (open(\"/etc/rc\",O_RDONLY,0))\n            _exit(1);\n        execve(\"/bin/sh\",argv_rc,envp_rc);\n        _exit(2);\n    }\n    if (pid\u003e0)\n        while (pid != wait(\u0026#x26;i))\n            /* nothing */;\n    while (1) {\n        if ((pid=fork())\u0026#x3C;0) {\n            printf(\"Fork failed in init\\r\\n\");\n            continue;\n        }\n        if (!pid) {\n            close(0);close(1);close(2);\n            setsid();\n            (void) open(\"/dev/tty0\",O_RDWR,0);\n            (void) dup(0);\n            (void) dup(0);\n            _exit(execve(\"/bin/sh\",argv,envp));\n        }\n        while (1)\n            if (pid == wait(\u0026#x26;i))\n                break;\n        printf(\"\\n\\rchild %d died with code %04x\\n\\r\",pid,i);\n        sync();\n    }\n    _exit(0);   /* NOTE! _exit, not exit() */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e那么 1 号任务在做什么呢？看 init 的代码，可以看到大量诸如 \u003ccode\u003e/dev/tty0\u003c/code\u003e, \u003ccode\u003e/bin/sh\u003c/code\u003e 的代码。哈哈，下面通过 1,2,3... 对步骤进行标号简单描述一下。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e1 号进程在做的是 fork 出新的进程(暂时叫它进程 X )\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e1 号进程不断询问 X 是否被销毁 \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果 X 进程被销毁了：那么继续执行步骤 1\u003c/li\u003e\n\u003cli\u003e否则：继续执行步骤 2 （为什么会出现不断循环呢？其实由于任务调度程序的存在，在单个 CPU 看来，这个轮询并不一直发生，有一些时间片已经给了其他进程继续执行任务了\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eX 任务通过调用 \u003ccode\u003eexecve()\u003c/code\u003e 把当前程序的代码+数据全部替换成是 shell 的 (其实大量的用户程序都是通过这种 fork + execve 的形式出现的)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eX 任务(也就是 Shell 程序) 开始通过 tty 与用户开始交互。直到用户选择 \u003ccode\u003eexit\u003c/code\u003e 退出 shell \u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eexecve(...)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e前面介绍过 fork 是复制一份程序的各个寄存器的状态 + 程序的数据。现在 execve 做出的操作是直接将当前程序的代码和数据替换成目标程序的代码和数据，并通过对寄存器一定的重置，完成一个用户程序的启动流程(程序启动说到底不就是在内存中存在这个程序的代码，然后通过 CS:IP 定位到即将执行的程序指令，最后让 CPU 开始执行就 OK 了)\u003c/p\u003e\n\u003ch2\u003e小结\u003c/h2\u003e\n\u003cp\u003e整个操作系统的启动流程就简单地介绍到这里。\u003c/p\u003e\n\u003cp\u003e0 号任务作为操作系统的常驻程序，在 OS 启动完成，每次时间片被分配给它，它就让 CPU 停止工作(通过 pause() 系统调用)\u003c/p\u003e\n\u003cp\u003e1 号任务作为操作系统的常驻程序，唯一的任务就是判断进程X是否被退出，如果退出了，就重新创建一个(当然，也可能有人有疑问，为什么现在的 Linux 开多个 bash 都没有问题呢? 这里有个猜测是有一个隐藏的 shell 是被 1 号任务启动的，其它的 bash 是多余的。不过这只是猜测，待考察)\u003c/p\u003e\n\u003ch2\u003e附录\u003c/h2\u003e\n\u003ch3\u003e附录一\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e.\n|-- Makefile\n|-- boot\n|   |-- head.s\n|-- fs\n|   |-- Makefile\n|   |-- bitmap.c\n|   |-- block_dev.c\n|   |-- buffer.c\n|   |-- char_dev.c\n|   |-- exec.c\n|   |-- fcntl.c\n|   |-- file_dev.c\n|   |-- file_table.c\n|   |-- inode.c\n|   |-- ioctl.c\n|   |-- namei.c\n|   |-- open.c\n|   |-- pipe.c\n|   |-- read_write.c\n|   |-- stat.c\n|   |-- super.c\n|   `-- truncate.c\n|-- include\n|   |-- a.out.h\n|   |-- asm\n|   |   |-- io.h\n|   |   |-- memory.h\n|   |   |-- segment.h\n|   |   `-- system.h\n|   |-- const.h\n|   |-- ctype.h\n|   |-- errno.h\n|   |-- fcntl.h\n|   |-- linux\n|   |   |-- config.h\n|   |   |-- fdreg.h\n|   |   |-- fs.h\n|   |   |-- hdreg.h\n|   |   |-- head.h\n|   |   |-- kernel.h\n|   |   |-- mm.h\n|   |   |-- sched.h\n|   |   |-- sys.h\n|   |   `-- tty.h\n|   |-- signal.h\n|   |-- stdarg.h\n|   |-- stddef.h\n|   |-- string.h\n|   |-- sys\n|   |   |-- stat.h\n|   |   |-- times.h\n|   |   |-- types.h\n|   |   |-- utsname.h\n|   |   `-- wait.h\n|   |-- termios.h\n|   |-- time.h\n|   |-- unistd.h\n|   `-- utime.h\n|-- init\n|   |-- main.c\n|-- kernel\n|   |-- Makefile\n|   |-- asm.o\n|   |-- asm.s\n|   |-- blk_drv\n|   |   |-- Makefile\n|   |   |-- blk.h\n|   |   |-- floppy.c\n|   |   |-- hd.c\n|   |   |-- ll_rw_blk.c\n|   |   `-- ramdisk.c\n|   |-- chr_drv\n|   |   |-- Makefile\n|   |   |-- console.c\n|   |   |-- keyboard.S\n|   |   |-- rs_io.s\n|   |   |-- serial.c\n|   |   |-- tty_io.c\n|   |   `-- tty_ioctl.c\n|   |-- exit.c\n|   |-- fork.c\n|   |-- fork.i\n|   |-- math\n|   |   |-- Makefile\n|   |   `-- math_emulate.c\n|   |-- mktime.c\n|   |-- panic.c\n|   |-- printk.c\n|   |-- sched.c\n|   |-- sched.o\n|   |-- signal.c\n|   |-- sys.c\n|   |-- system_call.o\n|   |-- system_call.s\n|   |-- traps.c\n|   |-- traps.o\n|   `-- vsprintf.c\n|-- lib\n|   |-- Makefile\n|   |-- _exit.c\n|   |-- close.c\n|   |-- ctype.c\n|   |-- dup.c\n|   |-- errno.c\n|   |-- execve.c\n|   |-- malloc.c\n|   |-- open.c\n|   |-- setsid.c\n|   |-- string.c\n|   |-- wait.c\n|   `-- write.c\n|-- mm\n|   |-- Makefile\n|   |-- memory.c\n|   `-- page.s\n`-- tools\n    `-- build.c\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e这次拖得有够久的，毕竟需要将知识串联起来并不是一件容易的事情。更何况很多内容可以说和常理(个人理解的常理)有了比较大的偏差。\u003c/p\u003e\n\u003cp\u003e不过确实比较有意思。从引导程序到操作系统启动，这中间究竟经历了多少流程呢？\u003c/p\u003e\n\u003cp\u003e由于有了前几节的内容，这里不会再对引导程序及汇编语法做过多的介绍。而着重在于整个流程的描述。\u003c/p\u003e"},{"url":"2018-09-27-mail","fileName":"2018-09-27-mail.md","title":"Understand MAIL","author":"fangfeng","date":"2018-09-27T00:00:00.000Z","tags":["mail","SMTP","TCP"],"content":"\u003cp\u003e在网络协议上，高层协议确实比底层协议更容易理解，也更加的人性化。\n传输层的 TCP, UDP 都还停留在各种字节内容的整合和校验上，而更上层的应用层协议就已经能够直观到通过直接解读就能理解其每条消息的含义了。\u003c/p\u003e\n\u003ch2\u003eSMTP 协议\u003c/h2\u003e\n\u003cp\u003eSMTP，简单邮件传输协议。单从协议内容上来说确实没有太多的学习难度。但是，扭转“常识”恰恰是巨大的绊脚石。\n直接就进入了网页邮件系统 or 客户端邮件系统的时代。图形化的界面配合上一些关键字的内容 (比如收件人，主题等)。\n点击发送就觉得一封邮件已经发出去了。\u003c/p\u003e\n\u003cp\u003e但是，究竟这中间做了什么呢？\n163，GMAIL, QQ 等邮箱究竟又在其中扮演着怎样的一个角色？\u003c/p\u003e\n\u003cp\u003e首先，SMTP 是为了高效、可靠地传递邮件而存在的。\u003c/p\u003e\n\u003cp\u003e下面先给一段演示。通过 telnet 连接到 183.57.48.34 (这个是腾讯企业邮其中一台机器的 IP) 25 (SMTP 服务端口) ，以本机作为 SMTP 的客户端，而将 183.XXX 作为 SMTP 的服务端，来完成邮件信息的一次交互。 (当然，最后失败了。被企业邮识别为垃圾邮件了...)\u003c/p\u003e\n\u003cp\u003e下列每行 \u003ccode\u003e#\u003c/code\u003e 开始及之后的内容是个人添加的注释，其它内容是 telnet 交互的内容。\n同时，\u003ccode\u003e--\u003c/code\u003e 标志该行内容由\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ telnet 183.57.48.34 25\nTrying 183.57.48.34...\nConnected to 183.57.48.34.\nEscape character is '^]'.\n220 bizmx17.qq.com MX QQ Mail Server\nHELO test                               -- # MEANS HELLO \u0026#x3C;domain\u003e 在每次建立连接通道后，发送的第一条消息\n250 bizmx17.qq.com                         # 服务器的回复值 Code 250 \nMAIL FROM: \u0026#x3C;from@test.net\u003e              -- # MAIL 表示邮件的发起方，用于退信等其他邮件反向事件\n250 Ok                                   \nRCPT TO: \u0026#x3C;to@xxx.xxx\u003e                   -- # RCPT 表示邮件的接收方，用于投递邮件等正向事件\n250 Ok\nDATA                                    -- # DATA 表示之后的内容将作为邮件正文 (正文这个描述可能不太恰当，更应该是等同于信封内的所有内容)\n354 End data with \u0026#x3C;CR\u003e\u0026#x3C;LF\u003e.\u0026#x3C;CR\u003e\u0026#x3C;LF\u003e\n                                        --\nIt's a fake mail.                       -- # 邮件正文，其实还可以写上诸如 'Subject: XXX' 'Cc: XXX' 的内容\n.                                       -- # 正文内容结束的标志，\u0026#x3C;CR\u003e\u0026#x3C;LF\u003e.\u0026#x3C;CR\u003e\u0026#x3C;LF\u003e\n550 Mail content denied. http://service.exmail.qq.com/cgi-bin/help?subtype=1\u0026#x26;\u0026#x26;id=20022\u0026#x26;\u0026#x26;no=1000726 # 这里很无奈，没腾讯给拦了，没发出去。不过反正是假的，邮件信息不全。\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e几个主要的 SMTP 交互指令\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHELO: (HELLO)\n主要用于让 SMTP 服务器对当前连接的 SMTP 客户端(上例是 telnet 模拟的) 建立一个身份标志 (一般是当前的主机名)\u003c/li\u003e\n\u003cli\u003eMAIL:\n用法 MAIL FROM: \u003ca href=\"mailto:xx@xx.xx\"\u003exx@xx.xx\u003c/a\u003e (不区分大小写)\n可以将其与普通信件的信封等同。毕竟都是要写上发信人，如果没人收信，也就可以根据这个声明将信件退回。\u003c/li\u003e\n\u003cli\u003eRCPT: (RECIPIENT)\n用法 RCPT TO: \u003ca href=\"mailto:xx@xx.xx\"\u003exx@xx.xx\u003c/a\u003e (可多次重复声明，即将一封信件复制多次投送给每次声明的对象)\n相当于普通信件的收信人。不过也有点区别，毕竟普通信件没法一件多发嘛。\u003c/li\u003e\n\u003cli\u003eDATA:\n\u003ccode\u003eDATA\u003c/code\u003e 之后到 \u003ccode\u003e\u0026#x3C;CR\u003e\u0026#x3C;LF\u003e.\u0026#x3C;CR\u003e\u0026#x3C;LF\u003e\u003c/code\u003e 之前的所有内容都作为邮件的正文内容。等同于普通信件信封内的信纸(当然了，信纸上在写上 \u003ccode\u003eTo XXX:\u003c/code\u003e \u003ccode\u003eYours XXX\u003c/code\u003e 也是很正常的嘛)，类似的也就是 DATA 数据中也可以包括 \u003ccode\u003eSubject:\u003c/code\u003e (主题), \u003ccode\u003eFrom:\u003c/code\u003e (写信人), \u003ccode\u003eDate:\u003c/code\u003e (日期), \u003ccode\u003eTo:\u003c/code\u003e(收件人)等内容。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e几个次要的 SMTP 交互指令\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eRSET: (Reset)\n重置，丢弃之前针对邮件所描述的所有内容，重新开始。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVRFY: (VERIFY)\n用于确认收件人是否存在，以及收件人的完整地址\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNOOP:\n强制服务器做出一个回应，没有实际意义。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eQUIT:\n要求收信服务器返回一个邮件接收成功的信号，之后释放连接通道。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eSMTP 扩展\u003c/h2\u003e\n\u003cp\u003e前面描述了这么多，应该来说找一些支持 TCP (或者其他稳定的传输层连接也是可以的) 连接的命令就完全可以支持一次邮件发送的需求。\u003c/p\u003e\n\u003cp\u003e但是，如果想要发送一些中文字符之类的，马上就出现了问题。\u003c/p\u003e\n\u003cp\u003e这里有几种方式，但本人还没有理解透彻。仅列出知道的可行方案。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通过 IMF (Internet Message Format) 进行发件\u003c/li\u003e\n\u003cli\u003e通过 ESMTP \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eSMTP 安全\u003c/h2\u003e\n\u003cp\u003e出于 SMTP 本身协议的设计，没有一个有效的身份认证机制。\u003c/p\u003e\n\u003cp\u003e纵使通过 \u003ccode\u003eMAIL FROM: \u0026#x3C;A@test.net\u003e\u003c/code\u003e 在信封上写明了是由 A 发出的信件。\n但是，装在信封内的信纸却可以属上另一个人的名字。\u003c/p\u003e\n\u003cp\u003e利用这种规则，也就出现了伪装发信人这样的操作。当然，现在的大量邮箱服务提供商都会对这种情况进行标记。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fvpbzedf67j315e01q0sp.jpg\" alt=\"“代发”标记\"\u003e\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://tools.ietf.org/html/rfc821\"\u003eSIMPLE MAIL TRANSFER PROTOCOL\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.ruanyifeng.com/blog/2008/06/mime.html\"\u003eMIME\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e在网络协议上，高层协议确实比底层协议更容易理解，也更加的人性化。\n传输层的 TCP, UDP 都还停留在各种字节内容的整合和校验上，而更上层的应用层协议就已经能够直观到通过直接解读就能理解其每条消息的含义了。\u003c/p\u003e"},{"url":"2018-09-18-TCP-SYN","fileName":"2018-09-18-TCP-SYN.md","title":"TCP SYN 包模拟","author":"fangfeng","date":"2018-09-18T00:00:00.000Z","tags":["TCP"],"content":"\u003cp\u003e写了两天，几乎是从零开始，C 语言搞了一个发 TCP SYN 包的小程序。\n从协议到程序代码的转换，确实没有花费太多的时间，但是为了字节序(byteorder)的问题简直折腾得...\u003c/p\u003e\n\u003ch2\u003eTCP 首部格式\u003c/h2\u003e\n\u003cp\u003e从 RFC 793 了解到基础的 TCP 首部格式(当然，模拟三次握手的 SYN 包也根本不需要填充任何数据)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |          Source Port          |       Destination Port        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                        Sequence Number                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Acknowledgment Number                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Data |           |U|A|P|R|S|F|                               |\n   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n   |       |           |G|K|H|T|N|N|                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |           Checksum            |         Urgent Pointer        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Options                    |    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                             data                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于仅仅模拟一个 SYN 包而言，似乎无需关心 Sequence Number, Ack Number, Window 等信息，毕竟都不关心服务器端给的返回。\n最低的要求，仅仅是发一个合法的 TCP 报文，得到服务器端的反馈，而非直接被服务器端丢弃(如果被验证到报文非法或者数据出错等)。\u003c/p\u003e\n\u003cp\u003e那么，最为重要的细节就是 Checksum (校验和) 了。服务器端会对接收到的数据流进行校验，如果有差错，则直接丢弃，而无任何结果。\u003c/p\u003e\n\u003ch2\u003e校验和\u003c/h2\u003e\n\u003cp\u003e从细节上来说，网络协议中的校验和显得比较简单。以 TCP 协议的 Checksum 字段举例，就是为了让伪首部(TCP 首部 + source IP + destination IP 等一些额外信息)\n以每 16 位 (2 字节) 为一个单位，循环累加和最终达到 0xFFFF 的效果。\u003c/p\u003e\n\u003cp\u003e下面以一个由 Source IP: 172.16.2.101 -\u003e Destination IP: 172.16.2.127 的 TCP 首部为例进行细节描述:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 总长为 20 字节的 TCP 报文首部\n27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 1d 2c 00 00\n\nsrc Port: 0x2711 -\u003e 10001\ndst Port: 0x0fa0 -\u003e 4000\nSeq nr: 0x00000000 -\u003e 0\nAck nr: 0x00000000 -\u003e 0\nData off: 5 -\u003e 32 bits 数量是 5 -\u003e 20 字节 (即 TCP 首部长度为 20 字节)\nFLAG: 0x02 -\u003e urg ack psh rst SYN fin \nWindow: 0xFF00 (窗口大小为 65280 字节)\nchk sum: 0x1d2c\nurg pointer: 0x0000\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在计算之前，TCP 校验和还将涉及到伪首部的概念\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e+--------+--------+--------+--------+\n|           Source Address          |\n+--------+--------+--------+--------+\n|         Destination Address       |\n+--------+--------+--------+--------+\n|  zero  |  PTCL  |    TCP Length   |\n+--------+--------+--------+--------+\n\n在此例中:\nSource Address: 172.16.2.101 -\u003e 0xAC100265\nDestination Address: 172.16.2.127 -\u003e 0XAC10027F\nzero: 0x00\nPTCL(protocol): TCP(6) -\u003e 0x06\nTCP Length: 20 bytes -\u003e 0x0014\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e即加上伪首部的内容，需要共同进行校验的数据流如下\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eac 10 02 65 ac 10 02 7f 00 06 00 14 27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 1d 2c 00 00\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e服务器端校验\u003c/h3\u003e\n\u003cp\u003e服务器端接收到 TCP 报文后，将对整个需要校验的数据流，按 16 bits (2字节) 为单位，进行累加。\u003c/p\u003e\n\u003cp\u003e即: \u003ccode\u003e0xac10+0x0265+0xac10+0x027f+0x0006+0x0014+0x2711+0x0fa0+0x0000+0x0000+0x0000+0x0000+0x5002+0xff00+0x1d2c+0x0000 = 0x2fffd\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e对于超长计算结果 (超出 0xFFFF) ，循环将高位右移 16 位与低位进行累加，直到结果 \u0026#x3C;= 0xFFFF ，即 \u003ccode\u003e0x20000 \u003e\u003e 16 + 0xfffd = 0xffff\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e如果最终结果 \u003ccode\u003e=0xffff\u003c/code\u003e(全为 1) ，则认为 TCP 首部没有问题，服务器端接收报文，并回复 ACK SYN 包。\u003c/p\u003e\n\u003ch3\u003e客户端构造校验和\u003c/h3\u003e\n\u003cp\u003e与服务器端相对，显然客户端必须通过 Check sum ，使得最终的结果服务器端校验的条件。\u003c/p\u003e\n\u003cp\u003e作为反向问题，同样以上面为例子，假设 check sum 还未确定具体的值。则计算方式如下:\u003c/p\u003e\n\u003cp\u003e加上伪首部, 校验和暂时置零的数据流\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eac 10 02 65 ac 10 02 7f 00 06 00 14 27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 00 00 00 00\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e作为逆过程，按 16 bits 为单位，进行累加。即: \u003ccode\u003e0xac10+0x0265+0xac10+0x027f+0x0006+0x0014+0x2711+0x0fa0+0x0000+0x0000+0x0000+0x0000+0x5002+0xff00+0x0000+0x0000 = 0x2e2d1\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e超长部分循环累加，\u003ccode\u003e0x20000 \u003e\u003e 16 + 0xe2d1 = 0xe2d3\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e结果取反，\u003ccode\u003e~ 0xe2d3 = 0x1d2c\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e即认为 \u003ccode\u003e0x1d2c\u003c/code\u003e 为校验和\u003c/p\u003e\n\u003ch2\u003eHBO 与 NBO\u003c/h2\u003e\n\u003cp\u003eHBO: host byte order\nNBO: network byte order \u003c/p\u003e\n\u003cp\u003e说起字节序简直能够把人逼疯，说实话虽然有一定的历史原因，但是不做统一真的对底层编程相当得不友好。\u003c/p\u003e\n\u003cp\u003e不过，再厌烦也不能改变什么。总还得继续写代码不是嘛。\u003c/p\u003e\n\u003ch3\u003e主机字节序 (HBO, Host Byte Order)\u003c/h3\u003e\n\u003cp\u003e采用小端字节排序方式。简单描述为 高位字节存放在内存的高地址处，低位字节存储在内存的低地址处。\u003c/p\u003e\n\u003cp\u003e以 4 字节 int 型数据 0xAB1267EF 为例:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fvdu3zhh92j31040newel.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e而程序读取数据的顺序，如果不考虑数据类型，按字节读取，普遍将采用字节递增序读取，则优先将读到 0xEF 等低位字节数据\u003c/p\u003e\n\u003ch3\u003e网络字节序 (NBO, Network Byte Order)\u003c/h3\u003e\n\u003cp\u003e采用大端字节排序方式。简单描述为通过网络接收到数据时将优先接收到数据的高位字节，然后再得到低位字节。\u003c/p\u003e\n\u003cp\u003e还是以 4 字节 int 型数据 0xAB1267EF 为例:\u003c/p\u003e\n\u003cp\u003e则通过网络得到的数据流将是 \u003ccode\u003e0xEF 0x67 0x12 0xAB\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003e实际使用\u003c/h3\u003e\n\u003cp\u003eC 语言，BSD 平台的 netinet/tcp.h 定义了 tcp header 结构体。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct tcphdr {\n    unsigned short  th_sport;   /* source port */\n    unsigned short  th_dport;   /* destination port */\n    tcp_seq th_seq;         /* sequence number */\n    tcp_seq th_ack;         /* acknowledgement number */\n#if __DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIAN\n    unsigned int    th_x2:4,    /* (unused) */\n            th_off:4;   /* data offset */\n#endif\n#if __DARWIN_BYTE_ORDER == __DARWIN_BIG_ENDIAN\n    unsigned int    th_off:4,   /* data offset */\n            th_x2:4;    /* (unused) */\n#endif\n    unsigned char   th_flags;\n#define TH_FIN  0x01\n#define TH_SYN  0x02\n#define TH_RST  0x04\n#define TH_PUSH 0x08\n#define TH_ACK  0x10\n#define TH_URG  0x20\n#define TH_ECE  0x40\n#define TH_CWR  0x80\n#define TH_FLAGS    (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)\n\n    unsigned short  th_win;     /* window */\n    unsigned short  th_sum;     /* checksum */\n    unsigned short  th_urp;     /* urgent pointer */\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于 \u003ccode\u003eunsigned char\u003c/code\u003e 之类的单字节数据，将不存在任何问题。但是，诸如 \u003ccode\u003eunsigned short\u003c/code\u003e 等多字节数据，将涉及到字节序的转换。\u003c/p\u003e\n\u003cp\u003e比如，虽然令 \u003ccode\u003eth_sport = 0x2711 (10001)\u003c/code\u003e 看似合理。但是，从内存的角度来看，数据将被存储为 \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 假设起始物理内存地址为 0x00007c000\n0x00007c01: 0x27 \n0x00007c00: 0x11\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e等到构造完 TCP 首部，顺次地发送数据时，呈现的数据流将形如: \u003ccode\u003e0x11 0x27...\u003c/code\u003e 即使用里 HBO (小端字节序) 的数据无法满足 NBO (大端字节序) 的要求。\n毕竟，两者相互对立。\u003c/p\u003e\n\u003cp\u003e因此，需要特别注意字节序的问题。当然，C 语言还是想当友好地提供了字节序转换的工具 \u003ccode\u003ehtons\u003c/code\u003e, \u003ccode\u003ehtonl\u003c/code\u003e, \u003ccode\u003entohs\u003c/code\u003e, \u003ccode\u003entohl\u003c/code\u003e 。详情请通过 \u003ccode\u003eman byteorder\u003c/code\u003e 查看。\u003c/p\u003e\n\u003ch2\u003eTCP SYN 的简单例程\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \u0026#x3C;stdio.h\u003e\n#include \u0026#x3C;stdlib.h\u003e\n#include \u0026#x3C;string.h\u003e\n#include \u0026#x3C;unistd.h\u003e\n#include \u0026#x3C;errno.h\u003e\n#include \u0026#x3C;arpa/inet.h\u003e\n#include \u0026#x3C;netinet/tcp.h\u003e\n#include \u0026#x3C;netinet/ip.h\u003e\n#include \u0026#x3C;netinet/in.h\u003e\n\n/**\n * +--------+--------+--------+--------+\n * |           Source Address          |\n * +--------+--------+--------+--------+\n * |         Destination Address       |\n * +--------+--------+--------+--------+\n * |  zero  |  PTCL  |    TCP Length   |\n * +--------+--------+--------+--------+\n */\nstruct pseudohdr {\n    unsigned int src_addr;\n    unsigned int dst_addr;\n    unsigned short zero:8;\n    unsigned short protocol:8;\n    unsigned short tcp_length;\n\n    struct tcphdr tcpHdr;\n};\n\nunsigned short check_sum(unsigned short *ptr, size_t nbytes) \n{\n    unsigned int sum = 0;\n\n    while(nbytes \u003e 0) \n    {\n        sum += htons(*ptr++);\n        nbytes -= 2;\n    }\n\n    sum = (sum \u003e\u003e 16) + (sum \u0026#x26; 0xFFFF);\n    sum = (sum \u003e\u003e 16) + (sum \u0026#x26; 0xFFFF);\n\n    sum = ~sum;\n    return (unsigned short) sum;\n}\n\nstruct tcphdr * init_tcp_header(int sport) \n{\n    struct tcphdr * header = (struct tcphdr *) malloc(sizeof(struct tcphdr));\n    header-\u003eth_sport = htons(sport);    // 源端口\n    header-\u003eth_dport = htons(4000);     // 目标端口\n    header-\u003eth_seq = 0;                // 序列号\n    header-\u003eth_ack = 0;                // 确认序号 | ACK 置位时有效\n    header-\u003eth_off = sizeof(struct tcphdr) / 4;   // TCP 首部长度 (字节)\n    header-\u003eth_flags = TH_SYN;      // 标志位\n    header-\u003eth_win = 255;           // 数据窗口大小\n    header-\u003eth_sum = 0;             // 校验值 (先置为 0, 等会再修正)\n    header-\u003eth_urp = 0;\n    return header;\n}\n\nvoid tcp_syn(int tcp_sock, struct tcphdr *header)\n{\n    struct sockaddr_in *addr = (struct sockaddr_in *) malloc(sizeof(struct sockaddr_in));\n    addr-\u003esin_family = PF_INET;\n    addr-\u003esin_port = htons(4000);\n    addr-\u003esin_addr.s_addr = inet_addr(\"172.16.2.127\");\n    ssize_t size = sendto(tcp_sock, header, sizeof(struct tcphdr), 0, (struct sockaddr *)addr, sizeof(addr));\n}\n\nint main(int argc, char **argv)\n{\n    int tcp_sock = socket(PF_INET, SOCK_RAW, IPPROTO_TCP);\n    if(tcp_sock == -1) \n    {\n        fprintf(stderr, \"Open Socket Failed: %s(errno: %d)\\n\", strerror(errno), errno);\n        exit(0);\n    }\n\n    struct tcphdr *tcpHdr = init_tcp_header(10001);\n\n    struct pseudohdr *psdHdr = (struct pseudohdr *) malloc(sizeof(struct pseudohdr));\n    psdHdr-\u003esrc_addr = inet_addr(\"172.16.2.101\");\n    psdHdr-\u003edst_addr = inet_addr(\"172.16.2.127\");\n    psdHdr-\u003ezero = 0;\n    psdHdr-\u003eprotocol = 6;\n    psdHdr-\u003etcp_length = htons(sizeof(struct tcphdr));\n    memcpy(\u0026#x26;psdHdr-\u003etcpHdr, tcpHdr, sizeof(struct tcphdr));\n    tcpHdr-\u003eth_sum = htons(check_sum((unsigned short *) psdHdr, sizeof(struct pseudohdr)));\n    free(psdHdr);\n\n    tcp_syn(tcp_sock, tcpHdr);\n    free(tcpHdr);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e写了两天，几乎是从零开始，C 语言搞了一个发 TCP SYN 包的小程序。\n从协议到程序代码的转换，确实没有花费太多的时间，但是为了字节序(byteorder)的问题简直折腾得...\u003c/p\u003e"},{"url":"2018-09-08-preprocessor-output","fileName":"2018-09-08-preprocessor-output.md","title":"Preprocessor Output","author":"fangfeng","date":"2018-09-08T00:00:00.000Z","tags":["C","CPP","GCC"],"content":"\u003cp\u003e最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。\n暂时告别一步到位的命令 \u003ccode\u003egcc main.c\u003c/code\u003e，如果从 \u003ccode\u003e.c\u003c/code\u003e 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。\n但是，仅仅从第一个流程 \u003cstrong\u003e预编译\u003c/strong\u003e 而言，就已经遇到了一些麻烦。\u003c/p\u003e\n\u003cp\u003eprogram.i\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e# 1 \"program.c\"\n# 1 \"\u0026#x3C;built-in\u003e\"\n# 1 \"\u0026#x3C;command-line\u003e\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"\u0026#x3C;command-line\u003e\" 2\n# 1 \"program.c\"\n# 1 \"header.h\" 1\nchar *test(void);\n# 2 \"program.c\" 2\n\nint main(void)\n{\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e预编译后的问题出现了诸如 \u003ccode\u003e# 1 \"program.c\"\u003c/code\u003e 的 \u003cem\u003e注释?\u003c/em\u003e \u003c/p\u003e\n\u003cp\u003e这里简单记录预处理输出文件的基本格式，方便今后回顾。\u003c/p\u003e\n\u003ch2\u003eOutput File format\u003c/h2\u003e\n\u003cp\u003e首先，从预编译的结果看，\u003ccode\u003ecpp (C preprocessor)\u003c/code\u003e 程序主要是处理了所有的\u003cstrong\u003e宏指令\u003c/strong\u003e。然后添加上了一些所谓\u003cstrong\u003e线性标记\u003c/strong\u003e的内容。\n最终得到的就是类似 \u003ccode\u003eprogram.i\u003c/code\u003e 的结果。\u003c/p\u003e\n\u003cp\u003e从细节上来说:\n首先，所有的宏指令，包括 \u003ccode\u003e#include\u003c/code\u003e (用于引入用户自定义及系统预定义的头文件)、\u003ccode\u003e#define\u003c/code\u003e (用于将使用到的宏进行替换)。\n当然，在替换完成后，这些指令所在的行将被替换成空行。同时，所有的注释行也将被替换成空行。\u003c/p\u003e\n\u003cp\u003e此外，将添加上注入 \u003ccode\u003e#1 \"program.c\"\u003c/code\u003e 的\u003cstrong\u003e线性标记\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e线性标记\u003c/h3\u003e\n\u003cp\u003e线性标记的标准格式:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e# linenum filename flags\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003elinenum 是为了配合预定义宏 \u003ccode\u003e__LINE__\u003c/code\u003e 是使用的，用于定位紧随的下一行内容在原文件中所在的行。\u003c/p\u003e\n\u003cp\u003efilename 指出了接下来的内容来自哪个原文件\u003c/p\u003e\n\u003cp\u003eflags 有如下几个取值:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1 : 表示这是一个新的文件的开始\u003c/li\u003e\n\u003cli\u003e2 : 表示回到文件 \u003ccode\u003efilename\u003c/code\u003e 的内容 (从其他的 \u003cem\u003einclude\u003c/em\u003e 的文件中)\u003c/li\u003e\n\u003cli\u003e3 : 表示接下来的内容是从系统预定义头文件中来的，因此需要抑制某些警告\u003c/li\u003e\n\u003cli\u003e4 : 表示接下来的内容需要被视作是被封装的隐式 \u003ccode\u003eextern \"C\"\u003c/code\u003e 块\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e实例解读\u003c/h3\u003e\n\u003cp\u003eprogram.c\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \"header.h\"\nint main(void)\n{\n    puts(test());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eheader.h\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003echar *test(void);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来的演示都将以 \u003cstrong\u003eprogram.c\u003c/strong\u003e 和 \u003cstrong\u003eheader.h\u003c/strong\u003e 两个文件作为标准示例。\n期间，将对 \u003cstrong\u003eprogram.c\u003c/strong\u003e or \u003cstrong\u003eheader.h\u003c/strong\u003e 做不同程度的修改，已达到更好的展示效果。\n\u003cem\u003e注意:\u003c/em\u003e 额外添加的注释由 \u003ccode\u003e!\u003c/code\u003e 开始到该行结束(并不符合 C 语言语法)，但是帮助理解\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSample 1\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e直接利用 program.c 与 header.h 进行预编译 \u003ccode\u003ecpp -o program.i program.c\u003c/code\u003e\n结果如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e# 1 \"program.c\"\n# 1 \"\u0026#x3C;built-in\u003e\"\n# 1 \"\u0026#x3C;command-line\u003e\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"\u0026#x3C;command-line\u003e\" 2\n# 1 \"program.c\"\n# 1 \"header.h\" 1            ! 下一行代码对应的是 header.h 文件第一行\nchar *test(void);\n# 2 \"program.c\" 2           ! flag=2 表示下列内容由回到了 program.c 中，下一行对应原文件第二行\n\nint main(void)\n{\n    puts(test());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eSample 2\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e接着，给 \u003cstrong\u003eprogram.c\u003c/strong\u003e 加点注释，在加点空行\u003c/p\u003e\n\u003cp\u003eprogram.c - sub 1\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e// This is comment          ! 这里添加了一行注释\n#include \"header.h\"\n\n                            ! 这里加了个空行\nint main(void)\n{\n    puts(test());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再看看效果\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e# 1 \"program.c\"\n# 1 \"\u0026#x3C;built-in\u003e\"\n# 1 \"\u0026#x3C;command-line\u003e\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"\u0026#x3C;command-line\u003e\" 2\n# 1 \"program.c\"             ! 下一行代码对应原代码中第 1 行，本来是注释，但会被预编译器处理成空行 (多行将逐一处理，但行数不会变)\n\n# 1 \"header.h\" 1            ! 下面将描述 header.h 的代码\nchar *test(void);\n# 3 \"program.c\" 2           ! 继续描述 program.c ，下一行对应原代码第 3 行。至于第 2 行，就是 #include \"header.h\" ，不会直接表现了\n\n\nint main(void)\n{\n    puts(test());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eSample 3\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在改变一些\u003c/p\u003e\n\u003cp\u003eprogram.c - sub 2\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e// This is comment\n#include \"header.h\"\n#define TEN 10\n\nint main(void)\n{\n    puts(test());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e看看结果\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e# 1 \"program.c\"\n# 1 \"\u0026#x3C;built-in\u003e\"\n# 1 \"\u0026#x3C;command-line\u003e\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"\u0026#x3C;command-line\u003e\" 2\n# 1 \"program.c\"\n\n# 1 \"header.h\" 1\nchar *test(void);\n# 3 \"program.c\" 2\n                        ! 原代码中对应行是宏 #define TEN 10 ，已经被空行替换掉了。\n\nint main(void)\n{\n    puts(test());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。\n暂时告别一步到位的命令 \u003ccode\u003egcc main.c\u003c/code\u003e，如果从 \u003ccode\u003e.c\u003c/code\u003e 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。\n但是，仅仅从第一个流程 \u003cstrong\u003e预编译\u003c/strong\u003e 而言，就已经遇到了一些麻烦。\u003c/p\u003e\n\u003cp\u003eprogram.i\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e# 1 \"program.c\"\n# 1 \"\u0026#x3C;built-in\u003e\"\n# 1 \"\u0026#x3C;command-line\u003e\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"\u0026#x3C;command-line\u003e\" 2\n# 1 \"program.c\"\n# 1 \"header.h\" 1\nchar *test(void);\n# 2 \"program.c\" 2\n\nint main(void)\n{\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e预编译后的问题出现了诸如 \u003ccode\u003e# 1 \"program.c\"\u003c/code\u003e 的 \u003cem\u003e注释?\u003c/em\u003e \u003c/p\u003e\n\u003cp\u003e这里简单记录预处理输出文件的基本格式，方便今后回顾。\u003c/p\u003e"},{"url":"2018-08-26-understand-Kernel-2","fileName":"2018-08-26-understand-Kernel-2.md","title":"理解 Linux Kernel (2) - 多任务切换","author":"fangfeng","date":"2018-08-26T00:00:00.000Z","tags":["Linux","Kernel","Multi-Task"],"content":"\u003ch2\u003e概述\u003c/h2\u003e\n\u003cp\u003e《只是为了好玩》一书中，林纳斯描述过他最早的试验性程序就是让 CPU 执行两个不同的任务(一个不断输出A，另一个输出B)，同时不断地让 CPU 在两个任务间的切换。\u003c/p\u003e\n\u003cp\u003e结合《Linux 内核完全注释》一书，得到了多任务切换的示例程序。\u003c/p\u003e\n\u003cp\u003e本节所要描述的内容，正是结合一个框架式的汇编程序(多任务切换程序, 书中提供的内容比较老，无法适应目前的各种工具、环境)，在现有环境中加以处理并成功运行。\u003c/p\u003e\n\u003cp\u003e关于运行环境的说明，欢迎参考 \u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/\"\u003e理解 Linux Kernel (0)\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e引导程序\u003c/h2\u003e\n\u003cp\u003e在 \u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-1/\"\u003e理解 Linux Kernel (1)\u003c/a\u003e 已经描述过通过 BIOS 加载引导程序，并执行引导程序的全部流程。\n当然，也就仅仅到引导程序就结束了。诸如操作系统之类的内容根本就没有涉及。\u003c/p\u003e\n\u003cp\u003e不过，无论是操作系统，还是用户程序，都是基于 CPU、内存等硬件而进一步抽象的上层概念。如果问没有操作系统而直接运行程序是否可行？毫无疑问，这绝对是没有问题的。\u003c/p\u003e\n\u003cp\u003eCPU 只是忠实地执行寄存器定位到的机器指令，并加以执行。特别是，如果在 \u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-1/\"\u003e理解 Linux Kernel (1)\u003c/a\u003e 提供的输出 \"System Loading...\" 的示例程序上继续加以改编，无论是算术运算、显示文本等等目的都是没有问题的。\n当然，限制也还是有的，512B 是引导程序的上限。\u003c/p\u003e\n\u003cp\u003e在机器上电启动之后，存储在非易失性存储器 / 只读存储器上的 BIOS 程序将被加载到内存，并进行执行(至于细节，不甚了解，不表)\n之后，BIOS 将默认地将指定磁盘(软盘、硬盘等) 首个扇区 512 字节的内容(称为 boot 引导程序)加载到内存地址，并 JMP 到 CS:IP = 0x07c00:0x0000 的位置。从而触发引导程序。\u003c/p\u003e\n\u003cp\u003e继而，如果在编写 boot 引导程序的时候，我们使其能够从外存加载额外的代码，并在引导程序结束位置将 CPU 的控制权交给这段额外加载的代码。显然，操作系统就是这样子被加载的。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBIOS -\u003e boot 引导程序 -\u003e 操作系统引导程序 -\u003e 操作系统\u003c/code\u003e\n这就构成了一个宏观的操作系统启动的一个流程。\u003c/p\u003e\n\u003cp\u003eboot.s 引导程序 主体代码来自《Linux 内核完全注释》，进行了一定量的改写\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBOOTSEG = 0x07c0\nSYSSEG = 0x0100\nSYSLEN = 17\n\nentry start\nstart:\n    jmpi    go,#BOOTSEG\ngo:\n    mov ax,cs\n    mov ds,ax\n    mov ss,ax\n    mov sp,#0x0400\n\nload_system:\n    xor dx,dx       ! 开始位置, 磁头:硬盘号\n    mov cx,#0x0002  ! 开始位置, 磁道:扇区\n    mov ax,#0x0100\n    mov es,ax       ! 载入到, ES 段\n    xor bx,bx       ! 载入到, 偏移量 \n    mov ax,#0x0211  ! AH: 读取扇区子功能, AL: 读取多少个扇区\n    int 0x13        ! BIOS 13 号中断\n    jnc continue_load   ! JUMP if CF = 0\ndie:\n    jmp die\n\ncontinue_load:\n    cli             ! 清除中断允许位标志\n    mov ax,#SYSSEG \n    mov ds,ax       ! 设置数据段寄存器位置 0x1000\n    xor ax,ax\n    mov es,ax       ! 设置扩展段寄存器 0x0000\n    mov cx,#0x1000  ! 计数器\n    sub si,si\n    sub di,di\n    rep \n    movsw\n\n    mov ax,#BOOTSEG\n    mov ds,ax       ! 重新设置数据段寄存器到当前数据段基地址\n    lidt idt_48     ! 设置中断描述符表寄存器\n    lgdt gdt_48     ! 设置全局描述符表寄存器\n\n    mov ax,#0x0001\n    lmsw ax         ! 设置 CR0, 进入保护模式\n    jmpi 0,8\n\ngdt:\n    .word   0,0,0,0\n    .word   0x07FF,0x0000,0x9A00,0x00C0\n    .word   0x07FF,0x0000,0x9200,0x00C0\n\nidt_48:\n    .word   0,0,0\ngdt_48:\n    .word   0x07FF,0x7C00+gdt,0\n\n.org 510\n    .word   0xAA55\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这段汇编程序，通过 \u003ccode\u003eload_system\u003c/code\u003e 标识符标识的这段程序表明需要加载0号磁盘,0号磁头,0号磁道,从第2扇区开始,连续17个扇区的内容(这里将存储支持任务切换的程序)，加载到内存以 0x1000 开始的物理地址处。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econtinue_load\u003c/code\u003e 标识将 0x1000 物理地址开始的 4096 字 (即 8192 字节) 的内容依次复制到以 0x0000 开始的物理地址处。\u003c/p\u003e\n\u003cp\u003e其后，设置 IDT (中断描述符表)、IDTR(中断描述符表寄存器) 及 GDT(全局描述符表)、GDTR(全局描述符表寄存器)，将 CPU 运行模式改成 \u003ccode\u003e保护模式\u003c/code\u003e ，继而将控制权转交给这个被加载进来的程序。\u003c/p\u003e\n\u003ch2\u003e多任务程序\u003c/h2\u003e\n\u003cp\u003e主体内容来自《Linux 内核完全注释》，经过一定量改变以适应当前运行环境\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# head.s\n.code32\nLATCH = 11930\nSCRN_SEL = 0x18\nTSS0_SEL = 0x20\nLDT0_SEL = 0x28\nTSS1_SEL = 0x30\nLDT1_SEL = 0x38\n\n.text\n.globl startup_32\nstartup_32:\n\n    movl $0x00000010,%eax       # 段选择符 2\n    mov %ax,%ds                \n    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP \n\n    call setup_idt              # 设置中断描述符表\n    call setup_gdt              # 设置全局描述符表\n    movl $0x00000010,%eax\n    mov %ax,%ds\n    mov %ax,%es\n    mov %ax,%fs\n    mov %ax,%gs\n    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP\n\n# 设置 8253 定时芯片 10s 一个中断\n    movb $0x36,%al  \n    movl $0x00000043,%edx\n    outb %al,%dx\n    movl $LATCH,%eax\n    movl $0x40,%edx\n    outb %al,%dx\n    movb %ah,%al\n    outb %al,%dx\n\n    movl $0x00080000,%eax       # 重新设置 int 0x08 时钟中断\n    movw $timer_interrupt,%ax\n    movw $0x8E00,%dx\n    movl $0x08,%ecx\n    lea idt(,%ecx,8),%esi\n    movl %eax,(%esi)\n    movl %edx,4(%esi)\n    movw $system_interrupt,%ax  # 重新设置 int 0x80 系统中断\n    movw $0xef00,%dx\n    movl $0x80,%ecx\n    lea idt(,%ecx,8),%esi\n    movl %eax,(%esi)\n    movl %edx,4(%esi)\n\n    pushfl                      # 重置 EFLAGS 嵌套任务标志位\n    andl $0xffffbfff,(%esp)\n    popfl\n    movl $TSS0_SEL,%eax\n    ltr %ax                     # Load Task Register\n    movl $LDT0_SEL,%eax\n    lldt %ax                    # Load Local Descriptor Register\n    movl $0,current\n    sti                         # set interrupt flag\n    pushl $0x17\n    pushl $init_stack\n    pushfl\n    pushl $0x0f\n    pushl $task0\n    iret\n\n\nsetup_gdt:\n    lgdt lgdt_opcode\n    ret\nsetup_idt:\n    lea ignore_int,%edx         # 预先把中断处理程序的偏移地址 ignore_int 存到 EDX\n    movl $0x00080000,%eax       # 预存 0x0008 - 段选择符\n    movw %dx,%ax                # 补上 0-15 位偏移地址\n    movw $0x8E00,%dx            # DX 补上标志位\n    lea idt,%edi\n    mov $256,%ecx\nrp_idt: movl %eax,(%edi)        # 循环 256 遍处理 IDT\n    movl %edx,4(%edi)\n    addl $8,%edi\n    dec %ecx\n    jne rp_idt\n    lidt lidt_opcode\n    ret\n\n\nwrite_char:\n    push %gs\n    pushl %ebx\n    mov $SCRN_SEL,%ebx\n    mov %bx,%gs\n    movl scr_loc,%ebx\n    shl $1,%ebx\n    movb %al,%gs:(%ebx)\n    shr $1,%ebx\n    incl %ebx\n    cmpl $2000,%ebx\n    jb 1f\n    movl $0,%ebx\n1:  movl %ebx,scr_loc\n    popl %ebx\n    pop %gs\n    ret\n\n\n\n.align 4\nignore_int:                 # 默认的中断处理程序\n    push %ds\n    pushl %eax\n    movl $0x10,%eax\n    mov %ax,%ds\n    movl $67,%eax\n    call write_char\n    popl %eax\n    pop %ds\n    iret\n\n\n.align 4\ntimer_interrupt:            # 定时中断处理程序\n    push %ds\n    pushl %eax\n    movl $0x10,%eax\n    mov %ax,%ds\n    movb $0x20,%al\n    outb %al,$0x20\n    movl $1,%eax\n    cmpl %eax,current\n    je 1f\n    movl %eax,current\n    jmp $TSS1_SEL, $0\n    jmp 2f\n1:  movl $0,current\n    jmp $TSS0_SEL, $0\n2:  popl %eax\n    pop %ds\n    iret\n\n\n.align 4\nsystem_interrupt:           # 系统调用中断处理程序\n    push %ds\n    pushl %edx\n    pushl %ecx\n    pushl %ebx\n    pushl %eax\n    movl $0x10,%edx\n    mov %dx,%ds\n    call write_char\n    popl %eax\n    popl %ebx\n    popl %ecx\n    popl %edx\n    pop %ds\n    iret\n\n\ncurrent:.long 0\nscr_loc:.long 0\n\n.align 4\nlidt_opcode:\n    .word 256*8-1\n    .long idt\nlgdt_opcode:\n    .word (end_gdt-gdt)-1\n    .long gdt\n\n.align 8\nidt:    .fill 256,8,0\n\ngdt:    .quad 0x0000000000000000\n        .quad 0x00c09a00000007ff\n        .quad 0x00c09200000007ff\n        .quad 0x00c0920b80000002\n        .word 0x68,tss0,0xe900,0x0\n        .word 0x40,ldt0,0xe200,0x0\n        .word 0x68,tss1,0xe900,0x0\n        .word 0x40,ldt1,0xe200,0x0\nend_gdt:\n        .fill 128,4,0\ninit_stack:\n    .long init_stack\n    .word 0x0010\n\n\n.align 8\nldt0:   .quad 0x0000000000000000\n        .quad 0x00c0fa00000003ff\n        .quad 0x00c0f200000003ff\n\ntss0:   .long 0\n        .long krn_stk0, 0x10\n        .long 0,0,0,0,0\n        .long 0,0,0,0,0\n        .long 0,0,0,0,0\n        .long 0,0,0,0,0,0\n        .long LDT0_SEL,0x8000000\n\n        .fill 128,4,0\nkrn_stk0:\n\n\n.align 8\nldt1:   .quad 0x0000000000000000\n        .quad 0x00c0fa00000003ff\n        .quad 0x00c0f200000003ff\n\ntss1:   .long 0\n        .long krn_stk1,0x10\n        .long 0,0,0,0,0\n        .long task1,0x200\n        .long 0,0,0,0\n        .long usr_stk1,0,0,0\n        .long 0x17,0x0f,0x17,0x17,0x17,0x17\n        .long LDT1_SEL,0x8000000\n\n        .fill 128,4,0\nkrn_stk1:\n\n\ntask0:\n    movl $0x17,%eax\n    movw %ax,%ds\n    mov $65,%al\n    int $0x80\n    movl $0xfff,%ecx\n1:  loop 1b\n    jmp task0\ntask1:\n    mov $66,%al\n    int $0x80\n    movl $0xfff,%ecx\n1:  loop 1b\n    jmp task1\n\n    .fill 128,4,0\nusr_stk1:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的这个程序内容不再详述，想了解细节请参考 《Linux 内核完全注释》\u003c/p\u003e\n\u003cp\u003e下面提供编译 \u003ccode\u003eboot.s\u003c/code\u003e 以及 \u003ccode\u003ehead.s\u003c/code\u003e 的可用 Makefile\u003c/p\u003e\n\u003cp\u003e首先描述一下额外的工具版本\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGNU as : GNU assembler version 2.26.1 \u003c/li\u003e\n\u003cli\u003eGNU ld : GNU ld 2.26.1\n其它内容详见 \u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/\"\u003e理解 Linux Kernel (0)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-makefile\"\u003e# Makefile for the simple example kernel.\nAS86    =as86 -0 -a\nLD86    =ld86 -0\nAS  =as\nASFLAGS =-32\nLD  =ld\nLDFLAGS =-s -x -M -m elf_i386 -e startup_32 -Ttext 0x0\n\nall:    Image\n\nImage: boot system\n    dd bs=32 if=boot of=Image skip=1\n    dd bs=512 if=system of=Image skip=8 seek=1\n    sync\n\ndisk: Image\n    dd bs=8192 if=Image of=/dev/fd0\n    sync;sync;sync\n\nhead.o: \n    $(AS) $(ASFLAGS) -o head.o head.s\n\nsystem: head.o \n    $(LD) $(LDFLAGS) head.o  -o system \u003e System.map\n\nboot:   boot.s\n    $(AS86) -o boot.o boot.s\n    $(LD86) -s -o boot boot.o\n\nclean:\n    rm -f Image System.map core boot *.o system\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e运行结果\u003c/h2\u003e\n\u003cp\u003e想了解更多细节的请自行实操查看吧!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fun1fvafhwg30k40d4x6p.gif\"\u003e\u003c/p\u003e\n\u003ch2\u003e附件\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/understand-kernel-2.zip\"\u003e程序源码\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e概述\u003c/h2\u003e\n\u003cp\u003e《只是为了好玩》一书中，林纳斯描述过他最早的试验性程序就是让 CPU 执行两个不同的任务(一个不断输出A，另一个输出B)，同时不断地让 CPU 在两个任务间的切换。\u003c/p\u003e\n\u003cp\u003e结合《Linux 内核完全注释》一书，得到了多任务切换的示例程序。\u003c/p\u003e\n\u003cp\u003e本节所要描述的内容，正是结合一个框架式的汇编程序(多任务切换程序, 书中提供的内容比较老，无法适应目前的各种工具、环境)，在现有环境中加以处理并成功运行。\u003c/p\u003e\n\u003cp\u003e关于运行环境的说明，欢迎参考 \u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/\"\u003e理解 Linux Kernel (0)\u003c/a\u003e\u003c/p\u003e"},{"url":"2018-08-19-understand-Kernel-1","fileName":"2018-08-19-understand-Kernel-1.md","title":"理解 Linux Kernel (1) - BIOS","author":"fangfeng","date":"2018-08-19T00:00:00.000Z","tags":["Linux","Kernel","BIOS"],"content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e在\u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/\"\u003e概述\u003c/a\u003e，我想我已经介绍过我开始这一些列博文的原因。\n我不能担保我所进行的所有试验性操作都是对的，但是，至少这些在我所描述的环境下成功的运行了起来，并帮助我触及我始终敬畏而又敬而远之的\u003cstrong\u003e硬件\u0026#x26;OS\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在《Linux内核完全注释》一书第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，并最终通过 Bochs 仿真器在模拟开机通电后，BIOS Load\nboot 程序，通过显示器输出 \u003cem\u003eLoading System...\u003c/em\u003e 。\u003c/p\u003e\n\u003cp\u003e这些，将是这里所要描述的主要内容。\u003c/p\u003e\n\u003ch2\u003eboot.s 汇编程序\u003c/h2\u003e\n\u003cp\u003e这里没法多说，都是书中的源码，只是供未读过书的读者参考，特意摘录了下来(不过，就不加注释了)\u003c/p\u003e\n\u003cp\u003eboot.s 源代码\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e.global begtext, begdata, begbss, endtext, enddata, endbss\n.text\nbegtext:\n.data\nbegdata:\n.bss\nbegbss:\n.text\nBOOTSEG=0x07c0\n\nentry start\nstart:\n    jmpi    go,BOOTSEG\ngo: mov ax,cs\n    mov ds,ax\n    mov es,ax\n    mov [msg+17],ah\n    mov cx,#20\n    mov dx,#0x1004\n    mov bx,#0x000c\n    mov bp,#msg\n    mov ax,#0x1301\n    int 0x10\nloop1:  jmp loop1\nmsg:    .ascii  \"Loading System...\"\n        .byte   13,10\n.org    510\n.word   0xAA55\n.text\nendtext:\n.data\nenddata:\n.bss\nendbss:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这段程序的主要的执行流程将是:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e通过 BIOS 加载这段 boot 引导程序\u003c/li\u003e\n\u003cli\u003e红色字体打印 \u003cem\u003eLoading System...\u003c/em\u003e 并响铃\u003c/li\u003e\n\u003cli\u003e指令自循环 (\u003ccode\u003eloop1 jmp loop1\u003c/code\u003e) ，将始终展示上述字样，并不接收命令\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e下面就该把这个汇编程序 \u003cem\u003e编译 + 链接\u003c/em\u003e 成 boot 引导程序。\u003c/p\u003e\n\u003cp\u003e虽然在 macOS 上确实找到了一个 as86 汇编器(来自 nasm 的一个编译选项，但我不知道为什么始终无法正常编译，也可能这个根本就不是我想要的)。\u003c/p\u003e\n\u003cp\u003e通过 docker 容器部署的 Ubuntu，可以很容易地得到一个 as86 汇编程序。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003eapt-get install bin86   # as86, ld86 都在这个包里提供了\n\n# 这句需要在宿主机上执行\ndocker cp boot.s linux:/root/boot.s     # 这里 linux 是我 docker 部署的 Ubuntu 的容器的名称。   如果之前 boot.s 在宿主机上，可以这样拷贝到容器中\n\nas86 -0 -a -o boot.o boot.s             # 编译\n\nld86 -0 -s -o execfile boot.o           # 链接\n\n# 当然，到这里为止，其实都可以理解成在将汇编代码编译链接成可执行程序 (和 boot 引导程序没有太大关系，唯一有关系的就是这段汇编语言是以引导为目的写的)\n\ndd bs=32 if=execfile of=boot skip=1     # 这里去掉可执行程序的前 32 字节，形成刚好 512 字节的 boot 引导程序\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e用仿真器启动引导程序\u003c/h2\u003e\n\u003cp\u003e事实上，这部分内容，我始终没有搞清楚 \u003cstrong\u003e磁盘映像文件\u003c/strong\u003e 和 \u003cstrong\u003eboot 引导程序\u003c/strong\u003e 间的关系(当然还有 floppy 和 ata0~3)\u003c/p\u003e\n\u003cp\u003e在上一节成功拿到 \u003cem\u003e512B\u003c/em\u003e 的 boot 引导程序之后，直接使用这个貌似我也运行成功了(根本就不需要创建磁盘映像文件并将引导程序写入映像文件中，不过，也许只是因为这个引导程序太简单了，根本就不需要其他程序的配合。它最后就是一个死循环 )\u003c/p\u003e\n\u003cp\u003e总之，先按照最简单的来吧。\u003c/p\u003e\n\u003cp\u003e把 boot 引导程序拷贝到宿主机上(貌似频繁地在两个OS上交互文件，这个很无奈，docker容器中的进程难以启动显示程序)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在宿主机新建一个目录 \u003cem\u003elinux-boot\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003e拷贝 boot 引导程序到宿主机上 \u003ccode\u003edocker cp linux:/root/boot linux-boot/\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e在 \u003cem\u003elinux-boot\u003c/em\u003e 下建立 bochsrc 文件(这将是整个仿真器的配置，用于模拟组装机器涉及的 CPU, 内存, BIOS, 显示器等)\u003c/li\u003e\n\u003cli\u003e这里使用的配置文件如下:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-rc\"\u003e# You may now use double quotes around pathnames, in case\n# your pathname includes spaces.\n\ncpu: model=pentium, count=1, ips=50000000, reset_on_triple_fault=1, ignore_bad_msrs=1, msrs=\"msrs.def\"\ncpu: cpuid_limit_winnt=0\n\nmemory: guest=512, host=256\n\nromimage: file=$BXSHARE/BIOS-bochs-legacy, options=fastboot     # BIOS 配置\n\nvgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest\n\nmouse: enabled=0\n\npci: enabled=1, chipset=i440fx\n\nprivate_colormap: enabled=0\n\nfloppya: 1\\_44=\"./boot\", status=inserted         # 装载一个软盘 A ，这里用当前目录下的 boot (boot 引导程序，事实上书中说要用 .img 磁盘映像文件，但这里不影响实际效果)\n\nata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14\nata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15\nata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11\nata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9\n\nboot: a                                         # 配置引导程序所在的磁盘\n\nfloppy_bootsig_check: disabled=0\n\nlog: bochsout.txt\n\npanic: action=ask\nerror: action=report\ninfo: action=report\ndebug: action=ignore, pci=report # report BX_DEBUG from module 'pci'\n\ndebugger_log: -\n\nparport1: enabled=1, file=\"parport.out\"\n\nspeaker: enabled=1, mode=sound\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e当前目录 \u003cem\u003elinux-boot\u003c/em\u003e 下，键入命令 \u003ccode\u003ebochs\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e由于读取到 \u003cem\u003ebochsrc\u003c/em\u003e 配置文件的存在，menu 的默认选项为 6 (开始模拟机器)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003eYou can also start bochs with the -q option to skip these menus.\n\n1. Restore factory default configuration\n2. Read options from...\n3. Edit options\n4. Save options to...\n5. Restore the Bochs state from...\n6. Begin simulation\n7. Quit now\n\nPlease choose one: [6]\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003e直接开始运行机器，键入命令 \u003ccode\u003ec\u003c/code\u003e (这部分在 \u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/\"\u003e概述\u003c/a\u003e 有过了描述，以后将不再描述)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003ePlease choose one: [6]\n00000000000i[      ] lt_dlhandle is 0x7f85d0405ff0\n00000000000i[PLUGIN] loaded plugin libbx_sdl2.so\n00000000000i[      ] installing sdl2 module as the Bochs GUI\n00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800\n00000000000i[      ] using log file bochsout.txt\nNext at t=0\n(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0\n\u0026#x3C;bochs:1\u003e c\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"8\"\u003e\n\u003cli\u003e观察仿真器的表现\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fuf2kicsqyj313y0q0gn4.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eOh, YES! 成功输出了 \u003cem\u003eLoading System...\u003c/em\u003e (不过响铃没有听到，可能与我没有配置 sound 有关)\u003c/p\u003e\n\u003col start=\"9\"\u003e\n\u003cli\u003e关机\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e无需多言，右上角模拟的就是\u003cstrong\u003e关机实体按键\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e在\u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/\"\u003e概述\u003c/a\u003e，我想我已经介绍过我开始这一些列博文的原因。\n我不能担保我所进行的所有试验性操作都是对的，但是，至少这些在我所描述的环境下成功的运行了起来，并帮助我触及我始终敬畏而又敬而远之的\u003cstrong\u003e硬件\u0026#x26;OS\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在《Linux内核完全注释》一书第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，并最终通过 Bochs 仿真器在模拟开机通电后，BIOS Load\nboot 程序，通过显示器输出 \u003cem\u003eLoading System...\u003c/em\u003e 。\u003c/p\u003e\n\u003cp\u003e这些，将是这里所要描述的主要内容。\u003c/p\u003e"}],"items":32,"pages":4,"currentPage":1},"buildId":"YsOqVyLvFnUbWFBFmGa7N","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/" src="https://www.ffutop.com/blog/_next/static/YsOqVyLvFnUbWFBFmGa7N/pages/index.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/YsOqVyLvFnUbWFBFmGa7N/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.74c43a0e96cfe845a889.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>