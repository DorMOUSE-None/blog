<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/FKaOYCdVIHyUdoh_VHOSc/pages/index.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/FKaOYCdVIHyUdoh_VHOSc/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.969aa7fdf03e14118a99.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.f3603d0a56c82c4f5e78.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.00f35eb3.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.55a7521e.chunk.css"/></head><body><div id="__next"><header class="component-header"><h1 class="title">ffutop</h1><ul class="nav-items"><li><a href="/blog/index">博客</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/about">关于</a></li></ul></header><div><main class="main"><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-09-08-preprocessor-output">Preprocessor Output</a></h1><div><p>最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。
暂时告别一步到位的命令 <code>gcc main.c</code>，如果从 <code>.c</code> 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。
但是，仅仅从第一个流程 <strong>预编译</strong> 而言，就已经遇到了一些麻烦。</p>
<p>program.i</p>
<pre><code class="language-c"># 1 "program.c"
# 1 "&#x3C;built-in>"
# 1 "&#x3C;command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "&#x3C;command-line>" 2
# 1 "program.c"
# 1 "header.h" 1
char *test(void);
# 2 "program.c" 2

int main(void)
{
}
</code></pre>
<p>预编译后的问题出现了诸如 <code># 1 "program.c"</code> 的 <em>注释?</em> </p>
<p>这里简单记录预处理输出文件的基本格式，方便今后回顾。</p></div><p><a href="/blog/2018-09-08-preprocessor-output">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-08-26-understand-Kernel-2">理解 Linux Kernel (2) - 多任务切换</a></h1><div><h2>概述</h2>
<p>《只是为了好玩》一书中，林纳斯描述过他最早的试验性程序就是让 CPU 执行两个不同的任务(一个不断输出A，另一个输出B)，同时不断地让 CPU 在两个任务间的切换。</p>
<p>结合《Linux 内核完全注释》一书，得到了多任务切换的示例程序。</p>
<p>本节所要描述的内容，正是结合一个框架式的汇编程序(多任务切换程序, 书中提供的内容比较老，无法适应目前的各种工具、环境)，在现有环境中加以处理并成功运行。</p>
<p>关于运行环境的说明，欢迎参考 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">理解 Linux Kernel (0)</a></p></div><p><a href="/blog/2018-08-26-understand-Kernel-2">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-08-19-understand-Kernel-1">理解 Linux Kernel (1) - BIOS</a></h1><div><h2>前言</h2>
<p>在<a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">概述</a>，我想我已经介绍过我开始这一些列博文的原因。
我不能担保我所进行的所有试验性操作都是对的，但是，至少这些在我所描述的环境下成功的运行了起来，并帮助我触及我始终敬畏而又敬而远之的<strong>硬件&#x26;OS</strong></p>
<p>在《Linux内核完全注释》一书第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，并最终通过 Bochs 仿真器在模拟开机通电后，BIOS Load
boot 程序，通过显示器输出 <em>Loading System...</em> 。</p>
<p>这些，将是这里所要描述的主要内容。</p></div><p><a href="/blog/2018-08-19-understand-Kernel-1">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-08-19-understand-Kernel-0">理解 Linux Kernel (0) - 概述</a></h1><div><h2>概述</h2>
<p>之所以想要了解 Linux Kernel，与前一个月的 JVM ClassFile 的学习有这很大的关联。</p>
<p>说实话，刨除 JVM 的具体实现，Sun (或者现在该说是 Oracle) 确实将 Java 的底层逻辑设计得相当简单。</p>
<ol>
<li>有限而统一的指令集(不超过 256 个，可以用 1 字节表示)</li>
<li>操作数栈+局部变量表共同实现的指令运算</li>
<li>高度封装的成员变量/方法的寻址方式</li>
<li>... (见识短浅，想不到了...以后再补充吧)</li>
</ol>
<p>但是，与 JVM 模拟的虚拟机不同，实体机器有着更为复杂的结构。
最根本的，不同厂商的机器就带来了不同的 CPU 指令集，这就已经让人难以接受了。</p>
<p>其实最初，是想要继续去看看 Hotspot 虚拟机的。但是，混杂的代码(C++, Java, 平台相关各种实现) 带来了很大的阅读障碍。
最根本的，我甚至找不到一个学习的基本立足点，出发点(当然，也可能我根本就没仔细去看，哈哈)。</p>
<p>借着一次机会，我开始看《程序员的自我修养——链接、装载与库》一书。确实无论是 ELF 格式，静态链接与动态链接甚至 Linux 的内建函数
都给了我比较深刻的印象，向我展示了 C 更深入的一面。但是，macOS 给我带来了比较大的客观阻碍(即使用 Docker 容器得到了一个可用的 Linux 环境，但是否与直接建立在机器上的系统有所区别，此处还得打个问号)。
同时，书中的部分内容上下不统一，缺少前后文也是一个重大的问题。总之，这并不完全适合我这种初学者逐一进行书中所描述的全部实验。</p>
<p>最后，我决定展开对 Linux Kernel 的学习，试图通过对直接构架在硬件上的操作系统进行一番比较深入的学习。</p>
<p>期间，找过一些资料，也了解到 Linus Torvals 直接领导着的 <a href="https://www.kernel.org/">Kernel 项目的官网</a>；甚至，找到了各个版本的 kernel 源码(虽然确实地丢失了最早期 0.XX 的若干版本)。
不得不说，就目前来讲，我觉得《Linux内核完全注释》是最适合(<em>打个问号，至少暂时是的</em>)我学习的一书。</p>
<p>之后的若干博文，将都以《Linux内核完全注释》中的内容为基础，结合目前的实际需要，从而进行实操性的认知与学习。</p></div><p><a href="/blog/2018-08-19-understand-Kernel-0">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-08-15-Java-Instrumentation">Java Instrumentation</a></h1><div><h2>Start</h2>
<p>从现有的前置知识来说，我们能够认识到两个事实:</p>
<ol>
<li>Java Class 通过 ClassLoader 进行加载。
通过<code>全限定名</code>进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。
换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)</li>
<li>有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。
当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧
(虽然可能不了解细节。在此，欢迎学习前置技能 <a href="https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/">CGlib Enhancer 主流程源码解析</a> 和 <a href="https://dormouse-none.github.io/2018-07-20-Java-Proxy/">Java Proxy 源码解析</a>。不过不影响本文后续内容)</li>
</ol>
<p>另一个方面，也许绝大多数人都听说过所谓的<code>热部署</code>。但是究竟怎么才能做到 <code>热部署</code>(话题开得有点大哈。Y_Y 本文不讲这个)</p>
<p>操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。</p>
<p>如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚...</p>
<p>Java 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的</p>
<h2>Instrumentation</h2>
<p><code>java.lang.instrument.Instrumentation</code> 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)</p>
<p>相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。</p>
<p>下列有两种方法可以达到目的</p>
<ol>
<li>当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。</li>
<li>当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。</li>
</ol>
<p>话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了<em>检测</em>的目的)的使用</p></div><p><a href="/blog/2018-08-15-Java-Instrumentation">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-07-24-JVM-Instruction">JVM 指令简析</a></h1><div><p>在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。</p>
<p>当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。
那么，直接阅读 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">官方文档</a> 绝对是比本文的内容更为详实且准确。</p>
<p>这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。</p></div><p><a href="/blog/2018-07-24-JVM-Instruction">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-07-20-Java-Proxy">Java Proxy 源码解析</a></h1><div><p>在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。</p>
<p>从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。
而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。</p></div><p><a href="/blog/2018-07-20-Java-Proxy">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-07-13-How-to-easily-get-CGlib-generated-code">如何方便地获取 CGlib 生成类</a></h1><div><h2>配置参数</h2>
<p><strong>命令行使用</strong></p>
<p>在 java 启动命令中添加参数配置项 <code>-Dcglib.debugLocation=&#x3C;Custom Path></code></p>
<p><strong>编码实现</strong></p>
<p>在执行 CGlib 获取新生成类之前，调用 <code>System.setProperty("cglib.debugLocation", &#x3C;Custom Path>)</code></p></div><p><a href="/blog/2018-07-13-How-to-easily-get-CGlib-generated-code">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-07-10-CGlib-Enhancer">CGlib Enhancer 主流程源码解析</a></h1><div><h2>前言</h2>
<p>此博文写作的目的: </p>
<ul>
<li>(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。</li>
<li>基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。</li>
</ul></div><p><a href="/blog/2018-07-10-CGlib-Enhancer">阅读更多</a></p><hr/></div></div><div class="component-page-turner"><a href="/blog/page/2">上一页</a><a href="/blog/page/4">下一页</a></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Powered by <a href="https://reactjs.org/">React</a> and <a href="https://nextjs.org/">Next.js</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/","query":{"mdDatasParts":[{"url":"2018-09-08-preprocessor-output","fileName":"2018-09-08-preprocessor-output.md","title":"Preprocessor Output","author":"fangfeng","date":"2018-09-08T00:00:00.000Z","tags":["C","CPP","GCC"],"content":"\u003cp\u003e最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。\n暂时告别一步到位的命令 \u003ccode\u003egcc main.c\u003c/code\u003e，如果从 \u003ccode\u003e.c\u003c/code\u003e 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。\n但是，仅仅从第一个流程 \u003cstrong\u003e预编译\u003c/strong\u003e 而言，就已经遇到了一些麻烦。\u003c/p\u003e\n\u003cp\u003eprogram.i\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e# 1 \"program.c\"\n# 1 \"\u0026#x3C;built-in\u003e\"\n# 1 \"\u0026#x3C;command-line\u003e\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"\u0026#x3C;command-line\u003e\" 2\n# 1 \"program.c\"\n# 1 \"header.h\" 1\nchar *test(void);\n# 2 \"program.c\" 2\n\nint main(void)\n{\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e预编译后的问题出现了诸如 \u003ccode\u003e# 1 \"program.c\"\u003c/code\u003e 的 \u003cem\u003e注释?\u003c/em\u003e \u003c/p\u003e\n\u003cp\u003e这里简单记录预处理输出文件的基本格式，方便今后回顾。\u003c/p\u003e\n\u003ch2\u003eOutput File format\u003c/h2\u003e\n\u003cp\u003e首先，从预编译的结果看，\u003ccode\u003ecpp (C preprocessor)\u003c/code\u003e 程序主要是处理了所有的\u003cstrong\u003e宏指令\u003c/strong\u003e。然后添加上了一些所谓\u003cstrong\u003e线性标记\u003c/strong\u003e的内容。\n最终得到的就是类似 \u003ccode\u003eprogram.i\u003c/code\u003e 的结果。\u003c/p\u003e\n\u003cp\u003e从细节上来说:\n首先，所有的宏指令，包括 \u003ccode\u003e#include\u003c/code\u003e (用于引入用户自定义及系统预定义的头文件)、\u003ccode\u003e#define\u003c/code\u003e (用于将使用到的宏进行替换)。\n当然，在替换完成后，这些指令所在的行将被替换成空行。同时，所有的注释行也将被替换成空行。\u003c/p\u003e\n\u003cp\u003e此外，将添加上注入 \u003ccode\u003e#1 \"program.c\"\u003c/code\u003e 的\u003cstrong\u003e线性标记\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e线性标记\u003c/h3\u003e\n\u003cp\u003e线性标记的标准格式:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e# linenum filename flags\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003elinenum 是为了配合预定义宏 \u003ccode\u003e__LINE__\u003c/code\u003e 是使用的，用于定位紧随的下一行内容在原文件中所在的行。\u003c/p\u003e\n\u003cp\u003efilename 指出了接下来的内容来自哪个原文件\u003c/p\u003e\n\u003cp\u003eflags 有如下几个取值:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1 : 表示这是一个新的文件的开始\u003c/li\u003e\n\u003cli\u003e2 : 表示回到文件 \u003ccode\u003efilename\u003c/code\u003e 的内容 (从其他的 \u003cem\u003einclude\u003c/em\u003e 的文件中)\u003c/li\u003e\n\u003cli\u003e3 : 表示接下来的内容是从系统预定义头文件中来的，因此需要抑制某些警告\u003c/li\u003e\n\u003cli\u003e4 : 表示接下来的内容需要被视作是被封装的隐式 \u003ccode\u003eextern \"C\"\u003c/code\u003e 块\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e实例解读\u003c/h3\u003e\n\u003cp\u003eprogram.c\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \"header.h\"\nint main(void)\n{\n    puts(test());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eheader.h\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003echar *test(void);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来的演示都将以 \u003cstrong\u003eprogram.c\u003c/strong\u003e 和 \u003cstrong\u003eheader.h\u003c/strong\u003e 两个文件作为标准示例。\n期间，将对 \u003cstrong\u003eprogram.c\u003c/strong\u003e or \u003cstrong\u003eheader.h\u003c/strong\u003e 做不同程度的修改，已达到更好的展示效果。\n\u003cem\u003e注意:\u003c/em\u003e 额外添加的注释由 \u003ccode\u003e!\u003c/code\u003e 开始到该行结束(并不符合 C 语言语法)，但是帮助理解\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSample 1\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e直接利用 program.c 与 header.h 进行预编译 \u003ccode\u003ecpp -o program.i program.c\u003c/code\u003e\n结果如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e# 1 \"program.c\"\n# 1 \"\u0026#x3C;built-in\u003e\"\n# 1 \"\u0026#x3C;command-line\u003e\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"\u0026#x3C;command-line\u003e\" 2\n# 1 \"program.c\"\n# 1 \"header.h\" 1            ! 下一行代码对应的是 header.h 文件第一行\nchar *test(void);\n# 2 \"program.c\" 2           ! flag=2 表示下列内容由回到了 program.c 中，下一行对应原文件第二行\n\nint main(void)\n{\n    puts(test());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eSample 2\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e接着，给 \u003cstrong\u003eprogram.c\u003c/strong\u003e 加点注释，在加点空行\u003c/p\u003e\n\u003cp\u003eprogram.c - sub 1\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e// This is comment          ! 这里添加了一行注释\n#include \"header.h\"\n\n                            ! 这里加了个空行\nint main(void)\n{\n    puts(test());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再看看效果\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e# 1 \"program.c\"\n# 1 \"\u0026#x3C;built-in\u003e\"\n# 1 \"\u0026#x3C;command-line\u003e\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"\u0026#x3C;command-line\u003e\" 2\n# 1 \"program.c\"             ! 下一行代码对应原代码中第 1 行，本来是注释，但会被预编译器处理成空行 (多行将逐一处理，但行数不会变)\n\n# 1 \"header.h\" 1            ! 下面将描述 header.h 的代码\nchar *test(void);\n# 3 \"program.c\" 2           ! 继续描述 program.c ，下一行对应原代码第 3 行。至于第 2 行，就是 #include \"header.h\" ，不会直接表现了\n\n\nint main(void)\n{\n    puts(test());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eSample 3\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在改变一些\u003c/p\u003e\n\u003cp\u003eprogram.c - sub 2\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e// This is comment\n#include \"header.h\"\n#define TEN 10\n\nint main(void)\n{\n    puts(test());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e看看结果\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e# 1 \"program.c\"\n# 1 \"\u0026#x3C;built-in\u003e\"\n# 1 \"\u0026#x3C;command-line\u003e\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"\u0026#x3C;command-line\u003e\" 2\n# 1 \"program.c\"\n\n# 1 \"header.h\" 1\nchar *test(void);\n# 3 \"program.c\" 2\n                        ! 原代码中对应行是宏 #define TEN 10 ，已经被空行替换掉了。\n\nint main(void)\n{\n    puts(test());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。\n暂时告别一步到位的命令 \u003ccode\u003egcc main.c\u003c/code\u003e，如果从 \u003ccode\u003e.c\u003c/code\u003e 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。\n但是，仅仅从第一个流程 \u003cstrong\u003e预编译\u003c/strong\u003e 而言，就已经遇到了一些麻烦。\u003c/p\u003e\n\u003cp\u003eprogram.i\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e# 1 \"program.c\"\n# 1 \"\u0026#x3C;built-in\u003e\"\n# 1 \"\u0026#x3C;command-line\u003e\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"\u0026#x3C;command-line\u003e\" 2\n# 1 \"program.c\"\n# 1 \"header.h\" 1\nchar *test(void);\n# 2 \"program.c\" 2\n\nint main(void)\n{\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e预编译后的问题出现了诸如 \u003ccode\u003e# 1 \"program.c\"\u003c/code\u003e 的 \u003cem\u003e注释?\u003c/em\u003e \u003c/p\u003e\n\u003cp\u003e这里简单记录预处理输出文件的基本格式，方便今后回顾。\u003c/p\u003e"},{"url":"2018-08-26-understand-Kernel-2","fileName":"2018-08-26-understand-Kernel-2.md","title":"理解 Linux Kernel (2) - 多任务切换","author":"fangfeng","date":"2018-08-26T00:00:00.000Z","tags":["Linux","Kernel","Multi-Task"],"content":"\u003ch2\u003e概述\u003c/h2\u003e\n\u003cp\u003e《只是为了好玩》一书中，林纳斯描述过他最早的试验性程序就是让 CPU 执行两个不同的任务(一个不断输出A，另一个输出B)，同时不断地让 CPU 在两个任务间的切换。\u003c/p\u003e\n\u003cp\u003e结合《Linux 内核完全注释》一书，得到了多任务切换的示例程序。\u003c/p\u003e\n\u003cp\u003e本节所要描述的内容，正是结合一个框架式的汇编程序(多任务切换程序, 书中提供的内容比较老，无法适应目前的各种工具、环境)，在现有环境中加以处理并成功运行。\u003c/p\u003e\n\u003cp\u003e关于运行环境的说明，欢迎参考 \u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/\"\u003e理解 Linux Kernel (0)\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e引导程序\u003c/h2\u003e\n\u003cp\u003e在 \u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-1/\"\u003e理解 Linux Kernel (1)\u003c/a\u003e 已经描述过通过 BIOS 加载引导程序，并执行引导程序的全部流程。\n当然，也就仅仅到引导程序就结束了。诸如操作系统之类的内容根本就没有涉及。\u003c/p\u003e\n\u003cp\u003e不过，无论是操作系统，还是用户程序，都是基于 CPU、内存等硬件而进一步抽象的上层概念。如果问没有操作系统而直接运行程序是否可行？毫无疑问，这绝对是没有问题的。\u003c/p\u003e\n\u003cp\u003eCPU 只是忠实地执行寄存器定位到的机器指令，并加以执行。特别是，如果在 \u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-1/\"\u003e理解 Linux Kernel (1)\u003c/a\u003e 提供的输出 \"System Loading...\" 的示例程序上继续加以改编，无论是算术运算、显示文本等等目的都是没有问题的。\n当然，限制也还是有的，512B 是引导程序的上限。\u003c/p\u003e\n\u003cp\u003e在机器上电启动之后，存储在非易失性存储器 / 只读存储器上的 BIOS 程序将被加载到内存，并进行执行(至于细节，不甚了解，不表)\n之后，BIOS 将默认地将指定磁盘(软盘、硬盘等) 首个扇区 512 字节的内容(称为 boot 引导程序)加载到内存地址，并 JMP 到 CS:IP = 0x07c00:0x0000 的位置。从而触发引导程序。\u003c/p\u003e\n\u003cp\u003e继而，如果在编写 boot 引导程序的时候，我们使其能够从外存加载额外的代码，并在引导程序结束位置将 CPU 的控制权交给这段额外加载的代码。显然，操作系统就是这样子被加载的。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBIOS -\u003e boot 引导程序 -\u003e 操作系统引导程序 -\u003e 操作系统\u003c/code\u003e\n这就构成了一个宏观的操作系统启动的一个流程。\u003c/p\u003e\n\u003cp\u003eboot.s 引导程序 主体代码来自《Linux 内核完全注释》，进行了一定量的改写\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBOOTSEG = 0x07c0\nSYSSEG = 0x0100\nSYSLEN = 17\n\nentry start\nstart:\n    jmpi    go,#BOOTSEG\ngo:\n    mov ax,cs\n    mov ds,ax\n    mov ss,ax\n    mov sp,#0x0400\n\nload_system:\n    xor dx,dx       ! 开始位置, 磁头:硬盘号\n    mov cx,#0x0002  ! 开始位置, 磁道:扇区\n    mov ax,#0x0100\n    mov es,ax       ! 载入到, ES 段\n    xor bx,bx       ! 载入到, 偏移量 \n    mov ax,#0x0211  ! AH: 读取扇区子功能, AL: 读取多少个扇区\n    int 0x13        ! BIOS 13 号中断\n    jnc continue_load   ! JUMP if CF = 0\ndie:\n    jmp die\n\ncontinue_load:\n    cli             ! 清除中断允许位标志\n    mov ax,#SYSSEG \n    mov ds,ax       ! 设置数据段寄存器位置 0x1000\n    xor ax,ax\n    mov es,ax       ! 设置扩展段寄存器 0x0000\n    mov cx,#0x1000  ! 计数器\n    sub si,si\n    sub di,di\n    rep \n    movsw\n\n    mov ax,#BOOTSEG\n    mov ds,ax       ! 重新设置数据段寄存器到当前数据段基地址\n    lidt idt_48     ! 设置中断描述符表寄存器\n    lgdt gdt_48     ! 设置全局描述符表寄存器\n\n    mov ax,#0x0001\n    lmsw ax         ! 设置 CR0, 进入保护模式\n    jmpi 0,8\n\ngdt:\n    .word   0,0,0,0\n    .word   0x07FF,0x0000,0x9A00,0x00C0\n    .word   0x07FF,0x0000,0x9200,0x00C0\n\nidt_48:\n    .word   0,0,0\ngdt_48:\n    .word   0x07FF,0x7C00+gdt,0\n\n.org 510\n    .word   0xAA55\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这段汇编程序，通过 \u003ccode\u003eload_system\u003c/code\u003e 标识符标识的这段程序表明需要加载0号磁盘,0号磁头,0号磁道,从第2扇区开始,连续17个扇区的内容(这里将存储支持任务切换的程序)，加载到内存以 0x1000 开始的物理地址处。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econtinue_load\u003c/code\u003e 标识将 0x1000 物理地址开始的 4096 字 (即 8192 字节) 的内容依次复制到以 0x0000 开始的物理地址处。\u003c/p\u003e\n\u003cp\u003e其后，设置 IDT (中断描述符表)、IDTR(中断描述符表寄存器) 及 GDT(全局描述符表)、GDTR(全局描述符表寄存器)，将 CPU 运行模式改成 \u003ccode\u003e保护模式\u003c/code\u003e ，继而将控制权转交给这个被加载进来的程序。\u003c/p\u003e\n\u003ch2\u003e多任务程序\u003c/h2\u003e\n\u003cp\u003e主体内容来自《Linux 内核完全注释》，经过一定量改变以适应当前运行环境\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# head.s\n.code32\nLATCH = 11930\nSCRN_SEL = 0x18\nTSS0_SEL = 0x20\nLDT0_SEL = 0x28\nTSS1_SEL = 0x30\nLDT1_SEL = 0x38\n\n.text\n.globl startup_32\nstartup_32:\n\n    movl $0x00000010,%eax       # 段选择符 2\n    mov %ax,%ds                \n    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP \n\n    call setup_idt              # 设置中断描述符表\n    call setup_gdt              # 设置全局描述符表\n    movl $0x00000010,%eax\n    mov %ax,%ds\n    mov %ax,%es\n    mov %ax,%fs\n    mov %ax,%gs\n    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP\n\n# 设置 8253 定时芯片 10s 一个中断\n    movb $0x36,%al  \n    movl $0x00000043,%edx\n    outb %al,%dx\n    movl $LATCH,%eax\n    movl $0x40,%edx\n    outb %al,%dx\n    movb %ah,%al\n    outb %al,%dx\n\n    movl $0x00080000,%eax       # 重新设置 int 0x08 时钟中断\n    movw $timer_interrupt,%ax\n    movw $0x8E00,%dx\n    movl $0x08,%ecx\n    lea idt(,%ecx,8),%esi\n    movl %eax,(%esi)\n    movl %edx,4(%esi)\n    movw $system_interrupt,%ax  # 重新设置 int 0x80 系统中断\n    movw $0xef00,%dx\n    movl $0x80,%ecx\n    lea idt(,%ecx,8),%esi\n    movl %eax,(%esi)\n    movl %edx,4(%esi)\n\n    pushfl                      # 重置 EFLAGS 嵌套任务标志位\n    andl $0xffffbfff,(%esp)\n    popfl\n    movl $TSS0_SEL,%eax\n    ltr %ax                     # Load Task Register\n    movl $LDT0_SEL,%eax\n    lldt %ax                    # Load Local Descriptor Register\n    movl $0,current\n    sti                         # set interrupt flag\n    pushl $0x17\n    pushl $init_stack\n    pushfl\n    pushl $0x0f\n    pushl $task0\n    iret\n\n\nsetup_gdt:\n    lgdt lgdt_opcode\n    ret\nsetup_idt:\n    lea ignore_int,%edx         # 预先把中断处理程序的偏移地址 ignore_int 存到 EDX\n    movl $0x00080000,%eax       # 预存 0x0008 - 段选择符\n    movw %dx,%ax                # 补上 0-15 位偏移地址\n    movw $0x8E00,%dx            # DX 补上标志位\n    lea idt,%edi\n    mov $256,%ecx\nrp_idt: movl %eax,(%edi)        # 循环 256 遍处理 IDT\n    movl %edx,4(%edi)\n    addl $8,%edi\n    dec %ecx\n    jne rp_idt\n    lidt lidt_opcode\n    ret\n\n\nwrite_char:\n    push %gs\n    pushl %ebx\n    mov $SCRN_SEL,%ebx\n    mov %bx,%gs\n    movl scr_loc,%ebx\n    shl $1,%ebx\n    movb %al,%gs:(%ebx)\n    shr $1,%ebx\n    incl %ebx\n    cmpl $2000,%ebx\n    jb 1f\n    movl $0,%ebx\n1:  movl %ebx,scr_loc\n    popl %ebx\n    pop %gs\n    ret\n\n\n\n.align 4\nignore_int:                 # 默认的中断处理程序\n    push %ds\n    pushl %eax\n    movl $0x10,%eax\n    mov %ax,%ds\n    movl $67,%eax\n    call write_char\n    popl %eax\n    pop %ds\n    iret\n\n\n.align 4\ntimer_interrupt:            # 定时中断处理程序\n    push %ds\n    pushl %eax\n    movl $0x10,%eax\n    mov %ax,%ds\n    movb $0x20,%al\n    outb %al,$0x20\n    movl $1,%eax\n    cmpl %eax,current\n    je 1f\n    movl %eax,current\n    jmp $TSS1_SEL, $0\n    jmp 2f\n1:  movl $0,current\n    jmp $TSS0_SEL, $0\n2:  popl %eax\n    pop %ds\n    iret\n\n\n.align 4\nsystem_interrupt:           # 系统调用中断处理程序\n    push %ds\n    pushl %edx\n    pushl %ecx\n    pushl %ebx\n    pushl %eax\n    movl $0x10,%edx\n    mov %dx,%ds\n    call write_char\n    popl %eax\n    popl %ebx\n    popl %ecx\n    popl %edx\n    pop %ds\n    iret\n\n\ncurrent:.long 0\nscr_loc:.long 0\n\n.align 4\nlidt_opcode:\n    .word 256*8-1\n    .long idt\nlgdt_opcode:\n    .word (end_gdt-gdt)-1\n    .long gdt\n\n.align 8\nidt:    .fill 256,8,0\n\ngdt:    .quad 0x0000000000000000\n        .quad 0x00c09a00000007ff\n        .quad 0x00c09200000007ff\n        .quad 0x00c0920b80000002\n        .word 0x68,tss0,0xe900,0x0\n        .word 0x40,ldt0,0xe200,0x0\n        .word 0x68,tss1,0xe900,0x0\n        .word 0x40,ldt1,0xe200,0x0\nend_gdt:\n        .fill 128,4,0\ninit_stack:\n    .long init_stack\n    .word 0x0010\n\n\n.align 8\nldt0:   .quad 0x0000000000000000\n        .quad 0x00c0fa00000003ff\n        .quad 0x00c0f200000003ff\n\ntss0:   .long 0\n        .long krn_stk0, 0x10\n        .long 0,0,0,0,0\n        .long 0,0,0,0,0\n        .long 0,0,0,0,0\n        .long 0,0,0,0,0,0\n        .long LDT0_SEL,0x8000000\n\n        .fill 128,4,0\nkrn_stk0:\n\n\n.align 8\nldt1:   .quad 0x0000000000000000\n        .quad 0x00c0fa00000003ff\n        .quad 0x00c0f200000003ff\n\ntss1:   .long 0\n        .long krn_stk1,0x10\n        .long 0,0,0,0,0\n        .long task1,0x200\n        .long 0,0,0,0\n        .long usr_stk1,0,0,0\n        .long 0x17,0x0f,0x17,0x17,0x17,0x17\n        .long LDT1_SEL,0x8000000\n\n        .fill 128,4,0\nkrn_stk1:\n\n\ntask0:\n    movl $0x17,%eax\n    movw %ax,%ds\n    mov $65,%al\n    int $0x80\n    movl $0xfff,%ecx\n1:  loop 1b\n    jmp task0\ntask1:\n    mov $66,%al\n    int $0x80\n    movl $0xfff,%ecx\n1:  loop 1b\n    jmp task1\n\n    .fill 128,4,0\nusr_stk1:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的这个程序内容不再详述，想了解细节请参考 《Linux 内核完全注释》\u003c/p\u003e\n\u003cp\u003e下面提供编译 \u003ccode\u003eboot.s\u003c/code\u003e 以及 \u003ccode\u003ehead.s\u003c/code\u003e 的可用 Makefile\u003c/p\u003e\n\u003cp\u003e首先描述一下额外的工具版本\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGNU as : GNU assembler version 2.26.1 \u003c/li\u003e\n\u003cli\u003eGNU ld : GNU ld 2.26.1\n其它内容详见 \u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/\"\u003e理解 Linux Kernel (0)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-makefile\"\u003e# Makefile for the simple example kernel.\nAS86    =as86 -0 -a\nLD86    =ld86 -0\nAS  =as\nASFLAGS =-32\nLD  =ld\nLDFLAGS =-s -x -M -m elf_i386 -e startup_32 -Ttext 0x0\n\nall:    Image\n\nImage: boot system\n    dd bs=32 if=boot of=Image skip=1\n    dd bs=512 if=system of=Image skip=8 seek=1\n    sync\n\ndisk: Image\n    dd bs=8192 if=Image of=/dev/fd0\n    sync;sync;sync\n\nhead.o: \n    $(AS) $(ASFLAGS) -o head.o head.s\n\nsystem: head.o \n    $(LD) $(LDFLAGS) head.o  -o system \u003e System.map\n\nboot:   boot.s\n    $(AS86) -o boot.o boot.s\n    $(LD86) -s -o boot boot.o\n\nclean:\n    rm -f Image System.map core boot *.o system\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e运行结果\u003c/h2\u003e\n\u003cp\u003e想了解更多细节的请自行实操查看吧!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fun1fvafhwg30k40d4x6p.gif\"\u003e\u003c/p\u003e\n\u003ch2\u003e附件\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/understand-kernel-2.zip\"\u003e程序源码\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e概述\u003c/h2\u003e\n\u003cp\u003e《只是为了好玩》一书中，林纳斯描述过他最早的试验性程序就是让 CPU 执行两个不同的任务(一个不断输出A，另一个输出B)，同时不断地让 CPU 在两个任务间的切换。\u003c/p\u003e\n\u003cp\u003e结合《Linux 内核完全注释》一书，得到了多任务切换的示例程序。\u003c/p\u003e\n\u003cp\u003e本节所要描述的内容，正是结合一个框架式的汇编程序(多任务切换程序, 书中提供的内容比较老，无法适应目前的各种工具、环境)，在现有环境中加以处理并成功运行。\u003c/p\u003e\n\u003cp\u003e关于运行环境的说明，欢迎参考 \u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/\"\u003e理解 Linux Kernel (0)\u003c/a\u003e\u003c/p\u003e"},{"url":"2018-08-19-understand-Kernel-1","fileName":"2018-08-19-understand-Kernel-1.md","title":"理解 Linux Kernel (1) - BIOS","author":"fangfeng","date":"2018-08-19T00:00:00.000Z","tags":["Linux","Kernel","BIOS"],"content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e在\u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/\"\u003e概述\u003c/a\u003e，我想我已经介绍过我开始这一些列博文的原因。\n我不能担保我所进行的所有试验性操作都是对的，但是，至少这些在我所描述的环境下成功的运行了起来，并帮助我触及我始终敬畏而又敬而远之的\u003cstrong\u003e硬件\u0026#x26;OS\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在《Linux内核完全注释》一书第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，并最终通过 Bochs 仿真器在模拟开机通电后，BIOS Load\nboot 程序，通过显示器输出 \u003cem\u003eLoading System...\u003c/em\u003e 。\u003c/p\u003e\n\u003cp\u003e这些，将是这里所要描述的主要内容。\u003c/p\u003e\n\u003ch2\u003eboot.s 汇编程序\u003c/h2\u003e\n\u003cp\u003e这里没法多说，都是书中的源码，只是供未读过书的读者参考，特意摘录了下来(不过，就不加注释了)\u003c/p\u003e\n\u003cp\u003eboot.s 源代码\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e.global begtext, begdata, begbss, endtext, enddata, endbss\n.text\nbegtext:\n.data\nbegdata:\n.bss\nbegbss:\n.text\nBOOTSEG=0x07c0\n\nentry start\nstart:\n    jmpi    go,BOOTSEG\ngo: mov ax,cs\n    mov ds,ax\n    mov es,ax\n    mov [msg+17],ah\n    mov cx,#20\n    mov dx,#0x1004\n    mov bx,#0x000c\n    mov bp,#msg\n    mov ax,#0x1301\n    int 0x10\nloop1:  jmp loop1\nmsg:    .ascii  \"Loading System...\"\n        .byte   13,10\n.org    510\n.word   0xAA55\n.text\nendtext:\n.data\nenddata:\n.bss\nendbss:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这段程序的主要的执行流程将是:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e通过 BIOS 加载这段 boot 引导程序\u003c/li\u003e\n\u003cli\u003e红色字体打印 \u003cem\u003eLoading System...\u003c/em\u003e 并响铃\u003c/li\u003e\n\u003cli\u003e指令自循环 (\u003ccode\u003eloop1 jmp loop1\u003c/code\u003e) ，将始终展示上述字样，并不接收命令\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e下面就该把这个汇编程序 \u003cem\u003e编译 + 链接\u003c/em\u003e 成 boot 引导程序。\u003c/p\u003e\n\u003cp\u003e虽然在 macOS 上确实找到了一个 as86 汇编器(来自 nasm 的一个编译选项，但我不知道为什么始终无法正常编译，也可能这个根本就不是我想要的)。\u003c/p\u003e\n\u003cp\u003e通过 docker 容器部署的 Ubuntu，可以很容易地得到一个 as86 汇编程序。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003eapt-get install bin86   # as86, ld86 都在这个包里提供了\n\n# 这句需要在宿主机上执行\ndocker cp boot.s linux:/root/boot.s     # 这里 linux 是我 docker 部署的 Ubuntu 的容器的名称。   如果之前 boot.s 在宿主机上，可以这样拷贝到容器中\n\nas86 -0 -a -o boot.o boot.s             # 编译\n\nld86 -0 -s -o execfile boot.o           # 链接\n\n# 当然，到这里为止，其实都可以理解成在将汇编代码编译链接成可执行程序 (和 boot 引导程序没有太大关系，唯一有关系的就是这段汇编语言是以引导为目的写的)\n\ndd bs=32 if=execfile of=boot skip=1     # 这里去掉可执行程序的前 32 字节，形成刚好 512 字节的 boot 引导程序\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e用仿真器启动引导程序\u003c/h2\u003e\n\u003cp\u003e事实上，这部分内容，我始终没有搞清楚 \u003cstrong\u003e磁盘映像文件\u003c/strong\u003e 和 \u003cstrong\u003eboot 引导程序\u003c/strong\u003e 间的关系(当然还有 floppy 和 ata0~3)\u003c/p\u003e\n\u003cp\u003e在上一节成功拿到 \u003cem\u003e512B\u003c/em\u003e 的 boot 引导程序之后，直接使用这个貌似我也运行成功了(根本就不需要创建磁盘映像文件并将引导程序写入映像文件中，不过，也许只是因为这个引导程序太简单了，根本就不需要其他程序的配合。它最后就是一个死循环 )\u003c/p\u003e\n\u003cp\u003e总之，先按照最简单的来吧。\u003c/p\u003e\n\u003cp\u003e把 boot 引导程序拷贝到宿主机上(貌似频繁地在两个OS上交互文件，这个很无奈，docker容器中的进程难以启动显示程序)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在宿主机新建一个目录 \u003cem\u003elinux-boot\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003e拷贝 boot 引导程序到宿主机上 \u003ccode\u003edocker cp linux:/root/boot linux-boot/\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e在 \u003cem\u003elinux-boot\u003c/em\u003e 下建立 bochsrc 文件(这将是整个仿真器的配置，用于模拟组装机器涉及的 CPU, 内存, BIOS, 显示器等)\u003c/li\u003e\n\u003cli\u003e这里使用的配置文件如下:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-rc\"\u003e# You may now use double quotes around pathnames, in case\n# your pathname includes spaces.\n\ncpu: model=pentium, count=1, ips=50000000, reset_on_triple_fault=1, ignore_bad_msrs=1, msrs=\"msrs.def\"\ncpu: cpuid_limit_winnt=0\n\nmemory: guest=512, host=256\n\nromimage: file=$BXSHARE/BIOS-bochs-legacy, options=fastboot     # BIOS 配置\n\nvgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest\n\nmouse: enabled=0\n\npci: enabled=1, chipset=i440fx\n\nprivate_colormap: enabled=0\n\nfloppya: 1\\_44=\"./boot\", status=inserted         # 装载一个软盘 A ，这里用当前目录下的 boot (boot 引导程序，事实上书中说要用 .img 磁盘映像文件，但这里不影响实际效果)\n\nata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14\nata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15\nata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11\nata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9\n\nboot: a                                         # 配置引导程序所在的磁盘\n\nfloppy_bootsig_check: disabled=0\n\nlog: bochsout.txt\n\npanic: action=ask\nerror: action=report\ninfo: action=report\ndebug: action=ignore, pci=report # report BX_DEBUG from module 'pci'\n\ndebugger_log: -\n\nparport1: enabled=1, file=\"parport.out\"\n\nspeaker: enabled=1, mode=sound\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e当前目录 \u003cem\u003elinux-boot\u003c/em\u003e 下，键入命令 \u003ccode\u003ebochs\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e由于读取到 \u003cem\u003ebochsrc\u003c/em\u003e 配置文件的存在，menu 的默认选项为 6 (开始模拟机器)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003eYou can also start bochs with the -q option to skip these menus.\n\n1. Restore factory default configuration\n2. Read options from...\n3. Edit options\n4. Save options to...\n5. Restore the Bochs state from...\n6. Begin simulation\n7. Quit now\n\nPlease choose one: [6]\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003e直接开始运行机器，键入命令 \u003ccode\u003ec\u003c/code\u003e (这部分在 \u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/\"\u003e概述\u003c/a\u003e 有过了描述，以后将不再描述)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003ePlease choose one: [6]\n00000000000i[      ] lt_dlhandle is 0x7f85d0405ff0\n00000000000i[PLUGIN] loaded plugin libbx_sdl2.so\n00000000000i[      ] installing sdl2 module as the Bochs GUI\n00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800\n00000000000i[      ] using log file bochsout.txt\nNext at t=0\n(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0\n\u0026#x3C;bochs:1\u003e c\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"8\"\u003e\n\u003cli\u003e观察仿真器的表现\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fuf2kicsqyj313y0q0gn4.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eOh, YES! 成功输出了 \u003cem\u003eLoading System...\u003c/em\u003e (不过响铃没有听到，可能与我没有配置 sound 有关)\u003c/p\u003e\n\u003col start=\"9\"\u003e\n\u003cli\u003e关机\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e无需多言，右上角模拟的就是\u003cstrong\u003e关机实体按键\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e在\u003ca href=\"https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/\"\u003e概述\u003c/a\u003e，我想我已经介绍过我开始这一些列博文的原因。\n我不能担保我所进行的所有试验性操作都是对的，但是，至少这些在我所描述的环境下成功的运行了起来，并帮助我触及我始终敬畏而又敬而远之的\u003cstrong\u003e硬件\u0026#x26;OS\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在《Linux内核完全注释》一书第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，并最终通过 Bochs 仿真器在模拟开机通电后，BIOS Load\nboot 程序，通过显示器输出 \u003cem\u003eLoading System...\u003c/em\u003e 。\u003c/p\u003e\n\u003cp\u003e这些，将是这里所要描述的主要内容。\u003c/p\u003e"},{"url":"2018-08-19-understand-Kernel-0","fileName":"2018-08-19-understand-Kernel-0.md","title":"理解 Linux Kernel (0) - 概述","author":"fangfeng","date":"2018-08-19T00:00:00.000Z","tags":["Linux","Kernel"],"content":"\u003ch2\u003e概述\u003c/h2\u003e\n\u003cp\u003e之所以想要了解 Linux Kernel，与前一个月的 JVM ClassFile 的学习有这很大的关联。\u003c/p\u003e\n\u003cp\u003e说实话，刨除 JVM 的具体实现，Sun (或者现在该说是 Oracle) 确实将 Java 的底层逻辑设计得相当简单。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e有限而统一的指令集(不超过 256 个，可以用 1 字节表示)\u003c/li\u003e\n\u003cli\u003e操作数栈+局部变量表共同实现的指令运算\u003c/li\u003e\n\u003cli\u003e高度封装的成员变量/方法的寻址方式\u003c/li\u003e\n\u003cli\u003e... (见识短浅，想不到了...以后再补充吧)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e但是，与 JVM 模拟的虚拟机不同，实体机器有着更为复杂的结构。\n最根本的，不同厂商的机器就带来了不同的 CPU 指令集，这就已经让人难以接受了。\u003c/p\u003e\n\u003cp\u003e其实最初，是想要继续去看看 Hotspot 虚拟机的。但是，混杂的代码(C++, Java, 平台相关各种实现) 带来了很大的阅读障碍。\n最根本的，我甚至找不到一个学习的基本立足点，出发点(当然，也可能我根本就没仔细去看，哈哈)。\u003c/p\u003e\n\u003cp\u003e借着一次机会，我开始看《程序员的自我修养——链接、装载与库》一书。确实无论是 ELF 格式，静态链接与动态链接甚至 Linux 的内建函数\n都给了我比较深刻的印象，向我展示了 C 更深入的一面。但是，macOS 给我带来了比较大的客观阻碍(即使用 Docker 容器得到了一个可用的 Linux 环境，但是否与直接建立在机器上的系统有所区别，此处还得打个问号)。\n同时，书中的部分内容上下不统一，缺少前后文也是一个重大的问题。总之，这并不完全适合我这种初学者逐一进行书中所描述的全部实验。\u003c/p\u003e\n\u003cp\u003e最后，我决定展开对 Linux Kernel 的学习，试图通过对直接构架在硬件上的操作系统进行一番比较深入的学习。\u003c/p\u003e\n\u003cp\u003e期间，找过一些资料，也了解到 Linus Torvals 直接领导着的 \u003ca href=\"https://www.kernel.org/\"\u003eKernel 项目的官网\u003c/a\u003e；甚至，找到了各个版本的 kernel 源码(虽然确实地丢失了最早期 0.XX 的若干版本)。\n不得不说，就目前来讲，我觉得《Linux内核完全注释》是最适合(\u003cem\u003e打个问号，至少暂时是的\u003c/em\u003e)我学习的一书。\u003c/p\u003e\n\u003cp\u003e之后的若干博文，将都以《Linux内核完全注释》中的内容为基础，结合目前的实际需要，从而进行实操性的认知与学习。\u003c/p\u003e\n\u003ch2\u003e软硬件描述\u003c/h2\u003e\n\u003cp\u003e进行这方面的描述，是因为 Linux Kernel 将直接与底层硬件打交道(当然，这方面使用的 Bochs 仿真器)。\n但是，准备诸如 .img (磁盘映像文件), 机器指令文件等都不得不借助于现有的平台。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e操作系统: macOS 10.13.6 , Ubuntu 16.04 (Docker 虚拟机容器)\u003c/li\u003e\n\u003cli\u003e仿真器  : Bochs 2.6.9_2 (macOS 与 Ubuntu 上相同)\u003c/li\u003e\n\u003cli\u003e更多    : 将直接在正文首次使用到时进行说明\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eBochs\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"http://bochs.sourceforge.net/\"\u003eBochs 官网\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://sourceforge.net/projects/bochs/files/\"\u003eBochs 下载链\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e说实话这一周都差不多要被 Bochs 折腾死，用源码进行编译出现各种各样的问题。(我猜新版本根本就没考虑对 macOS 做兼容)\u003c/p\u003e\n\u003cp\u003e最后，不得不使用经编译后的二进制分发版。 \u003ccode\u003ebrew install bochs\u003c/code\u003e 当然了，反正也能用，就不纠结非得自己编译了。(如果哪位能成功编译个 macOS 可用的应用，希望能把踩得坑整理整理，供后来者参考)\u003c/p\u003e\n\u003ch3\u003e目录结构\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e.\n├── CHANGES\n├── COPYING\n├── INSTALL_RECEIPT.json\n├── LICENSE\n├── README\n├── TODO\n├── bin\n│   ├── bochs                           // bochs 可执行文件\n│   └── bximage                         // 制作磁盘映像文件的工具\n├── lib                                 // 动态库目录\n│   └── bochs\n│       └── plugins\n│           ├── libbx_acpi.0.0.0.so\n│           ├── ... 略\n│           └── libbx_vga.so -\u003e libbx_vga.0.0.0.so\n└── share                               // 与体系结构无关的文件放在此目录下\n    ├── bochs\n    │   ├── BIOS-bochs-latest\n    │   ├── BIOS-bochs-legacy\n    │   ├── SeaBIOS-README\n    │   ├── VGABIOS-elpin-2.40\n    │   ├── VGABIOS-elpin-LICENSE\n    │   ├── VGABIOS-lgpl-README\n    │   ├── VGABIOS-lgpl-latest\n    │   ├── VGABIOS-lgpl-latest-cirrus\n    │   ├── VGABIOS-lgpl-latest-cirrus-debug\n    │   ├── VGABIOS-lgpl-latest-debug\n    │   ├── bios.bin-1.7.5\n    │   └── keymaps\n    │       ├── sdl-pc-us.map\n    │       ├── ... 略\n    │       └── x11-pc-us.map\n    ├── doc\n    │   └── bochs\n    │       ├── CHANGES\n    │       ├── COPYING\n    │       ├── LICENSE\n    │       ├── README\n    │       ├── TODO\n    │       ├── bochsrc-sample.txt      // bochsrc 配置文件的示例样板\n    │       └── slirp.conf\n    └── man\n        ├── man1\n        │   ├── bochs-dlx.1.gz\n        │   ├── bochs.1.gz\n        │   └── bximage.1.gz\n        └── man5\n            └── bochsrc.5.gz\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e简单使用\u003c/h3\u003e\n\u003cp\u003eBochs 下载链提供了 Bochs 不同版本的源码的下载，同时也提供了一些可用的磁盘映像文件(都是一些已经经过处理，可用使用进行仿真运行的 OS )\u003c/p\u003e\n\u003cp\u003e说实话，这是绝对有必要进行的一步，不仅仅是了解配置文件 bochsrc 的配置方式，更可用借此了解一下仿真器的使用方式。(在启动系统上，我也被坑了一天，后面细说)\u003c/p\u003e\n\u003cp\u003e首先，这里演示的将是 DLX Linux 。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e下载，解压，进入目录。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e目录下文件如下\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e.\n├── bochsrc.txt         // bochs 启动时将默认通过这个文件读取仿真器配置\n├── hd10meg.img         // 磁盘映像文件\n├── readme.txt\n└── testform.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e启动仿真器\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在 DLX Linux 目录下键入命令 \u003ccode\u003ebochs\u003c/code\u003e, 观察到命令行输出:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e========================================================================\n                       Bochs x86 Emulator 2.6.9\n               Built from SVN snapshot on April 9, 2017\n                  Compiled on May  2 2018 at 13:26:32\n========================================================================\n00000000000i[      ] LTDL_LIBRARY_PATH not set. using compile time default '/usr/local/Cellar/bochs/2.6.9_2/lib/bochs/plugins'\n00000000000i[      ] BXSHARE not set. using compile time default '/usr/local/Cellar/bochs/2.6.9_2/share/bochs'\n00000000000i[      ] lt_dlhandle is 0x7fef2252a500\n00000000000i[PLUGIN] loaded plugin libbx_usb_common.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252a8a0\n00000000000i[PLUGIN] loaded plugin libbx_unmapped.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252ad00\n00000000000i[PLUGIN] loaded plugin libbx_biosdev.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252b1e0\n00000000000i[PLUGIN] loaded plugin libbx_speaker.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252ba50\n00000000000i[PLUGIN] loaded plugin libbx_extfpuirq.so\n00000000000i[      ] lt_dlhandle is 0x7fef2252be70\n00000000000i[PLUGIN] loaded plugin libbx_parallel.so\n00000000000i[      ] lt_dlhandle is 0x7fef238013c0\n00000000000i[PLUGIN] loaded plugin libbx_serial.so\n00000000000i[      ] lt_dlhandle is 0x7fef22706cd0\n00000000000i[PLUGIN] loaded plugin libbx_iodebug.so\n00000000000i[      ] reading configuration from bochsrc.txt\n------------------------------\nBochs Configuration: Main Menu\n------------------------------\n\nThis is the Bochs Configuration Interface, where you can describe the\nmachine that you want to simulate.  Bochs has already searched for a\nconfiguration file (typically called bochsrc.txt) and loaded it if it\ncould be found.  When you are satisfied with the configuration, go\nahead and start the simulation.\n\nYou can also start bochs with the -q option to skip these menus.\n\n1. Restore factory default configuration\n2. Read options from...\n3. Edit options\n4. Save options to...\n5. Restore the Bochs state from...\n6. Begin simulation\n7. Quit now\n\nPlease choose one: [6]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebochs 默认读取当前目录下 \u003ccode\u003ebochsrc.txt\u003c/code\u003e 文件，因此不需要其他配置。\u003c/p\u003e\n\u003cp\u003e选择 6 或者直接 \u003cem\u003e回车\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e00000000000i[      ] lt_dlhandle is 0x7fef22707270\n00000000000i[PLUGIN] loaded plugin libbx_sdl2.so\n00000000000i[      ] installing sdl2 module as the Bochs GUI\n00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800\n00000000000i[      ] using log file bochsout.txt\nNext at t=0\n(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0\n\u0026#x3C;bochs:1\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tNbRwgy1fuevtktuh0j30zc0tcwfd.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e终端出现更多输出，同时 Bochs 开启了一个可视化终端(当然，现在还没有任何内容)。\u003c/p\u003e\n\u003cp\u003e在这儿被坑了好久。本来以为 Bochs 会直接执行 BIOS 指令，启动操作系统，但是自始至终，停在这里就没动过...\u003c/p\u003e\n\u003cp\u003e这边是由于 Bochs 本身是支持调试的(T_T，见鬼)，就像是 GDB 和 LLDB 一样，进入调试后，需要指令 \u003ccode\u003ec\u003c/code\u003e (continue) 来继续执行(当然，还有其它调试命令)\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e键入 \u003ccode\u003ec\u003c/code\u003e \u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e\u0026#x3C;bochs:1\u003e c\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e仿真器开始引导程序的加载\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fuew9zoocuj313c0pstaw.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eOS Kernel 启动，等待用户登录 (默认的用户是 root , 没有密码)。\n之后就和普通的 Linux 机器类似，不过支持的命令比较少。毕竟是一个精简后的系统。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fuewamqzm6j313q0pqjtw.jpg\"\u003e\u003c/p\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e关机\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNbRwgy1fuewi9wjawj313q0q2gnc.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e仿真器仿真了许多实体机案件，右上角最后一个就是关机键\u003c/p\u003e\n\u003ch2\u003eDocker 容器中运行 Ubuntu\u003c/h2\u003e\n\u003cp\u003e这部分不详述，作为一个热门的技术，这方面的资料很多。Ubuntu 系统只是为了来执行一些 macOS 上没有的命令的(比如 \u003ccode\u003eas86\u003c/code\u003e, \u003ccode\u003eld86\u003c/code\u003e)\u003c/p\u003e\n\u003cp\u003e简述两个 docker 容器和宿主机间复制文件的命令 \u003c/p\u003e\n\u003cp\u003e在宿主机下执行命令:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003edocker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-\ndocker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH [flags]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e例如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003edocker cp linux:/root/hello.c ./hello.c         # 这里 linux 是 docker 容器名\ndocker cp 92dfc8ad70e1:/root/hello.c ./hello.c  # 这里 92dfc8ad70e1 是 docker 容器 ID\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e[1]. 俞甲子. 程序员的自我修养[M]. 电子工业出版社, 2009.\n[2]. 赵炯. Linux内核完全注释 内核版本0.11 V3.0[EB/OL]. \u003ca href=\"http://www.oldlinux.org/\"\u003ehttp://www.oldlinux.org/\u003c/a\u003e, 2007\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e概述\u003c/h2\u003e\n\u003cp\u003e之所以想要了解 Linux Kernel，与前一个月的 JVM ClassFile 的学习有这很大的关联。\u003c/p\u003e\n\u003cp\u003e说实话，刨除 JVM 的具体实现，Sun (或者现在该说是 Oracle) 确实将 Java 的底层逻辑设计得相当简单。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e有限而统一的指令集(不超过 256 个，可以用 1 字节表示)\u003c/li\u003e\n\u003cli\u003e操作数栈+局部变量表共同实现的指令运算\u003c/li\u003e\n\u003cli\u003e高度封装的成员变量/方法的寻址方式\u003c/li\u003e\n\u003cli\u003e... (见识短浅，想不到了...以后再补充吧)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e但是，与 JVM 模拟的虚拟机不同，实体机器有着更为复杂的结构。\n最根本的，不同厂商的机器就带来了不同的 CPU 指令集，这就已经让人难以接受了。\u003c/p\u003e\n\u003cp\u003e其实最初，是想要继续去看看 Hotspot 虚拟机的。但是，混杂的代码(C++, Java, 平台相关各种实现) 带来了很大的阅读障碍。\n最根本的，我甚至找不到一个学习的基本立足点，出发点(当然，也可能我根本就没仔细去看，哈哈)。\u003c/p\u003e\n\u003cp\u003e借着一次机会，我开始看《程序员的自我修养——链接、装载与库》一书。确实无论是 ELF 格式，静态链接与动态链接甚至 Linux 的内建函数\n都给了我比较深刻的印象，向我展示了 C 更深入的一面。但是，macOS 给我带来了比较大的客观阻碍(即使用 Docker 容器得到了一个可用的 Linux 环境，但是否与直接建立在机器上的系统有所区别，此处还得打个问号)。\n同时，书中的部分内容上下不统一，缺少前后文也是一个重大的问题。总之，这并不完全适合我这种初学者逐一进行书中所描述的全部实验。\u003c/p\u003e\n\u003cp\u003e最后，我决定展开对 Linux Kernel 的学习，试图通过对直接构架在硬件上的操作系统进行一番比较深入的学习。\u003c/p\u003e\n\u003cp\u003e期间，找过一些资料，也了解到 Linus Torvals 直接领导着的 \u003ca href=\"https://www.kernel.org/\"\u003eKernel 项目的官网\u003c/a\u003e；甚至，找到了各个版本的 kernel 源码(虽然确实地丢失了最早期 0.XX 的若干版本)。\n不得不说，就目前来讲，我觉得《Linux内核完全注释》是最适合(\u003cem\u003e打个问号，至少暂时是的\u003c/em\u003e)我学习的一书。\u003c/p\u003e\n\u003cp\u003e之后的若干博文，将都以《Linux内核完全注释》中的内容为基础，结合目前的实际需要，从而进行实操性的认知与学习。\u003c/p\u003e"},{"url":"2018-08-15-Java-Instrumentation","fileName":"2018-08-15-Java-Instrumentation.md","title":"Java Instrumentation","author":"fangfeng","date":"2018-08-15T00:00:00.000Z","tags":["Java","ASM","BTrace"],"content":"\u003ch2\u003eStart\u003c/h2\u003e\n\u003cp\u003e从现有的前置知识来说，我们能够认识到两个事实:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eJava Class 通过 ClassLoader 进行加载。\n通过\u003ccode\u003e全限定名\u003c/code\u003e进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。\n换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)\u003c/li\u003e\n\u003cli\u003e有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。\n当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧\n(虽然可能不了解细节。在此，欢迎学习前置技能 \u003ca href=\"https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/\"\u003eCGlib Enhancer 主流程源码解析\u003c/a\u003e 和 \u003ca href=\"https://dormouse-none.github.io/2018-07-20-Java-Proxy/\"\u003eJava Proxy 源码解析\u003c/a\u003e。不过不影响本文后续内容)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e另一个方面，也许绝大多数人都听说过所谓的\u003ccode\u003e热部署\u003c/code\u003e。但是究竟怎么才能做到 \u003ccode\u003e热部署\u003c/code\u003e(话题开得有点大哈。Y_Y 本文不讲这个)\u003c/p\u003e\n\u003cp\u003e操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。\u003c/p\u003e\n\u003cp\u003e如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚...\u003c/p\u003e\n\u003cp\u003eJava 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的\u003c/p\u003e\n\u003ch2\u003eInstrumentation\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ejava.lang.instrument.Instrumentation\u003c/code\u003e 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)\u003c/p\u003e\n\u003cp\u003e相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。\u003c/p\u003e\n\u003cp\u003e下列有两种方法可以达到目的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。\u003c/li\u003e\n\u003cli\u003e当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了\u003cem\u003e检测\u003c/em\u003e的目的)的使用\u003c/p\u003e\n\u003ch2\u003e对各方法进行执行时间统计\u003c/h2\u003e\n\u003ch3\u003e随 JVM 一起启动\u003c/h3\u003e\n\u003cp\u003e基本实例: 将对特定包 \u003ccode\u003eme.fangfeng.client\u003c/code\u003e 下的每个方法执行计时\u003c/p\u003e\n\u003cp\u003e首先了解一下 client 包的内容:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage me.fangfeng.client;\n\n/**\n * Main.java\n * 执行两个方法，rand() \u0026#x26; sleep() \n *\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class Main {\n\n    static void sleep() {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Rand rand = new Rand();\n\n        for (int i=0;i\u0026#x3C;10;i++) {\n            System.out.println(\"\u003e\u003e\u003e start Rand.run() \u0026#x3C;\u0026#x3C;\u0026#x3C;\");\n            rand.run();\n            System.out.println(\"\u003e\u003e\u003e end Rand.run() \u0026#x3C;\u0026#x3C;\u0026#x3C;\");\n\n            System.out.println();\n\n            System.out.println(\"\u003e\u003e\u003e start Main.sleep() \u0026#x3C;\u0026#x3C;\u0026#x3C;\");\n            Main.sleep();\n            System.out.println(\"\u003e\u003e\u003e end MAin.sleep() \u0026#x3C;\u0026#x3C;\u0026#x3C;\");\n\n            System.out.println();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage me.fangfeng.client;\n\n/**\n * Rand.java\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class Rand {\n\n    public void run() {\n        while (true) {\n            double rand = Math.random();\n            if (rand \u003e 0.995) {\n                System.out.println(String.format(\"get random, values %f\", rand));\n                return;\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接着，来构造一个代理类，以及最重要的 \u003ccode\u003epremain\u003c/code\u003e 方法\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage me.fangfeng.javaagent;\n\nimport java.lang.instrument.Instrumentation;\n\n/**\n * Agent - 代理\n * 基于 JVM TI (JVM Tool Interface) 实现的 Java ClassFile 的增强\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class Agent {\n\n    // premain 将 JVM 初始化后，main(String... ) 执行前调用\n    public static void premain(String args, Instrumentation instrumentation) {\n        // new 一个转换器实例\n        ClassTimer transformer = new ClassTimer();\n        instrumentation.addTransformer(transformer);\n    }\n\n    // 之后的 agentmain(...) 将在这里提供，暂时隐去，避免对对读者产生干扰\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage me.fangfeng.javaagent;\n\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.Opcodes;\n\nimport java.lang.instrument.ClassFileTransformer;\nimport java.security.ProtectionDomain;\n\n/**\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class ClassTimer implements ClassFileTransformer {\n\n    @Override\n    public byte[] transform(ClassLoader loader, String className, Class\u0026#x3C;?\u003e classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {\n        // 这里涉及到了 ASM 的内容，主要目的是向每个方法块的开始及方法块的结束部分插入与计时器有关的代码\n        // 如果想了解 ASM 的内容，请参阅 https://dormouse-none.github.io/2018-06-25-ASM-Core/  提供了一些基础性的内容，更多的请自行学习\n        // 不了解具体内容将不影响对主体内容的理解\n        ClassReader cr = new ClassReader(classfileBuffer);\n        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n        MyClassWriter mcw = new MyClassWriter(Opcodes.ASM6, cw);\n        cr.accept(mcw, ClassReader.EXPAND_FRAMES);\n        return cw.toByteArray();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其它代码略，详见附件。\u003c/p\u003e\n\u003cp\u003eJava 这种对操作字节码的支持有个坑爹的地方，就是不得不打包成 Jar 来使用。\u003c/p\u003e\n\u003cp\u003e具体来看一下\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eme.fangfeng.javaagent\u003c/code\u003e 包中包括 \u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fublsbbdw0j309o07g74u.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e将被打包成 \u003ccode\u003eagent.jar\u003c/code\u003e 来使用\u003c/p\u003e\n\u003cp\u003e首先，来看一下需要打包在 \u003ccode\u003eagent.jar\u003c/code\u003e 的 \u003cstrong\u003eMANIFEST.MF\u003c/strong\u003e 的内容\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eManifest-Version: 1.0\nClass-Path: /Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar\nPremain-Class: me.fangfeng.javaagent.Agent\nCan-Retransform-Classes: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再来个 SHELL 脚本，用来给打包这个 Jar\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e#!/bin/bash\n\n# 编译 me.fangfeng.javaagent 包下的类\njavac -cp .:/Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar me/fangfeng/javaagent/Agent.java me/fangfeng/javaagent/ClassTimer.java me/fangfeng/javaagent/MyClassWriter.java me/fangfeng/javaagent/MyMethodWriter.java me/fangfeng/javaagent/StaticTimer.java\n\n# 打包 me.fangfeng.javaagent 的 .class -\u003e agent.jar\njar cvfm agent.jar MANIFEST-agent.MF me/fangfeng/javaagent/Agent.class me/fangfeng/javaagent/ClassTimer.class me/fangfeng/javaagent/MyClassWriter.class me/fangfeng/javaagent/MyMethodWriter.class me/fangfeng/javaagent/StaticTimer.class\n\n# 编译 me.fangfeng.client 包下的类\njavac me/fangfeng/client/Main.java me/fangfeng/client/Rand.java\n\n# 以 me.fangfeng.client.Main 作为主类启动\njava -javaagent:agent.jar me.fangfeng.client.Main\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e执行后，可以看到类似如下内容:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fubmp354ejj30tq0rmtdp.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e而直接用 \u003ccode\u003ejava me.fangfeng.client.Main\u003c/code\u003e 的执行结果是:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fubmqmj4uhj30j00f0dho.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e从理论上来讲，\u003ccode\u003e-javaagent:agent.jar\u003c/code\u003e 配合 \u003ccode\u003eagent.jar\u003c/code\u003e 中的 MANIFEST.MF 文件，\n使得 JVM 在初始化之后触发了被声明为 \u003ccode\u003ePre-Main\u003c/code\u003e 的 me.fangfeng.javaagent.Agent 类的 premain(...) 方法。\u003c/p\u003e\n\u003cp\u003e并为 ClassLoader 在加载类的流程上增加了一层\u003cstrong\u003e拦截器\u003c/strong\u003e (这里是 ClassTimer.java 类，它实现了 \u003ccode\u003eClassFileTransformer\u003c/code\u003e 接口\u003c/p\u003e\n\u003cp\u003e另外，\u003ccode\u003eCan-Retransform-Classes: true\u003c/code\u003e 的配置使得 ClassTimer 被允许对字节码进行重新转换。(而操作字节码是通过 ASM 来实现的)\u003c/p\u003e\n\u003ch3\u003e在运行中进行增强\u003c/h3\u003e\n\u003cp\u003e随着程序启动时直接使用了 \u003ccode\u003e-javaagent\u003c/code\u003e 选项。\u003c/p\u003e\n\u003cp\u003e那么是否存在在程序运行中进行额外代理操作的支持呢？当然是可以的。这里要借助 Java 提供的另一个类 com.sun.tools.attach.VirtualMachine 。\u003c/p\u003e\n\u003cp\u003e启动一个新的进程来连接到 正在运行中的进程，并令其加载 java agent。\u003c/p\u003e\n\u003cp\u003e基本的类与上一节的描述相同，主要是包 \u003ccode\u003eme.fangfeng.javaagent.*\u003c/code\u003e 和 \u003ccode\u003eme.fangfeng.client.*\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e新增一个类 \u003ccode\u003eme.fangfeng.javaagent.Main\u003c/code\u003e 用来启动另一个进程，并要求运行中的 java 进程加载 agent.jar 来进行增强。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage me.fangfeng.javaagent;\n\nimport com.sun.tools.attach.AgentInitializationException;\nimport com.sun.tools.attach.AgentLoadException;\nimport com.sun.tools.attach.AttachNotSupportedException;\nimport com.sun.tools.attach.VirtualMachine;\n\nimport java.io.IOException;\n\n/**\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class Main {\n\n    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException {\n        VirtualMachine vm = null;\n        try {\n            // 通过 VirtualMachine 连接到 运行中的进程 (可以通过 jps 找到进程号)\n            vm = VirtualMachine.attach(\u0026#x3C;PID\u003e);\n            vm.loadAgent(\u0026#x3C;agent.jar 的路径\u003e);\n        } finally {\n            if (vm != null) {\n                vm.detach();\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Agent {\n\n    public static void premain(String args, Instrumentation instrumentation) {\n        ClassTimer transformer = new ClassTimer();\n        instrumentation.addTransformer(transformer);\n    }\n\n    // 现在在 Agent.java 上补上 agentmain(...) 的具体实现\n    public static void agentmain(String args, Instrumentation instrumentation) throws UnmodifiableClassException {\n        System.out.println(\"SUCCESS AGENTMAIN\");\n        ClassTimer transformer = new ClassTimer();\n        // add Transformer\n        instrumentation.addTransformer(transformer, true);\n        // 对 Rand.class 进行重新转换\n        instrumentation.retransformClasses(Rand.class);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其它内容基本相同\u003c/p\u003e\n\u003cp\u003e首先需要先打包 agent.jar 。当然，如果是顺着本文的顺序进行本机实验，则 agent.jar 已经存在\u003c/p\u003e\n\u003cp\u003e先启动进程 \u003ccode\u003ejava me.fangfeng.client.Main\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e通过 \u003ccode\u003ejps\u003c/code\u003e 获取 Main 进程的 \u003cstrong\u003ePID\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 \u003ccode\u003ejava me.fangfeng.javaagent.Main\u003c/code\u003e 中替换上进程号，并执行\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fuboclcelsj30tu152dlw.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e从执行结果可以看到，原进程首先正常执行代码，等到被 load Agent 之后，字节码已经有了新的变化，从而导致输出结果动态的产生了变化。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e当然，需要注意的是，执行中的进程被要求 load Agent 之后，运行中的 Class 将被改写，并始终如此，知道进程终止。再下一次重新启动\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003eBTrace\u003c/h2\u003e\n\u003cp\u003e以上描述的内容也可以理解为是 BTrace 实现的基础。毕竟，JVMTI (JVM Tool Interface) 原本的目的就是赋予使用者一个在运行中\n查询系统各项数据的权利\u003c/p\u003e\n\u003cp\u003e当然，实现上，上述代码直接将各种增强(计时)硬编码到该进程中，同时统一使用了该进程的输入输出。\u003c/p\u003e\n\u003cp\u003e但是，BTrace 通过 Socket 将这些分离，检测代码通过 Socket 发回新的进程来维持输入输出。\u003c/p\u003e\n\u003cp\u003e在此，不再细说。\u003c/p\u003e\n\u003ch2\u003e附录\u003c/h2\u003e\n\u003cp\u003e[1]. 示例代码: \u003ca href=\"https://github.com/DorMOUSE-None/Repo/raw/master/instru.zip\"\u003einstru.zip\u003c/a\u003e\n[2]. \u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html\"\u003ejava.lang.instrument.Instrumentation\u003c/a\u003e\n[3]. \u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html\"\u003ePackage java.lang.instrument\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003eStart\u003c/h2\u003e\n\u003cp\u003e从现有的前置知识来说，我们能够认识到两个事实:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eJava Class 通过 ClassLoader 进行加载。\n通过\u003ccode\u003e全限定名\u003c/code\u003e进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。\n换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)\u003c/li\u003e\n\u003cli\u003e有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。\n当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧\n(虽然可能不了解细节。在此，欢迎学习前置技能 \u003ca href=\"https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/\"\u003eCGlib Enhancer 主流程源码解析\u003c/a\u003e 和 \u003ca href=\"https://dormouse-none.github.io/2018-07-20-Java-Proxy/\"\u003eJava Proxy 源码解析\u003c/a\u003e。不过不影响本文后续内容)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e另一个方面，也许绝大多数人都听说过所谓的\u003ccode\u003e热部署\u003c/code\u003e。但是究竟怎么才能做到 \u003ccode\u003e热部署\u003c/code\u003e(话题开得有点大哈。Y_Y 本文不讲这个)\u003c/p\u003e\n\u003cp\u003e操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。\u003c/p\u003e\n\u003cp\u003e如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚...\u003c/p\u003e\n\u003cp\u003eJava 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的\u003c/p\u003e\n\u003ch2\u003eInstrumentation\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ejava.lang.instrument.Instrumentation\u003c/code\u003e 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)\u003c/p\u003e\n\u003cp\u003e相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。\u003c/p\u003e\n\u003cp\u003e下列有两种方法可以达到目的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。\u003c/li\u003e\n\u003cli\u003e当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了\u003cem\u003e检测\u003c/em\u003e的目的)的使用\u003c/p\u003e"},{"url":"2018-07-24-JVM-Instruction","fileName":"2018-07-24-JVM-Instruction.md","title":"JVM 指令简析","author":"fangfeng","date":"2018-07-24T00:00:00.000Z","tags":["JVM","Instruction"],"content":"\u003cp\u003e在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。\u003c/p\u003e\n\u003cp\u003e当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。\n那么，直接阅读 \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\"\u003e官方文档\u003c/a\u003e 绝对是比本文的内容更为详实且准确。\u003c/p\u003e\n\u003cp\u003e这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。\u003c/p\u003e\n\u003ch2\u003e术语约定\u003c/h2\u003e\n\u003cp\u003e首先，需要就 \u003ccode\u003e术语\u003c/code\u003e 进行一些基础性的约定:\u003c/p\u003e\n\u003ch3\u003e变量\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNc79gy1ftidi0xpmij30oa07kaaq.jpg\" alt=\"变量\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e变量\u003c/code\u003e: 在类中，区分于 \u003ccode\u003e方法\u003c/code\u003e 的声明\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e成员变量\u003c/code\u003e: 作用域为整个类，在方法体与语句块之外声明的内容。在 \u003ccode\u003e字节码\u003c/code\u003e 中通常被称为 \u003ccode\u003e字段(Field)\u003c/code\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e类成员变量 / 静态成员变量\u003c/code\u003e: 被 \u003ccode\u003estatic\u003c/code\u003e 修饰的 \u003ccode\u003e成员变量\u003c/code\u003e。一个类只有一份，在类被加载的时候即初始化。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e实例成员变量\u003c/code\u003e: 非 \u003ccode\u003estatic\u003c/code\u003e 修饰的 \u003ccode\u003e成员变量\u003c/code\u003e。随着类被实例化而进行初始化，每个实例对象都有一份特有的 \u003ccode\u003e实例变量\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e局部变量\u003c/code\u003e: 作用域为方法体或者语句块。\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eJVM 指令\u003c/h3\u003e\n\u003cp\u003e通常，我们借助于 \u003ccode\u003ejavap\u003c/code\u003e 命令来对 .class 文件的字节码内容进行查阅。\u003c/p\u003e\n\u003cp\u003e类似于汇编代码，\u003ccode\u003ejavap\u003c/code\u003e 打印的JVM 指令将以下列格式进行展示:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e\u0026#x3C;index\u003e \u0026#x3C;opcode\u003e [\u0026#x3C;operand1\u003e [\u0026#x3C;operand2\u003e ...]] [\u0026#x3C;comment\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中 \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;index\u003e\u003c/code\u003e 指在 \u003ccode\u003ecode[]\u003c/code\u003e 属性中这条指令的偏移量(从 0 开始计数)。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;opcode\u003e\u003c/code\u003e 指 \u003ccode\u003e操作码\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;operandX\u003e\u003c/code\u003e 指 \u003ccode\u003e操作数\u003c/code\u003e，每个 \u003ccode\u003e\u0026#x3C;opcode\u003e\u003c/code\u003e 都需要确定数量的操作数(规范中已经确定)。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;comment\u003e\u003c/code\u003e 指注释\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e指令集概览\u003c/h2\u003e\n\u003cp\u003e首先，Java 代码经编译后的所有指令都基于 \u003ccode\u003e方法(Method)\u003c/code\u003e 被定义在 \u003ccode\u003eCode\u003c/code\u003e 属性中。\u003c/p\u003e\n\u003cp\u003e在 \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3\"\u003eClassFile\u003c/a\u003e 的 \u003ccode\u003eCode\u003c/code\u003e 属性，结构定义如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCode_attribute {\n    // 其中 u1, u2, u4 分别表示这个变量所占的字节长度\n    u2 attribute_name_index;                    // 属性名在常量池中的 index (执行常量池中 Code 的位置)\n    u4 attribute_length;                        // 属性长度，不包括开始的六个字节\n    u2 max_stack;                               // 运行时操作数栈的最大深度\n    u2 max_locals;                              // 运行时所需的局部变量表的大小\n    u4 code_length;                             // code 数组的长度\n    u1 code[code_length];                       // code 数组，编译后方法体的内容都通过字节码指令存储在这里\n    u2 exception_table_length;                  // 异常表的长度\n    {   u2 start_pc;\n        u2 end_pc;\n        u2 handler_pc;\n        u2 catch_type;\n    } exception_table[exception_table_length]; // 异常表，Java 代码中所有的 catch, finally 的捕获都将由此表进行实现\n    u2 attributes_count;                       // 属性计数\n    attribute_info attributes[attributes_count];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJava 虚拟机的指令是由一个字节长度的 \u003ccode\u003e操作码\u003c/code\u003e 配合上其后的 0 个或多个 \u003ccode\u003e操作数\u003c/code\u003e 所构成的。\u003c/p\u003e\n\u003cp\u003e其中，\u003ccode\u003e操作数\u003c/code\u003e 的数量取决于 \u003ccode\u003e操作码\u003c/code\u003e，不同的 \u003ccode\u003e操作码\u003c/code\u003e 需要不同数量的 \u003ccode\u003e操作数\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e按照类型划分，\u003ccode\u003e操作数\u003c/code\u003e 主要包括下列几类:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e加载与存储指令，例如 iload, istore 等\u003c/li\u003e\n\u003cli\u003e运算指令，例如 iadd, isub, imul 等\u003c/li\u003e\n\u003cli\u003e类型转换指令，例如 i2b, i2s 等\u003c/li\u003e\n\u003cli\u003e对象创建与操作指令，例如 new, newarray 等\u003c/li\u003e\n\u003cli\u003e操作数栈管理指令，例如 dup, pop 等\u003c/li\u003e\n\u003cli\u003e控制转移指令，例如 if_icmpeq 等\u003c/li\u003e\n\u003cli\u003e方法调用与返回指令，例如 invokevirtual, invokestatic 等\u003c/li\u003e\n\u003cli\u003e抛出异常指令，例如 athrow 等\u003c/li\u003e\n\u003cli\u003e同步指令，例如 monitorenter 等\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e举几个简单的例子:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eiadd\u003c/code\u003e 指令，表示对两个 int 数的相加指令。将从操作数栈顶依次取出两个数，并相加，再重新压入操作数栈中。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebipush 100\u003c/code\u003e ，其中 \u003ccode\u003ebipush\u003c/code\u003e 是指令，后随一个操作数，表示把 \u003ccode\u003e操作数 100 这个 byte 类型的数\u003c/code\u003e 压入操作数栈顶\u003c/p\u003e\n\u003ch2\u003e运行时数据区\u003c/h2\u003e\n\u003cp\u003eJVM 定义了若干种运行期间会使用到的运行时数据区，见下图:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg\" alt=\"JVM 运行时数据区\"\u003e\u003c/p\u003e\n\u003cp\u003e至于每一个的具体意义，在此不做详细展开，可用参考:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e由周志明等翻译的 《Java 虚拟机规范(Java SE 7版) 》 2.5节内容 \u003ca href=\"http://icyfenix.iteye.com/blog/1256329\"\u003e链接\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5\"\u003eJVMS 2.5. Run-Time Data Areas\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eGetter, Setter 的指令代码\u003c/h2\u003e\n\u003cp\u003e首先，有必要提及，想要得到 .class 可视且友好的展示结果，可以使用 JDK 自带的 \u003ccode\u003ejavap\u003c/code\u003e 命令。\u003c/p\u003e\n\u003cp\u003e本节要展示的内容是常见的 POJO 的 get, set 方法的指令代码。使用的示例代码如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Test {\n    \n    private int number;\n\n    public int getNumber() {\n        return number;\n    }\n\n    public void setNumber(int number) {\n        this.number = number;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在经过 \u003ccode\u003ejavac\u003c/code\u003e 编译，\u003ccode\u003ejavap\u003c/code\u003e 解析之后，我们将看到下列内容\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003eClassfile /Users/fangfeng/WorkPkg/lab/src/main/java/me/fangfeng/asm/Test.class\n  Last modified Jul 23, 2018; size 357 bytes\n  MD5 checksum bb1940cc6534d789359295b8dc80233b\n  Compiled from \"Test.java\"\npublic class me.fangfeng.asm.Test\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #4.#17         // java/lang/Object.\"\u0026#x3C;init\u003e\":()V\n   #2 = Fieldref           #3.#18         // me/fangfeng/asm/Test.number:I\n   #3 = Class              #19            // me/fangfeng/asm/Test\n   #4 = Class              #20            // java/lang/Object\n   #5 = Utf8               number\n   #6 = Utf8               I\n   #7 = Utf8               \u0026#x3C;init\u003e\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               getNumber\n  #12 = Utf8               ()I\n  #13 = Utf8               setNumber\n  #14 = Utf8               (I)V\n  #15 = Utf8               SourceFile\n  #16 = Utf8               Test.java\n  #17 = NameAndType        #7:#8          // \"\u0026#x3C;init\u003e\":()V\n  #18 = NameAndType        #5:#6          // number:I\n  #19 = Utf8               me/fangfeng/asm/Test\n  #20 = Utf8               java/lang/Object\n{\n  public me.fangfeng.asm.Test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"\u0026#x3C;init\u003e\":()V\n         4: return\n      LineNumberTable:\n        line 3: 0\n\n  public int getNumber();\n    descriptor: ()I\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field number:I\n         4: ireturn\n      LineNumberTable:\n        line 8: 0\n\n  public void setNumber(int);\n    descriptor: (I)V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=2\n         0: aload_0\n         1: iload_1\n         2: putfield      #2                  // Field number:I\n         5: return\n      LineNumberTable:\n        line 12: 0\n        line 13: 5\n}\nSourceFile: \"Test.java\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e打印出来的内容包括有 类的全限定名，访问控制权限，父类，接口，常量池以及各个方法。\u003c/p\u003e\n\u003cp\u003e以 \u003ccode\u003egetNumber\u003c/code\u003e 为例:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003epublic int getNumber();\n  descriptor: ()I\n  flags: ACC_PUBLIC\n  Code:\n    stack=1, locals=1, args_size=1\n       0: aload_0\n       1: getfield      #2                  // Field number:I\n       4: ireturn\n    LineNumberTable:\n      line 8: 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003edescriptor: 表示方法描述符，其中 \u003ccode\u003e()\u003c/code\u003e 内容表示入参，\u003ccode\u003eI\u003c/code\u003e 表示返回值的类型\u003c/li\u003e\n\u003cli\u003eflags     : 表示方法的访问权限，当前限定为 \u003ccode\u003epublic\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eCode      : 存储有当前方法体指令码的一种方法内部属性。\u003cul\u003e\n\u003cli\u003estack : 表示当前方法(意即在运行时所处的栈帧，每个方法的调用都将在 \u003ccode\u003e虚拟机栈\u003c/code\u003e 中构建一个新的 \u003ccode\u003e栈帧\u003c/code\u003e) 使用的 \u003ccode\u003e操作数栈的最大深度\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003elocals: 表示当前方法使用的 \u003ccode\u003e局部变量表\u003c/code\u003e 的大小\u003c/li\u003e\n\u003cli\u003eargs_size : 表示变量个数\u003c/li\u003e\n\u003cli\u003eLineNumberTable : 与 Debug 有关，指当前的的指令集在源文件中的第几行开始\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中\n1: getfield #2          // 获取常量池中 2 号元素(即 Field number:I) 的值，并加载到操作数栈中\n4: ireturn              // 抛出当前操作数栈顶元素作为返回值\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中，每条指令前的 0, 1, 4 指当前指令作为 \u003ccode\u003eCode\u003c/code\u003e 属性的内容的偏移量。\u003c/p\u003e\n\u003cp\u003e换一句话说，\u003ccode\u003eaload_0\u003c/code\u003e 是 Code 属性 code[] 的第 0 个字节的内容\n\u003ccode\u003egetfield #2\u003c/code\u003e 的是从 code[] 的第 1 个字节开始的。\n\u003ccode\u003eireturn\u003c/code\u003e 是从 code[] 的第 4 个字节开始。\u003c/p\u003e\n\u003cp\u003e至于为什么每条指令的开始位置不同，这取决于每条指令的长度。\u003ccode\u003eaload_0\u003c/code\u003e 指令本身为 1 字节的长度，且不要求附带操作数。\n\u003ccode\u003egetfield\u003c/code\u003e 指令自长 1 个字节，但需要一个长度为 2 字节的常量池索引。因此 \u003ccode\u003eireturn\u003c/code\u003e 将从第 4 字节开始\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e同时，可能有人会有所疑问，\u003ccode\u003eaload_0\u003c/code\u003e 加载的 0 号元素是什么？它貌似没有被用到？\u003c/p\u003e\n\u003cp\u003e首先，在每个方法被触发，在构建新的栈帧时，\u003ccode\u003ethis\u003c/code\u003e 将自动作为 0 号元素被存入新栈帧的局部变量表作为 0 号元素。\n同时，如果方法有入参，则入参按入参声明顺序依次作为 1, 2, 3, ... 元素存入。\n(当然，这里存在特殊情况，诸如 long, double 这样长为 8 字节的元素，将占用 2 个局部变量表的数组下标，而其他元素顺延)。\u003c/p\u003e\n\u003cp\u003e至于看似 0 号元素 \u003ccode\u003ethis\u003c/code\u003e 并没有被用到。事实上，它是作为 \u003ccode\u003egetfield\u003c/code\u003e 的一个限定被使用的。\n试想，\u003ccode\u003egetfield\u003c/code\u003e 虽然通过 \u003ccode\u003e#2\u003c/code\u003e 能够知道需要获取到的变量名为 \u003ccode\u003enumber\u003c/code\u003e 类型为 \u003ccode\u003eI(即 int)\u003c/code\u003e 的元素。但是，这个元素究竟属于哪个实例？\n而操作数栈顶的 \u003ccode\u003ethis\u003c/code\u003e 恰恰是指明，需要使用当前方法所在的类的 number 变量。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e类似的，我们看一下 \u003ccode\u003esetNumber\u003c/code\u003e 方法\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中 (用于确定字段所属的类)\n1: iload_1              // 从局部变量表中加载 1 号元素到操作数栈中 (用于确定将要给字段赋的值)\n2: putfield      #2     // 获取常量池中 2 号元素(即 Field number:I) 的地址，并赋值\n5: return               // 无返回值的 return 指令来结束当前栈帧的执行\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e给变量赋初始值\u003c/h2\u003e\n\u003cp\u003e经常会见到在方法体内部有类似这样的声明 \u003ccode\u003eint score = 100\u003c/code\u003e ，那么这样的内容翻译成指令会是如何？\u003c/p\u003e\n\u003cp\u003e对于较小的值，例如 100，将通过 \u003ccode\u003ebipush 100\u003c/code\u003e, \u003ccode\u003eistore_1(假设用局部变量表 1 号元素存储 score 变量\u003c/code\u003e 类似的形式进行赋值。\n类似的，还是 \u003ccode\u003esipush\u003c/code\u003e ，两者的区别是 bipush 可以支持 1 字节大小的整数，sipush 支持 2 字节大小的整数。\u003c/p\u003e\n\u003cp\u003e但是，int 最大可是可以到达 4 字节，更甚者，long 将达到 8 字节。\u003c/p\u003e\n\u003cp\u003e这时候，将要借助的就是 \u003ccode\u003eldc #\u0026#x3C;index\u003e\u003c/code\u003e 用来读取常量池编号小于 128 的常量(例如整数常量，浮点常量等等)\n那么，超出 128 编号的？使用 \u003ccode\u003eldc_w #\u0026#x3C;index\u003e\u003c/code\u003e 读取 2 字节内容作为编号，最大 65535。当然，更大的内容，常量池都不能支持了哈。\u003c/p\u003e\n\u003cp\u003e同时，区别于将 byte, short, int, float 统一作为 4 字节结果读取，对于 long, double 这样的八字节元素，使用 \u003ccode\u003eldc2_w\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e控制结构\u003c/h2\u003e\n\u003cp\u003e作为一门图灵完备的语言，至少，控制结构是必不可少的元素。\u003c/p\u003e\n\u003cp\u003e那么，类似 \u003ccode\u003efor(int i=0;i\u0026#x3C;10;i++)\u003c/code\u003e 的 Java 代码编译成指令到底是什么样的呢？\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e0: iconst_0                     // 赋值指令，往操作数栈顶添加整数值 0\n1: istore_1                     // 将操作数栈顶的元素存入局部变量表 1 号位置\n2: iload_1                      // 从局部变量表 1 号位置加载元素到操作数栈\n3: bipush        10             // 往操作数栈顶压入 byte 型值 10\n5: if_icmpge     21             // 将操作数栈顶的两个元素进行比较, 如果 次顶部元素 \u003e= 顶部元素，则重定向到偏移量为 21 的指令\n//  for (...) {} 语句块的内容\n15: iinc          1, 1          // 将局部变量表的 1 号位置元素 +1\n18: goto          2             // 跳转到偏移量为 2 的指令\n21: return                      // 调用无返回值的 return\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e类似的，\u003ccode\u003eif(...)\u003c/code\u003e 语句的比较较之 \u003ccode\u003efor(;;)\u003c/code\u003e 就更为简单。类比偏移量为 5 的指令即可。\u003c/p\u003e\n\u003ch2\u003e调用方法\u003c/h2\u003e\n\u003cp\u003eJVM 指令集中总计有 4 种调用方法的指令，包括有: \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003einvokevirtual\u003c/code\u003e, 对普通实例方法的调用，将根据对象类型进行分发调用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einvokestatic\u003c/code\u003e, 对静态方法的调用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einvokespecial\u003c/code\u003e, 用于调用类的初始化方法，也用于调用父类方法和私有方法\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einvokeinterface\u003c/code\u003e, 用于调用接口方法\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e以执行 \u003ccode\u003eSystem.out.println()\u003c/code\u003e 为例\n假设常量池内容存在目标元素(具体以相应注释为准)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003egetstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\ninvokevirtual #4                  // Method java/io/PrintStream.println:()V\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eMore\u003c/h2\u003e\n\u003cp\u003e更多内容，包括: 如何实例化一个对象，如何抛出及处理异常，代码同步声明等，暂且不表。\u003c/p\u003e\n\u003cp\u003e有时间再做补充\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。\u003c/p\u003e\n\u003cp\u003e当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。\n那么，直接阅读 \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\"\u003e官方文档\u003c/a\u003e 绝对是比本文的内容更为详实且准确。\u003c/p\u003e\n\u003cp\u003e这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。\u003c/p\u003e"},{"url":"2018-07-20-Java-Proxy","fileName":"2018-07-20-Java-Proxy.md","title":"Java Proxy 源码解析","author":"fangfeng","date":"2018-07-20T00:00:00.000Z","tags":[],"content":"\u003cp\u003e在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。\u003c/p\u003e\n\u003cp\u003e从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。\n而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。\u003c/p\u003e\n\u003ch2\u003e从实例开始...\u003c/h2\u003e\n\u003cp\u003e下面，首先来了解一下 Java Proxy 的使用编码:\u003c/p\u003e\n\u003cp\u003eICodeFactory 接口, 作为将被 Java 动态代理增强的基本接口\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface ICodeFactory {\n\n    Code getCode();\n\n    void setCode(Code code);\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCodeFactory 类, 作为 ICodeFactory 接口的实现类。被视为是真正被动态代理增强的内容，:) 因为接口方法并不存在方法体(当然，Java 8 及以上的 default 请容我忽视)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class CodeFactory implements ICodeFactory {\n\n    private Code code;\n\n    public Code getCode() {\n        return new Code();\n    }\n\n    @Override\n    public void setCode(Code code) {\n        this.code = code;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e辅助类 Code 的内容(简单写，请忽略不符合实际编程规范的一些内容):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Code {\n\n    public int codeA;\n\n    public String codeB;\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e构建增强的代码逻辑:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// main(String[]) 方法\npublic static void main(String[] args) throws Exception {\n\n    // 内部匿名类，用于动态代理生成类的构造方法及其它内容，后面讲。\n    InvocationHandler handler = new InvocationHandler() {\n\n        Object obj = new CodeFactory();\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n            if (method.getName() == \"getCode\") {\n                Code code = (Code) method.invoke(obj, args);\n                code.codeA = code.codeA + 100;\n                code.codeB = \"Proxied: \" + code.codeB;\n                return code;\n            } else {\n                return method.invoke(obj, args);\n            }\n        }\n    };\n\n    // 构建生成类实例\n    Class\u0026#x3C;?\u003e clazz = Proxy.getProxyClass(ICodeFactory.class.getClassLoader(), ICodeFactory.class);\n    // 获取生成类对象\n    ICodeFactory factory = (ICodeFactory) clazz.getConstructor(new Class[] { InvocationHandler.class }).newInstance(new Object[] { handler });\n\n    // 调用 getCode() 方法\n    Code code = factory.getCode();\n    // 打印参数\n    System.out.println(code.codeA);\n    System.out.println(code.codeB);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从默认预期来讲，我们是对接口进行增强。接口方法不存在方法体，也许将在 \u003ccode\u003efactory.getCode()\u003c/code\u003e 时执行失败？\n或者结合已有的认知，成功调用 \u003ccode\u003eCodeFactory.getCode()\u003c/code\u003e 方法，并获得 \u003ccode\u003enew Code()\u003c/code\u003e 。\u003c/p\u003e\n\u003cp\u003e那么，\u003ccode\u003ecode.codeA\u003c/code\u003e \u003ccode\u003ecode.codeB\u003c/code\u003e 的具体值将是什么？\u003c/p\u003e\n\u003cp\u003e执行结果将是:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e100\nProxied: null\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e了解 Proxy 的内容逻辑\u003c/h2\u003e\n\u003cp\u003e从 \u003ccode\u003eProxy.getProxyClass(ClassLoader, Class\u0026#x3C;?\u003e...)\u003c/code\u003e 入手，下面将展开对 \u003ccode\u003eProxy\u003c/code\u003e 具体执行逻辑的探究。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static Class\u0026#x3C;?\u003e getProxyClass(ClassLoader loader, Class\u0026#x3C;?\u003e... interfaces) throws IllegalArgumentException {\n    // 对 interfaces 数组的浅拷贝\n    final Class\u0026#x3C;?\u003e[] intfs = interfaces.clone();\n    final SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        // 如果配置了安全管理器，那么需要确认 Proxy 有创建新的代理类的许可\n        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n    }\n\n    // 调用 \n    return getProxyClass0(loader, intfs);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static Class\u0026#x3C;?\u003e getProxyClass0(ClassLoader loader, Class\u0026#x3C;?\u003e... interfaces) {\n    // 确认需要进行增强的接口数量少于等于 65535，详细原因请去了解 ClassFile 规范(规范中的接口上限)\n    if (interfaces.length \u003e 65535) {\n        throw new IllegalArgumentException(\"interface limit exceeded\");\n    }\n\n    // 如果需要由指定 ClassLoader 加载, 实现给定 interfaces 的代理类已经存在, \n    // 将直接返回已经缓存过的拷贝\n    // 否则，通过 ProxyClassFactory 创建新的代理类\n    return proxyClassCache.get(loader, interfaces);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在需要额外来考察一下 proxyClassCache 的具体类型。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static final WeakCache\u0026#x3C;ClassLoader, Class\u0026#x3C;?\u003e[], Class\u0026#x3C;?\u003e\u003e\n        proxyClassCache = new WeakCache\u0026#x3C;\u003e(new KeyFactory(), new ProxyClassFactory());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eWeakCache\u003c/code\u003e, 从名称来将，是一个缓存，同时应该使用了 WeakReference 技术\u003c/p\u003e\n\u003cp\u003e进入 \u003ccode\u003eWeakCache.get(...)\u003c/code\u003e 方法体\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic V get(K key, P parameter) {\n    // parameter 传入的是接口数组，要求不能为空\n    Objects.requireNonNull(parameter);\n\n    // 删除过期元素\n    expungeStaleEntries();\n\n    // 构建一个 WeakReference 对象(key 表示 ClassLoader)\n    Object cacheKey = CacheKey.valueOf(key, refQueue);\n\n    // lazily install the 2nd level valuesMap for the particular cacheKey\n    ConcurrentMap\u0026#x3C;Object, Supplier\u0026#x3C;V\u003e\u003e valuesMap = map.get(cacheKey);\n    if (valuesMap == null) {\n        ConcurrentMap\u0026#x3C;Object, Supplier\u0026#x3C;V\u003e\u003e oldValuesMap\n                = map.putIfAbsent(cacheKey,\n                valuesMap = new ConcurrentHashMap\u0026#x3C;\u003e());\n        if (oldValuesMap != null) {\n            valuesMap = oldValuesMap;\n        }\n    }\n\n    // 创建次级 Key\n    // 同时检索是否存在过去有同一个 ClassLoader 加载的表示 Supplier\u0026#x3C;V\u003e\n    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));\n    Supplier\u0026#x3C;V\u003e supplier = valuesMap.get(subKey);\n    Factory factory = null;\n\n    while (true) {\n        if (supplier != null) {\n            // supplier might be a Factory or a CacheValue\u0026#x3C;V\u003e instance\n            // 最终 supplier 将非空，同时调用 .get() 方法获取 Class 类\n            V value = supplier.get();\n            if (value != null) {\n                return value;\n            }\n        }\n        // else no supplier in cache\n        // or a supplier that returned null (could be a cleared CacheValue\n        // or a Factory that wasn't successful in installing the CacheValue)\n        // 未找到过去加载的记录\n\n        // 懒加载一个 Factory \n        if (factory == null) {\n            factory = new Factory(key, parameter, subKey, valuesMap);\n        }\n\n        if (supplier == null) {\n            supplier = valuesMap.putIfAbsent(subKey, factory);\n            if (supplier == null) {\n                // successfully installed Factory\n                supplier = factory;\n            }\n            // else retry with winning supplier\n        } else {\n            if (valuesMap.replace(subKey, supplier, factory)) {\n                // successfully replaced\n                // cleared CacheEntry / unsuccessful Factory\n                // with our Factory\n                supplier = factory;\n            } else {\n                // retry with current supplier\n                supplier = valuesMap.get(subKey);\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic synchronized V get() { // serialize access\n    // re-check\n    Supplier\u0026#x3C;V\u003e supplier = valuesMap.get(subKey);\n    if (supplier != this) {\n        // something changed while we were waiting:\n        // might be that we were replaced by a CacheValue\n        // or were removed because of failure -\u003e\n        // return null to signal WeakCache.get() to retry\n        // the loop\n        return null;\n    }\n    // else still us (supplier == this)\n\n    // create new value\n    V value = null;\n    try {\n        // 触发 valueFactory.apply() 真正的构建\n        value = Objects.requireNonNull(valueFactory.apply(key, parameter));\n    } finally {\n        if (value == null) { // remove us on failure\n            valuesMap.remove(subKey, this);\n        }\n    }\n    // the only path to reach here is with non-null value\n    assert value != null;\n\n    // wrap value with CacheValue (WeakReference)\n    CacheValue\u0026#x3C;V\u003e cacheValue = new CacheValue\u0026#x3C;\u003e(value);\n\n    // put into reverseMap\n    reverseMap.put(cacheValue, Boolean.TRUE);\n\n    // try replacing us with CacheValue (this should always succeed)\n    if (!valuesMap.replace(subKey, this, cacheValue)) {\n        throw new AssertionError(\"Should not reach here\");\n    }\n\n    // successfully replaced us with new CacheValue -\u003e return the value\n    // wrapped by it\n    return value;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面两段代码的内容，都是在反复确认将要构建的生成类是否在过去曾经创建过，如果是，则直接返回过去构建的类实例;\n否则才会尝试创建，并最终将这个构建的类也进行缓存。\u003c/p\u003e\n\u003cp\u003e下面这段代码来自于 \u003ccode\u003eProxy\u003c/code\u003e 的内部类 \u003ccode\u003eProxyClassFactory\u003c/code\u003e\n这部分，也终于开始了对代理类字节码的统筹性构造的内容。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Class\u0026#x3C;?\u003e apply(ClassLoader loader, Class\u0026#x3C;?\u003e[] interfaces) {\n\n    Map\u0026#x3C;Class\u0026#x3C;?\u003e, Boolean\u003e interfaceSet = new IdentityHashMap\u0026#x3C;\u003e(interfaces.length);\n    for (Class\u0026#x3C;?\u003e intf : interfaces) {\n        /*\n         * 校验当前接口是由同一个 ClassLoader (将要用来加载新的代理类)加载的\n         */\n        Class\u0026#x3C;?\u003e interfaceClass = null;\n        try {\n            interfaceClass = Class.forName(intf.getName(), false, loader);\n        } catch (ClassNotFoundException e) {\n        }\n        if (interfaceClass != intf) {\n            throw new IllegalArgumentException(\n                    intf + \" is not visible from class loader\");\n        }\n        /*\n         * 校验当前 Class 对象确实是一个接口\n         */\n        if (!interfaceClass.isInterface()) {\n            throw new IllegalArgumentException(\n                    interfaceClass.getName() + \" is not an interface\");\n        }\n        /*\n         * 校验当前接口没有被要求重复进行代理增强\n         */\n        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {\n            throw new IllegalArgumentException(\n                    \"repeated interface: \" + interfaceClass.getName());\n        }\n    }\n\n    String proxyPkg = null;     // 生成的代理类所属的 package\n    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n\n    /*\n     * 如果代理的接口是非 PUBLIC ，那么生成的代理类的接口将与这个非 PUBLIC 接口\n     * 在同一个包下。\n     * 如果代理的接口有多个非 PUBLIC ，且分别位于不同的包下，那么抛出异常\n     */\n    for (Class\u0026#x3C;?\u003e intf : interfaces) {\n        int flags = intf.getModifiers();\n        if (!Modifier.isPublic(flags)) {\n            accessFlags = Modifier.FINAL;\n            String name = intf.getName();\n            int n = name.lastIndexOf('.');\n            String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1));\n            if (proxyPkg == null) {\n                proxyPkg = pkg;\n            } else if (!pkg.equals(proxyPkg)) {\n                throw new IllegalArgumentException(\n                        \"non-public interfaces from different packages\");\n            }\n        }\n    }\n\n    // 如果代理的接口全是 PUBLIC 的，那么使用默认的包 com.sun.proxy\n    if (proxyPkg == null) {\n        // if no non-public proxy interfaces, use com.sun.proxy package\n        proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\";\n    }\n\n    /*\n     * 为将要生成的代理类选择一个全限定名\n     * 规则是 包名 + \"$Proxy\" + \u0026#x3C;唯一递增的id, 从0开始编号\u003e\n     */\n    long num = nextUniqueNumber.getAndIncrement();\n    String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n    /*\n     * 生成一个特殊的代理类的字节码\n     * byte[] proxyClassFile 就等同于 .class 文件的全部二进制内容。\n     * 与 .class 文件的区别就在于一个写在了外存上，另一个完全在内存中创建\n     */\n    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n            proxyName, interfaces, accessFlags);\n    try {\n        /**\n          * 调用 ClassLoader 的 defineClass0(...) 方法加载字节码内容，构造 Class 对象\n          * 本来 defineClass0(...) 方法是定义在 ClassLoader 中，但这里额外声明了一个本地方法 defineClass0(...)\n          * 想来实现也是类似的，最终的目的也是加载 Class \n          */\n        return defineClass0(loader, proxyName,\n                proxyClassFile, 0, proxyClassFile.length);\n    } catch (ClassFormatError e) {\n        /*\n         * A ClassFormatError here means that (barring bugs in the\n         * proxy class generation code) there was some other\n         * invalid aspect of the arguments supplied to the proxy\n         * class creation (such as virtual machine limitations\n         * exceeded).\n         */\n        throw new IllegalArgumentException(e.toString());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在完成基础性的校验，并构造了生成类的类名等内容后，\n\u003ccode\u003eProxyGenerator.generateProxyClass\u003c/code\u003e 将开始构造 \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html\"\u003eClassFile\u003c/a\u003e 的具体内容。\u003c/p\u003e\n\u003cp\u003e关于这部分生成字节码的内容，请在了解了 ClassFile 的基础性内容之后，在自行学习，内容全部在 ProxyGenerator 类中。\u003c/p\u003e\n\u003cp\u003e这部分的规则是(在构建新的代理生成类时):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e额外添加三个 Object 的方法 (\u003ccode\u003ehashCode\u003c/code\u003e, \u003ccode\u003eequals\u003c/code\u003e, \u003ccode\u003etoString\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e逐一读取所有需要增强的接口的方法，并对重复方法进行判断; 如果方法名相同，入参数量与类型相同，但返回参数不同，则抛出异常\u003c/li\u003e\n\u003cli\u003e在遍历所有接口的方法的时候，同时也将为新的生成类构造新的字段(内容就是通过反射获取该方法)\u003c/li\u003e\n\u003cli\u003e最后将新的生成类将要包含的所有字段与方法进行构造，同时维护一个常量池内容\u003c/li\u003e\n\u003cli\u003e输出这些内容的二进制表示 byte[];\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e如何对方法增强\u003c/h2\u003e\n\u003cp\u003e想必上了上一节，虽然对 Java 动态代理的调用链有了一定的了解。\u003c/p\u003e\n\u003cp\u003e但是，究竟 Proxy 是如何完成对实现类方法的增强呢？\u003c/p\u003e\n\u003cp\u003e也许我们需要先看一下生成类 .class 文件的一些内容来对这个命题形成基础性的影响。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic final Code getCode() throws  {\n    try {\n        return (Code)super.h.invoke(this, m4, (Object[])null);\n    } catch (RuntimeException | Error var2) {\n        throw var2;\n    } catch (Throwable var3) {\n        throw new UndeclaredThrowableException(var3);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到，生成类的 \u003ccode\u003egetCode()\u003c/code\u003e 方法几乎没有什么实质性的内容, 只是 \u003ccode\u003esuper.h.invoke(...)\u003c/code\u003e 。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eh\u003c/code\u003e 实例变量是什么？\u003ccode\u003eInvocationHandler\u003c/code\u003e 的一个实例对象。\u003c/p\u003e\n\u003cp\u003e事实上，Java Proxy 生成类的每个方法结构几乎都是类似的。方法体的内容就是通过实例持有的 \u003ccode\u003eh\u003c/code\u003e 变量分发实际的操作指令\u003c/p\u003e\n\u003cp\u003e至于 h 的具体内容。:) 有编程者自定义，并在 Proxy 生成字节码，并被 ClassLoader 加载后，在准备实例化的时候作为构造参数进行传入。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eICodeFactory factory = (ICodeFactory) clazz.getConstructor(new Class[] { InvocationHandler.class }).newInstance(new Object[] { handler });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至于具体将做哪些增强，调用例如上例的 \u003ccode\u003eICodeFactory\u003c/code\u003e 的那个实现类的方法，全部有使用者自定义。\u003c/p\u003e\n\u003ch2\u003e生成类的反编译结果\u003c/h2\u003e\n\u003cp\u003e仍然以本文开始的 ICodeFactory 的增强为例，看一下究竟通过 Java Proxy 动态代理生成的字节码的反编译结果究竟是什么？\n并以此来对这种动态代理机制形成更为直观的印象\u003c/p\u003e\n\u003cp\u003e在 Java 源代码中，虽然默认不会输出生成类的二进制内容，但是，仍然预留了打印 .class 文件的可选项。\u003c/p\u003e\n\u003cp\u003e有兴趣的同学可以看一下 \u003ccode\u003eProxyGenerator.saveGeneratedFiles\u003c/code\u003e 字段的内容，这就决定是在构造代理类后是否存储到外存中。\u003c/p\u003e\n\u003cp\u003e想要看到代理类的字节码，直接通过在 Java 执行程序中添加一行代码\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eSystem.setProperty(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e或者在启动程序的 \u003ccode\u003ejava\u003c/code\u003e 命令下添加参数\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true`\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至于生成类将打印在哪，首先必然是在项目所属的目录下。有上一节中构造生成类全限定名的内容，根据包名的规则去寻找即可。(具体不再详述)\u003c/p\u003e\n\u003cp\u003e直接通过 IDEA, Eclipse 或者其它工具，对生成类 .class 文件进行反编译可以查看到整个生成类的内容。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.sun.proxy;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\nimport me.fangfeng.jdk.proxy.Code;\nimport me.fangfeng.jdk.proxy.ICodeFactory;\n\npublic final class $Proxy0 extends Proxy implements ICodeFactory {\n    private static Method m1;\n    private static Method m2;\n    private static Method m4;\n    private static Method m3;\n    private static Method m0;\n\n    public $Proxy0(InvocationHandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        try {\n            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final String toString() throws  {\n        try {\n            return (String)super.h.invoke(this, m2, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final Code getCode() throws  {\n        try {\n            return (Code)super.h.invoke(this, m4, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final void setCode(Code var1) throws  {\n        try {\n            super.h.invoke(this, m3, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final int hashCode() throws  {\n        try {\n            return (Integer)super.h.invoke(this, m0, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    static {\n        try {\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\"));\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\");\n            m4 = Class.forName(\"me.fangfeng.jdk.proxy.ICodeFactory\").getMethod(\"getCode\");\n            m3 = Class.forName(\"me.fangfeng.jdk.proxy.ICodeFactory\").getMethod(\"setCode\", Class.forName(\"me.fangfeng.jdk.proxy.Code\"));\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\");\n        } catch (NoSuchMethodException var2) {\n            throw new NoSuchMethodError(var2.getMessage());\n        } catch (ClassNotFoundException var3) {\n            throw new NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。\u003c/p\u003e\n\u003cp\u003e从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。\n而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。\u003c/p\u003e"},{"url":"2018-07-13-How-to-easily-get-CGlib-generated-code","fileName":"2018-07-13-How-to-easily-get-CGlib-generated-code.md","title":"如何方便地获取 CGlib 生成类","author":"fangfeng","date":"2018-07-13T00:00:00.000Z","tags":["CGlib","tools"],"content":"\u003ch2\u003e配置参数\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e命令行使用\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 java 启动命令中添加参数配置项 \u003ccode\u003e-Dcglib.debugLocation=\u0026#x3C;Custom Path\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e编码实现\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在执行 CGlib 获取新生成类之前，调用 \u003ccode\u003eSystem.setProperty(\"cglib.debugLocation\", \u0026#x3C;Custom Path\u003e)\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e如何游刃有余地 Debug 掺杂 CGlib 生成类的调用链\u003c/h2\u003e\n\u003cp\u003e经常会遇到，项目中不经意间就遇到了 CGlib 代理，然后对调用链的 Debug 就开始出现断层。继而，对对象或实例变量的跟踪就显得一头雾水。\u003c/p\u003e\n\u003cp\u003e特别是在不了解生成类到底是增强了那些内容的时候，甚至可能连调用链都跟踪不下去了 T_T 。\u003c/p\u003e\n\u003cp\u003e通过 \u003cstrong\u003e配置参数\u003c/strong\u003e 一节的内容，你就可以在你理想的目录 \u003ccode\u003e\u0026#x3C;Custom Path\u003e\u003c/code\u003e 下看到\u003cstrong\u003e所谓黑盒\u003c/strong\u003e中生成类的完成内容了。\u003c/p\u003e\n\u003cp\u003e下面的内容，将简单地介绍如何配合 CGlib 生成类的内容实现: 保证 Debug 的每一步骤可见; 保证 Debug 的过程不会出现\u003cem\u003e黑盒\u003c/em\u003e。\u003c/p\u003e\n\u003ch3\u003e确定 \u003ccode\u003e\u0026#x3C;Custom Path\u003e\u003c/code\u003e 下哪个文件是原有 Java 类的生成类\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic String getClassName(String prefix, String source, Object key, Predicate names) {\n    if (prefix == null) {\n        prefix = \"net.sf.cglib.empty.Object\";\n    } else if (prefix.startsWith(\"java\")) {\n        prefix = \"$\" + prefix;\n    }\n    String base =\n        prefix + \"$$\" +\n        source.substring(source.lastIndexOf('.') + 1) +\n        getTag() + \"$$\" +\n        Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\n    String attempt = base;\n    int index = 2;\n    while (names.evaluate(attempt))\n        attempt = base + \"_\" + index++;\n    return attempt;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCGlib 默认的类名生成策略下，生成类的全限定名将结合原文件的全限定名决定。\u003c/p\u003e\n\u003cp\u003e通常命名如下: \u003ccode\u003e\u0026#x3C;原 Java 类全限定名\u003e$$\u0026#x3C;类似 EnhancerByCGlib\u003e$$\u0026#x3C;生成类核心内容的 hash 值\u003e_\u0026#x3C;index[可能存在]\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e例如: 原有 Java 类全限定名为 me.fangfeng.Test ，则生成类名可能为 \u003ccode\u003eme.fangfeng.Test$$EnhancerByCGlib$$ab1203aa\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e当然，通常情况下会存在一个类名形如 \u003ccode\u003eme.fangfeng.Test$$FastClassBySpring$$...\u003c/code\u003e 的类，这是作为生成类 \u003ccode\u003eme.fangfeng.Test$$EnhancerByCGlib$$ab1203aa\u003c/code\u003e 的辅助类来使用。\u003c/p\u003e\n\u003ch3\u003e简单了解生成类下的调用关系\u003c/h3\u003e\n\u003cp\u003eJava 代码触发被增强的类，将首先调用生成类。但是，这是没办法进行 Debug 的，因为这个生成类的字节码缺少 SourceFile 属性，同时缺少 LineNumberTable 属性。\u003c/p\u003e\n\u003cp\u003e但是，这并不影响对调用链的跟踪。\u003c/p\u003e\n\u003cp\u003eCGlib 的增强，所有的增强逻辑都是以 Callback 实现类的形式来提供的。同时在 CGlib 生成类中也有 Callback 的实例变量来持有这些注入的 Callback 。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原有 Java 类\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1ft8e7kr7qvj30sc0j0wh4.jpg\" alt=\"LogonService.java\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e对应的生成类\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8e9ww4hqj31hg0oojzv.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eanb6c9j31j00lgn1e.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e跟踪 LogonService.addLogon(String var1) 演示\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e当前 LogonService 的生成类全限定名为me.fangfeng.transactionBugs.LogonService\u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eE\u003c/mi\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmi\u003eh\u003c/mi\u003e\u003cmi\u003ea\u003c/mi\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmi\u003ec\u003c/mi\u003e\u003cmi\u003ee\u003c/mi\u003e\u003cmi\u003er\u003c/mi\u003e\u003cmi\u003eB\u003c/mi\u003e\u003cmi\u003ey\u003c/mi\u003e\u003cmi\u003eS\u003c/mi\u003e\u003cmi\u003ep\u003c/mi\u003e\u003cmi\u003er\u003c/mi\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmi\u003eg\u003c/mi\u003e\u003cmi\u003eC\u003c/mi\u003e\u003cmi\u003eG\u003c/mi\u003e\u003cmi\u003eL\u003c/mi\u003e\u003cmi\u003eI\u003c/mi\u003e\u003cmi\u003eB\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eEnhancerBySpringCGLIB\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05764em;\"\u003eE\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003en\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003eh\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ea\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003en\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ec\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ee\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003er\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05017em;\"\u003eB\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.03588em;\"\u003ey\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05764em;\"\u003eS\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ep\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003er\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ei\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003en\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.03588em;\"\u003eg\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07153em;\"\u003eC\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003eG\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003eL\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07847em;\"\u003eI\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05017em;\"\u003eB\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003ebfc1dc3.class; 以下简称为 LogonSerivce$$bfc1dc3 \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e首先，配置 \u003ccode\u003ecglib.debugLocation\u003c/code\u003e 参数，值 = 项目生成的 .class 路径\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e无断点直接运行一次需要处理的逻辑\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e找到 LogonSerive$$bfc1dc3.class, 随意打上一个看似有效的断点\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在各处打上必要的断点，开始进行真正的调试工作\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e代码执行到 \u003ccode\u003eLogonService$$bfc1dc3.class\u003c/code\u003e, 虽然没有真正进入断点位置, 但是可以看到这个 \u003ccode\u003eLogonService$$bfc1dc3\u003c/code\u003e 实例的实例变量信息\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1ft8eq1be61j319w0bwtde.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8egtg1naj31ji0fmgp2.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e比照生成类代码中 addLogon(String var1) 方法体的内容以及展示的实例变量信息。可以看到生成类调用的 Callback 实例是 \u003ccode\u003eCGLIB$CALLBACK_0\u003c/code\u003e\n类型是 CglibAopProxy 的静态内部私有类 DynamicAdvisedInterceptor 。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eu91oscj31gq0ayju5.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e在 intercept(...) 上打个断点，跳过生成类 addLogon(String var1) 方法的下一个调用方法就是 intercept(...) \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e而且事实上，CGlib 生成类的内容基本也就是对调用方法进行的一种转发\u003c/strong\u003e\u003c/p\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e继续 Debug ，对于生成类的内容，人肉了解并定位到触发的 Callback 实例或者 super.Xxx() 方法。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e配置参数\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e命令行使用\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 java 启动命令中添加参数配置项 \u003ccode\u003e-Dcglib.debugLocation=\u0026#x3C;Custom Path\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e编码实现\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在执行 CGlib 获取新生成类之前，调用 \u003ccode\u003eSystem.setProperty(\"cglib.debugLocation\", \u0026#x3C;Custom Path\u003e)\u003c/code\u003e\u003c/p\u003e"},{"url":"2018-07-10-CGlib-Enhancer","fileName":"2018-07-10-CGlib-Enhancer.md","title":"CGlib Enhancer 主流程源码解析","author":"fangfeng","date":"2018-07-10T00:00:00.000Z","tags":["CGlib","ASM"],"content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e此博文写作的目的: \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。\u003c/li\u003e\n\u003cli\u003e基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eEnhancer\u003c/h2\u003e\n\u003cp\u003e从这篇不是官方但更胜于官方文档的 \u003ca href=\"http://mydailyjava.blogspot.com/2013/11/cglib-missing-manual.html\"\u003eCGlib Guide\u003c/a\u003e 来看，它首先提到的第一个类就是 Enhancer。\n其被用于创建 Java 代理类，相较于 Java 标准库的 Proxy 类，它\u003cstrong\u003e特别地\u003c/strong\u003e，能够支持那些没有实现接口的类的代理工作。\u003c/p\u003e\n\u003ch3\u003eEnhancer 简单示例展示\u003c/h3\u003e\n\u003cp\u003e针对现有的 SampleClass 类\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SampleClass {\n    public String test(String input) {\n        return \"Hello World!\";\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用 CGlib 的 Enhancer 对 SampleClass 进行增强，下列操作的目的在于将 test(String) 方法的返回值改写成 \"Hello cglib!\"\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Test\npublic void testFixedValue() {\n    // new 一个 Enhancer 实例\n    Enhancer enhancer = new Enhancer();\n    // 声明使用的父类是 SampleClass\n    enhancer.setSuperclass(SampleClass.class);\n    // 设置回调方法 - 回调方法实现为 FixedValue (固定值) .\n    enhancer.setCallback(new FixedValue() {\n        public Object loadObject() throws Exception {\n            return \"Hello cglib!\";\n        }\n    });\n    // 创建 SampleClass 的代理子类实例\n    SampleClass proxy = (SampleClass) enhancer.create();\n    Assert.assertEquals(\"Hello cglib!\", proxy.test(null));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e简单测试上述代码，可以了解到确实，代理类的 test(String) 方法的返回值被改写了。\n那么，究竟这种操作是如何实现的？下面👇将进行具体的探究。\u003c/p\u003e\n\u003ch2\u003e调用链跟踪\u003c/h2\u003e\n\u003ch3\u003e高度抽象的时序图\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1ft4ifuo997j31jh0st42t.jpg\" alt=\"Enhancer 调用链 时序图\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e下列内容将根据时序图进行组织，根据调用编号(1,2,3...)进行展开\u003c/em\u003e\u003c/p\u003e\n\u003ch3\u003eSeq 1.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Object create() {\n    classOnly = false;\n    argumentTypes = null;\n    return createHelper();\n}\n\npublic Object create(Class[] argumentTypes, Object[] arguments) {\n    classOnly = false;\n    if (argumentTypes == null || arguments == null || argumentTypes.length != arguments.length) {\n        throw new IllegalArgumentException(\"Arguments must be non-null and of equal length\");\n    }\n    this.argumentTypes = argumentTypes;\n    this.arguments = arguments;\n    return createHelper();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述两个 \u003ccode\u003ecreate(...)\u003c/code\u003e 方法。结合上一节的使用示例，可以看到 \u003ccode\u003ecreate()\u003c/code\u003e 对应的\u003cstrong\u003e无参构造\u003c/strong\u003e。\n存在无参构造，那么\u003cstrong\u003e有参的构造方法\u003c/strong\u003e显然也是应该被支持id。\u003ccode\u003ecreate(Class[], Object[])\u003c/code\u003e 正是为了这个目标而存在。通过提供参数类型数组和参数实例数组，可以唯一地定位及调用代理类的特定构造方法。\u003c/p\u003e\n\u003cp\u003e这个方法比较简单，只是将 Enhancer 作为一个数据内容的持有者，重置了新代理类将使用的构造函数参数内容，之后就直接调用了 \u003ccode\u003ecreateHelper()\u003c/code\u003e 。\u003c/p\u003e\n\u003ch3\u003eSeq 2.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Object createHelper() {\n    // 对预声明的回调方法进行验证，要求 [多个回调就必须存在 CallbackFilter 作为调度器]\n    preValidate();\n    // 构建一个对这类增强操作唯一定位的 key\n    Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,\n            ReflectUtils.getNames(interfaces),\n            filter == ALL_ZERO ? null : new WeakCacheKey\u0026#x3C;CallbackFilter\u003e(filter),\n            callbackTypes,\n            useFactory,\n            interceptDuringConstruction,\n            serialVersionUID);\n    this.currentKey = key;\n    // 调用父类通过的 create(...) 方法\n    Object result = super.create(key);\n    return result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSeq 3.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprotected Object create(Object key) {\n    try {\n        // 获取用于 加载 生成类 的 ClassLoader\n        ClassLoader loader = getClassLoader();\n        // 从缓存中加载 这个 ClassLoader 过去加载的相关数据\n        Map\u0026#x3C;ClassLoader, ClassLoaderData\u003e cache = CACHE;\n        ClassLoaderData data = cache.get(loader);\n        // 如果在 缓存 中找不到，则初始化构造关于这个 ClassLoader 的数据实例\n        if (data == null) {\n            // 同步\n            synchronized (AbstractClassGenerator.class) {\n                // 进入同步块后的 再次确认，避免重复初始化构建\n                cache = CACHE;\n                data = cache.get(loader);\n                if (data == null) {\n                    // 构建新的 缓存，拷贝原有的缓存集的内容\n                    Map\u0026#x3C;ClassLoader, ClassLoaderData\u003e newCache = new WeakHashMap\u0026#x3C;ClassLoader, ClassLoaderData\u003e(cache);\n                    // 初始化 ClassLoaderData ，真正的构造操作\n                    data = new ClassLoaderData(loader);\n                    // 添加到缓存中\n                    newCache.put(loader, data);\n                    CACHE = newCache;\n                }\n            }\n        }\n        this.key = key;\n        Object obj = data.get(this, getUseCache());\n        if (obj instanceof Class) {\n            // 初次实例化操作，就是 Class 利用反射来进行实例化\n            return firstInstance((Class) obj);\n        }\n        // 非初次实例化，则是从 ClassLoaderData 中得到的之前维护的内容\n        return nextInstance(obj);\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (Error e) {\n        throw e;\n    } catch (Exception e) {\n        throw new CodeGenerationException(e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这部分内容比较多，且是调用链比较重要的一环。\u003cstrong\u003eSeq 4.\u003c/strong\u003e 和 \u003cstrong\u003eSeq 5.\u003c/strong\u003e 将作为其子内容进行调用，但为了本博文的结构完整， \u003cem\u003eSeq 4. \u0026#x26; Seq5.\u003c/em\u003e 的标题与 \u003cem\u003eSeq 3.\u003c/em\u003e 标题同级\u003c/p\u003e\n\u003ch3\u003eSeq 4.\u003c/h3\u003e\n\u003cp\u003e首先应该认识到，每个被加载的 Class ，在 \u003ccode\u003eequal\u003c/code\u003e 的判断过程中，依据的是同一个 ClassLoader 加载的同一 Class 才被认为是相同的，否则即使 Class 是同一个，但仍会被认为是不同的(由不同的 ClassLoader 加载)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic ClassLoader getClassLoader() {\n    ClassLoader t = classLoader;\n    if (t == null) {\n        t = getDefaultClassLoader();\n    }\n    if (t == null) {\n        t = getClass().getClassLoader();\n    }\n    if (t == null) {\n        t = Thread.currentThread().getContextClassLoader();\n    }\n    if (t == null) {\n        throw new IllegalStateException(\"Cannot determine classloader\");\n    }\n    return t;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因此，在这部分中，首先需要确定的是由哪个 ClassLoader 进行加载的工作。\u003ccode\u003egetClassLoader()\u003c/code\u003e 的确定顺序是:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e具体实现类声明的 \u003cstrong\u003e默认 ClassLoader\u003c/strong\u003e 为第一优先级\u003c/li\u003e\n\u003cli\u003e加载当前类(这里是 Enhancer) 的 ClassLoader 为第二优先级\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e当前线程上下文 ClassLoader\u003c/strong\u003e 为第三优先级\u003c/li\u003e\n\u003cli\u003e抛出异常\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e回到 \u003cstrong\u003eSeq 3.\u003c/strong\u003e 的内容，\n下一步是对当前这个\u003cstrong\u003eAbstractClassGenerator\u003c/strong\u003e 维护的 CACHE 进行处理，如果在 CACHE 中能够得到以确定的 ClassLoader 为 Key 的键值对，则直接获取 ClassLoader 对应的值，否则将进行初始化构建一个新的 ClassLoaderData 作为这个 ClassLoader 的值。\u003c/p\u003e\n\u003ch3\u003eSeq 5.\u003c/h3\u003e\n\u003cp\u003e在构建 ClassLoaderData 的过程中，最重要的一步:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic ClassLoaderData(ClassLoader classLoader) {\n    // ClassLoader 不可为空\n    if (classLoader == null) {\n        throw new IllegalArgumentException(\"classLoader == null is not yet supported\");\n    }\n    // 构建 ClassLoader 的弱引用\n    this.classLoader = new WeakReference\u0026#x3C;ClassLoader\u003e(classLoader);\n    // 写了个后置调用的函数，用于懒加载，只有调用了 load.apply(...) 才会构建 生成类\n    Function\u0026#x3C;AbstractClassGenerator, Object\u003e load =\n            new Function\u0026#x3C;AbstractClassGenerator, Object\u003e() {\n                public Object apply(AbstractClassGenerator gen) {\n                    Class klass = gen.generate(ClassLoaderData.this);\n                    return gen.wrapCachedClass(klass);\n                }\n            };\n    generatedClasses = new LoadingCache\u0026#x3C;AbstractClassGenerator, Object, Object\u003e(GET_KEY, load);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e构建了一个 Function 实例，这个 Function 作为函数式接口，预定义执行的具体流程，但由上下文确定具体的调用时刻。\u003c/p\u003e\n\u003ch3\u003eSeq 6.\u003c/h3\u003e\n\u003cp\u003e在正确得到了 ClassLoader 对应的 ClassLoaderData 之后，ClassLoaderData 的 \u003ccode\u003eget(...)\u003c/code\u003e 方法将在特定的 ClassLoader 之下，进行更具体的加载新生成类的工作。\n当然，这里的前提是新的生成类的字节码已经被构建:)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Object get(AbstractClassGenerator gen, boolean useCache) {\n    // 标记为不使用缓存，直接构建 新的生成类\n    if (!useCache) {\n      return gen.generate(ClassLoaderData.this);\n    }\n    // 使用缓冲的情况\n    else {\n      Object cachedValue = generatedClasses.get(gen);\n      return gen.unwrapCachedValue(cachedValue);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003egen.generate(ClassLoaderData.this)\u003c/code\u003e 这段代码在 \u003ccode\u003eget(...)\u003c/code\u003e 方法和上一小节 \u003ccode\u003eClassLoaderData(...)\u003c/code\u003e 构造方法的 Function 函数式实例都出现了。\u003c/p\u003e\n\u003cp\u003e实际上，这也是触发 ClassLoader 来加载动态生成的新 Class 的唯一入口。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e判断逻辑\u003c/em\u003e 的 \u003ccode\u003eelse\u003c/code\u003e 内容的唯一区别就在于其构建的是一个加载缓存，将真正触发 gen.generate(ClassLoaderData.this) 的逻辑延迟。(不过，最终也还是会进行调用的，:) 这是毋庸置疑的)。\u003c/p\u003e\n\u003ch3\u003eSeq 7.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprotected Class generate(ClassLoaderData data) {\n    Class gen;\n    Object save = CURRENT.get();\n    CURRENT.set(this);\n    try {\n        // 拿到用于加载生成类的 ClassLoader\n        ClassLoader classLoader = data.getClassLoader();\n        if (classLoader == null) {\n            throw new IllegalStateException(\"ClassLoader is null while trying to define class \" +\n                    getClassName() + \". It seems that the loader has been expired from a weak reference somehow. \" +\n                    \"Please file an issue at cglib's issue tracker.\");\n        }\n        // 构建一个合法的 生成类 的类名(非重复)\n        synchronized (classLoader) {\n          String name = generateClassName(data.getUniqueNamePredicate());\n          data.reserveName(name);\n          this.setClassName(name);\n        }\n        if (attemptLoad) {\n            try {\n                // 尝试直接通过 ClassLoader 进行加载\n                gen = classLoader.loadClass(getClassName());\n                return gen;\n            } catch (ClassNotFoundException e) {\n                // ignore\n            }\n        }\n        // 策略下的生成类构建方法\n        byte[] b = strategy.generate(this);\n        // 通过解析字节码的形式获取 生成类的 className\n        String className = ClassNameReader.getClassName(new ClassReader(b));\n        ProtectionDomain protectionDomain = getProtectionDomain();\n        synchronized (classLoader) { // just in case\n            // 反射的形式加载 Class 类\n            if (protectionDomain == null) {\n                gen = ReflectUtils.defineClass(className, b, classLoader);\n            } else {\n                gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);\n            }\n        }\n        return gen;\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (Error e) {\n        throw e;\n    } catch (Exception e) {\n        throw new CodeGenerationException(e);\n    } finally {\n        CURRENT.set(save);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个方法，就是操作字节码，加载 Class 的核心调度方法。\u003c/p\u003e\n\u003cp\u003e可以看到 \u003ccode\u003egenerateClassName(...)\u003c/code\u003e 方法将构建一个当前 ClassLoader 下唯一, 不重复的新的类名。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estrategy.generate(this)\u003c/code\u003e 将通过特定策略实现的形式生成新的字节码\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eReflectUtils.defineClass(className, b, classLoader)\u003c/code\u003e 将使用反射使得 ClassLoader 来加载这个新的生成类。\u003c/p\u003e\n\u003ch3\u003eSeq 8.\u003c/h3\u003e\n\u003cp\u003e生成新的不重复类名这部分不做过多陈述，可以简单进行了解，并熟悉 CGlib 默认的新类名的命名规则\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// DefaultNamePolicy\npublic String getClassName(String prefix, String source, Object key, Predicate names) {\n    if (prefix == null) {\n        prefix = \"net.sf.cglib.empty.Object\";\n    } else if (prefix.startsWith(\"java\")) {\n        prefix = \"$\" + prefix;\n    }\n    String base =\n        prefix + \"$$\" +\n        source.substring(source.lastIndexOf('.') + 1) +\n        getTag() + \"$$\" +\n        Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\n    String attempt = base;\n    int index = 2;\n    while (names.evaluate(attempt))\n        attempt = base + \"_\" + index++;\n    return attempt;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSeq 9.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 下列是 DefaultGeneratorStrategy 的实现\npublic byte[] generate(ClassGenerator cg) throws Exception {\n    DebuggingClassWriter cw = getClassVisitor();\n    transform(cg).generateClass(cw);\n    return transform(cw.toByteArray());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSeq 10.\u003c/h3\u003e\n\u003cp\u003e调用 \u003ccode\u003egenerateClass(ClassVisitor)\u003c/code\u003e 将获得到新类的字节码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void generateClass(ClassVisitor v) throws Exception {\n    // 确定生成类的 父类\n    Class sc = (superclass == null) ? Object.class : superclass;\n\n    // 父类标识符不可以为 final\n    if (TypeUtils.isFinal(sc.getModifiers()))\n        throw new IllegalArgumentException(\"Cannot subclass final class \" + sc.getName());\n    // 获取父类直接声明的构造方法\n    List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));\n    filterConstructors(sc, constructors);\n\n    // Order is very important: must add superclass, then\n    // its superclass chain, then each interface and\n    // its superinterfaces.\n    List actualMethods = new ArrayList();\n    List interfaceMethods = new ArrayList();\n    final Set forcePublic = new HashSet();\n    // 从父类中提取各种信息\n    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);\n\n    List methods = CollectionUtils.transform(actualMethods, new Transformer() {\n        public Object transform(Object value) {\n            Method method = (Method)value;\n            int modifiers = Constants.ACC_FINAL\n                | (method.getModifiers()\n                   \u0026#x26; ~Constants.ACC_ABSTRACT\n                   \u0026#x26; ~Constants.ACC_NATIVE\n                   \u0026#x26; ~Constants.ACC_SYNCHRONIZED);\n            if (forcePublic.contains(MethodWrapper.create(method))) {\n                modifiers = (modifiers \u0026#x26; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;\n            }\n            return ReflectUtils.getMethodInfo(method, modifiers);\n        }\n    });\n\n    ClassEmitter e = new ClassEmitter(v);\n    if (currentData == null) {\n    e.begin_class(Constants.V1_2,\n                  Constants.ACC_PUBLIC,\n                  getClassName(),\n                  Type.getType(sc),\n                  (useFactory ?\n                   TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :\n                   TypeUtils.getTypes(interfaces)),\n                  Constants.SOURCE_FILE);\n    } else {\n        e.begin_class(Constants.V1_2,\n                Constants.ACC_PUBLIC,\n                getClassName(),\n                null,\n                new Type[]{FACTORY},\n                Constants.SOURCE_FILE);\n    }\n    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\n\n    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);\n    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, null);\n    if (!interceptDuringConstruction) {\n        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null);\n    }\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);\n    if (serialVersionUID != null) {\n        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);\n    }\n\n    for (int i = 0; i \u0026#x3C; callbackTypes.length; i++) {\n        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null);\n    }\n    // This is declared private to avoid \"public field\" pollution\n    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, null);\n\n    if (currentData == null) {\n        emitMethods(e, methods, actualMethods);\n        emitConstructors(e, constructorInfo);\n    } else {\n        emitDefaultConstructor(e);\n    }\n    emitSetThreadCallbacks(e);\n    emitSetStaticCallbacks(e);\n    emitBindCallbacks(e);\n\n    if (useFactory || currentData != null) {\n        int[] keys = getCallbackKeys();\n        emitNewInstanceCallbacks(e);\n        emitNewInstanceCallback(e);\n        emitNewInstanceMultiarg(e, constructorInfo);\n        emitGetCallback(e, keys);\n        emitSetCallback(e, keys);\n        emitGetCallbacks(e);\n        emitSetCallbacks(e);\n    }\n\n    e.end_class();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egenerateClass(...)\u003c/code\u003e 执行的操作和 ASM 库的 ClassVisitor 访问 Class 文件结构的流程基本类似。\u003c/p\u003e\n\u003cp\u003e从上述截取到的部分代码，例如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ee.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), \n        (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)),\n        Constants.SOURCE_FILE);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ee.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e都与 \u003ccode\u003eclassVisitor.visit(...)\u003c/code\u003e 以及 \u003ccode\u003eclassVisitor.visitField(...)\u003c/code\u003e 相当类似。而事实上，这些方法的具体实现也确实调用了 cv.visitXxx(...) 。\n毕竟，作为 CGlib 唯一依赖的库，ASM 还是可以说是难以替代的(既然已经有了可用的轮子，又何必重复造呢?)\u003c/p\u003e\n\u003ch2\u003e构造的实例\u003c/h2\u003e\n\u003cp\u003e下面将展示通过 CGlib 生成的新的类(由于生成的是字节码，懒得再自行解析 ClassFile 的内容，所有直接用 \u003ccode\u003eIDEA\u003c/code\u003e 做了字节码的解析)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e首先展示的需要进行增强的 SampleClass 的具体内容\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SampleClass {\n    public String test(String input) {\n        return \"Hello World!\";\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e用于增强的简单代码\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 省略部分代码\npublic static void main(String... args) {\n    Enhancer enhancer = new Enhancer();\n    enhancer.setSuperclass(SampleClass.class);\n    enhancer.setCallback(new FixedValue() {\n        public Object loadObject() throws Exception {\n            return \"Hello cglib!\";\n        }\n    });\n    SampleClass proxy = (SampleClass) enhancer.create();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e动态生成的新的类\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\n// 不用过多关注，只是 CGlib 保证生成类与原有的类一定属于同一包下，偷懒直接把 SampleClass 写在 CGlib 项目里了\npackage net.sf.cglib.samples;\n\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.FixedValue;\n\n/**\n * 新的类名，通过 $$EnhancerByCGLIB 以及 $$7cd64b81(这个是哈希值) 对类名进行唯一区分 \n * 如果还是重复了，在动态生成前会进行类名的检测，并通过增加序号 \"_\u0026#x3C;index\u003e\" 的形式进行进一步区分\n *\n * 可以看到新生成的类继承了 SampleClass \n */\npublic class SampleClass$$EnhancerByCGLIB$$7cd64b81 extends SampleClass implements Factory {\n    private boolean CGLIB$BOUND;\n    public static Object CGLIB$FACTORY_DATA;\n    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;\n    private static final Callback[] CGLIB$STATIC_CALLBACKS;\n\n    // 绑定一个在增强中声明的 Callback 实例\n    private FixedValue CGLIB$CALLBACK_0;\n    // 绑定一个静态的回调调度实例\n    private static Object CGLIB$CALLBACK_FILTER;\n\n    static void CGLIB$STATICHOOK1() {\n        CGLIB$THREAD_CALLBACKS = new ThreadLocal();\n    }\n\n    /**\n      * 对 test(String) 的方法的增强\n      */ \n    public final String test(String var1) {\n        // 在方法块中拿到 Callback 实例\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        // 为空则尝试获取\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        // 触发回调实例的方法获得返回值\n        return (String)var10000.loadObject();\n    }\n\n    /**\n      * 由于此次增强只声明了一个 Callback\n      * 因此所有方法的增强都相同, 都是调用这个回调方法获取\n      */\n    public final boolean equals(Object var1) {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        Object var2 = var10000.loadObject();\n        /**\n         * 但是，此处会尝试强制转型\n         * 同时在最终执行失败的时候直接抛出运行时异常\n         * 毕竟上面增强的时候返回固定值 \"Hello, cglib!\"\n         */\n        return var2 == null ? false : (Boolean)var2;\n    }\n\n    public final String toString() {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return (String)var10000.loadObject();\n    }\n\n    public final int hashCode() {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        Object var1 = var10000.loadObject();\n        return var1 == null ? 0 : ((Number)var1).intValue();\n    }\n\n    protected final Object clone() throws CloneNotSupportedException {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return var10000.loadObject();\n    }\n\n    public SampleClass$$EnhancerByCGLIB$$7cd64b81() {\n        CGLIB$BIND_CALLBACKS(this);\n    }\n\n    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {\n        CGLIB$THREAD_CALLBACKS.set(var0);\n    }\n\n    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {\n        CGLIB$STATIC_CALLBACKS = var0;\n    }\n\n    private static final void CGLIB$BIND_CALLBACKS(Object var0) {\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var1 = (SampleClass$$EnhancerByCGLIB$$7cd64b81)var0;\n        if (!var1.CGLIB$BOUND) {\n            var1.CGLIB$BOUND = true;\n            Object var10000 = CGLIB$THREAD_CALLBACKS.get();\n            if (var10000 == null) {\n                var10000 = CGLIB$STATIC_CALLBACKS;\n                if (CGLIB$STATIC_CALLBACKS == null) {\n                    return;\n                }\n            }\n\n            var1.CGLIB$CALLBACK_0 = (FixedValue)((Callback[])var10000)[0];\n        }\n\n    }\n\n    public Object newInstance(Callback[] var1) {\n        CGLIB$SET_THREAD_CALLBACKS(var1);\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Callback var1) {\n        CGLIB$SET_THREAD_CALLBACKS(new Callback[]{var1});\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {\n        CGLIB$SET_THREAD_CALLBACKS(var3);\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81;\n        switch(var1.length) {\n        case 0:\n            var10000.\u0026#x3C;init\u003e();\n            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n            return var10000;\n        default:\n            throw new IllegalArgumentException(\"Constructor not found\");\n        }\n    }\n\n    public Callback getCallback(int var1) {\n        CGLIB$BIND_CALLBACKS(this);\n        FixedValue var10000;\n        switch(var1) {\n        case 0:\n            var10000 = this.CGLIB$CALLBACK_0;\n            break;\n        default:\n            var10000 = null;\n        }\n\n        return var10000;\n    }\n\n    public void setCallback(int var1, Callback var2) {\n        switch(var1) {\n        case 0:\n            this.CGLIB$CALLBACK_0 = (FixedValue)var2;\n        default:\n        }\n    }\n\n    public Callback[] getCallbacks() {\n        CGLIB$BIND_CALLBACKS(this);\n        return new Callback[]{this.CGLIB$CALLBACK_0};\n    }\n\n    public void setCallbacks(Callback[] var1) {\n        this.CGLIB$CALLBACK_0 = (FixedValue)var1[0];\n    }\n\n    static {\n        CGLIB$STATICHOOK1();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从上面的生成类可以看出来，CGlib 所进行的增强，是在不直接对原有的方法体内容进行改造的基础上(例如上面的 test(String) 方法，没有直接改写成 \u003ccode\u003ereturn \"Hello, cglib!\u003c/code\u003e 的形式)，对方法执行之前入参或者方法执行之后的返回值进行一定的处理。\u003c/p\u003e\n\u003cp\u003e主要使用的形式就是将回调实例与原有方法进行绑定，并通过调用回调方法来实现方法的增强。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e此博文写作的目的: \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。\u003c/li\u003e\n\u003cli\u003e基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。\u003c/li\u003e\n\u003c/ul\u003e"}],"items":36,"pages":4,"currentPage":2},"buildId":"FKaOYCdVIHyUdoh_VHOSc","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/" src="https://www.ffutop.com/blog/_next/static/FKaOYCdVIHyUdoh_VHOSc/pages/index.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/FKaOYCdVIHyUdoh_VHOSc/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.969aa7fdf03e14118a99.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.f3603d0a56c82c4f5e78.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>