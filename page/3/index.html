<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" class="next-head"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/ujZVwdt9FYQDcwzYKNDVs/pages/index.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/ujZVwdt9FYQDcwzYKNDVs/pages/_app.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/chunks/styles.74c43a0e96cfe845a889.js" as="script"/><link rel="preload" href="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" as="script"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/commons.a1d4ae30.chunk.css"/><link rel="stylesheet" href="https://www.ffutop.com/blog/_next/static/css/styles.42fbd406.chunk.css"/></head><body><div id="__next"><header class="component-header"><h1 class="title">ffutop</h1><ul class="nav-items"><li><a href="/blog/index">博客</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/about">关于</a></li></ul></header><div><main class="main"><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-08-15-Java-Instrumentation">Java Instrumentation</a></h1><div><h2>Start</h2>
<p>从现有的前置知识来说，我们能够认识到两个事实:</p>
<ol>
<li>Java Class 通过 ClassLoader 进行加载。
通过<code>全限定名</code>进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。
换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)</li>
<li>有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。
当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧
(虽然可能不了解细节。在此，欢迎学习前置技能 <a href="https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/">CGlib Enhancer 主流程源码解析</a> 和 <a href="https://dormouse-none.github.io/2018-07-20-Java-Proxy/">Java Proxy 源码解析</a>。不过不影响本文后续内容)</li>
</ol>
<p>另一个方面，也许绝大多数人都听说过所谓的<code>热部署</code>。但是究竟怎么才能做到 <code>热部署</code>(话题开得有点大哈。Y_Y 本文不讲这个)</p>
<p>操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。</p>
<p>如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚...</p>
<p>Java 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的</p>
<h2>Instrumentation</h2>
<p><code>java.lang.instrument.Instrumentation</code> 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)</p>
<p>相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。</p>
<p>下列有两种方法可以达到目的</p>
<ol>
<li>当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。</li>
<li>当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。</li>
</ol>
<p>话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了<em>检测</em>的目的)的使用</p></div><p><a href="/blog/2018-08-15-Java-Instrumentation">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-07-24-JVM-Instruction">JVM 指令简析</a></h1><div><p>在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。</p>
<p>当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。
那么，直接阅读 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">官方文档</a> 绝对是比本文的内容更为详实且准确。</p>
<p>这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。</p></div><p><a href="/blog/2018-07-24-JVM-Instruction">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-07-20-Java-Proxy">Java Proxy 源码解析</a></h1><div><p>在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。</p>
<p>从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。
而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。</p></div><p><a href="/blog/2018-07-20-Java-Proxy">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-07-13-How-to-easily-get-CGlib-generated-code">如何方便地获取 CGlib 生成类</a></h1><div><h2>配置参数</h2>
<p><strong>命令行使用</strong></p>
<p>在 java 启动命令中添加参数配置项 <code>-Dcglib.debugLocation=&#x3C;Custom Path></code></p>
<p><strong>编码实现</strong></p>
<p>在执行 CGlib 获取新生成类之前，调用 <code>System.setProperty("cglib.debugLocation", &#x3C;Custom Path>)</code></p></div><p><a href="/blog/2018-07-13-How-to-easily-get-CGlib-generated-code">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-07-10-CGlib-Enhancer">CGlib Enhancer 主流程源码解析</a></h1><div><h2>前言</h2>
<p>此博文写作的目的: </p>
<ul>
<li>(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。</li>
<li>基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。</li>
</ul></div><p><a href="/blog/2018-07-10-CGlib-Enhancer">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-07-04-JDK-Permission">Java 安全访问与权限控制</a></h1><div><h2>绪论</h2>
<p><em>本文只是对 Java 安全访问与权限控制的基础性探究。</em></p>
<p><strong>本节与全文内容无关，如无兴趣阅读，可以跳过</strong></p>
<p>了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行"自动发现"和加载。
这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要
1. 在 <code>META-INF.services</code> 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容
2. 由项目的注册管理器触发下列 Java 代码</p>
<pre><code class="language-java">{
    ServiceLoader&#x3C;XxxPolicy> xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);
    for (Iterator&#x3C;XxxPolicy> it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) {
        XxxPolicy xxxPolicy = it.next();
        // ... more code ...
    }
}
</code></pre>
<p>就可以完成一个新的 SPI 策略的注册工作。</p>
<p>但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-.jar 在注册 Driver 相关的代码。
发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:</p>
<pre><code class="language-java">AccessController.doPrivileged(new PrivilegedAction&#x3C;Void>() {
    public Void run() {

        ServiceLoader&#x3C;Driver> loadedDrivers = ServiceLoader.load(Driver.class);
        Iterator&#x3C;Driver> driversIterator = loadedDrivers.iterator();

        try{
            while(driversIterator.hasNext()) {
            driversIterator.next();
            }
        } catch(Throwable t) {
                // Do nothing
        }
        return null;
    }
});
</code></pre>
<p>诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。</p>
<p>为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。</p></div><p><a href="/blog/2018-07-04-JDK-Permission">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-06-28-ASM-VerifyError">ASM-VerifyError错误信息解决</a></h1><div><h2>报错信息</h2>
<pre><code class="language-java">java.lang.VerifyError: class net.sf.cglib.core.DebuggingClassWriter overrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V
</code></pre></div><p><a href="/blog/2018-06-28-ASM-VerifyError">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-06-25-ASM-Core">ASM 核心包基本内容漫谈</a></h1><div><blockquote>
<p>本文描述的 ASM 指的是 OW2 ASM</p>
</blockquote>
<h2>ASM-Core 的结构</h2>
<p><em>首先是一些概述性的内容。</em></p>
<p>由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。
因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)</p>
<p>从核心包声明的类来看，主要包括:</p>
<ol>
<li>
<p>ClassReader - 作为结构化对象，将接收(accept)访问者的访问</p>
</li>
<li>
<p>几种访问者抽象类以及相应的实现类</p>
</li>
</ol>
<ul>
<li>AnnotationVisitor -> AnnotationWriter</li>
<li>ClassVisitor -> ClassWriter</li>
<li>FieldVisitor -> FieldWriter</li>
<li>MethodVisitor -> MethodWriter</li>
<li>ModuleVisitor -> ModuleWriter</li>
</ul>
<ol start="3">
<li>
<p>Opcodes &#x26; Constants - ClassFile 中描述的大量常量符号与值</p>
</li>
<li>
<p>其它一些辅助的类</p>
</li>
</ol>
<ul>
<li>Attribute - 用于处理非标准化的属性(ClassFile 允许<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">JVMS</a> 中未定义的 Attribute)</li>
<li>ByteArray - 动态可自适应的 byte[] (字节数组)</li>
<li>Context - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象</li>
<li>Symbol - 用于表示 ClassFile 中描述的 Constant 的基类</li>
<li>SymbolTable - 用于存储常量池对象</li>
<li>其它内容省略</li>
</ul></div><p><a href="/blog/2018-06-25-ASM-Core">阅读更多</a></p><hr/></div></div><div><div class="component-post-digest"><h1 class="title"><a href="/blog/2018-06-21-java-memory-model">java-memory-model</a></h1><div><h2>JVM 运行时数据区</h2>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg"></p></div><p><a href="/blog/2018-06-21-java-memory-model">阅读更多</a></p><hr/></div></div><div><a href="/blog/page/2">上一页</a><a href="/blog/page/4">下一页</a></div></main><footer class="footer">ffutop © <!-- -->2019<!-- -->, Built with<a href="https://reactjs.org/">React</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/","query":{"mdDatasParts":[{"url":"2018-08-15-Java-Instrumentation","fileName":"2018-08-15-Java-Instrumentation.md","title":"Java Instrumentation","author":"fangfeng","date":"2018-08-15T00:00:00.000Z","tags":["Java","ASM","BTrace"],"content":"\u003ch2\u003eStart\u003c/h2\u003e\n\u003cp\u003e从现有的前置知识来说，我们能够认识到两个事实:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eJava Class 通过 ClassLoader 进行加载。\n通过\u003ccode\u003e全限定名\u003c/code\u003e进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。\n换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)\u003c/li\u003e\n\u003cli\u003e有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。\n当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧\n(虽然可能不了解细节。在此，欢迎学习前置技能 \u003ca href=\"https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/\"\u003eCGlib Enhancer 主流程源码解析\u003c/a\u003e 和 \u003ca href=\"https://dormouse-none.github.io/2018-07-20-Java-Proxy/\"\u003eJava Proxy 源码解析\u003c/a\u003e。不过不影响本文后续内容)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e另一个方面，也许绝大多数人都听说过所谓的\u003ccode\u003e热部署\u003c/code\u003e。但是究竟怎么才能做到 \u003ccode\u003e热部署\u003c/code\u003e(话题开得有点大哈。Y_Y 本文不讲这个)\u003c/p\u003e\n\u003cp\u003e操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。\u003c/p\u003e\n\u003cp\u003e如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚...\u003c/p\u003e\n\u003cp\u003eJava 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的\u003c/p\u003e\n\u003ch2\u003eInstrumentation\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ejava.lang.instrument.Instrumentation\u003c/code\u003e 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)\u003c/p\u003e\n\u003cp\u003e相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。\u003c/p\u003e\n\u003cp\u003e下列有两种方法可以达到目的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。\u003c/li\u003e\n\u003cli\u003e当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了\u003cem\u003e检测\u003c/em\u003e的目的)的使用\u003c/p\u003e\n\u003ch2\u003e对各方法进行执行时间统计\u003c/h2\u003e\n\u003ch3\u003e随 JVM 一起启动\u003c/h3\u003e\n\u003cp\u003e基本实例: 将对特定包 \u003ccode\u003eme.fangfeng.client\u003c/code\u003e 下的每个方法执行计时\u003c/p\u003e\n\u003cp\u003e首先了解一下 client 包的内容:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage me.fangfeng.client;\n\n/**\n * Main.java\n * 执行两个方法，rand() \u0026#x26; sleep() \n *\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class Main {\n\n    static void sleep() {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Rand rand = new Rand();\n\n        for (int i=0;i\u0026#x3C;10;i++) {\n            System.out.println(\"\u003e\u003e\u003e start Rand.run() \u0026#x3C;\u0026#x3C;\u0026#x3C;\");\n            rand.run();\n            System.out.println(\"\u003e\u003e\u003e end Rand.run() \u0026#x3C;\u0026#x3C;\u0026#x3C;\");\n\n            System.out.println();\n\n            System.out.println(\"\u003e\u003e\u003e start Main.sleep() \u0026#x3C;\u0026#x3C;\u0026#x3C;\");\n            Main.sleep();\n            System.out.println(\"\u003e\u003e\u003e end MAin.sleep() \u0026#x3C;\u0026#x3C;\u0026#x3C;\");\n\n            System.out.println();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage me.fangfeng.client;\n\n/**\n * Rand.java\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class Rand {\n\n    public void run() {\n        while (true) {\n            double rand = Math.random();\n            if (rand \u003e 0.995) {\n                System.out.println(String.format(\"get random, values %f\", rand));\n                return;\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接着，来构造一个代理类，以及最重要的 \u003ccode\u003epremain\u003c/code\u003e 方法\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage me.fangfeng.javaagent;\n\nimport java.lang.instrument.Instrumentation;\n\n/**\n * Agent - 代理\n * 基于 JVM TI (JVM Tool Interface) 实现的 Java ClassFile 的增强\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class Agent {\n\n    // premain 将 JVM 初始化后，main(String... ) 执行前调用\n    public static void premain(String args, Instrumentation instrumentation) {\n        // new 一个转换器实例\n        ClassTimer transformer = new ClassTimer();\n        instrumentation.addTransformer(transformer);\n    }\n\n    // 之后的 agentmain(...) 将在这里提供，暂时隐去，避免对对读者产生干扰\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage me.fangfeng.javaagent;\n\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.Opcodes;\n\nimport java.lang.instrument.ClassFileTransformer;\nimport java.security.ProtectionDomain;\n\n/**\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class ClassTimer implements ClassFileTransformer {\n\n    @Override\n    public byte[] transform(ClassLoader loader, String className, Class\u0026#x3C;?\u003e classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {\n        // 这里涉及到了 ASM 的内容，主要目的是向每个方法块的开始及方法块的结束部分插入与计时器有关的代码\n        // 如果想了解 ASM 的内容，请参阅 https://dormouse-none.github.io/2018-06-25-ASM-Core/  提供了一些基础性的内容，更多的请自行学习\n        // 不了解具体内容将不影响对主体内容的理解\n        ClassReader cr = new ClassReader(classfileBuffer);\n        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n        MyClassWriter mcw = new MyClassWriter(Opcodes.ASM6, cw);\n        cr.accept(mcw, ClassReader.EXPAND_FRAMES);\n        return cw.toByteArray();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其它代码略，详见附件。\u003c/p\u003e\n\u003cp\u003eJava 这种对操作字节码的支持有个坑爹的地方，就是不得不打包成 Jar 来使用。\u003c/p\u003e\n\u003cp\u003e具体来看一下\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eme.fangfeng.javaagent\u003c/code\u003e 包中包括 \u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fublsbbdw0j309o07g74u.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e将被打包成 \u003ccode\u003eagent.jar\u003c/code\u003e 来使用\u003c/p\u003e\n\u003cp\u003e首先，来看一下需要打包在 \u003ccode\u003eagent.jar\u003c/code\u003e 的 \u003cstrong\u003eMANIFEST.MF\u003c/strong\u003e 的内容\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eManifest-Version: 1.0\nClass-Path: /Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar\nPremain-Class: me.fangfeng.javaagent.Agent\nCan-Retransform-Classes: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再来个 SHELL 脚本，用来给打包这个 Jar\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e#!/bin/bash\n\n# 编译 me.fangfeng.javaagent 包下的类\njavac -cp .:/Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar me/fangfeng/javaagent/Agent.java me/fangfeng/javaagent/ClassTimer.java me/fangfeng/javaagent/MyClassWriter.java me/fangfeng/javaagent/MyMethodWriter.java me/fangfeng/javaagent/StaticTimer.java\n\n# 打包 me.fangfeng.javaagent 的 .class -\u003e agent.jar\njar cvfm agent.jar MANIFEST-agent.MF me/fangfeng/javaagent/Agent.class me/fangfeng/javaagent/ClassTimer.class me/fangfeng/javaagent/MyClassWriter.class me/fangfeng/javaagent/MyMethodWriter.class me/fangfeng/javaagent/StaticTimer.class\n\n# 编译 me.fangfeng.client 包下的类\njavac me/fangfeng/client/Main.java me/fangfeng/client/Rand.java\n\n# 以 me.fangfeng.client.Main 作为主类启动\njava -javaagent:agent.jar me.fangfeng.client.Main\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e执行后，可以看到类似如下内容:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fubmp354ejj30tq0rmtdp.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e而直接用 \u003ccode\u003ejava me.fangfeng.client.Main\u003c/code\u003e 的执行结果是:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fubmqmj4uhj30j00f0dho.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e从理论上来讲，\u003ccode\u003e-javaagent:agent.jar\u003c/code\u003e 配合 \u003ccode\u003eagent.jar\u003c/code\u003e 中的 MANIFEST.MF 文件，\n使得 JVM 在初始化之后触发了被声明为 \u003ccode\u003ePre-Main\u003c/code\u003e 的 me.fangfeng.javaagent.Agent 类的 premain(...) 方法。\u003c/p\u003e\n\u003cp\u003e并为 ClassLoader 在加载类的流程上增加了一层\u003cstrong\u003e拦截器\u003c/strong\u003e (这里是 ClassTimer.java 类，它实现了 \u003ccode\u003eClassFileTransformer\u003c/code\u003e 接口\u003c/p\u003e\n\u003cp\u003e另外，\u003ccode\u003eCan-Retransform-Classes: true\u003c/code\u003e 的配置使得 ClassTimer 被允许对字节码进行重新转换。(而操作字节码是通过 ASM 来实现的)\u003c/p\u003e\n\u003ch3\u003e在运行中进行增强\u003c/h3\u003e\n\u003cp\u003e随着程序启动时直接使用了 \u003ccode\u003e-javaagent\u003c/code\u003e 选项。\u003c/p\u003e\n\u003cp\u003e那么是否存在在程序运行中进行额外代理操作的支持呢？当然是可以的。这里要借助 Java 提供的另一个类 com.sun.tools.attach.VirtualMachine 。\u003c/p\u003e\n\u003cp\u003e启动一个新的进程来连接到 正在运行中的进程，并令其加载 java agent。\u003c/p\u003e\n\u003cp\u003e基本的类与上一节的描述相同，主要是包 \u003ccode\u003eme.fangfeng.javaagent.*\u003c/code\u003e 和 \u003ccode\u003eme.fangfeng.client.*\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e新增一个类 \u003ccode\u003eme.fangfeng.javaagent.Main\u003c/code\u003e 用来启动另一个进程，并要求运行中的 java 进程加载 agent.jar 来进行增强。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage me.fangfeng.javaagent;\n\nimport com.sun.tools.attach.AgentInitializationException;\nimport com.sun.tools.attach.AgentLoadException;\nimport com.sun.tools.attach.AttachNotSupportedException;\nimport com.sun.tools.attach.VirtualMachine;\n\nimport java.io.IOException;\n\n/**\n * @author fangfeng\n * @since 2018/8/7\n */\npublic class Main {\n\n    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException {\n        VirtualMachine vm = null;\n        try {\n            // 通过 VirtualMachine 连接到 运行中的进程 (可以通过 jps 找到进程号)\n            vm = VirtualMachine.attach(\u0026#x3C;PID\u003e);\n            vm.loadAgent(\u0026#x3C;agent.jar 的路径\u003e);\n        } finally {\n            if (vm != null) {\n                vm.detach();\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Agent {\n\n    public static void premain(String args, Instrumentation instrumentation) {\n        ClassTimer transformer = new ClassTimer();\n        instrumentation.addTransformer(transformer);\n    }\n\n    // 现在在 Agent.java 上补上 agentmain(...) 的具体实现\n    public static void agentmain(String args, Instrumentation instrumentation) throws UnmodifiableClassException {\n        System.out.println(\"SUCCESS AGENTMAIN\");\n        ClassTimer transformer = new ClassTimer();\n        // add Transformer\n        instrumentation.addTransformer(transformer, true);\n        // 对 Rand.class 进行重新转换\n        instrumentation.retransformClasses(Rand.class);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其它内容基本相同\u003c/p\u003e\n\u003cp\u003e首先需要先打包 agent.jar 。当然，如果是顺着本文的顺序进行本机实验，则 agent.jar 已经存在\u003c/p\u003e\n\u003cp\u003e先启动进程 \u003ccode\u003ejava me.fangfeng.client.Main\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e通过 \u003ccode\u003ejps\u003c/code\u003e 获取 Main 进程的 \u003cstrong\u003ePID\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 \u003ccode\u003ejava me.fangfeng.javaagent.Main\u003c/code\u003e 中替换上进程号，并执行\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws2.sinaimg.cn/large/006tNbRwgy1fuboclcelsj30tu152dlw.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e从执行结果可以看到，原进程首先正常执行代码，等到被 load Agent 之后，字节码已经有了新的变化，从而导致输出结果动态的产生了变化。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e当然，需要注意的是，执行中的进程被要求 load Agent 之后，运行中的 Class 将被改写，并始终如此，知道进程终止。再下一次重新启动\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003eBTrace\u003c/h2\u003e\n\u003cp\u003e以上描述的内容也可以理解为是 BTrace 实现的基础。毕竟，JVMTI (JVM Tool Interface) 原本的目的就是赋予使用者一个在运行中\n查询系统各项数据的权利\u003c/p\u003e\n\u003cp\u003e当然，实现上，上述代码直接将各种增强(计时)硬编码到该进程中，同时统一使用了该进程的输入输出。\u003c/p\u003e\n\u003cp\u003e但是，BTrace 通过 Socket 将这些分离，检测代码通过 Socket 发回新的进程来维持输入输出。\u003c/p\u003e\n\u003cp\u003e在此，不再细说。\u003c/p\u003e\n\u003ch2\u003e附录\u003c/h2\u003e\n\u003cp\u003e[1]. 示例代码: \u003ca href=\"https://github.com/DorMOUSE-None/Repo/raw/master/instru.zip\"\u003einstru.zip\u003c/a\u003e\n[2]. \u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html\"\u003ejava.lang.instrument.Instrumentation\u003c/a\u003e\n[3]. \u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html\"\u003ePackage java.lang.instrument\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003eStart\u003c/h2\u003e\n\u003cp\u003e从现有的前置知识来说，我们能够认识到两个事实:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eJava Class 通过 ClassLoader 进行加载。\n通过\u003ccode\u003e全限定名\u003c/code\u003e进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。\n换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)\u003c/li\u003e\n\u003cli\u003e有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。\n当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧\n(虽然可能不了解细节。在此，欢迎学习前置技能 \u003ca href=\"https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/\"\u003eCGlib Enhancer 主流程源码解析\u003c/a\u003e 和 \u003ca href=\"https://dormouse-none.github.io/2018-07-20-Java-Proxy/\"\u003eJava Proxy 源码解析\u003c/a\u003e。不过不影响本文后续内容)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e另一个方面，也许绝大多数人都听说过所谓的\u003ccode\u003e热部署\u003c/code\u003e。但是究竟怎么才能做到 \u003ccode\u003e热部署\u003c/code\u003e(话题开得有点大哈。Y_Y 本文不讲这个)\u003c/p\u003e\n\u003cp\u003e操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。\u003c/p\u003e\n\u003cp\u003e如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚...\u003c/p\u003e\n\u003cp\u003eJava 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的\u003c/p\u003e\n\u003ch2\u003eInstrumentation\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ejava.lang.instrument.Instrumentation\u003c/code\u003e 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)\u003c/p\u003e\n\u003cp\u003e相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。\u003c/p\u003e\n\u003cp\u003e下列有两种方法可以达到目的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。\u003c/li\u003e\n\u003cli\u003e当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了\u003cem\u003e检测\u003c/em\u003e的目的)的使用\u003c/p\u003e"},{"url":"2018-07-24-JVM-Instruction","fileName":"2018-07-24-JVM-Instruction.md","title":"JVM 指令简析","author":"fangfeng","date":"2018-07-24T00:00:00.000Z","tags":["JVM","Instruction"],"content":"\u003cp\u003e在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。\u003c/p\u003e\n\u003cp\u003e当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。\n那么，直接阅读 \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\"\u003e官方文档\u003c/a\u003e 绝对是比本文的内容更为详实且准确。\u003c/p\u003e\n\u003cp\u003e这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。\u003c/p\u003e\n\u003ch2\u003e术语约定\u003c/h2\u003e\n\u003cp\u003e首先，需要就 \u003ccode\u003e术语\u003c/code\u003e 进行一些基础性的约定:\u003c/p\u003e\n\u003ch3\u003e变量\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tNc79gy1ftidi0xpmij30oa07kaaq.jpg\" alt=\"变量\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e变量\u003c/code\u003e: 在类中，区分于 \u003ccode\u003e方法\u003c/code\u003e 的声明\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e成员变量\u003c/code\u003e: 作用域为整个类，在方法体与语句块之外声明的内容。在 \u003ccode\u003e字节码\u003c/code\u003e 中通常被称为 \u003ccode\u003e字段(Field)\u003c/code\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e类成员变量 / 静态成员变量\u003c/code\u003e: 被 \u003ccode\u003estatic\u003c/code\u003e 修饰的 \u003ccode\u003e成员变量\u003c/code\u003e。一个类只有一份，在类被加载的时候即初始化。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e实例成员变量\u003c/code\u003e: 非 \u003ccode\u003estatic\u003c/code\u003e 修饰的 \u003ccode\u003e成员变量\u003c/code\u003e。随着类被实例化而进行初始化，每个实例对象都有一份特有的 \u003ccode\u003e实例变量\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e局部变量\u003c/code\u003e: 作用域为方法体或者语句块。\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eJVM 指令\u003c/h3\u003e\n\u003cp\u003e通常，我们借助于 \u003ccode\u003ejavap\u003c/code\u003e 命令来对 .class 文件的字节码内容进行查阅。\u003c/p\u003e\n\u003cp\u003e类似于汇编代码，\u003ccode\u003ejavap\u003c/code\u003e 打印的JVM 指令将以下列格式进行展示:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e\u0026#x3C;index\u003e \u0026#x3C;opcode\u003e [\u0026#x3C;operand1\u003e [\u0026#x3C;operand2\u003e ...]] [\u0026#x3C;comment\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中 \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;index\u003e\u003c/code\u003e 指在 \u003ccode\u003ecode[]\u003c/code\u003e 属性中这条指令的偏移量(从 0 开始计数)。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;opcode\u003e\u003c/code\u003e 指 \u003ccode\u003e操作码\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;operandX\u003e\u003c/code\u003e 指 \u003ccode\u003e操作数\u003c/code\u003e，每个 \u003ccode\u003e\u0026#x3C;opcode\u003e\u003c/code\u003e 都需要确定数量的操作数(规范中已经确定)。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;comment\u003e\u003c/code\u003e 指注释\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e指令集概览\u003c/h2\u003e\n\u003cp\u003e首先，Java 代码经编译后的所有指令都基于 \u003ccode\u003e方法(Method)\u003c/code\u003e 被定义在 \u003ccode\u003eCode\u003c/code\u003e 属性中。\u003c/p\u003e\n\u003cp\u003e在 \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3\"\u003eClassFile\u003c/a\u003e 的 \u003ccode\u003eCode\u003c/code\u003e 属性，结构定义如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCode_attribute {\n    // 其中 u1, u2, u4 分别表示这个变量所占的字节长度\n    u2 attribute_name_index;                    // 属性名在常量池中的 index (执行常量池中 Code 的位置)\n    u4 attribute_length;                        // 属性长度，不包括开始的六个字节\n    u2 max_stack;                               // 运行时操作数栈的最大深度\n    u2 max_locals;                              // 运行时所需的局部变量表的大小\n    u4 code_length;                             // code 数组的长度\n    u1 code[code_length];                       // code 数组，编译后方法体的内容都通过字节码指令存储在这里\n    u2 exception_table_length;                  // 异常表的长度\n    {   u2 start_pc;\n        u2 end_pc;\n        u2 handler_pc;\n        u2 catch_type;\n    } exception_table[exception_table_length]; // 异常表，Java 代码中所有的 catch, finally 的捕获都将由此表进行实现\n    u2 attributes_count;                       // 属性计数\n    attribute_info attributes[attributes_count];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJava 虚拟机的指令是由一个字节长度的 \u003ccode\u003e操作码\u003c/code\u003e 配合上其后的 0 个或多个 \u003ccode\u003e操作数\u003c/code\u003e 所构成的。\u003c/p\u003e\n\u003cp\u003e其中，\u003ccode\u003e操作数\u003c/code\u003e 的数量取决于 \u003ccode\u003e操作码\u003c/code\u003e，不同的 \u003ccode\u003e操作码\u003c/code\u003e 需要不同数量的 \u003ccode\u003e操作数\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e按照类型划分，\u003ccode\u003e操作数\u003c/code\u003e 主要包括下列几类:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e加载与存储指令，例如 iload, istore 等\u003c/li\u003e\n\u003cli\u003e运算指令，例如 iadd, isub, imul 等\u003c/li\u003e\n\u003cli\u003e类型转换指令，例如 i2b, i2s 等\u003c/li\u003e\n\u003cli\u003e对象创建与操作指令，例如 new, newarray 等\u003c/li\u003e\n\u003cli\u003e操作数栈管理指令，例如 dup, pop 等\u003c/li\u003e\n\u003cli\u003e控制转移指令，例如 if_icmpeq 等\u003c/li\u003e\n\u003cli\u003e方法调用与返回指令，例如 invokevirtual, invokestatic 等\u003c/li\u003e\n\u003cli\u003e抛出异常指令，例如 athrow 等\u003c/li\u003e\n\u003cli\u003e同步指令，例如 monitorenter 等\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e举几个简单的例子:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eiadd\u003c/code\u003e 指令，表示对两个 int 数的相加指令。将从操作数栈顶依次取出两个数，并相加，再重新压入操作数栈中。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebipush 100\u003c/code\u003e ，其中 \u003ccode\u003ebipush\u003c/code\u003e 是指令，后随一个操作数，表示把 \u003ccode\u003e操作数 100 这个 byte 类型的数\u003c/code\u003e 压入操作数栈顶\u003c/p\u003e\n\u003ch2\u003e运行时数据区\u003c/h2\u003e\n\u003cp\u003eJVM 定义了若干种运行期间会使用到的运行时数据区，见下图:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg\" alt=\"JVM 运行时数据区\"\u003e\u003c/p\u003e\n\u003cp\u003e至于每一个的具体意义，在此不做详细展开，可用参考:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e由周志明等翻译的 《Java 虚拟机规范(Java SE 7版) 》 2.5节内容 \u003ca href=\"http://icyfenix.iteye.com/blog/1256329\"\u003e链接\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5\"\u003eJVMS 2.5. Run-Time Data Areas\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eGetter, Setter 的指令代码\u003c/h2\u003e\n\u003cp\u003e首先，有必要提及，想要得到 .class 可视且友好的展示结果，可以使用 JDK 自带的 \u003ccode\u003ejavap\u003c/code\u003e 命令。\u003c/p\u003e\n\u003cp\u003e本节要展示的内容是常见的 POJO 的 get, set 方法的指令代码。使用的示例代码如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Test {\n    \n    private int number;\n\n    public int getNumber() {\n        return number;\n    }\n\n    public void setNumber(int number) {\n        this.number = number;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在经过 \u003ccode\u003ejavac\u003c/code\u003e 编译，\u003ccode\u003ejavap\u003c/code\u003e 解析之后，我们将看到下列内容\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003eClassfile /Users/fangfeng/WorkPkg/lab/src/main/java/me/fangfeng/asm/Test.class\n  Last modified Jul 23, 2018; size 357 bytes\n  MD5 checksum bb1940cc6534d789359295b8dc80233b\n  Compiled from \"Test.java\"\npublic class me.fangfeng.asm.Test\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #4.#17         // java/lang/Object.\"\u0026#x3C;init\u003e\":()V\n   #2 = Fieldref           #3.#18         // me/fangfeng/asm/Test.number:I\n   #3 = Class              #19            // me/fangfeng/asm/Test\n   #4 = Class              #20            // java/lang/Object\n   #5 = Utf8               number\n   #6 = Utf8               I\n   #7 = Utf8               \u0026#x3C;init\u003e\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               getNumber\n  #12 = Utf8               ()I\n  #13 = Utf8               setNumber\n  #14 = Utf8               (I)V\n  #15 = Utf8               SourceFile\n  #16 = Utf8               Test.java\n  #17 = NameAndType        #7:#8          // \"\u0026#x3C;init\u003e\":()V\n  #18 = NameAndType        #5:#6          // number:I\n  #19 = Utf8               me/fangfeng/asm/Test\n  #20 = Utf8               java/lang/Object\n{\n  public me.fangfeng.asm.Test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"\u0026#x3C;init\u003e\":()V\n         4: return\n      LineNumberTable:\n        line 3: 0\n\n  public int getNumber();\n    descriptor: ()I\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field number:I\n         4: ireturn\n      LineNumberTable:\n        line 8: 0\n\n  public void setNumber(int);\n    descriptor: (I)V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=2\n         0: aload_0\n         1: iload_1\n         2: putfield      #2                  // Field number:I\n         5: return\n      LineNumberTable:\n        line 12: 0\n        line 13: 5\n}\nSourceFile: \"Test.java\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e打印出来的内容包括有 类的全限定名，访问控制权限，父类，接口，常量池以及各个方法。\u003c/p\u003e\n\u003cp\u003e以 \u003ccode\u003egetNumber\u003c/code\u003e 为例:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003epublic int getNumber();\n  descriptor: ()I\n  flags: ACC_PUBLIC\n  Code:\n    stack=1, locals=1, args_size=1\n       0: aload_0\n       1: getfield      #2                  // Field number:I\n       4: ireturn\n    LineNumberTable:\n      line 8: 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003edescriptor: 表示方法描述符，其中 \u003ccode\u003e()\u003c/code\u003e 内容表示入参，\u003ccode\u003eI\u003c/code\u003e 表示返回值的类型\u003c/li\u003e\n\u003cli\u003eflags     : 表示方法的访问权限，当前限定为 \u003ccode\u003epublic\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eCode      : 存储有当前方法体指令码的一种方法内部属性。\u003cul\u003e\n\u003cli\u003estack : 表示当前方法(意即在运行时所处的栈帧，每个方法的调用都将在 \u003ccode\u003e虚拟机栈\u003c/code\u003e 中构建一个新的 \u003ccode\u003e栈帧\u003c/code\u003e) 使用的 \u003ccode\u003e操作数栈的最大深度\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003elocals: 表示当前方法使用的 \u003ccode\u003e局部变量表\u003c/code\u003e 的大小\u003c/li\u003e\n\u003cli\u003eargs_size : 表示变量个数\u003c/li\u003e\n\u003cli\u003eLineNumberTable : 与 Debug 有关，指当前的的指令集在源文件中的第几行开始\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中\n1: getfield #2          // 获取常量池中 2 号元素(即 Field number:I) 的值，并加载到操作数栈中\n4: ireturn              // 抛出当前操作数栈顶元素作为返回值\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中，每条指令前的 0, 1, 4 指当前指令作为 \u003ccode\u003eCode\u003c/code\u003e 属性的内容的偏移量。\u003c/p\u003e\n\u003cp\u003e换一句话说，\u003ccode\u003eaload_0\u003c/code\u003e 是 Code 属性 code[] 的第 0 个字节的内容\n\u003ccode\u003egetfield #2\u003c/code\u003e 的是从 code[] 的第 1 个字节开始的。\n\u003ccode\u003eireturn\u003c/code\u003e 是从 code[] 的第 4 个字节开始。\u003c/p\u003e\n\u003cp\u003e至于为什么每条指令的开始位置不同，这取决于每条指令的长度。\u003ccode\u003eaload_0\u003c/code\u003e 指令本身为 1 字节的长度，且不要求附带操作数。\n\u003ccode\u003egetfield\u003c/code\u003e 指令自长 1 个字节，但需要一个长度为 2 字节的常量池索引。因此 \u003ccode\u003eireturn\u003c/code\u003e 将从第 4 字节开始\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e同时，可能有人会有所疑问，\u003ccode\u003eaload_0\u003c/code\u003e 加载的 0 号元素是什么？它貌似没有被用到？\u003c/p\u003e\n\u003cp\u003e首先，在每个方法被触发，在构建新的栈帧时，\u003ccode\u003ethis\u003c/code\u003e 将自动作为 0 号元素被存入新栈帧的局部变量表作为 0 号元素。\n同时，如果方法有入参，则入参按入参声明顺序依次作为 1, 2, 3, ... 元素存入。\n(当然，这里存在特殊情况，诸如 long, double 这样长为 8 字节的元素，将占用 2 个局部变量表的数组下标，而其他元素顺延)。\u003c/p\u003e\n\u003cp\u003e至于看似 0 号元素 \u003ccode\u003ethis\u003c/code\u003e 并没有被用到。事实上，它是作为 \u003ccode\u003egetfield\u003c/code\u003e 的一个限定被使用的。\n试想，\u003ccode\u003egetfield\u003c/code\u003e 虽然通过 \u003ccode\u003e#2\u003c/code\u003e 能够知道需要获取到的变量名为 \u003ccode\u003enumber\u003c/code\u003e 类型为 \u003ccode\u003eI(即 int)\u003c/code\u003e 的元素。但是，这个元素究竟属于哪个实例？\n而操作数栈顶的 \u003ccode\u003ethis\u003c/code\u003e 恰恰是指明，需要使用当前方法所在的类的 number 变量。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e类似的，我们看一下 \u003ccode\u003esetNumber\u003c/code\u003e 方法\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中 (用于确定字段所属的类)\n1: iload_1              // 从局部变量表中加载 1 号元素到操作数栈中 (用于确定将要给字段赋的值)\n2: putfield      #2     // 获取常量池中 2 号元素(即 Field number:I) 的地址，并赋值\n5: return               // 无返回值的 return 指令来结束当前栈帧的执行\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e给变量赋初始值\u003c/h2\u003e\n\u003cp\u003e经常会见到在方法体内部有类似这样的声明 \u003ccode\u003eint score = 100\u003c/code\u003e ，那么这样的内容翻译成指令会是如何？\u003c/p\u003e\n\u003cp\u003e对于较小的值，例如 100，将通过 \u003ccode\u003ebipush 100\u003c/code\u003e, \u003ccode\u003eistore_1(假设用局部变量表 1 号元素存储 score 变量\u003c/code\u003e 类似的形式进行赋值。\n类似的，还是 \u003ccode\u003esipush\u003c/code\u003e ，两者的区别是 bipush 可以支持 1 字节大小的整数，sipush 支持 2 字节大小的整数。\u003c/p\u003e\n\u003cp\u003e但是，int 最大可是可以到达 4 字节，更甚者，long 将达到 8 字节。\u003c/p\u003e\n\u003cp\u003e这时候，将要借助的就是 \u003ccode\u003eldc #\u0026#x3C;index\u003e\u003c/code\u003e 用来读取常量池编号小于 128 的常量(例如整数常量，浮点常量等等)\n那么，超出 128 编号的？使用 \u003ccode\u003eldc_w #\u0026#x3C;index\u003e\u003c/code\u003e 读取 2 字节内容作为编号，最大 65535。当然，更大的内容，常量池都不能支持了哈。\u003c/p\u003e\n\u003cp\u003e同时，区别于将 byte, short, int, float 统一作为 4 字节结果读取，对于 long, double 这样的八字节元素，使用 \u003ccode\u003eldc2_w\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e控制结构\u003c/h2\u003e\n\u003cp\u003e作为一门图灵完备的语言，至少，控制结构是必不可少的元素。\u003c/p\u003e\n\u003cp\u003e那么，类似 \u003ccode\u003efor(int i=0;i\u0026#x3C;10;i++)\u003c/code\u003e 的 Java 代码编译成指令到底是什么样的呢？\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e0: iconst_0                     // 赋值指令，往操作数栈顶添加整数值 0\n1: istore_1                     // 将操作数栈顶的元素存入局部变量表 1 号位置\n2: iload_1                      // 从局部变量表 1 号位置加载元素到操作数栈\n3: bipush        10             // 往操作数栈顶压入 byte 型值 10\n5: if_icmpge     21             // 将操作数栈顶的两个元素进行比较, 如果 次顶部元素 \u003e= 顶部元素，则重定向到偏移量为 21 的指令\n//  for (...) {} 语句块的内容\n15: iinc          1, 1          // 将局部变量表的 1 号位置元素 +1\n18: goto          2             // 跳转到偏移量为 2 的指令\n21: return                      // 调用无返回值的 return\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e类似的，\u003ccode\u003eif(...)\u003c/code\u003e 语句的比较较之 \u003ccode\u003efor(;;)\u003c/code\u003e 就更为简单。类比偏移量为 5 的指令即可。\u003c/p\u003e\n\u003ch2\u003e调用方法\u003c/h2\u003e\n\u003cp\u003eJVM 指令集中总计有 4 种调用方法的指令，包括有: \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003einvokevirtual\u003c/code\u003e, 对普通实例方法的调用，将根据对象类型进行分发调用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einvokestatic\u003c/code\u003e, 对静态方法的调用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einvokespecial\u003c/code\u003e, 用于调用类的初始化方法，也用于调用父类方法和私有方法\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einvokeinterface\u003c/code\u003e, 用于调用接口方法\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e以执行 \u003ccode\u003eSystem.out.println()\u003c/code\u003e 为例\n假设常量池内容存在目标元素(具体以相应注释为准)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003egetstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\ninvokevirtual #4                  // Method java/io/PrintStream.println:()V\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eMore\u003c/h2\u003e\n\u003cp\u003e更多内容，包括: 如何实例化一个对象，如何抛出及处理异常，代码同步声明等，暂且不表。\u003c/p\u003e\n\u003cp\u003e有时间再做补充\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。\u003c/p\u003e\n\u003cp\u003e当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。\n那么，直接阅读 \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\"\u003e官方文档\u003c/a\u003e 绝对是比本文的内容更为详实且准确。\u003c/p\u003e\n\u003cp\u003e这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。\u003c/p\u003e"},{"url":"2018-07-20-Java-Proxy","fileName":"2018-07-20-Java-Proxy.md","title":"Java Proxy 源码解析","author":"fangfeng","date":"2018-07-20T00:00:00.000Z","tags":[],"content":"\u003cp\u003e在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。\u003c/p\u003e\n\u003cp\u003e从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。\n而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。\u003c/p\u003e\n\u003ch2\u003e从实例开始...\u003c/h2\u003e\n\u003cp\u003e下面，首先来了解一下 Java Proxy 的使用编码:\u003c/p\u003e\n\u003cp\u003eICodeFactory 接口, 作为将被 Java 动态代理增强的基本接口\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface ICodeFactory {\n\n    Code getCode();\n\n    void setCode(Code code);\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCodeFactory 类, 作为 ICodeFactory 接口的实现类。被视为是真正被动态代理增强的内容，:) 因为接口方法并不存在方法体(当然，Java 8 及以上的 default 请容我忽视)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class CodeFactory implements ICodeFactory {\n\n    private Code code;\n\n    public Code getCode() {\n        return new Code();\n    }\n\n    @Override\n    public void setCode(Code code) {\n        this.code = code;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e辅助类 Code 的内容(简单写，请忽略不符合实际编程规范的一些内容):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Code {\n\n    public int codeA;\n\n    public String codeB;\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e构建增强的代码逻辑:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// main(String[]) 方法\npublic static void main(String[] args) throws Exception {\n\n    // 内部匿名类，用于动态代理生成类的构造方法及其它内容，后面讲。\n    InvocationHandler handler = new InvocationHandler() {\n\n        Object obj = new CodeFactory();\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n            if (method.getName() == \"getCode\") {\n                Code code = (Code) method.invoke(obj, args);\n                code.codeA = code.codeA + 100;\n                code.codeB = \"Proxied: \" + code.codeB;\n                return code;\n            } else {\n                return method.invoke(obj, args);\n            }\n        }\n    };\n\n    // 构建生成类实例\n    Class\u0026#x3C;?\u003e clazz = Proxy.getProxyClass(ICodeFactory.class.getClassLoader(), ICodeFactory.class);\n    // 获取生成类对象\n    ICodeFactory factory = (ICodeFactory) clazz.getConstructor(new Class[] { InvocationHandler.class }).newInstance(new Object[] { handler });\n\n    // 调用 getCode() 方法\n    Code code = factory.getCode();\n    // 打印参数\n    System.out.println(code.codeA);\n    System.out.println(code.codeB);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从默认预期来讲，我们是对接口进行增强。接口方法不存在方法体，也许将在 \u003ccode\u003efactory.getCode()\u003c/code\u003e 时执行失败？\n或者结合已有的认知，成功调用 \u003ccode\u003eCodeFactory.getCode()\u003c/code\u003e 方法，并获得 \u003ccode\u003enew Code()\u003c/code\u003e 。\u003c/p\u003e\n\u003cp\u003e那么，\u003ccode\u003ecode.codeA\u003c/code\u003e \u003ccode\u003ecode.codeB\u003c/code\u003e 的具体值将是什么？\u003c/p\u003e\n\u003cp\u003e执行结果将是:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e100\nProxied: null\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e了解 Proxy 的内容逻辑\u003c/h2\u003e\n\u003cp\u003e从 \u003ccode\u003eProxy.getProxyClass(ClassLoader, Class\u0026#x3C;?\u003e...)\u003c/code\u003e 入手，下面将展开对 \u003ccode\u003eProxy\u003c/code\u003e 具体执行逻辑的探究。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static Class\u0026#x3C;?\u003e getProxyClass(ClassLoader loader, Class\u0026#x3C;?\u003e... interfaces) throws IllegalArgumentException {\n    // 对 interfaces 数组的浅拷贝\n    final Class\u0026#x3C;?\u003e[] intfs = interfaces.clone();\n    final SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        // 如果配置了安全管理器，那么需要确认 Proxy 有创建新的代理类的许可\n        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n    }\n\n    // 调用 \n    return getProxyClass0(loader, intfs);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static Class\u0026#x3C;?\u003e getProxyClass0(ClassLoader loader, Class\u0026#x3C;?\u003e... interfaces) {\n    // 确认需要进行增强的接口数量少于等于 65535，详细原因请去了解 ClassFile 规范(规范中的接口上限)\n    if (interfaces.length \u003e 65535) {\n        throw new IllegalArgumentException(\"interface limit exceeded\");\n    }\n\n    // 如果需要由指定 ClassLoader 加载, 实现给定 interfaces 的代理类已经存在, \n    // 将直接返回已经缓存过的拷贝\n    // 否则，通过 ProxyClassFactory 创建新的代理类\n    return proxyClassCache.get(loader, interfaces);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在需要额外来考察一下 proxyClassCache 的具体类型。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static final WeakCache\u0026#x3C;ClassLoader, Class\u0026#x3C;?\u003e[], Class\u0026#x3C;?\u003e\u003e\n        proxyClassCache = new WeakCache\u0026#x3C;\u003e(new KeyFactory(), new ProxyClassFactory());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eWeakCache\u003c/code\u003e, 从名称来将，是一个缓存，同时应该使用了 WeakReference 技术\u003c/p\u003e\n\u003cp\u003e进入 \u003ccode\u003eWeakCache.get(...)\u003c/code\u003e 方法体\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic V get(K key, P parameter) {\n    // parameter 传入的是接口数组，要求不能为空\n    Objects.requireNonNull(parameter);\n\n    // 删除过期元素\n    expungeStaleEntries();\n\n    // 构建一个 WeakReference 对象(key 表示 ClassLoader)\n    Object cacheKey = CacheKey.valueOf(key, refQueue);\n\n    // lazily install the 2nd level valuesMap for the particular cacheKey\n    ConcurrentMap\u0026#x3C;Object, Supplier\u0026#x3C;V\u003e\u003e valuesMap = map.get(cacheKey);\n    if (valuesMap == null) {\n        ConcurrentMap\u0026#x3C;Object, Supplier\u0026#x3C;V\u003e\u003e oldValuesMap\n                = map.putIfAbsent(cacheKey,\n                valuesMap = new ConcurrentHashMap\u0026#x3C;\u003e());\n        if (oldValuesMap != null) {\n            valuesMap = oldValuesMap;\n        }\n    }\n\n    // 创建次级 Key\n    // 同时检索是否存在过去有同一个 ClassLoader 加载的表示 Supplier\u0026#x3C;V\u003e\n    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));\n    Supplier\u0026#x3C;V\u003e supplier = valuesMap.get(subKey);\n    Factory factory = null;\n\n    while (true) {\n        if (supplier != null) {\n            // supplier might be a Factory or a CacheValue\u0026#x3C;V\u003e instance\n            // 最终 supplier 将非空，同时调用 .get() 方法获取 Class 类\n            V value = supplier.get();\n            if (value != null) {\n                return value;\n            }\n        }\n        // else no supplier in cache\n        // or a supplier that returned null (could be a cleared CacheValue\n        // or a Factory that wasn't successful in installing the CacheValue)\n        // 未找到过去加载的记录\n\n        // 懒加载一个 Factory \n        if (factory == null) {\n            factory = new Factory(key, parameter, subKey, valuesMap);\n        }\n\n        if (supplier == null) {\n            supplier = valuesMap.putIfAbsent(subKey, factory);\n            if (supplier == null) {\n                // successfully installed Factory\n                supplier = factory;\n            }\n            // else retry with winning supplier\n        } else {\n            if (valuesMap.replace(subKey, supplier, factory)) {\n                // successfully replaced\n                // cleared CacheEntry / unsuccessful Factory\n                // with our Factory\n                supplier = factory;\n            } else {\n                // retry with current supplier\n                supplier = valuesMap.get(subKey);\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic synchronized V get() { // serialize access\n    // re-check\n    Supplier\u0026#x3C;V\u003e supplier = valuesMap.get(subKey);\n    if (supplier != this) {\n        // something changed while we were waiting:\n        // might be that we were replaced by a CacheValue\n        // or were removed because of failure -\u003e\n        // return null to signal WeakCache.get() to retry\n        // the loop\n        return null;\n    }\n    // else still us (supplier == this)\n\n    // create new value\n    V value = null;\n    try {\n        // 触发 valueFactory.apply() 真正的构建\n        value = Objects.requireNonNull(valueFactory.apply(key, parameter));\n    } finally {\n        if (value == null) { // remove us on failure\n            valuesMap.remove(subKey, this);\n        }\n    }\n    // the only path to reach here is with non-null value\n    assert value != null;\n\n    // wrap value with CacheValue (WeakReference)\n    CacheValue\u0026#x3C;V\u003e cacheValue = new CacheValue\u0026#x3C;\u003e(value);\n\n    // put into reverseMap\n    reverseMap.put(cacheValue, Boolean.TRUE);\n\n    // try replacing us with CacheValue (this should always succeed)\n    if (!valuesMap.replace(subKey, this, cacheValue)) {\n        throw new AssertionError(\"Should not reach here\");\n    }\n\n    // successfully replaced us with new CacheValue -\u003e return the value\n    // wrapped by it\n    return value;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面两段代码的内容，都是在反复确认将要构建的生成类是否在过去曾经创建过，如果是，则直接返回过去构建的类实例;\n否则才会尝试创建，并最终将这个构建的类也进行缓存。\u003c/p\u003e\n\u003cp\u003e下面这段代码来自于 \u003ccode\u003eProxy\u003c/code\u003e 的内部类 \u003ccode\u003eProxyClassFactory\u003c/code\u003e\n这部分，也终于开始了对代理类字节码的统筹性构造的内容。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Class\u0026#x3C;?\u003e apply(ClassLoader loader, Class\u0026#x3C;?\u003e[] interfaces) {\n\n    Map\u0026#x3C;Class\u0026#x3C;?\u003e, Boolean\u003e interfaceSet = new IdentityHashMap\u0026#x3C;\u003e(interfaces.length);\n    for (Class\u0026#x3C;?\u003e intf : interfaces) {\n        /*\n         * 校验当前接口是由同一个 ClassLoader (将要用来加载新的代理类)加载的\n         */\n        Class\u0026#x3C;?\u003e interfaceClass = null;\n        try {\n            interfaceClass = Class.forName(intf.getName(), false, loader);\n        } catch (ClassNotFoundException e) {\n        }\n        if (interfaceClass != intf) {\n            throw new IllegalArgumentException(\n                    intf + \" is not visible from class loader\");\n        }\n        /*\n         * 校验当前 Class 对象确实是一个接口\n         */\n        if (!interfaceClass.isInterface()) {\n            throw new IllegalArgumentException(\n                    interfaceClass.getName() + \" is not an interface\");\n        }\n        /*\n         * 校验当前接口没有被要求重复进行代理增强\n         */\n        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {\n            throw new IllegalArgumentException(\n                    \"repeated interface: \" + interfaceClass.getName());\n        }\n    }\n\n    String proxyPkg = null;     // 生成的代理类所属的 package\n    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n\n    /*\n     * 如果代理的接口是非 PUBLIC ，那么生成的代理类的接口将与这个非 PUBLIC 接口\n     * 在同一个包下。\n     * 如果代理的接口有多个非 PUBLIC ，且分别位于不同的包下，那么抛出异常\n     */\n    for (Class\u0026#x3C;?\u003e intf : interfaces) {\n        int flags = intf.getModifiers();\n        if (!Modifier.isPublic(flags)) {\n            accessFlags = Modifier.FINAL;\n            String name = intf.getName();\n            int n = name.lastIndexOf('.');\n            String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1));\n            if (proxyPkg == null) {\n                proxyPkg = pkg;\n            } else if (!pkg.equals(proxyPkg)) {\n                throw new IllegalArgumentException(\n                        \"non-public interfaces from different packages\");\n            }\n        }\n    }\n\n    // 如果代理的接口全是 PUBLIC 的，那么使用默认的包 com.sun.proxy\n    if (proxyPkg == null) {\n        // if no non-public proxy interfaces, use com.sun.proxy package\n        proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\";\n    }\n\n    /*\n     * 为将要生成的代理类选择一个全限定名\n     * 规则是 包名 + \"$Proxy\" + \u0026#x3C;唯一递增的id, 从0开始编号\u003e\n     */\n    long num = nextUniqueNumber.getAndIncrement();\n    String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n    /*\n     * 生成一个特殊的代理类的字节码\n     * byte[] proxyClassFile 就等同于 .class 文件的全部二进制内容。\n     * 与 .class 文件的区别就在于一个写在了外存上，另一个完全在内存中创建\n     */\n    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n            proxyName, interfaces, accessFlags);\n    try {\n        /**\n          * 调用 ClassLoader 的 defineClass0(...) 方法加载字节码内容，构造 Class 对象\n          * 本来 defineClass0(...) 方法是定义在 ClassLoader 中，但这里额外声明了一个本地方法 defineClass0(...)\n          * 想来实现也是类似的，最终的目的也是加载 Class \n          */\n        return defineClass0(loader, proxyName,\n                proxyClassFile, 0, proxyClassFile.length);\n    } catch (ClassFormatError e) {\n        /*\n         * A ClassFormatError here means that (barring bugs in the\n         * proxy class generation code) there was some other\n         * invalid aspect of the arguments supplied to the proxy\n         * class creation (such as virtual machine limitations\n         * exceeded).\n         */\n        throw new IllegalArgumentException(e.toString());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在完成基础性的校验，并构造了生成类的类名等内容后，\n\u003ccode\u003eProxyGenerator.generateProxyClass\u003c/code\u003e 将开始构造 \u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html\"\u003eClassFile\u003c/a\u003e 的具体内容。\u003c/p\u003e\n\u003cp\u003e关于这部分生成字节码的内容，请在了解了 ClassFile 的基础性内容之后，在自行学习，内容全部在 ProxyGenerator 类中。\u003c/p\u003e\n\u003cp\u003e这部分的规则是(在构建新的代理生成类时):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e额外添加三个 Object 的方法 (\u003ccode\u003ehashCode\u003c/code\u003e, \u003ccode\u003eequals\u003c/code\u003e, \u003ccode\u003etoString\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e逐一读取所有需要增强的接口的方法，并对重复方法进行判断; 如果方法名相同，入参数量与类型相同，但返回参数不同，则抛出异常\u003c/li\u003e\n\u003cli\u003e在遍历所有接口的方法的时候，同时也将为新的生成类构造新的字段(内容就是通过反射获取该方法)\u003c/li\u003e\n\u003cli\u003e最后将新的生成类将要包含的所有字段与方法进行构造，同时维护一个常量池内容\u003c/li\u003e\n\u003cli\u003e输出这些内容的二进制表示 byte[];\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e如何对方法增强\u003c/h2\u003e\n\u003cp\u003e想必上了上一节，虽然对 Java 动态代理的调用链有了一定的了解。\u003c/p\u003e\n\u003cp\u003e但是，究竟 Proxy 是如何完成对实现类方法的增强呢？\u003c/p\u003e\n\u003cp\u003e也许我们需要先看一下生成类 .class 文件的一些内容来对这个命题形成基础性的影响。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic final Code getCode() throws  {\n    try {\n        return (Code)super.h.invoke(this, m4, (Object[])null);\n    } catch (RuntimeException | Error var2) {\n        throw var2;\n    } catch (Throwable var3) {\n        throw new UndeclaredThrowableException(var3);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到，生成类的 \u003ccode\u003egetCode()\u003c/code\u003e 方法几乎没有什么实质性的内容, 只是 \u003ccode\u003esuper.h.invoke(...)\u003c/code\u003e 。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eh\u003c/code\u003e 实例变量是什么？\u003ccode\u003eInvocationHandler\u003c/code\u003e 的一个实例对象。\u003c/p\u003e\n\u003cp\u003e事实上，Java Proxy 生成类的每个方法结构几乎都是类似的。方法体的内容就是通过实例持有的 \u003ccode\u003eh\u003c/code\u003e 变量分发实际的操作指令\u003c/p\u003e\n\u003cp\u003e至于 h 的具体内容。:) 有编程者自定义，并在 Proxy 生成字节码，并被 ClassLoader 加载后，在准备实例化的时候作为构造参数进行传入。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eICodeFactory factory = (ICodeFactory) clazz.getConstructor(new Class[] { InvocationHandler.class }).newInstance(new Object[] { handler });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至于具体将做哪些增强，调用例如上例的 \u003ccode\u003eICodeFactory\u003c/code\u003e 的那个实现类的方法，全部有使用者自定义。\u003c/p\u003e\n\u003ch2\u003e生成类的反编译结果\u003c/h2\u003e\n\u003cp\u003e仍然以本文开始的 ICodeFactory 的增强为例，看一下究竟通过 Java Proxy 动态代理生成的字节码的反编译结果究竟是什么？\n并以此来对这种动态代理机制形成更为直观的印象\u003c/p\u003e\n\u003cp\u003e在 Java 源代码中，虽然默认不会输出生成类的二进制内容，但是，仍然预留了打印 .class 文件的可选项。\u003c/p\u003e\n\u003cp\u003e有兴趣的同学可以看一下 \u003ccode\u003eProxyGenerator.saveGeneratedFiles\u003c/code\u003e 字段的内容，这就决定是在构造代理类后是否存储到外存中。\u003c/p\u003e\n\u003cp\u003e想要看到代理类的字节码，直接通过在 Java 执行程序中添加一行代码\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eSystem.setProperty(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e或者在启动程序的 \u003ccode\u003ejava\u003c/code\u003e 命令下添加参数\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true`\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至于生成类将打印在哪，首先必然是在项目所属的目录下。有上一节中构造生成类全限定名的内容，根据包名的规则去寻找即可。(具体不再详述)\u003c/p\u003e\n\u003cp\u003e直接通过 IDEA, Eclipse 或者其它工具，对生成类 .class 文件进行反编译可以查看到整个生成类的内容。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.sun.proxy;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\nimport me.fangfeng.jdk.proxy.Code;\nimport me.fangfeng.jdk.proxy.ICodeFactory;\n\npublic final class $Proxy0 extends Proxy implements ICodeFactory {\n    private static Method m1;\n    private static Method m2;\n    private static Method m4;\n    private static Method m3;\n    private static Method m0;\n\n    public $Proxy0(InvocationHandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        try {\n            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final String toString() throws  {\n        try {\n            return (String)super.h.invoke(this, m2, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final Code getCode() throws  {\n        try {\n            return (Code)super.h.invoke(this, m4, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final void setCode(Code var1) throws  {\n        try {\n            super.h.invoke(this, m3, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final int hashCode() throws  {\n        try {\n            return (Integer)super.h.invoke(this, m0, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    static {\n        try {\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\"));\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\");\n            m4 = Class.forName(\"me.fangfeng.jdk.proxy.ICodeFactory\").getMethod(\"getCode\");\n            m3 = Class.forName(\"me.fangfeng.jdk.proxy.ICodeFactory\").getMethod(\"setCode\", Class.forName(\"me.fangfeng.jdk.proxy.Code\"));\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\");\n        } catch (NoSuchMethodException var2) {\n            throw new NoSuchMethodError(var2.getMessage());\n        } catch (ClassNotFoundException var3) {\n            throw new NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cp\u003e在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。\u003c/p\u003e\n\u003cp\u003e从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。\n而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。\u003c/p\u003e"},{"url":"2018-07-13-How-to-easily-get-CGlib-generated-code","fileName":"2018-07-13-How-to-easily-get-CGlib-generated-code.md","title":"如何方便地获取 CGlib 生成类","author":"fangfeng","date":"2018-07-13T00:00:00.000Z","tags":["CGlib","tools"],"content":"\u003ch2\u003e配置参数\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e命令行使用\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 java 启动命令中添加参数配置项 \u003ccode\u003e-Dcglib.debugLocation=\u0026#x3C;Custom Path\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e编码实现\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在执行 CGlib 获取新生成类之前，调用 \u003ccode\u003eSystem.setProperty(\"cglib.debugLocation\", \u0026#x3C;Custom Path\u003e)\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e如何游刃有余地 Debug 掺杂 CGlib 生成类的调用链\u003c/h2\u003e\n\u003cp\u003e经常会遇到，项目中不经意间就遇到了 CGlib 代理，然后对调用链的 Debug 就开始出现断层。继而，对对象或实例变量的跟踪就显得一头雾水。\u003c/p\u003e\n\u003cp\u003e特别是在不了解生成类到底是增强了那些内容的时候，甚至可能连调用链都跟踪不下去了 T_T 。\u003c/p\u003e\n\u003cp\u003e通过 \u003cstrong\u003e配置参数\u003c/strong\u003e 一节的内容，你就可以在你理想的目录 \u003ccode\u003e\u0026#x3C;Custom Path\u003e\u003c/code\u003e 下看到\u003cstrong\u003e所谓黑盒\u003c/strong\u003e中生成类的完成内容了。\u003c/p\u003e\n\u003cp\u003e下面的内容，将简单地介绍如何配合 CGlib 生成类的内容实现: 保证 Debug 的每一步骤可见; 保证 Debug 的过程不会出现\u003cem\u003e黑盒\u003c/em\u003e。\u003c/p\u003e\n\u003ch3\u003e确定 \u003ccode\u003e\u0026#x3C;Custom Path\u003e\u003c/code\u003e 下哪个文件是原有 Java 类的生成类\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic String getClassName(String prefix, String source, Object key, Predicate names) {\n    if (prefix == null) {\n        prefix = \"net.sf.cglib.empty.Object\";\n    } else if (prefix.startsWith(\"java\")) {\n        prefix = \"$\" + prefix;\n    }\n    String base =\n        prefix + \"$$\" +\n        source.substring(source.lastIndexOf('.') + 1) +\n        getTag() + \"$$\" +\n        Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\n    String attempt = base;\n    int index = 2;\n    while (names.evaluate(attempt))\n        attempt = base + \"_\" + index++;\n    return attempt;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCGlib 默认的类名生成策略下，生成类的全限定名将结合原文件的全限定名决定。\u003c/p\u003e\n\u003cp\u003e通常命名如下: \u003ccode\u003e\u0026#x3C;原 Java 类全限定名\u003e$$\u0026#x3C;类似 EnhancerByCGlib\u003e$$\u0026#x3C;生成类核心内容的 hash 值\u003e_\u0026#x3C;index[可能存在]\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e例如: 原有 Java 类全限定名为 me.fangfeng.Test ，则生成类名可能为 \u003ccode\u003eme.fangfeng.Test$$EnhancerByCGlib$$ab1203aa\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e当然，通常情况下会存在一个类名形如 \u003ccode\u003eme.fangfeng.Test$$FastClassBySpring$$...\u003c/code\u003e 的类，这是作为生成类 \u003ccode\u003eme.fangfeng.Test$$EnhancerByCGlib$$ab1203aa\u003c/code\u003e 的辅助类来使用。\u003c/p\u003e\n\u003ch3\u003e简单了解生成类下的调用关系\u003c/h3\u003e\n\u003cp\u003eJava 代码触发被增强的类，将首先调用生成类。但是，这是没办法进行 Debug 的，因为这个生成类的字节码缺少 SourceFile 属性，同时缺少 LineNumberTable 属性。\u003c/p\u003e\n\u003cp\u003e但是，这并不影响对调用链的跟踪。\u003c/p\u003e\n\u003cp\u003eCGlib 的增强，所有的增强逻辑都是以 Callback 实现类的形式来提供的。同时在 CGlib 生成类中也有 Callback 的实例变量来持有这些注入的 Callback 。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原有 Java 类\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1ft8e7kr7qvj30sc0j0wh4.jpg\" alt=\"LogonService.java\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e对应的生成类\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8e9ww4hqj31hg0oojzv.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eanb6c9j31j00lgn1e.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e跟踪 LogonService.addLogon(String var1) 演示\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e当前 LogonService 的生成类全限定名为me.fangfeng.transactionBugs.LogonService\u003cspan class=\"inlineMath\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eE\u003c/mi\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmi\u003eh\u003c/mi\u003e\u003cmi\u003ea\u003c/mi\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmi\u003ec\u003c/mi\u003e\u003cmi\u003ee\u003c/mi\u003e\u003cmi\u003er\u003c/mi\u003e\u003cmi\u003eB\u003c/mi\u003e\u003cmi\u003ey\u003c/mi\u003e\u003cmi\u003eS\u003c/mi\u003e\u003cmi\u003ep\u003c/mi\u003e\u003cmi\u003er\u003c/mi\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmi\u003eg\u003c/mi\u003e\u003cmi\u003eC\u003c/mi\u003e\u003cmi\u003eG\u003c/mi\u003e\u003cmi\u003eL\u003c/mi\u003e\u003cmi\u003eI\u003c/mi\u003e\u003cmi\u003eB\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eEnhancerBySpringCGLIB\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05764em;\"\u003eE\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003en\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003eh\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ea\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003en\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ec\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ee\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003er\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05017em;\"\u003eB\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.03588em;\"\u003ey\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05764em;\"\u003eS\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ep\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.02778em;\"\u003er\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003ei\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003en\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.03588em;\"\u003eg\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07153em;\"\u003eC\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003eG\u003c/span\u003e\u003cspan class=\"mord mathdefault\"\u003eL\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.07847em;\"\u003eI\u003c/span\u003e\u003cspan class=\"mord mathdefault\" style=\"margin-right:0.05017em;\"\u003eB\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003ebfc1dc3.class; 以下简称为 LogonSerivce$$bfc1dc3 \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e首先，配置 \u003ccode\u003ecglib.debugLocation\u003c/code\u003e 参数，值 = 项目生成的 .class 路径\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e无断点直接运行一次需要处理的逻辑\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e找到 LogonSerive$$bfc1dc3.class, 随意打上一个看似有效的断点\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在各处打上必要的断点，开始进行真正的调试工作\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e代码执行到 \u003ccode\u003eLogonService$$bfc1dc3.class\u003c/code\u003e, 虽然没有真正进入断点位置, 但是可以看到这个 \u003ccode\u003eLogonService$$bfc1dc3\u003c/code\u003e 实例的实例变量信息\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1ft8eq1be61j319w0bwtde.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8egtg1naj31ji0fmgp2.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e比照生成类代码中 addLogon(String var1) 方法体的内容以及展示的实例变量信息。可以看到生成类调用的 Callback 实例是 \u003ccode\u003eCGLIB$CALLBACK_0\u003c/code\u003e\n类型是 CglibAopProxy 的静态内部私有类 DynamicAdvisedInterceptor 。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eu91oscj31gq0ayju5.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e在 intercept(...) 上打个断点，跳过生成类 addLogon(String var1) 方法的下一个调用方法就是 intercept(...) \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e而且事实上，CGlib 生成类的内容基本也就是对调用方法进行的一种转发\u003c/strong\u003e\u003c/p\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e继续 Debug ，对于生成类的内容，人肉了解并定位到触发的 Callback 实例或者 super.Xxx() 方法。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e配置参数\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e命令行使用\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 java 启动命令中添加参数配置项 \u003ccode\u003e-Dcglib.debugLocation=\u0026#x3C;Custom Path\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e编码实现\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在执行 CGlib 获取新生成类之前，调用 \u003ccode\u003eSystem.setProperty(\"cglib.debugLocation\", \u0026#x3C;Custom Path\u003e)\u003c/code\u003e\u003c/p\u003e"},{"url":"2018-07-10-CGlib-Enhancer","fileName":"2018-07-10-CGlib-Enhancer.md","title":"CGlib Enhancer 主流程源码解析","author":"fangfeng","date":"2018-07-10T00:00:00.000Z","tags":["CGlib","ASM"],"content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e此博文写作的目的: \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。\u003c/li\u003e\n\u003cli\u003e基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eEnhancer\u003c/h2\u003e\n\u003cp\u003e从这篇不是官方但更胜于官方文档的 \u003ca href=\"http://mydailyjava.blogspot.com/2013/11/cglib-missing-manual.html\"\u003eCGlib Guide\u003c/a\u003e 来看，它首先提到的第一个类就是 Enhancer。\n其被用于创建 Java 代理类，相较于 Java 标准库的 Proxy 类，它\u003cstrong\u003e特别地\u003c/strong\u003e，能够支持那些没有实现接口的类的代理工作。\u003c/p\u003e\n\u003ch3\u003eEnhancer 简单示例展示\u003c/h3\u003e\n\u003cp\u003e针对现有的 SampleClass 类\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SampleClass {\n    public String test(String input) {\n        return \"Hello World!\";\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用 CGlib 的 Enhancer 对 SampleClass 进行增强，下列操作的目的在于将 test(String) 方法的返回值改写成 \"Hello cglib!\"\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Test\npublic void testFixedValue() {\n    // new 一个 Enhancer 实例\n    Enhancer enhancer = new Enhancer();\n    // 声明使用的父类是 SampleClass\n    enhancer.setSuperclass(SampleClass.class);\n    // 设置回调方法 - 回调方法实现为 FixedValue (固定值) .\n    enhancer.setCallback(new FixedValue() {\n        public Object loadObject() throws Exception {\n            return \"Hello cglib!\";\n        }\n    });\n    // 创建 SampleClass 的代理子类实例\n    SampleClass proxy = (SampleClass) enhancer.create();\n    Assert.assertEquals(\"Hello cglib!\", proxy.test(null));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e简单测试上述代码，可以了解到确实，代理类的 test(String) 方法的返回值被改写了。\n那么，究竟这种操作是如何实现的？下面👇将进行具体的探究。\u003c/p\u003e\n\u003ch2\u003e调用链跟踪\u003c/h2\u003e\n\u003ch3\u003e高度抽象的时序图\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1ft4ifuo997j31jh0st42t.jpg\" alt=\"Enhancer 调用链 时序图\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e下列内容将根据时序图进行组织，根据调用编号(1,2,3...)进行展开\u003c/em\u003e\u003c/p\u003e\n\u003ch3\u003eSeq 1.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Object create() {\n    classOnly = false;\n    argumentTypes = null;\n    return createHelper();\n}\n\npublic Object create(Class[] argumentTypes, Object[] arguments) {\n    classOnly = false;\n    if (argumentTypes == null || arguments == null || argumentTypes.length != arguments.length) {\n        throw new IllegalArgumentException(\"Arguments must be non-null and of equal length\");\n    }\n    this.argumentTypes = argumentTypes;\n    this.arguments = arguments;\n    return createHelper();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述两个 \u003ccode\u003ecreate(...)\u003c/code\u003e 方法。结合上一节的使用示例，可以看到 \u003ccode\u003ecreate()\u003c/code\u003e 对应的\u003cstrong\u003e无参构造\u003c/strong\u003e。\n存在无参构造，那么\u003cstrong\u003e有参的构造方法\u003c/strong\u003e显然也是应该被支持id。\u003ccode\u003ecreate(Class[], Object[])\u003c/code\u003e 正是为了这个目标而存在。通过提供参数类型数组和参数实例数组，可以唯一地定位及调用代理类的特定构造方法。\u003c/p\u003e\n\u003cp\u003e这个方法比较简单，只是将 Enhancer 作为一个数据内容的持有者，重置了新代理类将使用的构造函数参数内容，之后就直接调用了 \u003ccode\u003ecreateHelper()\u003c/code\u003e 。\u003c/p\u003e\n\u003ch3\u003eSeq 2.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Object createHelper() {\n    // 对预声明的回调方法进行验证，要求 [多个回调就必须存在 CallbackFilter 作为调度器]\n    preValidate();\n    // 构建一个对这类增强操作唯一定位的 key\n    Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,\n            ReflectUtils.getNames(interfaces),\n            filter == ALL_ZERO ? null : new WeakCacheKey\u0026#x3C;CallbackFilter\u003e(filter),\n            callbackTypes,\n            useFactory,\n            interceptDuringConstruction,\n            serialVersionUID);\n    this.currentKey = key;\n    // 调用父类通过的 create(...) 方法\n    Object result = super.create(key);\n    return result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSeq 3.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprotected Object create(Object key) {\n    try {\n        // 获取用于 加载 生成类 的 ClassLoader\n        ClassLoader loader = getClassLoader();\n        // 从缓存中加载 这个 ClassLoader 过去加载的相关数据\n        Map\u0026#x3C;ClassLoader, ClassLoaderData\u003e cache = CACHE;\n        ClassLoaderData data = cache.get(loader);\n        // 如果在 缓存 中找不到，则初始化构造关于这个 ClassLoader 的数据实例\n        if (data == null) {\n            // 同步\n            synchronized (AbstractClassGenerator.class) {\n                // 进入同步块后的 再次确认，避免重复初始化构建\n                cache = CACHE;\n                data = cache.get(loader);\n                if (data == null) {\n                    // 构建新的 缓存，拷贝原有的缓存集的内容\n                    Map\u0026#x3C;ClassLoader, ClassLoaderData\u003e newCache = new WeakHashMap\u0026#x3C;ClassLoader, ClassLoaderData\u003e(cache);\n                    // 初始化 ClassLoaderData ，真正的构造操作\n                    data = new ClassLoaderData(loader);\n                    // 添加到缓存中\n                    newCache.put(loader, data);\n                    CACHE = newCache;\n                }\n            }\n        }\n        this.key = key;\n        Object obj = data.get(this, getUseCache());\n        if (obj instanceof Class) {\n            // 初次实例化操作，就是 Class 利用反射来进行实例化\n            return firstInstance((Class) obj);\n        }\n        // 非初次实例化，则是从 ClassLoaderData 中得到的之前维护的内容\n        return nextInstance(obj);\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (Error e) {\n        throw e;\n    } catch (Exception e) {\n        throw new CodeGenerationException(e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这部分内容比较多，且是调用链比较重要的一环。\u003cstrong\u003eSeq 4.\u003c/strong\u003e 和 \u003cstrong\u003eSeq 5.\u003c/strong\u003e 将作为其子内容进行调用，但为了本博文的结构完整， \u003cem\u003eSeq 4. \u0026#x26; Seq5.\u003c/em\u003e 的标题与 \u003cem\u003eSeq 3.\u003c/em\u003e 标题同级\u003c/p\u003e\n\u003ch3\u003eSeq 4.\u003c/h3\u003e\n\u003cp\u003e首先应该认识到，每个被加载的 Class ，在 \u003ccode\u003eequal\u003c/code\u003e 的判断过程中，依据的是同一个 ClassLoader 加载的同一 Class 才被认为是相同的，否则即使 Class 是同一个，但仍会被认为是不同的(由不同的 ClassLoader 加载)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic ClassLoader getClassLoader() {\n    ClassLoader t = classLoader;\n    if (t == null) {\n        t = getDefaultClassLoader();\n    }\n    if (t == null) {\n        t = getClass().getClassLoader();\n    }\n    if (t == null) {\n        t = Thread.currentThread().getContextClassLoader();\n    }\n    if (t == null) {\n        throw new IllegalStateException(\"Cannot determine classloader\");\n    }\n    return t;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因此，在这部分中，首先需要确定的是由哪个 ClassLoader 进行加载的工作。\u003ccode\u003egetClassLoader()\u003c/code\u003e 的确定顺序是:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e具体实现类声明的 \u003cstrong\u003e默认 ClassLoader\u003c/strong\u003e 为第一优先级\u003c/li\u003e\n\u003cli\u003e加载当前类(这里是 Enhancer) 的 ClassLoader 为第二优先级\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e当前线程上下文 ClassLoader\u003c/strong\u003e 为第三优先级\u003c/li\u003e\n\u003cli\u003e抛出异常\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e回到 \u003cstrong\u003eSeq 3.\u003c/strong\u003e 的内容，\n下一步是对当前这个\u003cstrong\u003eAbstractClassGenerator\u003c/strong\u003e 维护的 CACHE 进行处理，如果在 CACHE 中能够得到以确定的 ClassLoader 为 Key 的键值对，则直接获取 ClassLoader 对应的值，否则将进行初始化构建一个新的 ClassLoaderData 作为这个 ClassLoader 的值。\u003c/p\u003e\n\u003ch3\u003eSeq 5.\u003c/h3\u003e\n\u003cp\u003e在构建 ClassLoaderData 的过程中，最重要的一步:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic ClassLoaderData(ClassLoader classLoader) {\n    // ClassLoader 不可为空\n    if (classLoader == null) {\n        throw new IllegalArgumentException(\"classLoader == null is not yet supported\");\n    }\n    // 构建 ClassLoader 的弱引用\n    this.classLoader = new WeakReference\u0026#x3C;ClassLoader\u003e(classLoader);\n    // 写了个后置调用的函数，用于懒加载，只有调用了 load.apply(...) 才会构建 生成类\n    Function\u0026#x3C;AbstractClassGenerator, Object\u003e load =\n            new Function\u0026#x3C;AbstractClassGenerator, Object\u003e() {\n                public Object apply(AbstractClassGenerator gen) {\n                    Class klass = gen.generate(ClassLoaderData.this);\n                    return gen.wrapCachedClass(klass);\n                }\n            };\n    generatedClasses = new LoadingCache\u0026#x3C;AbstractClassGenerator, Object, Object\u003e(GET_KEY, load);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e构建了一个 Function 实例，这个 Function 作为函数式接口，预定义执行的具体流程，但由上下文确定具体的调用时刻。\u003c/p\u003e\n\u003ch3\u003eSeq 6.\u003c/h3\u003e\n\u003cp\u003e在正确得到了 ClassLoader 对应的 ClassLoaderData 之后，ClassLoaderData 的 \u003ccode\u003eget(...)\u003c/code\u003e 方法将在特定的 ClassLoader 之下，进行更具体的加载新生成类的工作。\n当然，这里的前提是新的生成类的字节码已经被构建:)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Object get(AbstractClassGenerator gen, boolean useCache) {\n    // 标记为不使用缓存，直接构建 新的生成类\n    if (!useCache) {\n      return gen.generate(ClassLoaderData.this);\n    }\n    // 使用缓冲的情况\n    else {\n      Object cachedValue = generatedClasses.get(gen);\n      return gen.unwrapCachedValue(cachedValue);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003egen.generate(ClassLoaderData.this)\u003c/code\u003e 这段代码在 \u003ccode\u003eget(...)\u003c/code\u003e 方法和上一小节 \u003ccode\u003eClassLoaderData(...)\u003c/code\u003e 构造方法的 Function 函数式实例都出现了。\u003c/p\u003e\n\u003cp\u003e实际上，这也是触发 ClassLoader 来加载动态生成的新 Class 的唯一入口。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e判断逻辑\u003c/em\u003e 的 \u003ccode\u003eelse\u003c/code\u003e 内容的唯一区别就在于其构建的是一个加载缓存，将真正触发 gen.generate(ClassLoaderData.this) 的逻辑延迟。(不过，最终也还是会进行调用的，:) 这是毋庸置疑的)。\u003c/p\u003e\n\u003ch3\u003eSeq 7.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprotected Class generate(ClassLoaderData data) {\n    Class gen;\n    Object save = CURRENT.get();\n    CURRENT.set(this);\n    try {\n        // 拿到用于加载生成类的 ClassLoader\n        ClassLoader classLoader = data.getClassLoader();\n        if (classLoader == null) {\n            throw new IllegalStateException(\"ClassLoader is null while trying to define class \" +\n                    getClassName() + \". It seems that the loader has been expired from a weak reference somehow. \" +\n                    \"Please file an issue at cglib's issue tracker.\");\n        }\n        // 构建一个合法的 生成类 的类名(非重复)\n        synchronized (classLoader) {\n          String name = generateClassName(data.getUniqueNamePredicate());\n          data.reserveName(name);\n          this.setClassName(name);\n        }\n        if (attemptLoad) {\n            try {\n                // 尝试直接通过 ClassLoader 进行加载\n                gen = classLoader.loadClass(getClassName());\n                return gen;\n            } catch (ClassNotFoundException e) {\n                // ignore\n            }\n        }\n        // 策略下的生成类构建方法\n        byte[] b = strategy.generate(this);\n        // 通过解析字节码的形式获取 生成类的 className\n        String className = ClassNameReader.getClassName(new ClassReader(b));\n        ProtectionDomain protectionDomain = getProtectionDomain();\n        synchronized (classLoader) { // just in case\n            // 反射的形式加载 Class 类\n            if (protectionDomain == null) {\n                gen = ReflectUtils.defineClass(className, b, classLoader);\n            } else {\n                gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);\n            }\n        }\n        return gen;\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (Error e) {\n        throw e;\n    } catch (Exception e) {\n        throw new CodeGenerationException(e);\n    } finally {\n        CURRENT.set(save);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个方法，就是操作字节码，加载 Class 的核心调度方法。\u003c/p\u003e\n\u003cp\u003e可以看到 \u003ccode\u003egenerateClassName(...)\u003c/code\u003e 方法将构建一个当前 ClassLoader 下唯一, 不重复的新的类名。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estrategy.generate(this)\u003c/code\u003e 将通过特定策略实现的形式生成新的字节码\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eReflectUtils.defineClass(className, b, classLoader)\u003c/code\u003e 将使用反射使得 ClassLoader 来加载这个新的生成类。\u003c/p\u003e\n\u003ch3\u003eSeq 8.\u003c/h3\u003e\n\u003cp\u003e生成新的不重复类名这部分不做过多陈述，可以简单进行了解，并熟悉 CGlib 默认的新类名的命名规则\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// DefaultNamePolicy\npublic String getClassName(String prefix, String source, Object key, Predicate names) {\n    if (prefix == null) {\n        prefix = \"net.sf.cglib.empty.Object\";\n    } else if (prefix.startsWith(\"java\")) {\n        prefix = \"$\" + prefix;\n    }\n    String base =\n        prefix + \"$$\" +\n        source.substring(source.lastIndexOf('.') + 1) +\n        getTag() + \"$$\" +\n        Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\n    String attempt = base;\n    int index = 2;\n    while (names.evaluate(attempt))\n        attempt = base + \"_\" + index++;\n    return attempt;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSeq 9.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 下列是 DefaultGeneratorStrategy 的实现\npublic byte[] generate(ClassGenerator cg) throws Exception {\n    DebuggingClassWriter cw = getClassVisitor();\n    transform(cg).generateClass(cw);\n    return transform(cw.toByteArray());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSeq 10.\u003c/h3\u003e\n\u003cp\u003e调用 \u003ccode\u003egenerateClass(ClassVisitor)\u003c/code\u003e 将获得到新类的字节码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void generateClass(ClassVisitor v) throws Exception {\n    // 确定生成类的 父类\n    Class sc = (superclass == null) ? Object.class : superclass;\n\n    // 父类标识符不可以为 final\n    if (TypeUtils.isFinal(sc.getModifiers()))\n        throw new IllegalArgumentException(\"Cannot subclass final class \" + sc.getName());\n    // 获取父类直接声明的构造方法\n    List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));\n    filterConstructors(sc, constructors);\n\n    // Order is very important: must add superclass, then\n    // its superclass chain, then each interface and\n    // its superinterfaces.\n    List actualMethods = new ArrayList();\n    List interfaceMethods = new ArrayList();\n    final Set forcePublic = new HashSet();\n    // 从父类中提取各种信息\n    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);\n\n    List methods = CollectionUtils.transform(actualMethods, new Transformer() {\n        public Object transform(Object value) {\n            Method method = (Method)value;\n            int modifiers = Constants.ACC_FINAL\n                | (method.getModifiers()\n                   \u0026#x26; ~Constants.ACC_ABSTRACT\n                   \u0026#x26; ~Constants.ACC_NATIVE\n                   \u0026#x26; ~Constants.ACC_SYNCHRONIZED);\n            if (forcePublic.contains(MethodWrapper.create(method))) {\n                modifiers = (modifiers \u0026#x26; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;\n            }\n            return ReflectUtils.getMethodInfo(method, modifiers);\n        }\n    });\n\n    ClassEmitter e = new ClassEmitter(v);\n    if (currentData == null) {\n    e.begin_class(Constants.V1_2,\n                  Constants.ACC_PUBLIC,\n                  getClassName(),\n                  Type.getType(sc),\n                  (useFactory ?\n                   TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :\n                   TypeUtils.getTypes(interfaces)),\n                  Constants.SOURCE_FILE);\n    } else {\n        e.begin_class(Constants.V1_2,\n                Constants.ACC_PUBLIC,\n                getClassName(),\n                null,\n                new Type[]{FACTORY},\n                Constants.SOURCE_FILE);\n    }\n    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\n\n    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);\n    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, null);\n    if (!interceptDuringConstruction) {\n        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null);\n    }\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);\n    if (serialVersionUID != null) {\n        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);\n    }\n\n    for (int i = 0; i \u0026#x3C; callbackTypes.length; i++) {\n        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null);\n    }\n    // This is declared private to avoid \"public field\" pollution\n    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, null);\n\n    if (currentData == null) {\n        emitMethods(e, methods, actualMethods);\n        emitConstructors(e, constructorInfo);\n    } else {\n        emitDefaultConstructor(e);\n    }\n    emitSetThreadCallbacks(e);\n    emitSetStaticCallbacks(e);\n    emitBindCallbacks(e);\n\n    if (useFactory || currentData != null) {\n        int[] keys = getCallbackKeys();\n        emitNewInstanceCallbacks(e);\n        emitNewInstanceCallback(e);\n        emitNewInstanceMultiarg(e, constructorInfo);\n        emitGetCallback(e, keys);\n        emitSetCallback(e, keys);\n        emitGetCallbacks(e);\n        emitSetCallbacks(e);\n    }\n\n    e.end_class();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egenerateClass(...)\u003c/code\u003e 执行的操作和 ASM 库的 ClassVisitor 访问 Class 文件结构的流程基本类似。\u003c/p\u003e\n\u003cp\u003e从上述截取到的部分代码，例如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ee.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), \n        (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)),\n        Constants.SOURCE_FILE);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ee.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e都与 \u003ccode\u003eclassVisitor.visit(...)\u003c/code\u003e 以及 \u003ccode\u003eclassVisitor.visitField(...)\u003c/code\u003e 相当类似。而事实上，这些方法的具体实现也确实调用了 cv.visitXxx(...) 。\n毕竟，作为 CGlib 唯一依赖的库，ASM 还是可以说是难以替代的(既然已经有了可用的轮子，又何必重复造呢?)\u003c/p\u003e\n\u003ch2\u003e构造的实例\u003c/h2\u003e\n\u003cp\u003e下面将展示通过 CGlib 生成的新的类(由于生成的是字节码，懒得再自行解析 ClassFile 的内容，所有直接用 \u003ccode\u003eIDEA\u003c/code\u003e 做了字节码的解析)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e首先展示的需要进行增强的 SampleClass 的具体内容\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SampleClass {\n    public String test(String input) {\n        return \"Hello World!\";\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e用于增强的简单代码\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 省略部分代码\npublic static void main(String... args) {\n    Enhancer enhancer = new Enhancer();\n    enhancer.setSuperclass(SampleClass.class);\n    enhancer.setCallback(new FixedValue() {\n        public Object loadObject() throws Exception {\n            return \"Hello cglib!\";\n        }\n    });\n    SampleClass proxy = (SampleClass) enhancer.create();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e动态生成的新的类\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\n// 不用过多关注，只是 CGlib 保证生成类与原有的类一定属于同一包下，偷懒直接把 SampleClass 写在 CGlib 项目里了\npackage net.sf.cglib.samples;\n\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.FixedValue;\n\n/**\n * 新的类名，通过 $$EnhancerByCGLIB 以及 $$7cd64b81(这个是哈希值) 对类名进行唯一区分 \n * 如果还是重复了，在动态生成前会进行类名的检测，并通过增加序号 \"_\u0026#x3C;index\u003e\" 的形式进行进一步区分\n *\n * 可以看到新生成的类继承了 SampleClass \n */\npublic class SampleClass$$EnhancerByCGLIB$$7cd64b81 extends SampleClass implements Factory {\n    private boolean CGLIB$BOUND;\n    public static Object CGLIB$FACTORY_DATA;\n    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;\n    private static final Callback[] CGLIB$STATIC_CALLBACKS;\n\n    // 绑定一个在增强中声明的 Callback 实例\n    private FixedValue CGLIB$CALLBACK_0;\n    // 绑定一个静态的回调调度实例\n    private static Object CGLIB$CALLBACK_FILTER;\n\n    static void CGLIB$STATICHOOK1() {\n        CGLIB$THREAD_CALLBACKS = new ThreadLocal();\n    }\n\n    /**\n      * 对 test(String) 的方法的增强\n      */ \n    public final String test(String var1) {\n        // 在方法块中拿到 Callback 实例\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        // 为空则尝试获取\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        // 触发回调实例的方法获得返回值\n        return (String)var10000.loadObject();\n    }\n\n    /**\n      * 由于此次增强只声明了一个 Callback\n      * 因此所有方法的增强都相同, 都是调用这个回调方法获取\n      */\n    public final boolean equals(Object var1) {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        Object var2 = var10000.loadObject();\n        /**\n         * 但是，此处会尝试强制转型\n         * 同时在最终执行失败的时候直接抛出运行时异常\n         * 毕竟上面增强的时候返回固定值 \"Hello, cglib!\"\n         */\n        return var2 == null ? false : (Boolean)var2;\n    }\n\n    public final String toString() {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return (String)var10000.loadObject();\n    }\n\n    public final int hashCode() {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        Object var1 = var10000.loadObject();\n        return var1 == null ? 0 : ((Number)var1).intValue();\n    }\n\n    protected final Object clone() throws CloneNotSupportedException {\n        FixedValue var10000 = this.CGLIB$CALLBACK_0;\n        if (this.CGLIB$CALLBACK_0 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return var10000.loadObject();\n    }\n\n    public SampleClass$$EnhancerByCGLIB$$7cd64b81() {\n        CGLIB$BIND_CALLBACKS(this);\n    }\n\n    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {\n        CGLIB$THREAD_CALLBACKS.set(var0);\n    }\n\n    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {\n        CGLIB$STATIC_CALLBACKS = var0;\n    }\n\n    private static final void CGLIB$BIND_CALLBACKS(Object var0) {\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var1 = (SampleClass$$EnhancerByCGLIB$$7cd64b81)var0;\n        if (!var1.CGLIB$BOUND) {\n            var1.CGLIB$BOUND = true;\n            Object var10000 = CGLIB$THREAD_CALLBACKS.get();\n            if (var10000 == null) {\n                var10000 = CGLIB$STATIC_CALLBACKS;\n                if (CGLIB$STATIC_CALLBACKS == null) {\n                    return;\n                }\n            }\n\n            var1.CGLIB$CALLBACK_0 = (FixedValue)((Callback[])var10000)[0];\n        }\n\n    }\n\n    public Object newInstance(Callback[] var1) {\n        CGLIB$SET_THREAD_CALLBACKS(var1);\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Callback var1) {\n        CGLIB$SET_THREAD_CALLBACKS(new Callback[]{var1});\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {\n        CGLIB$SET_THREAD_CALLBACKS(var3);\n        SampleClass$$EnhancerByCGLIB$$7cd64b81 var10000 = new SampleClass$$EnhancerByCGLIB$$7cd64b81;\n        switch(var1.length) {\n        case 0:\n            var10000.\u0026#x3C;init\u003e();\n            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n            return var10000;\n        default:\n            throw new IllegalArgumentException(\"Constructor not found\");\n        }\n    }\n\n    public Callback getCallback(int var1) {\n        CGLIB$BIND_CALLBACKS(this);\n        FixedValue var10000;\n        switch(var1) {\n        case 0:\n            var10000 = this.CGLIB$CALLBACK_0;\n            break;\n        default:\n            var10000 = null;\n        }\n\n        return var10000;\n    }\n\n    public void setCallback(int var1, Callback var2) {\n        switch(var1) {\n        case 0:\n            this.CGLIB$CALLBACK_0 = (FixedValue)var2;\n        default:\n        }\n    }\n\n    public Callback[] getCallbacks() {\n        CGLIB$BIND_CALLBACKS(this);\n        return new Callback[]{this.CGLIB$CALLBACK_0};\n    }\n\n    public void setCallbacks(Callback[] var1) {\n        this.CGLIB$CALLBACK_0 = (FixedValue)var1[0];\n    }\n\n    static {\n        CGLIB$STATICHOOK1();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从上面的生成类可以看出来，CGlib 所进行的增强，是在不直接对原有的方法体内容进行改造的基础上(例如上面的 test(String) 方法，没有直接改写成 \u003ccode\u003ereturn \"Hello, cglib!\u003c/code\u003e 的形式)，对方法执行之前入参或者方法执行之后的返回值进行一定的处理。\u003c/p\u003e\n\u003cp\u003e主要使用的形式就是将回调实例与原有方法进行绑定，并通过调用回调方法来实现方法的增强。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e此博文写作的目的: \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。\u003c/li\u003e\n\u003cli\u003e基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。\u003c/li\u003e\n\u003c/ul\u003e"},{"url":"2018-07-04-JDK-Permission","fileName":"2018-07-04-JDK-Permission.md","title":"Java 安全访问与权限控制","author":"fangfeng","date":"2018-07-04T00:00:00.000Z","tags":["Java","Security","Permission"],"content":"\u003ch2\u003e绪论\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003e本文只是对 Java 安全访问与权限控制的基础性探究。\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e本节与全文内容无关，如无兴趣阅读，可以跳过\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行\"自动发现\"和加载。\n这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要\n1. 在 \u003ccode\u003eMETA-INF.services\u003c/code\u003e 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容\n2. 由项目的注册管理器触发下列 Java 代码\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e{\n    ServiceLoader\u0026#x3C;XxxPolicy\u003e xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);\n    for (Iterator\u0026#x3C;XxxPolicy\u003e it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) {\n        XxxPolicy xxxPolicy = it.next();\n        // ... more code ...\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e就可以完成一个新的 SPI 策略的注册工作。\u003c/p\u003e\n\u003cp\u003e但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-.jar 在注册 Driver 相关的代码。\n发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eAccessController.doPrivileged(new PrivilegedAction\u0026#x3C;Void\u003e() {\n    public Void run() {\n\n        ServiceLoader\u0026#x3C;Driver\u003e loadedDrivers = ServiceLoader.load(Driver.class);\n        Iterator\u0026#x3C;Driver\u003e driversIterator = loadedDrivers.iterator();\n\n        try{\n            while(driversIterator.hasNext()) {\n            driversIterator.next();\n            }\n        } catch(Throwable t) {\n                // Do nothing\n        }\n        return null;\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。\u003c/p\u003e\n\u003cp\u003e为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。\u003c/p\u003e\n\u003ch2\u003e从现象开始...\u003c/h2\u003e\n\u003cp\u003e在通过 \u003ccode\u003ejava\u003c/code\u003e 命令执行本地代码时，偶尔/经常会出现文件I/O操作。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String... args) throws IOException {\n\n    System.out.println(System.getSecurityManager());\n\n    FileInputStream fis = new FileInputStream(\"/Users/fangfeng/test.in\");\n    for (int chr; (chr = fis.read()) != -1;) {\n        System.out.print((char) chr);\n    }\n    fis.close();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e诸如上面这段代码，意在读取外部路径下 \u003ccode\u003etest.in\u003c/code\u003e 文件(不要放在项目路径下，文本内容为 \u003ccode\u003e0123456789\u003c/code\u003e)。当然，还包括打印 System.getSecurityManager().toString() 。\u003c/p\u003e\n\u003cp\u003e正常情况下，这都是能够执行成功，结果为:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003enull\n0123456789\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是，通过在命令行 \u003ccode\u003ejava\u003c/code\u003e 中添加选项 \u003ccode\u003e-Djava.security.manager\u003c/code\u003e，再次执行代码，结果为:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003ejava.lang.SecurityManager@4e25154f\nException in thread \"main\" java.security.AccessControlException: access denied (\"java.io.FilePermission\" \"/Users/fangfeng/test.in\" \"read\")\n    at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)\n    at java.security.AccessController.checkPermission(AccessController.java:884)\n    at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)\n    at java.lang.SecurityManager.checkRead(SecurityManager.java:888)\n    at java.io.FileInputStream.\u0026#x3C;init\u003e(FileInputStream.java:127)\n    at java.io.FileInputStream.\u0026#x3C;init\u003e(FileInputStream.java:93)\n    at me.fangfeng.security.SecurityTest.main(SecurityTest.java:16)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在已经能够获取到 \u003ccode\u003eSystem.getSecuriryManager\u003c/code\u003e 的实例。\n但是想要读取 \u003ccode\u003etest.in\u003c/code\u003e 文件却失败了，表现为 access denied（访问被拒绝）。\u003c/p\u003e\n\u003cp\u003e现在，在用户目录下(这里是 /Users/fangfeng, 不同系统不同用户请做相应修改) 添加 \u003ccode\u003e.java.policy\u003c/code\u003e 文件，添加下列文本:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003egrant {\n    permission java.io.FilePermission \"/Users/fangfeng/test.in\", \"read\";\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再次 \u003ccode\u003ejava -Djava.security.manager \u0026#x3C;class's path\u003e\u003c/code\u003e，不仅能够得到 SecurityManager 的实例，同时也读取到了文本内容。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003ejava.lang.SecurityManager@3af49f1c\n0123456789\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到此为止，应该已经能够感受到 Java 对安全访问的控制在文件I/O上的体现了。\u003c/p\u003e\n\u003ch2\u003e安全控制下的操作\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e在开始下列内容之前，需要提前了解一个前提:\u003c/strong\u003e\n\u003cstrong\u003eJava 对操作权限的控制是通过检查当前线程操作上下文的代码是否存在要求的操作权限实现的(除了特权的声明以及其它还需要控制别的线程上下文权限的情况)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e上一节演示了权限控制下本地代码对本地资源的访问。但是，安全控制真的有必要吗？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e就本地程序而言，不必要。事实上，Java 也确实是这么做的。平时在本地利用 \u003ccode\u003ejava\u003c/code\u003e 命令执行程序，都不会受到任何限制。Java 启动时默认不会装载 SecurityManager，也就不会触发对各种操作的权限验证。\u003c/li\u003e\n\u003cli\u003e可如果程序运行与网络上其它程序交互，甚至直接加载来自网络的字节码。那么，权限控制确实是有必要的。至少，如果不存在权限控制，来自网络的恶意代码访问整台机器的任意资源都将畅通无阻。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eSecurityManager\u003c/h3\u003e\n\u003cp\u003eSecurityManager 是整个访问控制的管理器和基本入口。所有涉及到权限控制的代码，都会类似地存在下列这般的代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eSecurityManager security = System.getSecurityManager();\n// 如果系统存在安全管理器\nif (security != null) {\n    // 调用 SecurityManager 中以 check 开头的方法\n    security.checkXxx(...);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esecurity.checkXxx(...)\u003c/code\u003e 是没有返回值的(除了 checkTopLevelWindow)；对于没有操作权限的代码，直接抛出异常\u003c/p\u003e\n\u003cp\u003e至于到底在 check 什么，Java 中定义了包括文件(File)、套接字(Socket)、网络(Net)、安全性(Security)、运行时(Runtime)、属性(Property)、AWT、反射(Reflect)和可序列化(Serializable) 九类权限。\u003c/p\u003e\n\u003cp\u003e通常，security.checkXxx(...) 方法将构造一个 XxxPermission(...) 对象来调用 SecurityManager 提供的统一方法 checkPermission(Permission) 。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 以 checkRead(name) 为例\npublic void checkRead(String file) {\n    checkPermission(new FilePermission(file, SecurityConstants.FILE_READ_ACTION));\n}\n\n// 调用 checkPermission(Permission) 方法\npublic void checkPermission(Permission perm) {\n    // 直接调用 访问控制器 来对权限进行鉴别\n    java.security.AccessController.checkPermission(perm);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eAccessController\u003c/h3\u003e\n\u003cp\u003eAccessController 用于与访问控制相关的操作和决定。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAccessController 类用于以下三个目的：\u003c/p\u003e\n\u003cp\u003e基于当前生效的安全策略决定是允许还是拒绝对关键系统资源的访问\n将代码标记为享有“特权”，从而影响后续访问决定，以及\n获取当前调用上下文的“快照”，这样便可以相对于已保存的上下文作出其他上下文的访问控制决定\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e小结\u003c/h3\u003e\n\u003cp\u003e总的来说，Java 的访问控制就是通过针对不同的操作构建不同的 Permission 对象，然后通过与 AccessControllerContent 持有的各代码的权限进行比对，\n从而判断代码是否存在相应的访问权限。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e所谓的Permission判断将是对当前线程的调用栈的每个调用者逐一倒序递归，判断是否拥有权限。如果其中的某个代码被声明为 Privileged，则直接认为是拥有权限\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e更多的关于 checkPermission(...) 调用相关的内容，可以自行查阅资料进行学习，在此不做过多陈述。:)\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003e为操作赋权\u003c/h2\u003e\n\u003cp\u003e上一节讲完了如果对当前项目配置了 SecurityManager ，将对各种敏感操作进行访问控制，并且将根据整个调用链被赋予的权限来决定是允许执行还是抛出 access denied。\u003c/p\u003e\n\u003cp\u003e但是，究竟怎么才能够给 code 赋予权限呢？\u003c/p\u003e\n\u003cp\u003e回顾前一节的内容，在基本探究中，其实一个能够看到 \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003egrant {\n    permission java.io.FilePermission \"/Users/fangfeng/test.in\", \"read\";\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这就是一种赋权的操作。\u003c/p\u003e\n\u003cp\u003e通过在指定的文件中写入符合特定规则的代码，来完成对 code 的赋权。\u003ca href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html\"\u003eDefault Policy Implementation and Policy File Syntax\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e在项目启动的时候，默认就会读取 \u003ccode\u003e$JAVA\\_HOME/jre/lib/security/java.policy\u003c/code\u003e 以及 \u003ccode\u003e${user.home}/.java.policy\u003c/code\u003e 两个文件的赋权内容，并做缓存给后面代码使用。\u003c/p\u003e\n\u003cp\u003e当然，Java 也提供指定自定义的赋权文件，通过 -Djava.security.policy= 或者 -Djava.security.policy== 。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e[1]. Java Document - Security. \u003ca href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html\"\u003ehttps://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e绪论\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003e本文只是对 Java 安全访问与权限控制的基础性探究。\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e本节与全文内容无关，如无兴趣阅读，可以跳过\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行\"自动发现\"和加载。\n这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要\n1. 在 \u003ccode\u003eMETA-INF.services\u003c/code\u003e 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容\n2. 由项目的注册管理器触发下列 Java 代码\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e{\n    ServiceLoader\u0026#x3C;XxxPolicy\u003e xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);\n    for (Iterator\u0026#x3C;XxxPolicy\u003e it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) {\n        XxxPolicy xxxPolicy = it.next();\n        // ... more code ...\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e就可以完成一个新的 SPI 策略的注册工作。\u003c/p\u003e\n\u003cp\u003e但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-.jar 在注册 Driver 相关的代码。\n发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eAccessController.doPrivileged(new PrivilegedAction\u0026#x3C;Void\u003e() {\n    public Void run() {\n\n        ServiceLoader\u0026#x3C;Driver\u003e loadedDrivers = ServiceLoader.load(Driver.class);\n        Iterator\u0026#x3C;Driver\u003e driversIterator = loadedDrivers.iterator();\n\n        try{\n            while(driversIterator.hasNext()) {\n            driversIterator.next();\n            }\n        } catch(Throwable t) {\n                // Do nothing\n        }\n        return null;\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。\u003c/p\u003e\n\u003cp\u003e为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。\u003c/p\u003e"},{"url":"2018-06-28-ASM-VerifyError","fileName":"2018-06-28-ASM-VerifyError.md","title":"ASM-VerifyError错误信息解决","author":"fangfeng","date":"2018-06-28T00:00:00.000Z","tags":[],"content":"\u003ch2\u003e报错信息\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ejava.lang.VerifyError: class net.sf.cglib.core.DebuggingClassWriter overrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e背景\u003c/h2\u003e\n\u003cp\u003e项目依赖的 \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCGlib 版本是 2.2.2\u003c/li\u003e\n\u003cli\u003eASM 版本是 3.3.1\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e问题定位\u003c/h2\u003e\n\u003cp\u003e前两天刚粗略通读了 ASM ，结果就遇上这样一个问题。\u003c/p\u003e\n\u003cp\u003e从 \u003ccode\u003enet.sf.cglib.core.DebuggingClassWriter\u003c/code\u003e 看，这是 CGlib 的一个实现类\u003c/p\u003e\n\u003cp\u003e从描述 \u003ccode\u003eoverrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V\u003c/code\u003e\n以及 DebuggingClassWriter 类的字节码反编译结果\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DebuggingClassWriter extends ClassWriter {\n    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n        this.className = name.replace('/', '.');\n        this.superName = superName.replace('/', '.');\n        super.visit(version, access, name, signature, superName, interfaces);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至少应该是 visit(...) 方法要重载的父类的被声明为 final 的 ClassWriter.visit(...) 才导致的问题。\u003c/p\u003e\n\u003cp\u003e但是从 ASM 3.3.1 版本的 ClassWriter 类可以看到\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public void visit(int var1, int var2, String var3, String var4, String var5, String[] var6) {\n        ...\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003evisit 方法并没有被声明为 final 。\u003c/p\u003e\n\u003cp\u003e但是，结合一定的背景知识，ASM 项目在加入了 OW2 组织后的新版本(asm-3.3.1 是未加入 OW2 前的最后一个版本)，\nClassWriter 类的所有 visitXxx(...) 方法都被添加了 \u003ccode\u003efinal\u003c/code\u003e 限制。\u003c/p\u003e\n\u003cp\u003e因此，怀疑是项目实际依赖了高版本的 asm (asm 4.x 及以上)\u003c/p\u003e\n\u003ch2\u003e解决\u003c/h2\u003e\n\u003cp\u003e经过确认，由于整个项目依赖关系复杂，有其它项目引入了 asm-4.1.jar。\n而且由于使用 MAVEN 进行项目依赖管理，asm-4.1.jar 与依赖树根的深度更浅，\n因此，最终打包的 war 里面确实引入了 asm-4.1.jar 。导致了这个问题。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003e报错信息\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ejava.lang.VerifyError: class net.sf.cglib.core.DebuggingClassWriter overrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V\n\u003c/code\u003e\u003c/pre\u003e"},{"url":"2018-06-25-ASM-Core","fileName":"2018-06-25-ASM-Core.md","title":"ASM 核心包基本内容漫谈","author":"fangfeng","date":"2018-06-25T00:00:00.000Z","tags":["Java","ASM","Visitor Pattern"],"content":"\u003cblockquote\u003e\n\u003cp\u003e本文描述的 ASM 指的是 OW2 ASM\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eASM-Core 的结构\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003e首先是一些概述性的内容。\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。\n因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)\u003c/p\u003e\n\u003cp\u003e从核心包声明的类来看，主要包括:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eClassReader - 作为结构化对象，将接收(accept)访问者的访问\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e几种访问者抽象类以及相应的实现类\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eAnnotationVisitor -\u003e AnnotationWriter\u003c/li\u003e\n\u003cli\u003eClassVisitor -\u003e ClassWriter\u003c/li\u003e\n\u003cli\u003eFieldVisitor -\u003e FieldWriter\u003c/li\u003e\n\u003cli\u003eMethodVisitor -\u003e MethodWriter\u003c/li\u003e\n\u003cli\u003eModuleVisitor -\u003e ModuleWriter\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\n\u003cp\u003eOpcodes \u0026#x26; Constants - ClassFile 中描述的大量常量符号与值\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e其它一些辅助的类\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eAttribute - 用于处理非标准化的属性(ClassFile 允许\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html\"\u003eJVMS\u003c/a\u003e 中未定义的 Attribute)\u003c/li\u003e\n\u003cli\u003eByteArray - 动态可自适应的 byte[] (字节数组)\u003c/li\u003e\n\u003cli\u003eContext - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象\u003c/li\u003e\n\u003cli\u003eSymbol - 用于表示 ClassFile 中描述的 Constant 的基类\u003c/li\u003e\n\u003cli\u003eSymbolTable - 用于存储常量池对象\u003c/li\u003e\n\u003cli\u003e其它内容省略\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eClassFile 文件格式\u003c/h2\u003e\n\u003cp\u003e本节的内容可以参阅 \u003ca href=\"https://dormouse-none.github.io/2018-06-11-ASM-ClassReader/\"\u003eClassFile 文件格式\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eClassFile 是 ASM 操作字节码的基础与前提。在 JVMS 定义了 .class 文件格式之后，ASM 才在此基础上进行了对 ClassFile 的字节码操作。\u003c/p\u003e\n\u003cp\u003e因此，无论如何，个人认为在真正开始了解 ASM 之前，通读一遍 ClassFile 文件格式是完全有必要的。并且，在基本了解 ClassFile 内容的基础上，\n尝试对某个 .class 文件进行手工解析也不失为一种加深理解的途径。\u003c/p\u003e\n\u003ch2\u003eVisitor Pattern\u003c/h2\u003e\n\u003cp\u003e由于 ASM 的实现采用了偏门的访问者模式。因此，了解访问者模式也是一个必不可少的重要环节。同时在了解后也将为源码阅读者提供更清晰的解读思路。\u003c/p\u003e\n\u003cp\u003e《设计模式：可复用面向对象软件的基础》一书的“5.11 VISITOR(访问者)——对象行为型模式”提供了很详尽的解释。\u003c/p\u003e\n\u003cp\u003e本人对这方面的不甚了解，推荐自行查找资料。\u003c/p\u003e\n\u003ch2\u003eClassReader\u003c/h2\u003e\n\u003cp\u003eClassReader 是解析现有的 .class 文件的基本工具。同时，ClassReader 也作为一个内容的持有者，与 SymboleTable 配合，来满足访问者基本的访问需求。\u003c/p\u003e\n\u003cp\u003e刨除大量的内部私有方法，ClassReader 对外开放的接口相当简单。最核心的方法仅包括 ClassReader(...) 以及 accetp(...)\u003c/p\u003e\n\u003ch3\u003eClassReader(...) 构造方法\u003c/h3\u003e\n\u003cp\u003e顾名思义，构造方法用于实例化 ClassReader 对象，包括一些必须的变量的初始化。\u003c/p\u003e\n\u003cp\u003e在构造函数中完成的初始化内容包括:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e校验版本号\u003c/li\u003e\n\u003cli\u003e存储每个常量池项目的起始偏移量 cpInfoOffsets\u003c/li\u003e\n\u003cli\u003e存储每个引导方法的起始偏移量 bootstrapMethodOffsets\u003c/li\u003e\n\u003cli\u003e存储最长字符串常量的大小 maxStringLength\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e  ClassReader(final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {\n    this.b = classFileBuffer;   // .class 文件缓存\n    // 检查主版本号, 第6,7个字节(从0字节开始计数)\n    if (checkClassVersion \u0026#x26;\u0026#x26; readShort(classFileOffset + 6) \u003e Opcodes.V11) {\n      throw new IllegalArgumentException(\n          \"Unsupported class file major version \" + readShort(classFileOffset + 6));\n    }\n    // 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节\n    int constantPoolCount = readUnsignedShort(classFileOffset + 8);     // 读取无符号short, 即读取连续两字节作为一个short值\n    cpInfoOffsets = new int[constantPoolCount];                         // 每个常量的偏移位置\n    cpInfoValues = new Object[constantPoolCount];                       // 每个常量的实例对象\n    int currentCpInfoIndex = 1;\n    int currentCpInfoOffset = classFileOffset + 10;\n    int currentMaxStringLength = 0;                                     // 最长字符串常量\n    while (currentCpInfoIndex \u0026#x3C; constantPoolCount) {\n      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;\n      int cpInfoSize;\n      switch (classFileBuffer[currentCpInfoOffset]) {\n        case Symbol.CONSTANT_FIELDREF_TAG:\n        case Symbol.CONSTANT_METHODREF_TAG:\n        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n        case Symbol.CONSTANT_INTEGER_TAG:\n        case Symbol.CONSTANT_FLOAT_TAG:\n        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n        case Symbol.CONSTANT_DYNAMIC_TAG:\n          cpInfoSize = 5;\n          break;\n        case Symbol.CONSTANT_LONG_TAG:\n        case Symbol.CONSTANT_DOUBLE_TAG:\n          cpInfoSize = 9;\n          currentCpInfoIndex++;\n          break;\n        case Symbol.CONSTANT_UTF8_TAG:\n          cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);\n          if (cpInfoSize \u003e currentMaxStringLength) {\n            // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate\n            // of the length in characters of the corresponding string, and is much cheaper to\n            // compute than this exact length.\n            currentMaxStringLength = cpInfoSize;\n          }\n          break;\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n          cpInfoSize = 4;\n          break;\n        case Symbol.CONSTANT_CLASS_TAG:\n        case Symbol.CONSTANT_STRING_TAG:\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\n        case Symbol.CONSTANT_PACKAGE_TAG:\n        case Symbol.CONSTANT_MODULE_TAG:\n          cpInfoSize = 3;\n          break;\n        default:\n          throw new IllegalArgumentException();\n      }\n      currentCpInfoOffset += cpInfoSize;\n    }\n    this.maxStringLength = currentMaxStringLength;\n    // The Classfile's access_flags field is just after the last constant pool entry.\n    this.header = currentCpInfoOffset;\n\n    // 读取 BootstrapMethods 属性(如果存在)\n    int currentAttributeOffset = getFirstAttributeOffset();\n    int[] currentBootstrapMethodOffsets = null;\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i \u003e 0; --i) {\n      // 读取每个 attribute_info 的属性名和属性长度\n      String attributeName = readUTF8(currentAttributeOffset, new char[maxStringLength]);\n      int attributeLength = readInt(currentAttributeOffset + 2);\n      currentAttributeOffset += 6;\n      // 如果当前属性名为 BootstrapMethods ，则进入处理逻辑\n      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        // Read the num_bootstrap_methods field and create an array of this size.\n        currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];\n        // Compute and store the offset of each 'bootstrap_methods' array field entry.\n        int currentBootstrapMethodOffset = currentAttributeOffset + 2;\n        for (int j = 0; j \u0026#x3C; currentBootstrapMethodOffsets.length; ++j) {\n          currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;\n          // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\n          // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\n          currentBootstrapMethodOffset +=\n              4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\n        }\n      }\n      currentAttributeOffset += attributeLength;\n    }\n    this.bootstrapMethodOffsets = currentBootstrapMethodOffsets;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。\n但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。\u003c/p\u003e\n\u003ch3\u003eaccept(...)\u003c/h3\u003e\n\u003cp\u003e访问者模式的核心操作就是结构化对象接受(accept)访问者对象实例的访问，并将结构化内容完全暴露给访问者。\u003c/p\u003e\n\u003cp\u003e从抽象的方法角度看，可以理解成:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e  // --- 结构化对象的 accept() 方法 ---\n  public void accept(Visitor visitor) {\n    visitor.visit(this);\n  }\n\n  // --- 访问者对象的 visit() 方法 ---\n  public Xxx visit(Element element) {\n    // 若干关于 element 的读操作 + 其它操作\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void accept(\n      final ClassVisitor classVisitor,\n      final Attribute[] attributePrototypes,\n      final int parsingOptions) {\n    // 定义 Context 作为辅助类，暂存被访问过程的“累积状态”\n    Context context = new Context();\n    context.attributePrototypes = attributePrototypes;\n    /**\n     * 解析选项: \n     * 1. SKIP_CODE - 不解析 CODE 属性 \n     * 2. SKIP_DEBUG - 不解析 DEBUG 相关的属性(例如SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable, LineNumberTable)\n     * 4. SKIP_FRAMES - 跳过对 StackMap 和 StackMapTable 属性的解析\n     * ...\n     */\n    context.parsingOptions = parsingOptions;\n    // 从常量池读取常量所使用的缓冲数字\n    context.charBuffer = new char[maxStringLength];\n\n    // Read the access_flags, this_class, super_class, interface_count and interfaces fields.\n    // 解析访问控制, 当前类, 父类, 接口数量与接口值等\n    char[] charBuffer = context.charBuffer;\n    int currentOffset = header;\n    int accessFlags = readUnsignedShort(currentOffset);\n    String thisClass = readClass(currentOffset + 2, charBuffer);\n    String superClass = readClass(currentOffset + 4, charBuffer);\n    String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];\n    currentOffset += 8;\n    for (int i = 0; i \u0026#x3C; interfaces.length; ++i) {\n      interfaces[i] = readClass(currentOffset, charBuffer);\n      currentOffset += 2;\n    }\n\n    // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n    // - The offset of the InnerClasses attribute, or 0.\n    int innerClassesOffset = 0;\n    // - The offset of the EnclosingMethod attribute, or 0.\n    int enclosingMethodOffset = 0;\n    // - The string corresponding to the Signature attribute, or null.\n    String signature = null;\n    // - The string corresponding to the SourceFile attribute, or null.\n    String sourceFile = null;\n    // - The string corresponding to the SourceDebugExtension attribute, or null.\n    String sourceDebugExtension = null;\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n    int runtimeVisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n    int runtimeInvisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n    int runtimeVisibleTypeAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\n    // - The offset of the Module attribute, or 0.\n    int moduleOffset = 0;\n    // - The offset of the ModulePackages attribute, or 0.\n    int modulePackagesOffset = 0;\n    // - The string corresponding to the ModuleMainClass attribute, or null.\n    String moduleMainClass = null;\n    // - The string corresponding to the NestHost attribute, or null.\n    String nestHostClass = null;\n    // - The offset of the NestMembers attribute, or 0.\n    int nestMembersOffset = 0;\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n    //   This list in the \u0026#x3C;i\u003ereverse order\u0026#x3C;/i\u003e or their order in the ClassFile structure.\n    Attribute attributes = null;\n\n    // 解析 Class 持有的属性\n    int currentAttributeOffset = getFirstAttributeOffset();\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i \u003e 0; --i) {\n      // Read the attribute_info's attribute_name and attribute_length fields.\n      String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n      int attributeLength = readInt(currentAttributeOffset + 2);\n      currentAttributeOffset += 6;\n      // The tests are sorted in decreasing frequency order (based on frequencies observed on\n      // typical classes).\n      if (Constants.SOURCE_FILE.equals(attributeName)) {\n        sourceFile = readUTF8(currentAttributeOffset, charBuffer);\n      } else if (Constants.INNER_CLASSES.equals(attributeName)) {\n        innerClassesOffset = currentAttributeOffset;\n      } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {\n        enclosingMethodOffset = currentAttributeOffset;\n      } else if (Constants.NEST_HOST.equals(attributeName)) {\n        nestHostClass = readClass(currentAttributeOffset, charBuffer);\n      } else if (Constants.NEST_MEMBERS.equals(attributeName)) {\n        nestMembersOffset = currentAttributeOffset;\n      } else if (Constants.SIGNATURE.equals(attributeName)) {\n        signature = readUTF8(currentAttributeOffset, charBuffer);\n      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.DEPRECATED.equals(attributeName)) {\n        accessFlags |= Opcodes.ACC_DEPRECATED;\n      } else if (Constants.SYNTHETIC.equals(attributeName)) {\n        accessFlags |= Opcodes.ACC_SYNTHETIC;\n      } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {\n        sourceDebugExtension =\n            readUTF(currentAttributeOffset, attributeLength, new char[attributeLength]);\n      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.MODULE.equals(attributeName)) {\n        moduleOffset = currentAttributeOffset;\n      } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {\n        moduleMainClass = readClass(currentAttributeOffset, charBuffer);\n      } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {\n        modulePackagesOffset = currentAttributeOffset;\n      } else if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        // This attribute is read in the constructor.\n      } else {\n        Attribute attribute =\n            readAttribute(\n                attributePrototypes,\n                attributeName,\n                currentAttributeOffset,\n                attributeLength,\n                charBuffer,\n                -1,\n                null);\n        attribute.nextAttribute = attributes;\n        attributes = attribute;\n      }\n      currentAttributeOffset += attributeLength;\n    }\n\n    // 第一个 .visit() 。让 ClassVisitor 的实现类处理当前类的版本号, 访问控制标志, 当前类, 结构, 父类, 接口\n    // 具体 visit() 由实现类随意定制。例如，针对于那些有打印功能的访问者实现类，直接打印也不失为一种有效的访问操作\n    // Visit the class declaration. The minor_version and major_version fields start 6 bytes before\n    // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).\n    classVisitor.visit(\n        readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);\n\n    // 访问 SourceFile 和 SourceDebugExtenstion 属性\n    // Visit the SourceFile and SourceDebugExtenstion attributes.\n    if ((parsingOptions \u0026#x26; SKIP_DEBUG) == 0\n        \u0026#x26;\u0026#x26; (sourceFile != null || sourceDebugExtension != null)) {\n      classVisitor.visitSource(sourceFile, sourceDebugExtension);\n    }\n\n    // Visit the Module, ModulePackages and ModuleMainClass attributes.\n    if (moduleOffset != 0) {\n      readModule(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);\n    }\n\n    // Visit the NestHost attribute.\n    if (nestHostClass != null) {\n      classVisitor.visitNestHostExperimental(nestHostClass);\n    }\n\n    // Visit the EnclosingMethod attribute.\n    if (enclosingMethodOffset != 0) {\n      String className = readClass(enclosingMethodOffset, charBuffer);\n      int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);\n      String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);\n      String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);\n      classVisitor.visitOuterClass(className, name, type);\n    }\n\n    // Visit the RuntimeVisibleAnnotations attribute.\n    if (runtimeVisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n      while (numAnnotations-- \u003e 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),\n                currentAnnotationOffset,\n                /* named = */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleAnnotations attribute.\n    if (runtimeInvisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n      while (numAnnotations-- \u003e 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),\n                currentAnnotationOffset,\n                /* named = */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- \u003e 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible = */ true),\n                currentAnnotationOffset,\n                /* named = */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- \u003e 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible = */ false),\n                currentAnnotationOffset,\n                /* named = */ true,\n                charBuffer);\n      }\n    }\n\n    // 访问非标准的属性\n    // Visit the non standard attributes.\n    while (attributes != null) {\n      // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.\n      Attribute nextAttribute = attributes.nextAttribute;\n      attributes.nextAttribute = null;\n      classVisitor.visitAttribute(attributes);\n      attributes = nextAttribute;\n    }\n\n    // Visit the NestedMembers attribute.\n    if (nestMembersOffset != 0) {\n      int numberOfNestMembers = readUnsignedShort(nestMembersOffset);\n      int currentNestMemberOffset = nestMembersOffset + 2;\n      while (numberOfNestMembers-- \u003e 0) {\n        classVisitor.visitNestMemberExperimental(readClass(currentNestMemberOffset, charBuffer));\n        currentNestMemberOffset += 2;\n      }\n    }\n\n    // Visit the InnerClasses attribute.\n    if (innerClassesOffset != 0) {\n      int numberOfClasses = readUnsignedShort(innerClassesOffset);\n      int currentClassesOffset = innerClassesOffset + 2;\n      while (numberOfClasses-- \u003e 0) {\n        classVisitor.visitInnerClass(\n            readClass(currentClassesOffset, charBuffer),\n            readClass(currentClassesOffset + 2, charBuffer),\n            readUTF8(currentClassesOffset + 4, charBuffer),\n            readUnsignedShort(currentClassesOffset + 6));\n        currentClassesOffset += 8;\n      }\n    }\n\n    // 访问字段和方法\n    // Visit the fields and methods.\n    int fieldsCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (fieldsCount-- \u003e 0) {\n      currentOffset = readField(classVisitor, context, currentOffset);\n    }\n    int methodsCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (methodsCount-- \u003e 0) {\n      currentOffset = readMethod(classVisitor, context, currentOffset);\n    }\n\n    // Visit the end of the class.\n    classVisitor.visitEnd();\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e小结\u003c/h3\u003e\n\u003cp\u003e其实，将整个 ClassReader 理解成一个对 .class 字节文件的解析器不失为一种可行的认知。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在构造方法中完成对 .class 文件 minor_version, major_version 的确认。\u003c/li\u003e\n\u003cli\u003e继而完成对整个 Constants_pool 的解析\u003c/li\u003e\n\u003cli\u003e以及 BootstarpMethod 属性的定位\u003c/li\u003e\n\u003cli\u003e之后在 accept(...) 方法中逐一调用相应的访问者实现类实现对不同内容的访问。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e但是，要注意的是，ClassReader 绝对不会涉及到对其解析的 .class 文件内容的写操作。\n所有的写操作都基于不同的目的，在 ClassVisitor 中实现。\u003c/p\u003e\n\u003ch2\u003eClassVisitor\u003c/h2\u003e\n\u003cp\u003eJava .class 的访问者，按照严格的顺序规范逐一调用 \u003c/p\u003e\n\u003cp\u003evisit\n[ visitSource ] [ visitModule ][ visitNestHost ][ visitOuterClass ]\n( visitAnnotation | visitTypeAnnotation | visitAttribute )\u003cem\u003e\n( visitNestMember | visitInnerClass | visitField | visitMethod )\u003c/em\u003e\nvisitEnd.\u003c/p\u003e\n\u003cp\u003e各个 visitXXX 方法\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic abstract class ClassVisitor {\n\n  /**\n   * 访问类的首部\n      */\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {}\n\n  /**\n   * 访问类的源文件名等\n      */\n    public void visitSource(final String source, final String debug) {}\n\n  /**\n   * 访问与类关联的模块\n      */\n    public ModuleVisitor visitModule(final String name, final int access, final String version) {}\n\n  public void visitOuterClass(final String owner, final String name, final String descriptor) {}\n\n  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {}\n\n  public AnnotationVisitor visitTypeAnnotation(\n      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {}\n\n  public void visitAttribute(final Attribute attribute) {}\n\n  public void visitInnerClass(\n      final String name, final String outerName, final String innerName, final int access) {}\n\n  /**\n   * 访问类的变量\n      */\n    public FieldVisitor visitField(\n      final int access,\n      final String name,\n      final String descriptor,\n      final String signature,\n      final Object value) {}\n\n  /**\n   * 访问类的方法\n      */\n    public MethodVisitor visitMethod(\n      final int access,\n      final String name,\n      final String descriptor,\n      final String signature,\n      final String[] exceptions) {}\n\n  public void visitEnd() {}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e随着 visitXxx() 方法的逐一执行，ClassVisitor 将对当前的 .class 文件越来越熟悉，并逐渐补全常量池(由 SymbolTable 持有并维护)\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e到此为止，对整个 ClassReader \u0026#x26; ClassVisitor 将有一个基础而简单的印象。\u003c/p\u003e\n\u003cp\u003eClassReader 通过对 .class 文件字节码的解析而获得对这个类的具体印象(更多的偏向是随意访问 .class 的各种细节)。\u003c/p\u003e\n\u003cp\u003eClassVisitor 通过 visitXxx(...) 方法，由其它对象(可以是 ClassReader, 也可以直接是 Coder)逐渐对其开放一些 .class 的细节，\n但需要 ClassVisitor 自行维护获得的内容(如果有必要的话)。由此得到对 .class 全部内容的了解(当然，如果本身 visitXxx() 得到的内容不全，则了解的自然有限)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003cblockquote\u003e\n\u003cp\u003e本文描述的 ASM 指的是 OW2 ASM\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eASM-Core 的结构\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003e首先是一些概述性的内容。\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。\n因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)\u003c/p\u003e\n\u003cp\u003e从核心包声明的类来看，主要包括:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eClassReader - 作为结构化对象，将接收(accept)访问者的访问\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e几种访问者抽象类以及相应的实现类\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eAnnotationVisitor -\u003e AnnotationWriter\u003c/li\u003e\n\u003cli\u003eClassVisitor -\u003e ClassWriter\u003c/li\u003e\n\u003cli\u003eFieldVisitor -\u003e FieldWriter\u003c/li\u003e\n\u003cli\u003eMethodVisitor -\u003e MethodWriter\u003c/li\u003e\n\u003cli\u003eModuleVisitor -\u003e ModuleWriter\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\n\u003cp\u003eOpcodes \u0026#x26; Constants - ClassFile 中描述的大量常量符号与值\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e其它一些辅助的类\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eAttribute - 用于处理非标准化的属性(ClassFile 允许\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html\"\u003eJVMS\u003c/a\u003e 中未定义的 Attribute)\u003c/li\u003e\n\u003cli\u003eByteArray - 动态可自适应的 byte[] (字节数组)\u003c/li\u003e\n\u003cli\u003eContext - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象\u003c/li\u003e\n\u003cli\u003eSymbol - 用于表示 ClassFile 中描述的 Constant 的基类\u003c/li\u003e\n\u003cli\u003eSymbolTable - 用于存储常量池对象\u003c/li\u003e\n\u003cli\u003e其它内容省略\u003c/li\u003e\n\u003c/ul\u003e"},{"url":"2018-06-21-java-memory-model","fileName":"2018-06-21-java-memory-model.md","title":"java-memory-model","author":"fangfeng","date":"2018-06-21T00:00:00.000Z","tags":["Java","JVM","Memory Model"],"content":"\u003ch2\u003eJVM 运行时数据区\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg\"\u003e\u003c/p\u003e\n\u003ch3\u003ePC寄存器\u003c/h3\u003e\n\u003cp\u003e与操作系统中的PC寄存器功能基本一致。毕竟 JVM 建立的初衷就是模拟一台机器。\n指向存储在\u003cstrong\u003e方法区\u003c/strong\u003e的字节码methods_info部分的内存地址。\u003c/p\u003e\n\u003ch3\u003e虚拟机栈\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e虚拟机栈\u003c/strong\u003e用于存储\u003cstrong\u003e栈帧\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003e本地方法栈\u003c/h3\u003e\n\u003cp\u003e用于支持 native 方法的执行\u003c/p\u003e\n\u003ch3\u003e栈帧\u003c/h3\u003e\n\u003cp\u003e存储在\u003cstrong\u003e虚拟机栈\u003c/strong\u003e中，主要包括\u003cstrong\u003e局部变量表\u003c/strong\u003e和\u003cstrong\u003e操作数栈\u003c/strong\u003e(又称\u003cstrong\u003e当前栈帧的操作数栈\u003c/strong\u003e)以及\u003cstrong\u003e运行时常量池的引用\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e仍然有必要区别两个概念: 操作数 \u0026#x26; 指令\u003c/em\u003e\n\u003cem\u003e指令指使操作数进行相关操作的基本命令\u003c/em\u003e\n\u003cem\u003e操作数通常指整数、浮点数以及类型引用等\u003c/em\u003e\u003c/p\u003e\n\u003ch3\u003e方法区\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e方法区\u003c/strong\u003e是多个线程共享的一块区域，主要用于存储I/O操作中读入的类/接口的字节码(ClassFile 文件)\n包括有 constant_pool, field_info, method_info, attribute_info 等\u003c/p\u003e\n\u003ch3\u003eJava堆\u003c/h3\u003e\n\u003cp\u003e用于存储各种类的实例对象\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003e  __                    __                  \n / _| __ _ _ __   __ _ / _| ___ _ __   __ _ \n| |_ / _` | '_ \\ / _` | |_ / _ \\ '_ \\ / _` |\n|  _| (_| | | | | (_| |  _|  __/ | | | (_| |\n|_|  \\__,_|_| |_|\\__, |_|  \\___|_| |_|\\__, |\n                 |___/                |___/ \n\u003c/code\u003e\u003c/pre\u003e","digest":"\u003ch2\u003eJVM 运行时数据区\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg\"\u003e\u003c/p\u003e"}],"items":32,"pages":4,"currentPage":2},"buildId":"ujZVwdt9FYQDcwzYKNDVs","dynamicBuildId":false,"assetPrefix":"https://www.ffutop.com/blog","nextExport":true}</script><script async="" id="__NEXT_PAGE__/" src="https://www.ffutop.com/blog/_next/static/ujZVwdt9FYQDcwzYKNDVs/pages/index.js"></script><script async="" id="__NEXT_PAGE__/_app" src="https://www.ffutop.com/blog/_next/static/ujZVwdt9FYQDcwzYKNDVs/pages/_app.js"></script><script src="https://www.ffutop.com/blog/_next/static/runtime/webpack-8ed9452df514b4d17d80.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/commons.ca07934498d0c5523bf5.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/chunks/styles.74c43a0e96cfe845a889.js" async=""></script><script src="https://www.ffutop.com/blog/_next/static/runtime/main-3daabeb1dde7624c7fe0.js" async=""></script></body></html>